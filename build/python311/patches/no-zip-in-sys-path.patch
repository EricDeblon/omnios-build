
By default, python places a zip file at the start of the module path

>>> import sys; sys.path
['', '/usr/lib/python3x.zip', '/usr/lib/python3.x', ...

We don't ship this or have any need to provide modules there, so remove it
from the path. This also cleans up package dependency resolution output
which frequently refers to this non-existent file.

diff -wpruN '--exclude=*.orig' a~/Lib/test/test_embed.py a/Lib/test/test_embed.py
--- a~/Lib/test/test_embed.py	1970-01-01 00:00:00
+++ a/Lib/test/test_embed.py	1970-01-01 00:00:00
@@ -1222,8 +1222,6 @@ class InitConfigTests(EmbeddingTestsMixi
             ver = sys.version_info
             return [
                 os.path.join(prefix, sys.platlibdir,
-                             f'python{ver.major}{ver.minor}.zip'),
-                os.path.join(prefix, sys.platlibdir,
                              f'python{ver.major}.{ver.minor}'),
                 os.path.join(exec_prefix, sys.platlibdir,
                              f'python{ver.major}.{ver.minor}', 'lib-dynload'),
diff -wpruN '--exclude=*.orig' a~/Modules/getpath.py a/Modules/getpath.py
--- a~/Modules/getpath.py	1970-01-01 00:00:00
+++ a/Modules/getpath.py	1970-01-01 00:00:00
@@ -533,33 +533,11 @@ else:
     # First try to detect prefix by looking alongside our runtime library, if known
     if library and not prefix:
         library_dir = dirname(library)
-        if ZIP_LANDMARK:
-            if os_name == 'nt':
-                # QUIRK: Windows does not search up for ZIP file
-                if isfile(joinpath(library_dir, ZIP_LANDMARK)):
-                    prefix = library_dir
-            else:
-                prefix = search_up(library_dir, ZIP_LANDMARK)
         if STDLIB_SUBDIR and STDLIB_LANDMARKS and not prefix:
             if any(isfile(joinpath(library_dir, f)) for f in STDLIB_LANDMARKS):
                 prefix = library_dir
                 stdlib_dir = joinpath(prefix, STDLIB_SUBDIR)
 
-
-    # Detect prefix by looking for zip file
-    if ZIP_LANDMARK and executable_dir and not prefix:
-        if os_name == 'nt':
-            # QUIRK: Windows does not search up for ZIP file
-            if isfile(joinpath(executable_dir, ZIP_LANDMARK)):
-                prefix = executable_dir
-        else:
-            prefix = search_up(executable_dir, ZIP_LANDMARK)
-        if prefix:
-            stdlib_dir = joinpath(prefix, STDLIB_SUBDIR)
-            if not isdir(stdlib_dir):
-                stdlib_dir = None
-
-
     # Detect prefix by searching from our executable location for the stdlib_dir
     if STDLIB_SUBDIR and STDLIB_LANDMARKS and executable_dir and not prefix:
         prefix = search_up(executable_dir, *STDLIB_LANDMARKS)
@@ -639,21 +617,6 @@ elif not pythonpath_was_set:
         for p in ENV_PYTHONPATH.split(DELIM):
             pythonpath.append(abspath(p))
 
-    # Then add the default zip file
-    if os_name == 'nt':
-        # QUIRK: Windows uses the library directory rather than the prefix
-        if library:
-            library_dir = dirname(library)
-        else:
-            library_dir = executable_dir
-        pythonpath.append(joinpath(library_dir, ZIP_LANDMARK))
-    elif build_prefix or venv_prefix:
-        # QUIRK: POSIX uses the default prefix when in the build directory
-        # or a venv
-        pythonpath.append(joinpath(PREFIX, ZIP_LANDMARK))
-    else:
-        pythonpath.append(joinpath(prefix, ZIP_LANDMARK))
-
     if os_name == 'nt' and use_environment and winreg:
         # QUIRK: Windows also lists paths in the registry. Paths are stored
         # as the default value of each subkey of
