To: vim_dev@googlegroups.com
Subject: Patch 8.0.0015
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0015
Problem:    Can't tell which part of a channel has "buffered" status.
Solution:   Add an optional argument to ch_status().  Let ch_info() also
            return "buffered" for out_status and err_status.
Files:      src/evalfunc.c, src/channel.c, src/proto/channel.pro,
            src/testdir/test_channel.vim, runtime/doc/eval.txt


*** ../vim-8.0.0014/src/evalfunc.c	2016-09-25 21:44:59.441600148 +0200
--- src/evalfunc.c	2016-09-26 22:03:14.961368676 +0200
***************
*** 514,520 ****
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 1, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
--- 514,520 ----
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 2, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
***************
*** 1985,1997 ****
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel));
  }
  #endif
  
--- 1985,2008 ----
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
+     jobopt_T	opt;
+     int		part = -1;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
! 
!     if (argvars[1].v_type != VAR_UNKNOWN)
!     {
! 	clear_job_options(&opt);
! 	if (get_job_options(&argvars[1], &opt, JO_PART) == OK
! 						     && (opt.jo_set & JO_PART))
! 	    part = opt.jo_part;
!     }
! 
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel, part));
  }
  #endif
  
*** ../vim-8.0.0014/src/channel.c	2016-09-07 23:15:55.000000000 +0200
--- src/channel.c	2016-09-26 22:19:18.270706785 +0200
***************
*** 2590,2612 ****
  
  /*
   * Return a string indicating the status of the channel.
   */
      char *
! channel_status(channel_T *channel)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (channel_is_open(channel))
! 	 return "open";
!     for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	if (channel_has_readahead(channel, part))
! 	{
  	    has_readahead = TRUE;
! 	    break;
! 	}
  
      if (has_readahead)
  	return "buffered";
--- 2590,2630 ----
  
  /*
   * Return a string indicating the status of the channel.
+  * If "req_part" is not negative check that part.
   */
      char *
! channel_status(channel_T *channel, int req_part)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (req_part == PART_OUT)
!     {
! 	if (channel->CH_OUT_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_OUT))
  	    has_readahead = TRUE;
!     }
!     else if (req_part == PART_ERR)
!     {
! 	if (channel->CH_ERR_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_ERR))
! 	    has_readahead = TRUE;
!     }
!     else
!     {
! 	if (channel_is_open(channel))
! 	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	    if (channel_has_readahead(channel, part))
! 	    {
! 		has_readahead = TRUE;
! 		break;
! 	    }
!     }
  
      if (has_readahead)
  	return "buffered";
***************
*** 2619,2624 ****
--- 2637,2643 ----
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
      size_t	tail;
+     char	*status;
      char	*s = "";
  
      vim_strncpy((char_u *)namebuf, (char_u *)name, 4);
***************
*** 2626,2633 ****
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     dict_add_nr_str(dict, namebuf, 0,
! 		(char_u *)(chanpart->ch_fd == INVALID_FD ? "closed" : "open"));
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
--- 2645,2657 ----
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     if (chanpart->ch_fd != INVALID_FD)
! 	status = "open";
!     else if (channel_has_readahead(channel, part))
! 	status = "buffered";
!     else
! 	status = "closed";
!     dict_add_nr_str(dict, namebuf, 0, (char_u *)status);
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
***************
*** 2660,2666 ****
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel));
  
      if (channel->ch_hostname != NULL)
      {
--- 2684,2690 ----
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel, -1));
  
      if (channel->ch_hostname != NULL)
      {
***************
*** 4244,4249 ****
--- 4268,4275 ----
  		val = get_tv_string(item);
  		if (STRCMP(val, "err") == 0)
  		    opt->jo_part = PART_ERR;
+ 		else if (STRCMP(val, "out") == 0)
+ 		    opt->jo_part = PART_OUT;
  		else
  		{
  		    EMSG2(_(e_invarg2), val);
*** ../vim-8.0.0014/src/proto/channel.pro	2016-09-12 13:04:24.000000000 +0200
--- src/proto/channel.pro	2016-09-26 22:14:54.376537165 +0200
***************
*** 24,30 ****
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
--- 24,30 ----
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel, int req_part);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
*** ../vim-8.0.0014/src/testdir/test_channel.vim	2016-09-07 23:23:56.000000000 +0200
--- src/testdir/test_channel.vim	2016-09-26 22:34:36.352321622 +0200
***************
*** 434,439 ****
--- 434,456 ----
    let job = job_start(s:python . " test_channel_pipe.py", {'mode': 'raw'})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
+ 
+   call assert_equal("open", ch_status(job))
+   call assert_equal("open", ch_status(job), {"part": "out"})
+   call assert_equal("open", ch_status(job), {"part": "err"})
+   call assert_fails('call ch_status(job, {"in_mode": "raw"})', 'E475:')
+   call assert_fails('call ch_status(job, {"part": "in"})', 'E475:')
+ 
+   let dict = ch_info(job)
+   call assert_true(dict.id != 0)
+   call assert_equal('open', dict.status)
+   call assert_equal('open', dict.out_status)
+   call assert_equal('RAW', dict.out_mode)
+   call assert_equal('pipe', dict.out_io)
+   call assert_equal('open', dict.err_status)
+   call assert_equal('RAW', dict.err_mode)
+   call assert_equal('pipe', dict.err_io)
+ 
    try
      " For a change use the job where a channel is expected.
      call ch_sendraw(job, "echo something\n")
*** ../vim-8.0.0014/runtime/doc/eval.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/eval.txt	2016-09-26 22:24:12.284664360 +0200
***************
*** 2030,2036 ****
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle})		String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
--- 2031,2038 ----
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle} [, {options}])
! 				String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
***************
*** 3041,3047 ****
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open" (any part is open) or "closed"
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
--- 3043,3050 ----
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open", "buffered" or "closed", like
! 				  ch_status()
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
***************
*** 3050,3060 ****
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
--- 3053,3063 ----
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open", "buffered" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open", "buffered" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
***************
*** 3139,3145 ****
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle})						*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
--- 3142,3148 ----
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle} [, {options}])				*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
***************
*** 3149,3154 ****
--- 3152,3162 ----
  		"buffered" is used when the channel was closed but there is
  		still data that can be obtained with |ch_read()|.
  
+ 		If {options} is given it can contain a "part" entry to specify
+ 		the part of the channel to return the status for: "out" or
+ 		"err".  For example, to get the error status: >
+ 			ch_status(job, {"part": "err"})
+ <
  							*copy()*
  copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
  		different from using {expr} directly.
*** ../vim-8.0.0014/src/version.c	2016-09-26 20:14:49.925906743 +0200
--- src/version.c	2016-09-26 22:15:39.060227458 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     15,
  /**/

-- 
"A mouse can be just as dangerous as a bullet or a bomb."
             (US Representative Lamar Smith, R-Texas)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0016 (after 8.0.0015)
Problem:    Build fails.
Solution:   Include missing change.
Files:      src/eval.c


*** ../vim-8.0.0015/src/eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/eval.c	2016-09-26 22:57:29.622842295 +0200
***************
*** 7305,7311 ****
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
--- 7305,7311 ----
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel, -1);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
*** ../vim-8.0.0015/src/version.c	2016-09-26 22:36:50.619386344 +0200
--- src/version.c	2016-09-26 22:58:00.882626187 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
Nothing is impossible for the man who doesn't have to do it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0017
Problem:    Cannot get the number of the current quickfix or location list.
Solution:   Use the current list if "nr" in "what" is zero. (Yegappan
            Lakshmanan)  Remove debug command from test.
Files:      src/quickfix.c, src/testdir/test_quickfix.vim,
            runtime/doc/eval.txt


*** ../vim-8.0.0016/src/quickfix.c	2016-09-25 21:44:59.445600117 +0200
--- src/quickfix.c	2016-09-27 21:27:48.729788268 +0200
***************
*** 4591,4599 ****
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    qf_idx = di->di_tv.vval.v_number - 1;
! 	    if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		return FAIL;
  	    flags |= QF_GETLIST_NR;
  	}
  	else
--- 4591,4603 ----
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /* for zero use the current list */
! 	    if (di->di_tv.vval.v_number != 0)
! 	    {
! 		qf_idx = di->di_tv.vval.v_number - 1;
! 		if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		    return FAIL;
! 	    }
  	    flags |= QF_GETLIST_NR;
  	}
  	else
*** ../vim-8.0.0016/src/testdir/test_quickfix.vim	2016-09-01 15:39:30.000000000 +0200
--- src/testdir/test_quickfix.vim	2016-09-27 21:22:51.671854368 +0200
***************
*** 1429,1440 ****
    laddexpr 'one.txt:3:one one one'
  
    let loc_one = getloclist(one_id)
- echo string(loc_one)
    call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))
    call assert_equal(3, loc_one[1].lnum)
  
    let loc_two = getloclist(two_id)
- echo string(loc_two)
    call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))
    call assert_equal(5, loc_two[1].lnum)
  
--- 1429,1438 ----
***************
*** 1534,1539 ****
--- 1532,1542 ----
      call assert_equal('N1', g:Xgetlist({'all':1}).title)
      call g:Xsetlist([], ' ', {'title' : 'N2'})
      call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)
+ 
+     let res = g:Xgetlist({'nr': 0})
+     call assert_equal(qfnr + 1, res.nr)
+     call assert_equal(['nr'], keys(res))
+ 
      call g:Xsetlist([], ' ', {'title' : 'N3'})
      call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)
  
***************
*** 1546,1552 ****
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, ['title']))
      endif
  endfunction
  
--- 1549,1555 ----
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
  endfunction
  
*** ../vim-8.0.0016/runtime/doc/eval.txt	2016-09-26 22:36:50.619386344 +0200
--- runtime/doc/eval.txt	2016-09-27 21:14:57.863151829 +0200
***************
*** 4510,4516 ****
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
--- 4516,4523 ----
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list; zero
! 				means the current quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
*** ../vim-8.0.0016/src/version.c	2016-09-26 22:58:54.498255420 +0200
--- src/version.c	2016-09-27 21:17:23.714136503 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
This is the polymorph virus!  Follow these instructions carefully:
1. Send this message to everybody you know.
2. Format your harddisk.
Thank you for your cooperation in spreading the most powerful virus ever!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0018
Problem:    When using ":sleep" channel input is not handled.
Solution:   When there is a channel check for input also when not in raw mode.
            Check every 100 msec.
Files:      src/channel.c, src/proto/channel.pro, src/ui.c, src/proto/ui.pro,
            src/ex_docmd.c, src/os_amiga.c, src/proto/os_amiga.pro,
            src/os_unix.c, src/proto/os_unix.pro, src/os_win32.c,
            src/proto/os_win32.pro


*** ../vim-8.0.0017/src/channel.c	2016-09-26 22:36:50.615386371 +0200
--- src/channel.c	2016-09-29 15:12:13.482556346 +0200
***************
*** 341,346 ****
--- 341,352 ----
      return channel;
  }
  
+     int
+ has_any_channel(void)
+ {
+     return first_channel != NULL;
+ }
+ 
  /*
   * Called when the refcount of a channel is zero.
   * Return TRUE if "channel" has a callback and the associated job wasn't
*** ../vim-8.0.0017/src/proto/channel.pro	2016-09-26 22:36:50.615386371 +0200
--- src/proto/channel.pro	2016-09-29 14:59:14.620048830 +0200
***************
*** 4,9 ****
--- 4,10 ----
  void ch_log(channel_T *ch, char *msg);
  void ch_logs(channel_T *ch, char *msg, char *name);
  channel_T *add_channel(void);
+ int has_any_channel(void);
  int channel_unref(channel_T *channel);
  int free_unused_channels_contents(int copyID, int mask);
  void free_unused_channels(int copyID, int mask);
*** ../vim-8.0.0017/src/ui.c	2016-08-29 22:42:20.000000000 +0200
--- src/ui.c	2016-09-29 15:06:26.753000044 +0200
***************
*** 353,364 ****
      void
  ui_breakcheck(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck();
  }
  
  /*****************************************************************************
--- 353,374 ----
      void
  ui_breakcheck(void)
  {
+     ui_breakcheck_force(FALSE);
+ }
+ 
+ /*
+  * When "force" is true also check when the terminal is not in raw mode.
+  * This is useful to read input on channels.
+  */
+     void
+ ui_breakcheck_force(int force)
+ {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck(force);
  }
  
  /*****************************************************************************
*** ../vim-8.0.0017/src/proto/ui.pro	2016-09-12 13:04:21.000000000 +0200
--- src/proto/ui.pro	2016-09-29 15:06:34.028948742 +0200
***************
*** 10,15 ****
--- 10,16 ----
  void ui_set_shellsize(int mustset);
  void ui_new_shellsize(void);
  void ui_breakcheck(void);
+ void ui_breakcheck_force(int force);
  void clip_init(int can_use);
  void clip_update_selection(VimClipboard *clip);
  void clip_own_selection(VimClipboard *cbd);
*** ../vim-8.0.0017/src/ex_docmd.c	2016-09-11 14:36:00.000000000 +0200
--- src/ex_docmd.c	2016-09-29 15:06:48.532846478 +0200
***************
*** 9065,9072 ****
  		wait_now = due_time;
  	}
  #endif
  	ui_delay(wait_now, TRUE);
! 	ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
--- 9065,9081 ----
  		wait_now = due_time;
  	}
  #endif
+ #ifdef FEAT_JOB_CHANNEL
+ 	if (has_any_channel() && wait_now > 100L)
+ 	    wait_now = 100L;
+ #endif
  	ui_delay(wait_now, TRUE);
! #ifdef FEAT_JOB_CHANNEL
! 	if (has_any_channel())
! 	    ui_breakcheck_force(TRUE);
! 	else
! #endif
! 	    ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
*** ../vim-8.0.0017/src/os_amiga.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_amiga.c	2016-09-29 15:07:57.060363361 +0200
***************
*** 1381,1387 ****
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(void)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
--- 1381,1387 ----
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(int force)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
*** ../vim-8.0.0017/src/proto/os_amiga.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_amiga.pro	2016-09-29 15:08:16.240228159 +0200
***************
*** 36,42 ****
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(void);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 36,42 ----
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(int force);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_unix.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_unix.c	2016-09-29 15:12:37.530386938 +0200
***************
*** 5364,5372 ****
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(void)
  {
!     if (curr_tmode == TMODE_RAW && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
--- 5364,5373 ----
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(int force)
  {
!     if ((curr_tmode == TMODE_RAW || force)
! 			       && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
*** ../vim-8.0.0017/src/proto/os_unix.pro	2016-09-12 13:04:15.000000000 +0200
--- src/proto/os_unix.pro	2016-09-29 15:09:02.235903956 +0200
***************
*** 61,67 ****
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(void);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 61,67 ----
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(int force);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_win32.c	2016-09-01 18:31:42.000000000 +0200
--- src/os_win32.c	2016-09-29 15:09:50.431564286 +0200
***************
*** 6187,6196 ****
  
  
  /*
!  * check for an "interrupt signal": CTRL-break or CTRL-C
   */
      void
! mch_breakcheck(void)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
--- 6187,6196 ----
  
  
  /*
!  * Check for an "interrupt signal": CTRL-break or CTRL-C.
   */
      void
! mch_breakcheck(int force)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
*** ../vim-8.0.0017/src/proto/os_win32.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_win32.pro	2016-09-29 15:10:04.219467120 +0200
***************
*** 48,54 ****
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(void);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
--- 48,54 ----
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(int force);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
*** ../vim-8.0.0017/src/version.c	2016-09-27 21:28:52.905342034 +0200
--- src/version.c	2016-09-29 15:17:41.140258776 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
ARTHUR:  Well, I can't just call you `Man'.
DENNIS:  Well, you could say `Dennis'.
ARTHUR:  Well, I didn't know you were called `Dennis.'
DENNIS:  Well, you didn't bother to find out, did you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0019
Problem:    Test_command_count is old style.
Solution:   Turn it into a new style test. (Naruhiko Nishino)
            Use more assert functions.
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/test_alot.vim,
            src/testdir/test_autocmd.vim, src/testdir/test_command_count.in,
            src/testdir/test_command_count.ok,
            src/testdir/test_command_count.vim


*** ../vim-8.0.0018/src/Makefile	2016-09-26 20:14:49.921906772 +0200
--- src/Makefile	2016-09-29 19:23:13.153274891 +0200
***************
*** 2028,2034 ****
  	test_breakindent \
  	test_changelist \
  	test_close_count \
- 	test_command_count \
  	test_comparators \
  	test_erasebackword \
  	test_eval \
--- 2028,2033 ----
***************
*** 2066,2071 ****
--- 2065,2071 ----
  	test_channel \
  	test_charsearch \
  	test_cmdline \
+ 	test_command_count \
  	test_crypt \
  	test_cscope \
  	test_cursor_func \
*** ../vim-8.0.0018/src/testdir/Make_all.mak	2016-09-26 20:14:49.921906772 +0200
--- src/testdir/Make_all.mak	2016-09-29 19:11:33.650159645 +0200
***************
*** 79,85 ****
  	test_breakindent.out \
  	test_changelist.out \
  	test_close_count.out \
- 	test_command_count.out \
  	test_comparators.out \
  	test_erasebackword.out \
  	test_eval.out \
--- 79,84 ----
*** ../vim-8.0.0018/src/testdir/test_alot.vim	2016-09-11 14:34:48.000000000 +0200
--- src/testdir/test_alot.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 3,8 ****
--- 3,9 ----
  
  source test_assign.vim
  source test_autocmd.vim
+ source test_command_count.vim
  source test_cursor_func.vim
  source test_delete.vim
  source test_execute_func.vim
*** ../vim-8.0.0018/src/testdir/test_autocmd.vim	2016-09-08 22:06:01.000000000 +0200
--- src/testdir/test_autocmd.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 1,5 ****
--- 1,13 ----
  " Tests for autocommands
  
+ function! s:cleanup_buffers() abort
+   for bnr in range(1, bufnr('$'))
+     if bufloaded(bnr) && bufnr('%') != bnr
+       execute 'bd! ' . bnr
+     endif
+   endfor
+ endfunction
+ 
  func Test_vim_did_enter()
    call assert_false(v:vim_did_enter)
  
***************
*** 254,259 ****
--- 262,270 ----
  " Tests for autocommands on :close command.
  " This used to be in test13.
  func Test_three_windows()
+   " Clean up buffers, because in some cases this function fails.
+   call s:cleanup_buffers()
+ 
    " Write three files and open them, each in a window.
    " Then go to next window, with autocommand that deletes the previous one.
    " Do this twice, writing the file.
*** ../vim-8.0.0018/src/testdir/test_command_count.in	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,158 ****
- Test for user command counts	    vim: set ft=vim :
- 
- STARTTEST
- :so small.vim
- :lang C
- :let g:lines = []
- :com -range=% RangeLines :call add(g:lines, 'RangeLines '.<line1>.' '.<line2>)
- :com -range -addr=arguments RangeArguments :call add(g:lines, 'RangeArguments '.<line1>.' '.<line2>)
- :com -range=% -addr=arguments RangeArgumentsAll :call add(g:lines, 'RangeArgumentsAll '.<line1>.' '.<line2>)
- :com -range -addr=loaded_buffers RangeLoadedBuffers :call add(g:lines, 'RangeLoadedBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=loaded_buffers RangeLoadedBuffersAll :call add(g:lines, 'RangeLoadedBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=buffers RangeBuffers :call add(g:lines, 'RangeBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=buffers RangeBuffersAll :call add(g:lines, 'RangeBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=windows RangeWindows :call add(g:lines, 'RangeWindows '.<line1>.' '.<line2>)
- :com -range=% -addr=windows RangeWindowsAll :call add(g:lines, 'RangeWindowsAll '.<line1>.' '.<line2>)
- :com -range -addr=tabs RangeTabs :call add(g:lines, 'RangeTabs '.<line1>.' '.<line2>)
- :com -range=% -addr=tabs RangeTabsAll :call add(g:lines, 'RangeTabsAll '.<line1>.' '.<line2>)
- :set hidden
- :arga a b c d
- :argdo echo "loading buffers"
- :argu 3
- :.-,$-RangeArguments
- :%RangeArguments
- :RangeArgumentsAll
- :N
- :.RangeArguments
- :split|split|split|split
- :3wincmd w
- :.,$RangeWindows
- :%RangeWindows
- :RangeWindowsAll
- :only
- :blast|bd
- :.,$RangeLoadedBuffers
- :%RangeLoadedBuffers
- :RangeLoadedBuffersAll
- :.,$RangeBuffers
- :%RangeBuffers
- :RangeBuffersAll
- :tabe|tabe|tabe|tabe
- :normal 2gt
- :.,$RangeTabs
- :%RangeTabs
- :RangeTabsAll
- :1tabonly
- :s/\n/\r\r\r\r\r/
- :2ma<
- :$-ma>
- :'<,'>RangeLines
- :com -range=% -buffer LocalRangeLines :call add(g:lines, 'LocalRangeLines '.<line1>.' '.<line2>)
- :'<,'>LocalRangeLines
- :b1
- ENDTEST
- 
- STARTTEST
- :call add(g:lines, '')
- :%argd
- :arga a b c d
- :let v:errmsg = ''
- :5argu
- :call add(g:lines, '5argu ' . v:errmsg)
- :$argu
- :call add(g:lines, '4argu ' . expand('%:t'))
- :let v:errmsg = ''
- :1argu
- :call add(g:lines, '1argu ' . expand('%:t'))
- :let v:errmsg = ''
- :100b
- :call add(g:lines, '100b ' . v:errmsg)
- :split|split|split|split
- :let v:errmsg = ''
- :0close
- :call add(g:lines, '0close ' . v:errmsg)
- :$wincmd w
- :$close
- :call add(g:lines, '$close ' . winnr())
- :let v:errmsg = ''
- :$+close
- :call add(g:lines, '$+close ' . v:errmsg)
- :$tabe
- :call add(g:lines, '$tabe ' . tabpagenr())
- :let v:errmsg = ''
- :$+tabe
- :call add(g:lines, '$+tabe ' . v:errmsg)
- :only!
- :e x
- :0tabm
- :normal 1gt
- :call add(g:lines, '0tabm ' . expand('%:t'))
- :tabonly!
- :only!
- :e! test.out
- :call append(0, g:lines)
- :unlet g:lines
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :let g:lines = []
- :func BufStatus()
- :  call add(g:lines, 'aaa: ' . buflisted(g:buf_aaa) . ' bbb: ' . buflisted(g:buf_bbb) . ' ccc: ' . buflisted(g:buf_ccc))
- :endfunc
- :se nohidden
- :e aaa
- :let buf_aaa = bufnr('%')
- :e bbb
- :let buf_bbb = bufnr('%')
- :e ccc
- :let buf_ccc = bufnr('%')
- :b1
- :call BufStatus()
- :exe buf_bbb . "," . buf_ccc . "bdelete"
- :call BufStatus()
- :exe buf_aaa . "bdelete"
- :call BufStatus()
- :e! test.out
- :call append('$', g:lines)
- :unlet g:lines
- :delfunc BufStatus
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :se hidden
- :only!
- :let g:lines = []
- :%argd
- :arga a b c d e f
- :3argu
- :let args = ''
- :.,$-argdo let args .= ' '.expand('%')
- :call add(g:lines, 'argdo:' . args)
- :split|split|split|split
- :2wincmd w
- :let windows = ''
- :.,$-windo let windows .= ' '.winnr()
- :call add(g:lines, 'windo:'. windows)
- :b2
- :let buffers = ''
- :.,$-bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :3bd
- :let buffers = ''
- :3,7bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :tabe|tabe|tabe|tabe
- :normal! 2gt
- :let tabpages = ''
- :.,$-tabdo let tabpages .= ' '.tabpagenr()
- :call add(g:lines, 'tabdo:' . tabpages)
- :e! test.out
- :call append('$', g:lines)
- :w|qa!
- ENDTEST
- 
- 
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.ok	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,38 ****
- RangeArguments 2 4
- RangeArguments 1 5
- RangeArgumentsAll 1 5
- RangeArguments 2 2
- RangeWindows 3 5
- RangeWindows 1 5
- RangeWindowsAll 1 5
- RangeLoadedBuffers 2 4
- RangeLoadedBuffers 1 4
- RangeLoadedBuffersAll 1 4
- RangeBuffers 2 5
- RangeBuffers 1 5
- RangeBuffersAll 1 5
- RangeTabs 2 5
- RangeTabs 1 5
- RangeTabsAll 1 5
- RangeLines 2 5
- LocalRangeLines 2 5
- 
- 5argu E16: Invalid range
- 4argu d
- 1argu a
- 100b E16: Invalid range
- 0close 
- $close 3
- $+close E16: Invalid range
- $tabe 2
- $+tabe E16: Invalid range
- 0tabm x
- 
- aaa: 1 bbb: 1 ccc: 1
- aaa: 1 bbb: 0 ccc: 0
- aaa: 0 bbb: 0 ccc: 0
- argdo: c d e
- windo: 2 3 4
- bufdo: 2 3 4 5 6 7 8 9 10 15
- bufdo: 4 5 6 7
- tabdo: 2 3 4
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.vim	2016-09-29 20:53:54.971440078 +0200
--- src/testdir/test_command_count.vim	2016-09-29 20:49:32.317263612 +0200
***************
*** 0 ****
--- 1,191 ----
+ " Test for user command counts.
+ 
+ func Test_command_count_0()
+   set hidden
+   set noswapfile
+ 
+   split DoesNotExistEver
+   let lastbuf = bufnr('$')
+   call setline(1, 'asdf')
+   quit!
+ 
+   command! -range -addr=loaded_buffers RangeLoadedBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=loaded_buffers RangeLoadedBuffersAll :let lines = [<line1>, <line2>]
+   command! -range -addr=buffers RangeBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=buffers RangeBuffersAll :let lines = [<line1>, <line2>]
+ 
+   .,$RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   %RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   RangeLoadedBuffersAll
+   call assert_equal([1, 1], lines)
+   .,$RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   %RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   RangeBuffersAll
+   call assert_equal([1, lastbuf], lines)
+ 
+   delcommand RangeLoadedBuffers
+   delcommand RangeLoadedBuffersAll
+   delcommand RangeBuffers
+   delcommand RangeBuffersAll
+ 
+   set hidden&
+   set swapfile&
+ endfunc
+ 
+ func Test_command_count_1()
+   silent! %argd
+   arga a b c d e
+   argdo echo "loading buffers"
+   argu 3
+   command! -range -addr=arguments RangeArguments :let lines = [<line1>, <line2>]
+   command! -range=% -addr=arguments RangeArgumentsAll :let lines = [<line1>, <line2>]
+   .-,$-RangeArguments
+   call assert_equal([2, 4], lines)
+   %RangeArguments
+   call assert_equal([1, 5], lines)
+   RangeArgumentsAll
+   call assert_equal([1, 5], lines)
+   N
+   .RangeArguments
+   call assert_equal([2, 2], lines)
+   delcommand RangeArguments
+   delcommand RangeArgumentsAll
+ 
+   split|split|split|split
+   3wincmd w
+   command! -range -addr=windows RangeWindows :let lines = [<line1>, <line2>]
+   .,$RangeWindows
+   call assert_equal([3, 5], lines)
+   %RangeWindows
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindows
+ 
+   command! -range=% -addr=windows RangeWindowsAll :let lines = [<line1>, <line2>]
+   RangeWindowsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindowsAll
+   only
+   blast|bd
+ 
+   tabe|tabe|tabe|tabe
+   normal 2gt
+   command! -range -addr=tabs RangeTabs :let lines = [<line1>, <line2>]
+   .,$RangeTabs
+   call assert_equal([2, 5], lines)
+   %RangeTabs
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabs
+ 
+   command! -range=% -addr=tabs RangeTabsAll :let lines = [<line1>, <line2>]
+   RangeTabsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabsAll
+   1tabonly
+ 
+   s/\n/\r\r\r\r\r/
+   2ma<
+   $-ma>
+   command! -range=% RangeLines :let lines = [<line1>, <line2>]
+   '<,'>RangeLines
+   call assert_equal([2, 5], lines)
+   delcommand RangeLines
+ 
+   command! -range=% -buffer LocalRangeLines :let lines = [<line1>, <line2>]
+   '<,'>LocalRangeLines
+   call assert_equal([2, 5], lines)
+   delcommand LocalRangeLines
+ endfunc
+ 
+ func Test_command_count_2()
+   silent! %argd
+   arga a b c d
+   call assert_fails('5argu', 'E16:')
+ 
+   $argu
+   call assert_equal('d', expand('%:t'))
+ 
+   1argu
+   call assert_equal('a', expand('%:t'))
+ 
+   call assert_fails('300b', 'E16:')
+ 
+   split|split|split|split
+   0close
+ 
+   $wincmd w
+   $close
+   call assert_equal(3, winnr())
+ 
+   call assert_fails('$+close', 'E16:')
+ 
+   $tabe
+   call assert_equal(2, tabpagenr())
+ 
+   call assert_fails('$+tabe', 'E16:')
+ 
+   only!
+   e x
+   0tabm
+   normal 1gt
+   call assert_equal('x', expand('%:t'))
+ 
+   tabonly!
+   only!
+ endfunc
+ 
+ func Test_command_count_3()
+   se nohidden
+   e aaa
+   let buf_aaa = bufnr('%')
+   e bbb
+   let buf_bbb = bufnr('%')
+   e ccc
+   let buf_ccc = bufnr('%')
+   buf 1
+   call assert_equal([1, 1, 1], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_bbb . "," . buf_ccc . "bdelete"
+   call assert_equal([1, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_aaa . "bdelete"
+   call assert_equal([0, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+ endfunc
+ 
+ func Test_command_count_4()
+   %argd
+   let bufnr = bufnr('$') + 1
+   arga aa bb cc dd ee ff
+   3argu
+   let args = []
+   .,$-argdo call add(args, expand('%'))
+   call assert_equal(['cc', 'dd', 'ee'], args)
+ 
+   " create windows to get 5
+   split|split|split|split
+   2wincmd w
+   let windows = []
+   .,$-windo call add(windows, winnr())
+   call assert_equal([2, 3, 4], windows)
+   only!
+ 
+   exe bufnr . 'buf'
+   let buffers = []
+   .,$-bufdo call add(buffers, bufnr('%'))
+   call assert_equal([bufnr, bufnr + 1, bufnr + 2, bufnr + 3, bufnr + 4], buffers)
+ 
+   exe (bufnr + 3) . 'bdel'
+   let buffers = []
+   exe (bufnr + 2) . ',' . (bufnr + 5) . "bufdo call add(buffers, bufnr('%'))"
+   call assert_equal([bufnr + 2, bufnr + 4, bufnr +  5], buffers)
+ 
+   " create tabpages to get 5
+   tabe|tabe|tabe|tabe
+   normal! 2gt
+   let tabpages = []
+   .,$-tabdo call add(tabpages, tabpagenr())
+   call assert_equal([2, 3, 4], tabpages)
+   tabonly!
+   bwipe!
+ endfunc
*** ../vim-8.0.0018/src/version.c	2016-09-29 15:18:51.359768012 +0200
--- src/version.c	2016-09-29 20:50:17.684948652 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
A computer programmer is a device for turning requirements into
undocumented features.  It runs on cola, pizza and Dilbert cartoons.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0020
Problem:    The regexp engines are not reentrant.
Solution:   Add regexec_T and save/restore the state when needed.
Files:      src/regexp.c, src/regexp_nfa.c, src/testdir/test_expr.vim,
            runtime/doc/eval.txt, runtime/doc/change.txt


*** ../vim-8.0.0019/src/regexp.c	2016-09-09 20:20:20.000000000 +0200
--- src/regexp.c	2016-10-02 16:21:22.709068952 +0200
***************
*** 3509,3535 ****
  #endif
  
  /*
-  * Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
-  * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
-  * contains '\c' or '\C' the value is overruled.
-  */
- static int	ireg_ic;
- 
- #ifdef FEAT_MBYTE
- /*
-  * Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
-  * in the regexp.  Defaults to false, always.
-  */
- static int	ireg_icombine;
- #endif
- 
- /*
-  * Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
-  * there is no maximum.
-  */
- static colnr_T	ireg_maxcol;
- 
- /*
   * Sometimes need to save a copy of a line.  Since alloc()/free() is very
   * slow, we keep one allocated piece of memory and only re-allocate it when
   * it's too small.  It's freed in bt_regexec_both() when finished.
--- 3509,3514 ----
***************
*** 3538,3544 ****
  static unsigned	reg_tofreelen;
  
  /*
!  * These variables are set when executing a regexp to speed up the execution.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
--- 3517,3523 ----
  static unsigned	reg_tofreelen;
  
  /*
!  * Structure used to store the execution state of the regex engine.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
***************
*** 3554,3570 ****
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! static regmatch_T	*reg_match;
! static regmmatch_T	*reg_mmatch;
! static char_u		**reg_startp = NULL;
! static char_u		**reg_endp = NULL;
! static lpos_T		*reg_startpos = NULL;
! static lpos_T		*reg_endpos = NULL;
! static win_T		*reg_win;
! static buf_T		*reg_buf;
! static linenr_T		reg_firstlnum;
! static linenr_T		reg_maxline;
! static int		reg_line_lbr;	    /* "\n" in string is line break */
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
--- 3533,3570 ----
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! typedef struct {
!     regmatch_T		*reg_match;
!     regmmatch_T		*reg_mmatch;
!     char_u		**reg_startp;
!     char_u		**reg_endp;
!     lpos_T		*reg_startpos;
!     lpos_T		*reg_endpos;
!     win_T		*reg_win;
!     buf_T		*reg_buf;
!     linenr_T		reg_firstlnum;
!     linenr_T		reg_maxline;
!     int			reg_line_lbr;	/* "\n" in string is line break */
! 
!     /* Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
!      * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
!      * contains '\c' or '\C' the value is overruled. */
!     int			reg_ic;
! 
! #ifdef FEAT_MBYTE
!     /* Similar to rex.reg_ic, but only for 'combining' characters.  Set with \Z
!      * flag in the regexp.  Defaults to false, always. */
!     int			reg_icombine;
! #endif
! 
!     /* Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
!      * there is no maximum. */
!     colnr_T		reg_maxcol;
! } regexec_T;
! 
! static regexec_T	rex;
! static int		rex_in_use = FALSE;
! 
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
***************
*** 3669,3680 ****
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(reg_buf, reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
--- 3669,3680 ----
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (rex.reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > rex.reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
***************
*** 3687,3696 ****
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(reg_match == NULL)
! 
! static int  bt_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);
! 
  
  /*
   * Match a regexp against a string.
--- 3687,3693 ----
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(rex.reg_match == NULL)
  
  /*
   * Match a regexp against a string.
***************
*** 3707,3729 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
- static long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm);
- 
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
--- 3704,3724 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
***************
*** 3741,3758 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
--- 3736,3753 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
***************
*** 3794,3809 ****
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 3789,3804 ----
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 3818,3836 ****
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
--- 3813,3831 ----
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
***************
*** 3850,3856 ****
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 3845,3851 ----
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 3862,3868 ****
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!ireg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
--- 3857,3863 ----
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
***************
*** 3898,3904 ****
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (ireg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
--- 3893,3899 ----
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (rex.reg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
***************
*** 3920,3926 ****
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!ireg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
--- 3915,3921 ----
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
***************
*** 3937,3943 ****
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	    {
  		retval = 0;
  		break;
--- 3932,3938 ----
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	    {
  		retval = 0;
  		break;
***************
*** 4056,4081 ****
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
--- 4051,4076 ----
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
***************
*** 4125,4131 ****
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
      return -1;
  }
  #endif
--- 4120,4126 ----
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			 - (*mb_head_off)(regline, reginput - 1), rex.reg_buf);
      return -1;
  }
  #endif
***************
*** 4141,4154 ****
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = reg_win == NULL ? curwin : reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
--- 4136,4149 ----
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = rex.reg_win == NULL ? curwin : rex.reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (rex.reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
***************
*** 4179,4185 ****
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
--- 4174,4180 ----
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + rex.reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
***************
*** 4309,4320 ****
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!reg_line_lbr && WITH_NL(op) && REG_MULTI
! 				&& *reginput == NUL && reglnum <= reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
--- 4304,4315 ----
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI
! 			     && *reginput == NUL && reglnum <= rex.reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (rex.reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
***************
*** 4345,4365 ****
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 					  || (REG_MULTI && reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * reg_win->w_cursor position to the match position. */
! 	    if (reg_win == NULL
! 		    || (reglnum + reg_firstlnum != reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline) != reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
--- 4340,4362 ----
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 				       || (REG_MULTI && rex.reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != rex.reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * rex.reg_win->w_cursor position to the match position. */
! 	    if (rex.reg_win == NULL
! 		    || (reglnum + rex.reg_firstlnum
! 						 != rex.reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline)
! 						 != rex.reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
***************
*** 4370,4385 ****
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
--- 4367,4382 ----
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(rex.reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
***************
*** 4392,4398 ****
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
--- 4389,4395 ----
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + rex.reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4404,4410 ****
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    reg_win == NULL ? curwin : reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
--- 4401,4407 ----
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    rex.reg_win == NULL ? curwin : rex.reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4418,4424 ****
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
--- 4415,4421 ----
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
***************
*** 4427,4434 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, reg_buf) || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
--- 4424,4431 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, rex.reg_buf) || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
***************
*** 4442,4448 ****
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
--- 4439,4445 ----
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
***************
*** 4451,4458 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], reg_buf)
! 			|| (reginput[0] != NUL && vim_iswordc_buf(c, reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
--- 4448,4456 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
! 			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(c, rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
***************
*** 4480,4493 ****
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput) || !vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
--- 4478,4492 ----
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput)
! 				    || !vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
***************
*** 4655,4661 ****
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!ireg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
--- 4654,4660 ----
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!rex.reg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
***************
*** 4670,4676 ****
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && ireg_ic)
  #endif
  			)
  		    {
--- 4669,4675 ----
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && rex.reg_ic)
  #endif
  			)
  		    {
***************
*** 4689,4695 ****
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !ireg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
--- 4688,4694 ----
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !rex.reg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
***************
*** 4840,4847 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_startpos[no],
! 							     &reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4839,4846 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],
! 							  &rex.reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4900,4906 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_endpos[no], &reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4899,4906 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],
! 							    &rex.reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4949,4955 ****
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
--- 4949,4955 ----
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
***************
*** 4958,4983 ****
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(reg_endp[no] - reg_startp[no]);
! 			if (cstrncmp(reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (reg_startpos[no].lnum == reglnum
! 				&& reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = reg_endpos[no].col - reg_startpos[no].col;
! 			    if (cstrncmp(regline + reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
--- 4958,4985 ----
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(rex.reg_endp[no] - rex.reg_startp[no]);
! 			if (cstrncmp(rex.reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (rex.reg_startpos[no].lnum < 0
! 						|| rex.reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (rex.reg_startpos[no].lnum == reglnum
! 				&& rex.reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = rex.reg_endpos[no].col
! 						    - rex.reg_startpos[no].col;
! 			    if (cstrncmp(regline + rex.reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
***************
*** 4986,4995 ****
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    reg_startpos[no].lnum,
! 					    reg_startpos[no].col,
! 					    reg_endpos[no].lnum,
! 					    reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
--- 4988,4997 ----
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    rex.reg_startpos[no].lnum,
! 					    rex.reg_startpos[no].col,
! 					    rex.reg_endpos[no].lnum,
! 					    rex.reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
***************
*** 5154,5160 ****
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (ireg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
--- 5156,5162 ----
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (rex.reg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
***************
*** 5282,5291 ****
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > reg_maxline
! 			     || reg_line_lbr) && (c != '\n' || !reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 5284,5294 ----
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > rex.reg_maxline
! 			     || rex.reg_line_lbr)
! 					   && (c != '\n' || !rex.reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 5331,5338 ****
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_startpos[rp->rs_no],
! 						  &reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5334,5341 ----
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],
! 						  &rex.reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5349,5356 ****
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_endpos[rp->rs_no],
! 						    &reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5352,5359 ----
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],
! 						    &rex.reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5785,5792 ****
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 					 || reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
--- 5788,5795 ----
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 				      || rex.reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
***************
*** 5810,5824 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5813,5827 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5834,5855 ****
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5837,5858 ----
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, rex.reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5871,5885 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5874,5888 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5897,5904 ****
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5900,5907 ----
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5910,5916 ****
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5913,5919 ----
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5929,5936 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5932,5939 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5947,5953 ****
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5950,5956 ----
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 6031,6037 ****
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (ireg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
--- 6034,6040 ----
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (rex.reg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
***************
*** 6062,6075 ****
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (ireg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!ireg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
--- 6065,6078 ----
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (rex.reg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!rex.reg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
***************
*** 6094,6108 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
--- 6097,6111 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
***************
*** 6124,6134 ****
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= reg_maxline && !reg_line_lbr
! 			    && REG_MULTI) || (*scan == '\n' && reg_line_lbr)))
  	{
  	    count++;
! 	    if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 6127,6138 ----
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= rex.reg_maxline
! 				       && !rex.reg_line_lbr && REG_MULTI)
! 		    || (*scan == '\n' && rex.reg_line_lbr)))
  	{
  	    count++;
! 	    if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 6183,6189 ****
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? reg_mmatch->regprog : reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
--- 6187,6193 ----
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
***************
*** 6209,6221 ****
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
--- 6213,6225 ----
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
***************
*** 6261,6273 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = reg_startpos[i];
! 		bp->save_end[i].se_u.pos = reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = reg_startp[i];
! 		bp->save_end[i].se_u.ptr = reg_endp[i];
  	    }
  	}
      }
--- 6265,6277 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = rex.reg_startpos[i];
! 		bp->save_end[i].se_u.pos = rex.reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = rex.reg_startp[i];
! 		bp->save_end[i].se_u.ptr = rex.reg_endp[i];
  	    }
  	}
      }
***************
*** 6289,6301 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
--- 6293,6305 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		rex.reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		rex.reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		rex.reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
***************
*** 6454,6460 ****
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
--- 6458,6464 ----
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= rex.reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
***************
*** 7039,7045 ****
  #endif
  
  /*
!  * Compare two strings, ignore case if ireg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
--- 7043,7049 ----
  #endif
  
  /*
!  * Compare two strings, ignore case if rex.reg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
***************
*** 7048,7061 ****
  {
      int		result;
  
!     if (!ireg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && ireg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
--- 7052,7065 ----
  {
      int		result;
  
!     if (!rex.reg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && rex.reg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
***************
*** 7074,7087 ****
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!ireg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12 && (!ireg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
--- 7078,7092 ----
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12
! 			    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
***************
*** 7103,7109 ****
      char_u	*p;
      int		cc;
  
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
--- 7108,7114 ----
      char_u	*p;
      int		cc;
  
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
***************
*** 7276,7289 ****
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used instead of reg_match and reg_mmatch for
!  * reg_submatch().  Needed for when the substitution string is an expression
!  * that contains a call to substitute() and submatch(). */
! static regmatch_T	*submatch_match;
! static regmmatch_T	*submatch_mmatch;
! static linenr_T		submatch_firstlnum;
! static linenr_T		submatch_maxline;
! static int		submatch_line_lbr;
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
--- 7281,7298 ----
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used for reg_submatch().  Needed for when the
!  * substitution string is an expression that contains a call to substitute()
!  * and submatch(). */
! typedef struct {
!     regmatch_T	*sm_match;
!     regmmatch_T	*sm_mmatch;
!     linenr_T	sm_firstlnum;
!     linenr_T	sm_maxline;
!     int		sm_line_lbr;
! } regsubmatch_T;
! 
! static regsubmatch_T rsm;  /* can only be used when can_f_submatch is TRUE */
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
***************
*** 7310,7320 ****
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = submatch_match->startp[i];
! 	if (s == NULL || submatch_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(submatch_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
--- 7319,7329 ----
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = rsm.sm_match->startp[i];
! 	if (s == NULL || rsm.sm_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(rsm.sm_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
***************
*** 7359,7370 ****
      int		magic,
      int		backslash)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_buf = curbuf;
!     reg_line_lbr = TRUE;
!     return vim_regsub_both(source, expr, dest, copy, magic, backslash);
  }
  #endif
  
--- 7368,7394 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_buf = curbuf;
!     rex.reg_line_lbr = TRUE;
!     result = vim_regsub_both(source, expr, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  #endif
  
***************
*** 7378,7390 ****
      int		magic,
      int		backslash)
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = curbuf;		/* always works on the current buffer! */
!     reg_firstlnum = lnum;
!     reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     return vim_regsub_both(source, NULL, dest, copy, magic, backslash);
  }
  
      static int
--- 7402,7429 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = curbuf;	/* always works on the current buffer! */
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  
      static int
***************
*** 7424,7434 ****
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='
! #ifdef FEAT_EVAL
! 	    && !can_f_submatch	    /* can't do this recursively */
! #endif
! 	    ))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
--- 7463,7469 ----
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
***************
*** 7447,7470 ****
  	}
  	else
  	{
! 	    win_T	*save_reg_win;
! 	    int		save_ireg_ic;
! 	    int		prev_can_f_submatch = can_f_submatch;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level.  Don't need to save "reg_buf", because
! 	     * vim_regexec_multi() can't be called recursively. */
! 	    submatch_match = reg_match;
! 	    submatch_mmatch = reg_mmatch;
! 	    submatch_firstlnum = reg_firstlnum;
! 	    submatch_maxline = reg_maxline;
! 	    submatch_line_lbr = reg_line_lbr;
! 	    save_reg_win = reg_win;
! 	    save_ireg_ic = ireg_ic;
  	    can_f_submatch = TRUE;
  
  	    if (expr != NULL)
  	    {
--- 7482,7503 ----
  	}
  	else
  	{
! 	    int		    prev_can_f_submatch = can_f_submatch;
! 	    regsubmatch_T   rsm_save;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level. */
! 	    if (can_f_submatch)
! 		rsm_save = rsm;
  	    can_f_submatch = TRUE;
+ 	    rsm.sm_match = rex.reg_match;
+ 	    rsm.sm_mmatch = rex.reg_mmatch;
+ 	    rsm.sm_firstlnum = rex.reg_firstlnum;
+ 	    rsm.sm_maxline = rex.reg_maxline;
+ 	    rsm.sm_line_lbr = rex.reg_line_lbr;
  
  	    if (expr != NULL)
  	    {
***************
*** 7476,7510 ****
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		if (prev_can_f_submatch)
! 		{
! 		    /* can't do this recursively */
! 		}
! 		else
! 		{
! 		    argv[0].v_type = VAR_LIST;
! 		    argv[0].vval.v_list = &matchList.sl_list;
! 		    matchList.sl_list.lv_len = 0;
! 		    if (expr->v_type == VAR_FUNC)
! 		    {
! 			s = expr->vval.v_string;
! 			call_func(s, (int)STRLEN(s), &rettv,
! 					1, argv, fill_submatch_list,
! 					     0L, 0L, &dummy, TRUE, NULL, NULL);
! 		    }
! 		    else if (expr->v_type == VAR_PARTIAL)
! 		    {
! 			partial_T   *partial = expr->vval.v_partial;
  
- 			s = partial_name(partial);
- 			call_func(s, (int)STRLEN(s), &rettv,
- 					1, argv, fill_submatch_list,
- 					  0L, 0L, &dummy, TRUE, partial, NULL);
- 		    }
- 		    if (matchList.sl_list.lv_len > 0)
- 			/* fill_submatch_list() was called */
- 			clear_submatch_list(&matchList);
- 		}
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
--- 7509,7537 ----
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		argv[0].v_type = VAR_LIST;
! 		argv[0].vval.v_list = &matchList.sl_list;
! 		matchList.sl_list.lv_len = 0;
! 		if (expr->v_type == VAR_FUNC)
! 		{
! 		    s = expr->vval.v_string;
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 					 0L, 0L, &dummy, TRUE, NULL, NULL);
! 		}
! 		else if (expr->v_type == VAR_PARTIAL)
! 		{
! 		    partial_T   *partial = expr->vval.v_partial;
! 
! 		    s = partial_name(partial);
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 				      0L, 0L, &dummy, TRUE, partial, NULL);
! 		}
! 		if (matchList.sl_list.lv_len > 0)
! 		    /* fill_submatch_list() was called */
! 		    clear_submatch_list(&matchList);
  
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
***************
*** 7522,7528 ****
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !submatch_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
--- 7549,7555 ----
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !rsm.sm_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
***************
*** 7533,7539 ****
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !submatch_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
--- 7560,7566 ----
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !rsm.sm_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
***************
*** 7552,7565 ****
  		dst += STRLEN(eval_result);
  	    }
  
! 	    reg_match = submatch_match;
! 	    reg_mmatch = submatch_mmatch;
! 	    reg_firstlnum = submatch_firstlnum;
! 	    reg_maxline = submatch_maxline;
! 	    reg_line_lbr = submatch_line_lbr;
! 	    reg_win = save_reg_win;
! 	    ireg_ic = save_ireg_ic;
! 	    can_f_submatch = FALSE;
  	}
  #endif
      }
--- 7579,7587 ----
  		dst += STRLEN(eval_result);
  	    }
  
! 	    can_f_submatch = prev_can_f_submatch;
! 	    if (can_f_submatch)
! 		rsm = rsm_save;
  	}
  #endif
      }
***************
*** 7688,7713 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + reg_mmatch->startpos[no].col;
! 		    if (reg_mmatch->endpos[no].lnum == clnum)
! 			len = reg_mmatch->endpos[no].col
! 					       - reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = reg_match->startp[no];
! 		if (reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
--- 7710,7735 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = rex.reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;
! 		    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 			len = rex.reg_mmatch->endpos[no].col
! 					    - rex.reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = rex.reg_match->startp[no];
! 		if (rex.reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(rex.reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
***************
*** 7717,7730 ****
  		    {
  			if (REG_MULTI)
  			{
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
! 				len = reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
--- 7739,7752 ----
  		    {
  			if (REG_MULTI)
  			{
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 				len = rex.reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
***************
*** 7824,7839 ****
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = reg_firstlnum;
!     linenr_T save_max = reg_maxline;
  
!     reg_firstlnum = submatch_firstlnum;
!     reg_maxline = submatch_maxline;
  
      s = reg_getline(lnum);
  
!     reg_firstlnum = save_first;
!     reg_maxline = save_max;
      return s;
  }
  
--- 7846,7861 ----
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = rex.reg_firstlnum;
!     linenr_T save_max = rex.reg_maxline;
  
!     rex.reg_firstlnum = rsm.sm_firstlnum;
!     rex.reg_maxline = rsm.sm_maxline;
  
      s = reg_getline(lnum);
  
!     rex.reg_firstlnum = save_first;
!     rex.reg_maxline = save_max;
      return s;
  }
  
***************
*** 7854,7860 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
--- 7876,7882 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
***************
*** 7862,7879 ****
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = submatch_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || submatch_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + submatch_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (submatch_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = submatch_mmatch->endpos[no].col
! 					  - submatch_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
--- 7884,7901 ----
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = rsm.sm_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + rsm.sm_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (rsm.sm_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = rsm.sm_mmatch->endpos[no].col
! 					  - rsm.sm_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
***************
*** 7890,7896 ****
  		}
  		++len;
  		++lnum;
! 		while (lnum < submatch_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
--- 7912,7918 ----
  		}
  		++len;
  		++lnum;
! 		while (lnum < rsm.sm_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
***************
*** 7902,7909 ****
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     submatch_mmatch->endpos[no].col);
! 		len += submatch_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
--- 7924,7931 ----
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     rsm.sm_mmatch->endpos[no].col);
! 		len += rsm.sm_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
***************
*** 7919,7929 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
      }
  
      return retval;
--- 7941,7951 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(rsm.sm_match->endp[no] - s));
      }
  
      return retval;
***************
*** 7951,7965 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
! 	slnum = submatch_mmatch->startpos[no].lnum;
! 	elnum = submatch_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = submatch_mmatch->startpos[no].col;
! 	ecol = submatch_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
--- 7973,7987 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
! 	slnum = rsm.sm_mmatch->startpos[no].lnum;
! 	elnum = rsm.sm_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = rsm.sm_mmatch->startpos[no].col;
! 	ecol = rsm.sm_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
***************
*** 7988,8001 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(submatch_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
--- 8010,8023 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(rsm.sm_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
***************
*** 8173,8179 ****
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8195,8214 ----
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
!     rex.reg_startp = NULL;
!     rex.reg_endp = NULL;
!     rex.reg_startpos = NULL;
!     rex.reg_endpos = NULL;
! 
!     result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8198,8203 ****
--- 8233,8243 ----
  
  	p_re = save_p_re;
      }
+ 
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result > 0;
  }
  
***************
*** 8264,8271 ****
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int result = rmp->regprog->engine->regexec_multi(
! 						rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8304,8319 ----
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8291,8295 ****
--- 8339,8347 ----
  	p_re = save_p_re;
      }
  
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result <= 0 ? 0 : result;
  }
*** ../vim-8.0.0019/src/regexp_nfa.c	2016-09-09 20:26:46.000000000 +0200
--- src/regexp_nfa.c	2016-10-02 15:51:12.173504331 +0200
***************
*** 5432,5438 ****
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 5432,5438 ----
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 5467,5473 ****
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!ireg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
--- 5467,5473 ----
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!rex.reg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
***************
*** 5485,5499 ****
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[0].lnum = reglnum;
! 		reg_startpos[0].col = col;
! 		reg_endpos[0].lnum = reglnum;
! 		reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		reg_startp[0] = regline + col;
! 		reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
--- 5485,5499 ----
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[0].lnum = reglnum;
! 		rex.reg_startpos[0].col = col;
! 		rex.reg_endpos[0].lnum = reglnum;
! 		rex.reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		rex.reg_startp[0] = regline + col;
! 		rex.reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
***************
*** 5728,5735 ****
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * ireg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !ireg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
--- 5728,5735 ----
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * rex.reg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !rex.reg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
***************
*** 6048,6063 ****
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, reg_buf)
  			   || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6048,6063 ----
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, rex.reg_buf)
  			   || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6076,6091 ****
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], reg_buf)
  			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(curc, reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6076,6091 ----
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
  			|| (reginput[0] != NUL
! 					&& vim_iswordc_buf(curc, rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6096,6102 ****
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 					&& (!REG_MULTI || reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6096,6102 ----
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 				     && (!REG_MULTI || rex.reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6104,6110 ****
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6104,6110 ----
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == rex.reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6131,6137 ****
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (ireg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
--- 6131,6137 ----
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (rex.reg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
***************
*** 6190,6197 ****
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !reg_line_lbr && REG_MULTI
! 						    && reglnum <= reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
--- 6190,6197 ----
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !rex.reg_line_lbr && REG_MULTI
! 						 && reglnum <= rex.reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
***************
*** 6199,6205 ****
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
--- 6199,6205 ----
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && rex.reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
***************
*** 6244,6250 ****
  			    result = result_if_matched;
  			    break;
  			}
! 			if (ireg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
--- 6244,6250 ----
  			    result = result_if_matched;
  			    break;
  			}
! 			if (rex.reg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
***************
*** 6262,6268 ****
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (ireg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
--- 6262,6268 ----
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (rex.reg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
***************
*** 6320,6332 ****
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 					&& vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6320,6332 ----
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 				     && vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6441,6464 ****
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (ireg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			  && !(ri_lower(curc) || (ireg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (ireg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			  && !(ri_upper(curc) || (ireg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6441,6464 ----
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6549,6555 ****
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6549,6555 ----
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + rex.reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6575,6581 ****
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = reg_win == NULL ? curwin : reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
--- 6575,6581 ----
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
***************
*** 6611,6628 ****
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
--- 6611,6628 ----
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
***************
*** 6634,6643 ****
  	      }
  
  	    case NFA_CURSOR:
! 		result = (reg_win != NULL
! 			&& (reglnum + reg_firstlnum == reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						   == reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6634,6644 ----
  	      }
  
  	    case NFA_CURSOR:
! 		result = (rex.reg_win != NULL
! 			&& (reglnum + rex.reg_firstlnum
! 						 == rex.reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						== rex.reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6691,6702 ****
  #endif
  		result = (c == curc);
  
! 		if (!result && ireg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If ireg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !ireg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
--- 6692,6703 ----
  #endif
  		result = (c == curc);
  
! 		if (!result && rex.reg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If rex.reg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !rex.reg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
***************
*** 6815,6822 ****
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (ireg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < ireg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
--- 6816,6823 ----
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (rex.reg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < rex.reg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
***************
*** 6856,6863 ****
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!ireg_ic || MB_TOLOWER(c)
! 					       != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
--- 6857,6864 ----
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!rex.reg_ic
! 			       || MB_TOLOWER(c) != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
***************
*** 6997,7036 ****
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startp[i] = subs.norm.list.line[i].start;
! 	    reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
--- 6998,7037 ----
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startp[i] = subs.norm.list.line[i].start;
! 	    rex.reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
***************
*** 7093,7108 ****
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 7094,7109 ----
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 7112,7127 ****
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      regline = line;
--- 7113,7128 ----
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      regline = line;
***************
*** 7160,7173 ****
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !ireg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
--- 7161,7174 ----
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !rex.reg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
***************
*** 7326,7342 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
--- 7327,7343 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
***************
*** 7375,7392 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
--- 7376,7393 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
*** ../vim-8.0.0019/src/testdir/test_expr.vim	2016-09-14 22:16:09.863803610 +0200
--- src/testdir/test_expr.vim	2016-10-02 16:29:45.285611327 +0200
***************
*** 405,413 ****
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y*', {-> g:val}, '')
    endfunc
!   call assert_equal('--', substitute('xxx', 'x*', {-> '-' . Recurse() . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
--- 405,414 ----
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y\(.\)y', {-> submatch(1)}, '')
    endfunc
!   " recursive call works
!   call assert_equal('-y-x-', substitute('xxx', 'x\(.\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
*** ../vim-8.0.0019/runtime/doc/eval.txt	2016-09-27 21:28:52.905342034 +0200
--- runtime/doc/eval.txt	2016-10-02 16:39:09.841721025 +0200
***************
*** 7379,7384 ****
--- 7390,7398 ----
  		|substitute()| this list will always contain one or zero
  		items, since there are no real line breaks.
  
+ 		When substitute() is used recursively only the submatches in
+ 		the current (deepest) call can be obtained.
+ 
  		Example: >
  			:s/\d\+/\=submatch(0) + 1/
  <		This finds the first number in the line and adds one to it.
*** ../vim-8.0.0019/runtime/doc/change.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/change.txt	2016-10-02 16:37:35.170373987 +0200
***************
*** 1,4 ****
! *change.txt*    For Vim version 8.0.  Last change: 2016 Sep 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *change.txt*    For Vim version 8.0.  Last change: 2016 Oct 02
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 913,920 ****
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.  This does not work recursively: a |substitute()| function inside
! the expression cannot use "\=" for the substitute string.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
--- 913,919 ----
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
*** ../vim-8.0.0019/src/version.c	2016-09-29 20:54:42.407110721 +0200
--- src/version.c	2016-10-02 15:27:58.639175908 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
    With sufficient thrust, pigs fly just fine.
                   -- RFC 1925

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0021
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0021
Problem:    In the GUI when redrawing the cursor it may be on the second half
            of a double byte character.
Solution:   Correct the cursor column. (Yasuhiro Matsumoto)
Files:      src/screen.c


*** ../vim-8.0.0020/src/screen.c	2016-08-29 22:42:20.000000000 +0200
--- src/screen.c	2016-10-02 23:04:57.705033401 +0200
***************
*** 765,770 ****
--- 765,773 ----
  	     * uses that. */
  	    gui.col = gui_cursor_col;
  	    gui.row = gui_cursor_row;
+ # ifdef FEAT_MBYTE
+ 	    gui.col = mb_fix_col(gui.col, gui.row);
+ # endif
  	    gui_update_cursor(FALSE, FALSE);
  	    screen_cur_col = gui.col;
  	    screen_cur_row = gui.row;
*** ../vim-8.0.0020/src/version.c	2016-10-02 16:51:32.748592858 +0200
--- src/version.c	2016-10-02 23:06:01.632588200 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     21,
  /**/

-- 
BLACK KNIGHT:  I move for no man.
ARTHUR:        So be it!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's left arm off]
ARTHUR:        Now stand aside, worthy adversary.
BLACK KNIGHT:  'Tis but a scratch.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0022
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0022
Problem:    If a channel in NL mode is missing the NL at the end the remaining
            characters are dropped.
Solution:   When the channel is closed use the remaining text. (Ozaki Kiichi)
Files:      src/channel.c, src/testdir/test_channel.vim


*** ../vim-8.0.0021/src/channel.c	2016-09-29 15:18:51.351768068 +0200
--- src/channel.c	2016-10-03 21:35:54.516547182 +0200
***************
*** 2355,2362 ****
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
!     cbq_T	*cbhead = &channel->ch_part[part].ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
--- 2355,2363 ----
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     chanpart_T	*ch_part = &channel->ch_part[part];
!     ch_mode_T	ch_mode = ch_part->ch_mode;
!     cbq_T	*cbhead = &ch_part->ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
***************
*** 2376,2385 ****
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (channel->ch_part[part].ch_callback != NULL)
      {
! 	callback = channel->ch_part[part].ch_callback;
! 	partial = channel->ch_part[part].ch_partial;
      }
      else
      {
--- 2377,2386 ----
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (ch_part->ch_callback != NULL)
      {
! 	callback = ch_part->ch_callback;
! 	partial = ch_part->ch_partial;
      }
      else
      {
***************
*** 2387,2397 ****
  	partial = channel->ch_partial;
      }
  
!     buffer = channel->ch_part[part].ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&channel->ch_part[part].ch_bufref))
      {
  	/* buffer was wiped out */
! 	channel->ch_part[part].ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
--- 2388,2398 ----
  	partial = channel->ch_partial;
      }
  
!     buffer = ch_part->ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&ch_part->ch_bufref))
      {
  	/* buffer was wiped out */
! 	ch_part->ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
***************
*** 2452,2458 ****
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl;
  	    char_u  *buf;
  	    readq_T *node;
  
--- 2453,2459 ----
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl = NULL;
  	    char_u  *buf;
  	    readq_T *node;
  
***************
*** 2465,2474 ****
--- 2466,2490 ----
  		if (nl != NULL)
  		    break;
  		if (channel_collapse(channel, part, TRUE) == FAIL)
+ 		{
+ 		    if (ch_part->ch_fd == INVALID_FD && node->rq_buflen > 0)
+ 			break;
  		    return FALSE; /* incomplete message */
+ 		}
  	    }
  	    buf = node->rq_buffer;
  
+ 	    if (nl == NULL)
+ 	    {
+ 		/* Flush remaining message that is missing a NL. */
+ 		buf = vim_realloc(buf, node->rq_buflen + 1);
+ 		if (buf == NULL)
+ 		    return FALSE;
+ 		node->rq_buffer = buf;
+ 		nl = buf + node->rq_buflen++;
+ 		*nl = NUL;
+ 	    }
+ 
  	    /* Convert NUL to NL, the internal representation. */
  	    for (p = buf; p < nl && p < buf + node->rq_buflen; ++p)
  		if (*p == NUL)
*** ../vim-8.0.0021/src/testdir/test_channel.vim	2016-09-26 22:36:50.615386371 +0200
--- src/testdir/test_channel.vim	2016-10-03 21:31:14.246500828 +0200
***************
*** 1484,1489 ****
--- 1484,1510 ----
    bwipe!
  endfunc
  
+ func MyLineCountCb(ch, msg)
+   let g:linecount += 1
+ endfunc
+ 
+ func Test_read_nonl_line()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes
+     let arg = 'import sys;sys.stdout.write(\"1\n2\n3\")'
+   else
+     let arg = 'import sys;sys.stdout.write("1\n2\n3")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('3 <= g:linecount')
+   call assert_equal(3, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0021/src/version.c	2016-10-02 23:09:27.643153731 +0200
--- src/version.c	2016-10-03 21:33:11.837681063 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
"It's so simple to be wise.  Just think of something stupid to say
and then don't say it."        -- Sam Levenson

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0023
Problem:    "gd" and "gD" may find a match in a comment or string.
Solution:   Ignore matches in comments and strings. (Anton Lindqvist)
Files:      src/normal.c, src/testdir/test_goto.vim


*** ../vim-8.0.0022/src/normal.c	2016-09-11 16:52:37.000000000 +0200
--- src/normal.c	2016-10-08 19:05:10.213933460 +0200
***************
*** 4240,4245 ****
--- 4240,4291 ----
  }
  
  /*
+  * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE
+  * otherwise.
+  */
+     static int
+ is_ident(char_u *line, int offset)
+ {
+     int	i;
+     int	incomment = FALSE;
+     int	instring = 0;
+     int	prev = 0;
+ 
+     for (i = 0; i < offset && line[i] != NUL; i++)
+     {
+ 	if (instring != 0)
+ 	{
+ 	    if (prev != '\\' && line[i] == instring)
+ 		instring = 0;
+ 	}
+ 	else if ((line[i] == '"' || line[i] == '\'') && !incomment)
+ 	{
+ 	    instring = line[i];
+ 	}
+ 	else
+ 	{
+ 	    if (incomment)
+ 	    {
+ 		if (prev == '*' && line[i] == '/')
+ 		    incomment = FALSE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '*')
+ 	    {
+ 		incomment = TRUE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '/')
+ 	    {
+ 		return FALSE;
+ 	    }
+ 	}
+ 
+ 	prev = line[i];
+     }
+ 
+     return incomment == FALSE && instring == 0;
+ }
+ 
+ /*
   * Search for variable declaration of "ptr[len]".
   * When "locally" is TRUE in the current function ("gd"), otherwise in the
   * current file ("gD").
***************
*** 4264,4269 ****
--- 4310,4316 ----
      int		retval = OK;
      int		incll;
      int		searchflags = flags_arg;
+     int		valid;
  
      if ((pat = alloc(len + 7)) == NULL)
  	return FAIL;
***************
*** 4301,4306 ****
--- 4348,4354 ----
      clearpos(&found_pos);
      for (;;)
      {
+ 	valid = FALSE;
  	t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD,
  			    pat, 1L, searchflags, RE_LAST, (linenr_T)0, NULL);
  	if (curwin->w_cursor.lnum >= old_pos.lnum)
***************
*** 4337,4345 ****
  	    continue;
  	}
  #endif
! 	if (!locally)	/* global search: use first match found */
  	    break;
! 	if (curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
--- 4385,4404 ----
  	    continue;
  	}
  #endif
! 	valid = is_ident(ml_get_curline(), curwin->w_cursor.col);
! 
! 	/* If the current position is not a valid identifier and a previous
! 	 * match is present, favor that one instead. */
! 	if (!valid && found_pos.lnum != 0)
! 	{
! 	    curwin->w_cursor = found_pos;
  	    break;
! 	}
! 
! 	/* Global search: use first valid match found */
! 	if (valid && !locally)
! 	    break;
! 	if (valid && curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
***************
*** 4347,4357 ****
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" search
! 	 * to find a later match.  For K&R style function declarations this
! 	 * skips the function header without types.  Remove SEARCH_START from
! 	 * flags to avoid getting stuck at one position. */
! 	found_pos = curwin->w_cursor;
  	searchflags &= ~SEARCH_START;
      }
  
--- 4406,4425 ----
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" or
! 	 * inside a comment, continue searching.  For K&R style function
! 	 * declarations this skips the function header without types. */
! 	if (!valid)
! 	{
! 	    /* Braces needed due to macro expansion of clearpos. */
! 	    clearpos(&found_pos);
! 	}
! 	else
! 	{
! 	    found_pos = curwin->w_cursor;
! 	}
! 	/* Remove SEARCH_START from flags to avoid getting stuck at one
! 	 * position. */
  	searchflags &= ~SEARCH_START;
      }
  
*** ../vim-8.0.0022/src/testdir/test_goto.vim	2016-06-15 21:58:47.000000000 +0200
--- src/testdir/test_goto.vim	2016-10-08 19:20:00.495818284 +0200
***************
*** 1,20 ****
  " Test commands that jump somewhere.
  
! func Test_geeDEE()
    new
!   call setline(1, ["Filename x;", "", "int Filename", "int func() {", "Filename y;"])
!   /y;/
!   normal gD
!   call assert_equal(1, line('.'))
    quit!
  endfunc
  
! func Test_gee_dee()
!   new
!   call setline(1, ["int x;", "", "int func(int x)", "{", "  return x;", "}"])
!   /return/
!   normal $hgd
!   call assert_equal(3, line('.'))
!   call assert_equal(14, col('.'))
!   quit!
  endfunc
--- 1,275 ----
  " Test commands that jump somewhere.
  
! " Create a new buffer using "lines" and place the cursor on the word after the
! " first occurrence of return and invoke "cmd". The cursor should now be
! " positioned at the given line and col.
! func XTest_goto_decl(cmd, lines, line, col)
    new
!   call setline(1, a:lines)
!   /return/
!   normal! W
!   execute 'norm! ' . a:cmd
!   call assert_equal(a:line, line('.'))
!   call assert_equal(a:col, col('.'))
    quit!
  endfunc
  
! func Test_gD()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 5)
! endfunc
! 
! func Test_gD_too()
!   let lines = [
! 	\ 'Filename x;',
! 	\ '',
! 	\ 'int Filename',
! 	\ 'int func() {',
! 	\ '  Filename x;',
! 	\ '  return x;',
! 	\ ]
!   call XTest_goto_decl('gD', lines, 1, 10)
! endfunc
! 
! func Test_gD_comment()
!   let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_inline_comment()
!   let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string()
!   let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string_same_line()
!   let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 22)
! endfunc
! 
! func Test_gD_char()
!   let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gd()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 14)
! endfunc
! 
! func Test_gd_not_local()
!   let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_kr_style()
!   let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 2, 7)
! endfunc
! 
! func Test_gd_missing_braces()
!   let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 11)
! endfunc
! 
! func Test_gd_comment()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_comment_in_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 22)
! endfunc
! 
! func Test_gd_string_in_comment()
!   set comments=
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 15)
!   set comments&
! endfunc
! 
! func Test_gd_inline_comment()
!   let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 32)
! endfunc
! 
! func Test_gd_inline_comment_only()
!   let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_inline_comment_body()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
!   call XTest_goto_decl('gd', lines, 7, 7)
! endfunc
! 
! func Test_gd_trailing_multiline_comment()
!   let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_trailing_comment()
!   let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_string_only()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0022/src/version.c	2016-10-03 21:37:37.619829811 +0200
--- src/version.c	2016-10-08 19:20:57.867423971 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
Two cows are standing together in a field.  One asks the other:
"So what do you think about this Mad Cow Disease?"
The other replies: "That doesn't concern me. I'm a helicopter."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0024
Problem:    When the netbeans channel closes, "DETACH" is put in the output
            part. (Ozaki Kiichi)
Solution:   Write "DETACH" in the socket part.
Files:      src/channel.c, src/testdir/test_netbeans.vim


*** ../vim-8.0.0023/src/channel.c	2016-10-03 21:37:37.619829811 +0200
--- src/channel.c	2016-10-09 15:42:14.971496844 +0200
***************
*** 3061,3067 ****
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_OUT, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
--- 3061,3067 ----
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
*** ../vim-8.0.0023/src/testdir/test_netbeans.vim	2016-09-09 15:28:11.000000000 +0200
--- src/testdir/test_netbeans.vim	2016-10-09 15:39:35.824606229 +0200
***************
*** 35,40 ****
--- 35,41 ----
    nbclose
  
    call WaitFor('len(readfile("Xnetbeans")) > 6')
+   call assert_false(has("netbeans_enabled"))
    let lines = readfile("Xnetbeans")
    call assert_equal('AUTH bunny', lines[0])
    call assert_equal('0:version=0 "2.5"', lines[1])
*** ../vim-8.0.0023/src/version.c	2016-10-08 19:21:26.083230027 +0200
--- src/version.c	2016-10-09 15:25:08.486659955 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
TALL KNIGHT: We are now no longer the Knights Who Say Ni!
ONE KNIGHT:  Ni!
OTHERS:      Sh!
ONE KNIGHT:  (whispers) Sorry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0025
Problem:    Inconsistent use of spaces vs tabs in gd test.
Solution:   Use tabs. (Anton Lindqvist)
Files:      src/testdir/test_goto.vim


*** ../vim-8.0.0024/src/testdir/test_goto.vim	2016-10-08 19:21:26.083230027 +0200
--- src/testdir/test_goto.vim	2016-10-09 15:47:40.725228290 +0200
***************
*** 16,28 ****
  
  func Test_gD()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
--- 16,28 ----
  
  func Test_gD()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
***************
*** 40,275 ****
  
  func Test_gD_comment()
    let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
--- 40,275 ----
  
  func Test_gD_comment()
    let lines = [
! 	\ '/* int x; */',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
! 	\ 'int y /* , x */;',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
! 	\ 'char *s[] = "x";',
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
! 	\ 'char *s[] = "x", int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
! 	\ "char c = 'x';",
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
! 	\ 'int func1(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ '',
! 	\ 'int func2(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
! 	\ 'int func(x)',
! 	\ '  int x;',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
! 	\ 'def func1(a)',
! 	\ '  a + 1',
! 	\ 'end',
! 	\ '',
! 	\ 'a = 1',
! 	\ '',
! 	\ 'def func2()',
! 	\ '  return a',
! 	\ 'end',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* int x; */',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s ="//"; int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* " */ int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
! 	\ 'int func(/* x is an int */ int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
! 	\ 'int func(void) /* one lonely x */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  int y /* , x */;',
! 	\ '',
! 	\ '  for (/* int x = 0 */; y < 2; y++);',
! 	\ '',
! 	\ '  int x = 0;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
! 	\ 'int func(int x) /* x is an int */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
! 	\ 'int func(int x) // x is an int',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '  int x = 1;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0024/src/version.c	2016-10-09 15:43:22.459026620 +0200
--- src/version.c	2016-10-09 15:49:39.288398847 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
The war between Emacs and Vi is over.  Vi has won with 3 to 1.
http://m.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/030/3044/3044s1.html

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0026
Problem:    Error format with %W, %C and %Z does not work. (Gerd Wachsmuth)
Solution:   Skip code when qf_multiignore is set. (Lcd)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0025/src/quickfix.c	2016-09-27 21:28:52.901342062 +0200
--- src/quickfix.c	2016-10-09 16:02:48.394927690 +0200
***************
*** 1010,1048 ****
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 	    if (qfprev == NULL)
! 		return QF_FAIL;
! 	    if (*fields->errmsg && !qi->qf_multiignore)
  	    {
! 		len = (int)STRLEN(qfprev->qf_text);
! 		if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			== NULL)
  		    return QF_FAIL;
! 		STRCPY(ptr, qfprev->qf_text);
! 		vim_free(qfprev->qf_text);
! 		qfprev->qf_text = ptr;
! 		*(ptr += len) = '\n';
! 		STRCPY(++ptr, fields->errmsg);
! 	    }
! 	    if (qfprev->qf_nr == -1)
! 		qfprev->qf_nr = fields->enr;
! 	    if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		/* only printable chars allowed */
! 		qfprev->qf_type = fields->type;
  
! 	    if (!qfprev->qf_lnum)
! 		qfprev->qf_lnum = fields->lnum;
! 	    if (!qfprev->qf_col)
! 		qfprev->qf_col = fields->col;
! 	    qfprev->qf_viscol = fields->use_viscol;
! 	    if (!qfprev->qf_fnum)
! 		qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			*fields->namebuf || qi->qf_directory != NULL
! 			? fields->namebuf
! 			: qi->qf_currfile != NULL && fields->valid
! 			? qi->qf_currfile : 0);
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
--- 1010,1051 ----
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    if (!qi->qf_multiignore)
  	    {
! 		qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 		if (qfprev == NULL)
  		    return QF_FAIL;
! 		if (*fields->errmsg && !qi->qf_multiignore)
! 		{
! 		    len = (int)STRLEN(qfprev->qf_text);
! 		    if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			    == NULL)
! 			return QF_FAIL;
! 		    STRCPY(ptr, qfprev->qf_text);
! 		    vim_free(qfprev->qf_text);
! 		    qfprev->qf_text = ptr;
! 		    *(ptr += len) = '\n';
! 		    STRCPY(++ptr, fields->errmsg);
! 		}
! 		if (qfprev->qf_nr == -1)
! 		    qfprev->qf_nr = fields->enr;
! 		if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		    /* only printable chars allowed */
! 		    qfprev->qf_type = fields->type;
  
! 		if (!qfprev->qf_lnum)
! 		    qfprev->qf_lnum = fields->lnum;
! 		if (!qfprev->qf_col)
! 		    qfprev->qf_col = fields->col;
! 		qfprev->qf_viscol = fields->use_viscol;
! 		if (!qfprev->qf_fnum)
! 		    qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			    *fields->namebuf || qi->qf_directory != NULL
! 			    ? fields->namebuf
! 			    : qi->qf_currfile != NULL && fields->valid
! 			    ? qi->qf_currfile : 0);
! 	    }
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
*** ../vim-8.0.0025/src/testdir/test_quickfix.vim	2016-09-27 21:28:52.901342062 +0200
--- src/testdir/test_quickfix.vim	2016-10-09 16:01:59.319265564 +0200
***************
*** 818,823 ****
--- 818,846 ----
    call delete('habits1.txt')
  endfunction
  
+ " Test for resync after continuing an ignored message
+ function! Xefm_ignore_continuations(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   let save_efm = &efm
+ 
+   let &efm =
+ 	\ '%Eerror %m %l,' .
+ 	\ '%-Wignored %m %l,' .
+ 	\ '%+Cmore ignored %m %l,' .
+ 	\ '%Zignored end'
+   Xgetexpr ['ignored warning 1', 'more ignored continuation 2', 'ignored end', 'error resync 4']
+   let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')
+   call assert_equal([['resync', 1, 4, 'E']], l)
+ 
+   let &efm = save_efm
+ endfunction
+ 
+ function! Test_efm_ignore_continuations()
+   call Xefm_ignore_continuations('c')
+   call Xefm_ignore_continuations('l')
+ endfunction
+ 
  " Tests for invalid error format specifies
  function Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
*** ../vim-8.0.0025/src/version.c	2016-10-09 15:50:45.927932466 +0200
--- src/version.c	2016-10-09 16:03:43.222550240 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
Q: How do you tell the difference between a female cat and a male cat?
A: You ask it a question and if HE answers, it's a male but, if SHE
   answers, it's a female.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0027
Problem:    A channel is closed when reading on stderr or stdout fails, but
            there may still be something to read on another part.
Solution:   Turn ch_to_be_closed into a bitfield. (Ozaki Kiichi)
Files:      src/channel.c, src/eval.c, src/structs.h, src/proto/channel.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0026/src/channel.c	2016-10-09 15:43:22.455026647 +0200
--- src/channel.c	2016-10-09 17:08:57.303345580 +0200
***************
*** 54,60 ****
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, int part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
--- 54,60 ----
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, ch_part_T part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
***************
*** 309,315 ****
      channel_T *
  add_channel(void)
  {
!     int		part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
--- 309,315 ----
      channel_T *
  add_channel(void)
  {
!     ch_part_T	part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
***************
*** 318,324 ****
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part <= PART_IN; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
--- 318,324 ----
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part < PART_COUNT; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
***************
*** 421,429 ****
      if (!in_free_unref_items)
      {
  	if (safe_to_invoke_callback == 0)
- 	{
  	    channel->ch_to_be_freed = TRUE;
- 	}
  	else
  	{
  	    channel_free_contents(channel);
--- 421,427 ----
***************
*** 511,517 ****
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     int		part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
--- 509,515 ----
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
***************
*** 557,563 ****
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, int part)
  {
      if (!CH_HAS_GUI)
  	return;
--- 555,561 ----
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, ch_part_T part)
  {
      if (!CH_HAS_GUI)
  	return;
***************
*** 627,633 ****
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, int part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
--- 625,631 ----
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, ch_part_T part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
***************
*** 653,659 ****
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     int	    part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
--- 651,657 ----
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     ch_part_T	part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
***************
*** 928,933 ****
--- 926,932 ----
      channel->ch_nb_close_cb = nb_close_cb;
      channel->ch_hostname = (char *)vim_strsave((char_u *)hostname);
      channel->ch_port = port_in;
+     channel->ch_to_be_closed |= (1 << PART_SOCK);
  
  #ifdef FEAT_GUI
      channel_gui_register_one(channel, PART_SOCK);
***************
*** 998,1009 ****
  }
  
      static void
! may_close_part(sock_T *fd)
  {
      if (*fd != INVALID_FD)
      {
! 	fd_close(*fd);
  	*fd = INVALID_FD;
      }
  }
  
--- 997,1015 ----
  }
  
      static void
! ch_close_part(channel_T *channel, ch_part_T part)
  {
+     sock_T *fd = &channel->ch_part[part].ch_fd;
+ 
      if (*fd != INVALID_FD)
      {
! 	if (part == PART_SOCK)
! 	    sock_close(*fd);
! 	else
! 	    fd_close(*fd);
  	*fd = INVALID_FD;
+ 
+ 	channel->ch_to_be_closed &= ~(1 << part);
      }
  }
  
***************
*** 1012,1018 ****
  {
      if (in != INVALID_FD)
      {
! 	may_close_part(&channel->CH_IN_FD);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
--- 1018,1024 ----
  {
      if (in != INVALID_FD)
      {
! 	ch_close_part(channel, PART_IN);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
***************
*** 1020,1027 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	may_close_part(&channel->CH_OUT_FD);
  	channel->CH_OUT_FD = out;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
--- 1026,1034 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	ch_close_part(channel, PART_OUT);
  	channel->CH_OUT_FD = out;
+ 	channel->ch_to_be_closed |= (1 << PART_OUT);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
***************
*** 1031,1038 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	may_close_part(&channel->CH_ERR_FD);
  	channel->CH_ERR_FD = err;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
--- 1038,1046 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	ch_close_part(channel, PART_ERR);
  	channel->CH_ERR_FD = err;
+ 	channel->ch_to_be_closed |= (1 << PART_ERR);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
***************
*** 1151,1160 ****
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     int		part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
--- 1159,1168 ----
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     ch_part_T	part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
***************
*** 1164,1170 ****
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
--- 1172,1178 ----
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
***************
*** 1282,1288 ****
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	int	    part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
--- 1290,1296 ----
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	ch_part_T   part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
***************
*** 1448,1454 ****
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	may_close_part(&channel->CH_IN_FD);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
--- 1456,1462 ----
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	ch_close_part(channel, PART_IN);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
***************
*** 1462,1471 ****
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
--- 1470,1479 ----
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
***************
*** 1574,1580 ****
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
--- 1582,1588 ----
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
***************
*** 1604,1610 ****
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1612,1618 ----
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1628,1634 ****
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1636,1642 ----
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1677,1683 ****
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, int part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1685,1691 ----
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, ch_part_T part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1693,1699 ****
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, int part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1701,1707 ----
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, ch_part_T part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1753,1759 ****
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, int part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
--- 1761,1767 ----
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, ch_part_T part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
***************
*** 1828,1834 ****
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     int		part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
--- 1836,1842 ----
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     ch_part_T	part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
***************
*** 1866,1872 ****
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, int part)
  {
      js_read_T	reader;
      typval_T	listtv;
--- 1874,1880 ----
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, ch_part_T part)
  {
      js_read_T	reader;
      typval_T	listtv;
***************
*** 2046,2052 ****
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, int part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
--- 2054,2060 ----
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, ch_part_T part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
***************
*** 2080,2086 ****
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, int part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
--- 2088,2094 ----
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, ch_part_T part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
***************
*** 2237,2243 ****
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, int part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
--- 2245,2251 ----
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, ch_part_T part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
***************
*** 2332,2338 ****
  }
  
      static void
! drop_messages(channel_T *channel, int part)
  {
      char_u *msg;
  
--- 2340,2346 ----
  }
  
      static void
! drop_messages(channel_T *channel, ch_part_T part)
  {
      char_u *msg;
  
***************
*** 2349,2355 ****
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, int part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
--- 2357,2363 ----
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, ch_part_T part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
***************
*** 2596,2602 ****
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, int part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
--- 2604,2610 ----
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, ch_part_T part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
***************
*** 2617,2623 ****
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
--- 2625,2631 ----
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     ch_part_T part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
***************
*** 2640,2646 ****
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
--- 2648,2654 ----
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
***************
*** 2654,2660 ****
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, int part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
--- 2662,2668 ----
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, ch_part_T part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
***************
*** 2736,2763 ****
      channel_gui_unregister(channel);
  #endif
  
!     if (channel->CH_SOCK_FD != INVALID_FD)
!     {
! 	sock_close(channel->CH_SOCK_FD);
! 	channel->CH_SOCK_FD = INVALID_FD;
!     }
!     may_close_part(&channel->CH_IN_FD);
!     may_close_part(&channel->CH_OUT_FD);
!     may_close_part(&channel->CH_ERR_FD);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  int		part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
--- 2744,2767 ----
      channel_gui_unregister(channel);
  #endif
  
!     ch_close_part(channel, PART_SOCK);
!     ch_close_part(channel, PART_IN);
!     ch_close_part(channel, PART_OUT);
!     ch_close_part(channel, PART_ERR);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  ch_part_T	part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
***************
*** 2789,2795 ****
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      drop_messages(channel, part);
      }
  
--- 2793,2799 ----
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      drop_messages(channel, part);
      }
  
***************
*** 2802,2815 ****
      void
  channel_close_in(channel_T *channel)
  {
!     may_close_part(&channel->CH_IN_FD);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, int part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
--- 2806,2819 ----
      void
  channel_close_in(channel_T *channel)
  {
!     ch_close_part(channel, PART_IN);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, ch_part_T part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
***************
*** 3043,3053 ****
  }
  
      static void
! channel_close_on_error(channel_T *channel, char *func)
  {
!     /* Do not call emsg(), most likely the other end just exited. */
!     ch_errors(channel, "%s(): Cannot read from channel, will close it soon",
! 									func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
--- 3047,3066 ----
  }
  
      static void
! ch_close_part_on_error(
! 	channel_T *channel, ch_part_T part, int is_err, char *func)
  {
!     char	msgbuf[80];
! 
!     vim_snprintf(msgbuf, sizeof(msgbuf),
! 	    "%%s(): Read %s from ch_part[%d], closing",
! 					    (is_err ? "error" : "EOF"), part);
! 
!     if (is_err)
! 	/* Do not call emsg(), most likely the other end just exited. */
! 	ch_errors(channel, msgbuf, func);
!     else
! 	ch_logs(channel, msgbuf, func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
***************
*** 3064,3084 ****
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading from stdout is not possible, assume the other side has
!      * died.  Don't close the channel right away, it may be the wrong moment
!      * to invoke callbacks. */
!     channel->ch_to_be_closed = TRUE;
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister(channel);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because of previous read error");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
--- 3077,3096 ----
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading is not possible close this part of the channel.  Don't
!      * close the channel yet, there may be something to read on another part. */
!     ch_close_part(channel, part);
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister_one(channel, part);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because all readable fds are closed");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
***************
*** 3090,3096 ****
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, int part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
--- 3102,3108 ----
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, ch_part_T part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
***************
*** 3098,3111 ****
      sock_T		fd;
      int			use_socket = FALSE;
  
-     /* If we detected a read error don't try reading again. */
-     if (channel->ch_to_be_closed)
- 	return;
- 
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_error(channel, "channel_read() called while socket is closed");
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
--- 3110,3120 ----
      sock_T		fd;
      int			use_socket = FALSE;
  
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_errors(channel, "channel_read() called while %s part is closed",
! 							    part_names[part]);
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
***************
*** 3141,3147 ****
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	channel_close_on_error(channel, func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
--- 3150,3156 ----
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	ch_close_part_on_error(channel, part, (len < 0), func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
***************
*** 3157,3163 ****
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, int part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
--- 3166,3172 ----
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, ch_part_T part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
***************
*** 3237,3243 ****
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	int	    part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
--- 3246,3252 ----
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	ch_part_T   part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
***************
*** 3323,3329 ****
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     int		part = -1;
      jobopt_T	opt;
      int		mode;
      int		timeout;
--- 3332,3338 ----
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     ch_part_T	part = PART_COUNT;
      jobopt_T	opt;
      int		mode;
      int		timeout;
***************
*** 3344,3350 ****
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part < 0)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
--- 3353,3359 ----
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part == PART_COUNT)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
***************
*** 3382,3391 ****
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, int *partp)
  {
      channel_T	*channel;
!     int		part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
--- 3391,3400 ----
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, ch_part_T *partp)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
***************
*** 3411,3427 ****
  channel_handle_events(void)
  {
      channel_T	*channel;
!     int		part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
- 	/* If we detected a read error don't try reading again. */
- 	if (channel->ch_to_be_closed)
- 	    continue;
- 
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
--- 3420,3432 ----
  channel_handle_events(void)
  {
      channel_T	*channel;
!     ch_part_T	part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
***************
*** 3431,3437 ****
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    channel_close_on_error(channel, "channel_handle_events()");
  	    }
  	}
      }
--- 3436,3443 ----
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    ch_close_part_on_error(channel, part, TRUE,
! 						     "channel_handle_events");
  	    }
  	}
      }
***************
*** 3444,3450 ****
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
--- 3450,3456 ----
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
***************
*** 3496,3502 ****
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
--- 3502,3508 ----
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     static channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
***************
*** 3504,3513 ****
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	int	    *part_read)
  {
      channel_T	*channel;
!     int		part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
--- 3510,3519 ----
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	ch_part_T   *part_read)
  {
      channel_T	*channel;
!     ch_part_T	part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
***************
*** 3550,3557 ****
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     int		part_send;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3556,3563 ----
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     ch_part_T	part_send;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3610,3616 ****
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3616,3622 ----
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3644,3650 ****
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3650,3656 ----
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3678,3684 ****
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
      int		idx;
      chanpart_T	*in_part;
  
--- 3684,3690 ----
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
      int		idx;
      chanpart_T	*in_part;
  
***************
*** 3725,3731 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3731,3737 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3757,3763 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
--- 3763,3769 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
***************
*** 3803,3809 ****
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     int		part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
--- 3809,3815 ----
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     ch_part_T	part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
***************
*** 3816,3824 ****
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed)
  	{
! 	    channel->ch_to_be_closed = FALSE;
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
--- 3822,3830 ----
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed == 0)
  	{
! 	    channel->ch_to_be_closed = (1 << PART_COUNT);
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
***************
*** 3840,3846 ****
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 		|| channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
--- 3846,3852 ----
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 				      || channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
***************
*** 3899,3905 ****
  /*
   * Return the "part" to write to for "channel".
   */
!     int
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3905,3911 ----
  /*
   * Return the "part" to write to for "channel".
   */
!     ch_part_T
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3910,3916 ****
  /*
   * Return the default "part" to read from for "channel".
   */
!     int
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3916,3922 ----
  /*
   * Return the default "part" to read from for "channel".
   */
!     ch_part_T
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3923,3929 ****
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, int part)
  {
      if (channel == NULL)
  	return MODE_JSON;
--- 3929,3935 ----
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, ch_part_T part)
  {
      if (channel == NULL)
  	return MODE_JSON;
***************
*** 3934,3940 ****
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, int part)
  {
      return channel->ch_part[part].ch_timeout;
  }
--- 3940,3946 ----
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, ch_part_T part)
  {
      return channel->ch_part[part].ch_timeout;
  }
***************
*** 3962,3968 ****
  }
  
      static int
! handle_io(typval_T *item, int part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
--- 3968,3974 ----
  }
  
      static int
! handle_io(typval_T *item, ch_part_T part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
***************
*** 4045,4051 ****
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     int		part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
--- 4051,4057 ----
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     ch_part_T	part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
***************
*** 4343,4352 ****
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when -1 use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, int part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
--- 4349,4358 ----
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when PART_COUNT use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
***************
*** 4367,4373 ****
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 			       part >= 0 ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
--- 4373,4379 ----
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 		       part != PART_COUNT ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
***************
*** 4659,4665 ****
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     int		part;
  
      job = job_alloc();
      if (job == NULL)
--- 4665,4671 ----
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     ch_part_T	part;
  
      job = job_alloc();
      if (job == NULL)
***************
*** 4679,4685 ****
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part <= PART_IN; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
--- 4685,4691 ----
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part < PART_COUNT; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
*** ../vim-8.0.0026/src/eval.c	2016-09-26 22:58:54.498255420 +0200
--- src/eval.c	2016-10-09 16:54:57.401187760 +0200
***************
*** 5622,5628 ****
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	int	    part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
--- 5622,5628 ----
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	ch_part_T   part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
***************
*** 5630,5636 ****
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part <= PART_IN; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
--- 5630,5636 ----
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
*** ../vim-8.0.0026/src/structs.h	2016-09-07 22:48:11.000000000 +0200
--- src/structs.h	2016-10-09 16:39:57.571448152 +0200
***************
*** 1499,1517 ****
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! #define PART_SOCK   0
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
- 
  #ifdef FEAT_JOB_CHANNEL
! # define INVALID_FD  (-1)
! 
! # define PART_OUT   1
! # define PART_ERR   2
! # define PART_IN    3
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
  
  /* The per-fd info for a channel. */
  typedef struct {
--- 1499,1519 ----
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! typedef enum {
!     PART_SOCK = 0,
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
  #ifdef FEAT_JOB_CHANNEL
!     PART_OUT,
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
+     PART_ERR,
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
+     PART_IN,
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
+     PART_COUNT
+ } ch_part_T;
+ 
+ #define INVALID_FD	(-1)
  
  /* The per-fd info for a channel. */
  typedef struct {
***************
*** 1566,1579 ****
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[4];	/* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* When TRUE reading or writing failed and
! 				  * the channel must be closed when it's safe
! 				  * to invoke callbacks. */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
--- 1568,1581 ----
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* bitset of readable fds to be closed.
! 				  * When all readable fds have been closed,
! 				  * set to (1 << PART_COUNT). */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
*** ../vim-8.0.0026/src/proto/channel.pro	2016-09-29 15:18:51.351768068 +0200
--- src/proto/channel.pro	2016-10-09 17:00:24.546924836 +0200
***************
*** 14,28 ****
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, int part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, int part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, int part);
! void channel_consume(channel_T *channel, int part, int len);
! int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
--- 14,28 ----
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, ch_part_T part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, ch_part_T part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, ch_part_T part);
! void channel_consume(channel_T *channel, ch_part_T part, int len);
! int channel_collapse(channel_T *channel, ch_part_T part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
***************
*** 31,43 ****
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, int part, int timeout);
! int channel_read_json_block(channel_T *channel, int part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, int *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun);
! channel_T *send_common(typval_T *argvars, char_u *text, int id, int eval, jobopt_T *opt, char *fun, int *part_read);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
--- 31,42 ----
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, ch_part_T part, int timeout);
! int channel_read_json_block(channel_T *channel, ch_part_T part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, ch_part_T *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
***************
*** 46,59 ****
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! int channel_part_send(channel_T *channel);
! int channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, int part);
! int channel_get_timeout(channel_T *channel, int part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, int part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
--- 45,58 ----
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! ch_part_T channel_part_send(channel_T *channel);
! ch_part_T channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, ch_part_T part);
! int channel_get_timeout(channel_T *channel, ch_part_T part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
*** ../vim-8.0.0026/src/testdir/test_channel.vim	2016-10-03 21:37:37.619829811 +0200
--- src/testdir/test_channel.vim	2016-10-09 16:28:59.732061278 +0200
***************
*** 1505,1510 ****
--- 1505,1527 ----
    call assert_equal(3, g:linecount)
  endfunc
  
+ func Test_read_from_terminated_job()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes 
+     let arg = 'import os,sys;os.close(1);sys.stderr.write(\"test\n\")'
+   else
+     let arg = 'import os,sys;os.close(1);sys.stderr.write("test\n")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('1 <= g:linecount')
+   call assert_equal(1, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0026/src/version.c	2016-10-09 16:10:02.135942266 +0200
--- src/version.c	2016-10-09 17:01:36.282423622 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
       [Autumn changed into Winter ... Winter changed into Spring ...  Spring
       changed back into Autumn and Autumn gave Winter and Spring a miss and
       went straight on into Summer ...  Until one day ...]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0028
Problem:    Superfluous semicolons.
Solution:   Remove them. (Ozaki Kiichi)
Files:      src/ex_cmds2.c


*** ../vim-8.0.0027/src/ex_cmds2.c	2016-09-10 19:01:19.000000000 +0200
--- src/ex_cmds2.c	2016-10-12 12:11:16.417291809 +0200
***************
*** 1093,1103 ****
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000);
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000;
  # endif
  
  /*
--- 1093,1103 ----
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000)
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000
  # endif
  
  /*
*** ../vim-8.0.0027/src/version.c	2016-10-09 17:27:56.863388510 +0200
--- src/version.c	2016-10-12 12:12:25.804801625 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
An indication you must be a manager:
You feel sorry for Dilbert's boss.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0029
Problem:    Code for MS-Windows is complicated because of the exceptions for
            old systems.
Solution:   Drop support for MS-Windows older than Windows XP. (Ken Takata)
Files:      runtime/doc/gui_w32.txt, runtime/doc/os_win32.txt,
            runtime/doc/todo.txt, src/GvimExt/Makefile, src/Make_mvc.mak,
            src/evalfunc.c, src/ex_cmds.c, src/ex_docmd.c, src/gui_w32.c,
            src/if_cscope.c, src/misc1.c, src/misc2.c, src/option.c,
            src/os_mswin.c, src/os_win32.c, src/os_win32.h,
            src/proto/os_mswin.pro, src/proto/os_win32.pro, src/version.c


*** ../vim-8.0.0028/runtime/doc/gui_w32.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/gui_w32.txt	2016-10-12 14:00:10.218811720 +0200
***************
*** 49,58 ****
  vimrc or gvimrc file: >
  	au GUIEnter * simalt ~x
  <
- 								*gui-w32s*
- There is a specific version of gvim.exe that runs under the Win32s subsystem
- of Windows 3.1 or 3.11.  See |win32s|.
- 
  
  Using Vim as a plugin					*gui-w32-windowid*
  
--- 49,54 ----
***************
*** 100,108 ****
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
-    Windows 95: %windir%\sendto (e.g. "c:\windows\sendto")
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto").
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
--- 96,105 ----
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto")
!    Windows XP: C:\Documents and Settings\%user%\SendTo
!    Windows Vista: C:\Users\%user%\AppData\Roaming\Microsoft\Windows\SendTo .
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
***************
*** 274,308 ****
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! In Windows 95, the window in which the commands are executed is always 25x80
! characters, to be as DOS compatible as possible (this matters!).  The default
! system font is used.  On NT, the window will be the default you have set up for
! "Console" in Control Panel.  On Win32s, the properties of the DOS box are
! determined by _default.pif in the windows directory.
! 
! 							*msdos-mode*
! If you get a dialog that says "This program is set to run in MS-DOS mode..."
! when you run an external program, you can solve this by changing the
! properties of the associated shortcut:
! - Use a Windows Explorer to find the command.com that is used.  It can be
!   c:\command.com, c:\dos\command.com, c:\windows\command.com, etc.
! - With the right mouse button, select properties of this command.com.
! - In the Program tab select "Advanced".
! - Unselect "MS-DOS mode".
! - Click "OK" twice.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax on W95 & NT: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
- On Win32s, you will have to go to another window instead.  Don't forget that
- you must tell Windows 3.1x to keep executing a DOS command in the background
- while you switch back to Vim.
- 
  ==============================================================================
  5. Special colors					*win32-colors*
  
--- 271,287 ----
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! The window in which the commands are executed will be the default you have set
! up for "Console" in Control Panel.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
  ==============================================================================
  5. Special colors					*win32-colors*
  
***************
*** 311,317 ****
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.  Note: On Win32s not all of these colors are supported.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
--- 290,296 ----
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
*** ../vim-8.0.0028/runtime/doc/os_win32.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/os_win32.txt	2016-10-12 14:04:26.836987376 +0200
***************
*** 1,4 ****
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Aug 28
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
--- 1,4 ----
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Oct 12
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
***************
*** 7,26 ****
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows NT, 95, 98, ME, XP, Vista and
! Windows 7.  There are both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
- There is GUI version for use in the Win32s subsystem in Windows 3.1[1].  You
- can also use the 32-bit DOS version of Vim instead.  See |os_msdos.txt|.
- 
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 3.1	|win32-win3.1|
! 6. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
--- 7,24 ----
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows XP, Vista, 7, 8 and 10.  There are
! both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 95	|win32-win95|
! 6. Running under Windows 3.1	|win32-win3.1|
! 7. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
***************
*** 43,62 ****
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems				*windows95* *win32-problems*
! 
! There are a few known problems with running in a console on Windows 95.  As
! far as we know, this is the same in Windows 98 and Windows ME.
! 
! Comments from somebody working at Microsoft: "Win95 console support has always
! been and will always be flaky".
! 1.  Dead key support doesn't work.
! 2.  Resizing the window with ":set columns=nn lines=nn" works, but executing
!     external commands MAY CAUSE THE SYSTEM TO HANG OR CRASH.
! 3.  Screen updating is slow, unless you change 'columns' or 'lines' to a
!     non-DOS value.  But then the second problem applies!
! 
! If this bothers you, use the 32 bit MS-DOS version or the Win32 GUI version.
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
--- 41,47 ----
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems					*win32-problems*
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
***************
*** 141,200 ****
  the console.
  
  ==============================================================================
! 5. Running under Windows 3.1				*win32-win3.1*
  
! 						*win32s* *windows-3.1*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 6. Win32 mini FAQ					*win32-faq*
! 
! Q. Why does the Win32 version of Vim update the screen so slowly on Windows 95?
! A. The support for Win32 console mode applications is very buggy in Win95.
!    For some unknown reason, the screen updates very slowly when Vim is run at
!    one of the standard resolutions (80x25, 80x43, or 80x50) and the 16-bit DOS
!    version updates the screen much more quickly than the Win32 version.
!    However, if the screen is set to some other resolution, such as by ":set
!    columns=100" or ":set lines=40", screen updating becomes about as fast as
!    it is with the 16-bit version.
! 
!    WARNING: Changing 'columns' may make Windows 95 crash while updating the
!    window (complaints --> Microsoft).  Since this mostly works, this has not
!    been disabled, but be careful with changing 'columns'.
! 
!    Changing the screen resolution makes updates faster, but it brings
!    additional problems.  External commands (e.g., ":!dir") can cause Vim to
!    freeze when the screen is set to a non-standard resolution, particularly
!    when 'columns' is not equal to 80.  It is not possible for Vim to reliably
!    set the screen resolution back to the value it had upon startup before
!    running external commands, so if you change the number of 'lines' or
!    'columns', be very, very careful.  In fact, Vim will not allow you to
!    execute external commands when 'columns' is not equal to 80, because it is
!    so likely to freeze up afterwards.
! 
!    None of the above applies on Windows NT.  Screen updates are fast, no
!    matter how many 'lines' or 'columns' the window has, and external commands
!    do not cause Vim to freeze.
! 
! Q. So if the Win32 version updates the screen so slowly on Windows 95 and the
!    16-bit DOS version updates the screen quickly, why would I want to run the
!    Win32 version?
! A. Firstly, the Win32 version isn't that slow, especially when the screen is
!    set to some non-standard number of 'lines' or 'columns'.  Secondly, the
!    16-bit DOS version has some severe limitations: It can't do big changes and
!    it doesn't know about long file names.  The Win32 version doesn't have these
!    limitations and it's faster overall (the same is true for the 32-bit DJGPP
!    DOS version of Vim).  The Win32 version is smarter about handling the
!    screen, the mouse, and the keyboard than the DJGPP version is.
! 
! Q. And what about the 16-bit DOS version versus the Win32 version on NT?
! A. There are no good reasons to run the 16-bit DOS version on NT.  The Win32
!    version updates the screen just as fast as the 16-bit version does when
!    running on NT.  All of the above disadvantages apply.  Finally, DOS
!    applications can take a long time to start up and will run more slowly.  On
!    non-Intel NT platforms, the DOS version is almost unusably slow, because it
!    runs on top of an 80x86 emulator.
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
--- 126,145 ----
  the console.
  
  ==============================================================================
! 5. Running under Windows 95				*win32-win95*
! 					*windows95* *windows98* *windowsme*
! Windows 95/98/ME support was removed in patch 8.0.0029  If you want to use it
! you will need to get a version older than that.
  
! ==============================================================================
! 6. Running under Windows 3.1				*win32-win3.1*
! 
! 					*win32s* *windows-3.1* *gui-w32s*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 7. Win32 mini FAQ					*win32-faq*
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
***************
*** 202,248 ****
  <  In the console version, you need to set the font of the console itself.
     You cannot do this from within Vim.
  
- Q. When I change the size of the console window with ':set lines=xx' or
-    similar, the font changes! (Win95)
- A. You have the console font set to 'Auto' in Vim's (or your MS-DOS prompt's)
-    properties.  This makes W95 guess (badly!) what font is best.  Set an explicit
-    font instead.
- 
- Q. Why can't I paste into Vim when running Windows 95?
- A. In the properties dialog box for the MS-DOS window, go to "MS-DOS
-    Prompt/Misc/Fast pasting" and make sure that it is NOT checked.  You should
-    also do ":set paste" in Vim to avoid unexpected effects.	|'paste'|
- 
- Q. How do I type dead keys on Windows 95, in the console version?
-    (A dead key is an accent key, such as acute, grave, or umlaut, that doesn't
-    produce a character by itself, but when followed by another key, produces
-    an accented character, such as a-acute, e-grave, u-umlaut, n-tilde, and so
-    on.  Very useful for most European languages.  English-language keyboard
-    layouts don't use dead keys, as far as we know.)
- A. You don't.  The console mode input routines simply do not work correctly in
-    Windows 95, and I have not been able to work around them.  In the words
-    of a senior developer at Microsoft:
- 	Win95 console support has always been and will always be flaky.
- 
- 	The flakiness is unavoidable because we are stuck between the world of
- 	MS-DOS keyboard TSRs like KEYB (which wants to cook the data;
- 	important for international) and the world of Win32.
- 
- 	So keys that don't "exist" in MS-DOS land (like dead keys) have a
- 	very tenuous existence in Win32 console land.  Keys that act
- 	differently between MS-DOS land and Win32 console land (like
- 	capslock) will act flaky.
- 
- 	Don't even _mention_ the problems with multiple language keyboard
- 	layouts...
- 
-    You may be able to fashion some sort of workaround with the digraphs
-    mechanism.							|digraphs|
- 
-    The best solution is to use the Win32 GUI version gvim.exe.  Alternatively,
-    you can try one of the DOS versions of Vim where dead keys reportedly do
-    work.
- 
  Q. How do I type dead keys on Windows NT?
  A. Dead keys work on NT 3.51.  Just type them as you would in any other
     application.
--- 147,152 ----
***************
*** 349,376 ****
  <  The first command runs notepad minimized and the second one runs it
     normally.
  
- Q. I'm using Win32s, and when I try to run an external command like "make",
-    Vim doesn't wait for it to finish!  Help!
- A. The problem is that a 32-bit application (Vim) can't get notification from
-    Windows that a 16-bit application (your DOS session) has finished.  Vim
-    includes a work-around for this, but you must set up your DOS commands to
-    run in a window, not full-screen.  Unfortunately the default when you
-    install Windows is full-screen.  To change this:
-    1) Start PIF editor (in the Main program group).
-    2) Open the file "_DEFAULT.PIF" in your Windows directory.
-    3) Changes the display option from "Full Screen" to "Windowed".
-    4) Save and exit.
- 
-    To test, start Vim and type >
- 	:!dir C:\<CR>".
- <  You should see a DOS box window appear briefly with the directory listing.
- 
- Q. I use Vim under Win32s and NT.  In NT, I can define the console to default to
-    50 lines, so that I get a 80x50 shell when I ':sh'.  Can I do the same in
-    W3.1x, or am I stuck with 80x25?
- A. Edit SYSTEM.INI and add 'ScreenLines=50' to the [NonWindowsApp] section.  DOS
-    prompts and external DOS commands will now run in a 50-line window.
- 
  						*windows-icon*
  Q. I don't like the Vim icon, can I change it?
  A. Yes, place your favorite icon in bitmaps/vim.ico in a directory of
--- 253,258 ----
*** ../vim-8.0.0028/src/GvimExt/Makefile	2016-02-02 18:48:30.000000000 +0100
--- src/GvimExt/Makefile	2016-10-12 14:00:10.222811692 +0200
***************
*** 3,9 ****
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=BOTH
  !ifndef APPVER
  APPVER=5.0
  !endif
--- 3,9 ----
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=WINNT
  !ifndef APPVER
  APPVER=5.0
  !endif
*** ../vim-8.0.0028/src/Make_mvc.mak	2016-09-08 20:25:34.000000000 +0200
--- src/Make_mvc.mak	2016-10-12 14:00:10.222811692 +0200
***************
*** 1,7 ****
! # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
! # and Win64, using the Microsoft Visual C++ compilers. Known to work with
! # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # VC9 (VS2008), VC10 (VS2010) and VC11 (VS2012)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
--- 1,7 ----
! # Makefile for Vim on Win32 (Windows XP/2003/Vista/7/8/10) and Win64,
! # using the Microsoft Visual C++ compilers. Known to work with VC5, VC6 (VS98),
! # VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005), VC9 (VS2008), VC10 (VS2010),
! # VC11 (VS2012), VC12 (VS2013) and VC14 (VS2015)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
***************
*** 119,125 ****
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 only)
  #
  # You can combine any of these interfaces
  #
--- 119,125 ----
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 or later)
  #
  # You can combine any of these interfaces
  #
***************
*** 162,170 ****
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on both Windows NT/XP and Windows 9x
  
! TARGETOS = BOTH
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
--- 162,170 ----
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on Windows NT/XP
  
! TARGETOS = WINNT
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
***************
*** 436,448 ****
  #>>>>> end of choices
  ###########################################################################
  
- !ifdef OS
- OS_TYPE	= winnt
  DEL_TREE = rmdir /s /q
- !else
- OS_TYPE	= win95
- DEL_TREE = deltree /y
- !endif
  
  INTDIR=$(OBJDIR)
  OUTDIR=$(OBJDIR)
--- 436,442 ----
*** ../vim-8.0.0028/src/evalfunc.c	2016-09-26 22:36:50.615386371 +0200
--- src/evalfunc.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 6017,6023 ****
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = mch_windows95();
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
--- 6017,6023 ----
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = FALSE;		/* Win9x is no more supported. */
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
*** ../vim-8.0.0028/src/ex_cmds.c	2016-09-04 21:08:45.000000000 +0200
--- src/ex_cmds.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 1175,1188 ****
      if (*cmd == NUL)	    /* no filter command */
  	return;
  
- #ifdef WIN3264
-     /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- #endif
- 
      cursor_save = curwin->w_cursor;
      linecount = line2 - line1 + 1;
      curwin->w_cursor.lnum = line1;
--- 1175,1180 ----
***************
*** 1460,1471 ****
  
  #ifdef MSWIN
      /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- 
-     /*
       * Check if ":!start" is used.
       */
      if (cmd != NULL)
--- 1452,1457 ----
*** ../vim-8.0.0028/src/ex_docmd.c	2016-09-29 15:18:51.355768041 +0200
--- src/ex_docmd.c	2016-10-12 14:00:10.230811635 +0200
***************
*** 7611,7624 ****
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted()
! #ifdef WIN3264
! 	/*
! 	 * Check if external commands are allowed now.
! 	 */
! 	&& can_end_termcap_mode(TRUE)
! #endif
! 					)
      {
  	if (!eap->forceit)
  	    autowrite_all();
--- 7611,7617 ----
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted())
      {
  	if (!eap->forceit)
  	    autowrite_all();
*** ../vim-8.0.0028/src/gui_w32.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_w32.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 319,325 ****
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
--- 319,325 ----
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # ifdef FEAT_MBYTE
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
***************
*** 369,375 ****
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
--- 369,375 ----
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if defined(FEAT_MBYTE) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
***************
*** 473,482 ****
  static int	s_timed_out = FALSE;
  static int	dead_key = 0;	/* 0: no dead key, 1: dead key pressed */
  
- #ifdef WIN3264
- static OSVERSIONINFO os_version;    /* like it says.  Init in gui_mch_init() */
- #endif
- 
  #ifdef FEAT_BEVAL
  /* balloon-eval WM_NOTIFY_HANDLER */
  static void Handle_WM_Notify(HWND hwnd, LPNMHDR pnmh);
--- 473,478 ----
***************
*** 695,755 ****
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     if (os_version.dwPlatformId != VER_PLATFORM_WIN32_NT)
!     {
! 	/* On Windows 95/98 we apparently get the character in the active
! 	 * codepage, not in UCS-2.  If conversion is needed convert it to
! 	 * UCS-2 first. */
! 	if ((int)GetACP() == enc_codepage)
! 	    len = 0;	    /* no conversion required */
! 	else
  	{
! 	    string[0] = ch;
! 	    len = MultiByteToWideChar(GetACP(), 0, (LPCSTR)string,
! 		    1, wstring, 2);
  	}
      }
      else
      {
- 	wstring[0] = ch;
  	len = 1;
!     }
! 
!     if (len > 0)
!     {
! 	/* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
! 	 * "enc_codepage" is non-zero use the standard Win32 function,
! 	 * otherwise use our own conversion function (e.g., for UTF-8). */
! 	if (enc_codepage > 0)
! 	{
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 	    /* If we had included the ALT key into the character but now the
! 	     * upper bit is no longer set, that probably means the conversion
! 	     * failed.  Convert the original character and set the upper bit
! 	     * afterwards. */
! 	    if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
! 	    {
! 		wstring[0] = ch & 0x7f;
! 		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 		if (len == 1) /* safety check */
! 		    string[0] |= 0x80;
! 	    }
! 	}
  	else
  	{
! 	    len = 1;
! 	    ws = utf16_to_enc(wstring, &len);
! 	    if (ws == NULL)
! 		len = 0;
! 	    else
! 	    {
! 		if (len > slen)	/* just in case */
! 		    len = slen;
! 		mch_memmove(string, ws, len);
! 		vim_free(ws);
! 	    }
  	}
      }
  
--- 691,731 ----
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     wstring[0] = ch;
!     len = 1;
! 
!     /* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
!      * "enc_codepage" is non-zero use the standard Win32 function,
!      * otherwise use our own conversion function (e.g., for UTF-8). */
!     if (enc_codepage > 0)
!     {
! 	len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		(LPSTR)string, slen, 0, NULL);
! 	/* If we had included the ALT key into the character but now the
! 	 * upper bit is no longer set, that probably means the conversion
! 	 * failed.  Convert the original character and set the upper bit
! 	 * afterwards. */
! 	if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
  	{
! 	    wstring[0] = ch & 0x7f;
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		    (LPSTR)string, slen, 0, NULL);
! 	    if (len == 1) /* safety check */
! 		string[0] |= 0x80;
  	}
      }
      else
      {
  	len = 1;
! 	ws = utf16_to_enc(wstring, &len);
! 	if (ws == NULL)
! 	    len = 0;
  	else
  	{
! 	    if (len > slen)	/* just in case */
! 		len = slen;
! 	    mch_memmove(string, ws, len);
! 	    vim_free(ws);
  	}
      }
  
***************
*** 1079,1085 ****
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
--- 1055,1061 ----
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # ifdef FEAT_MBYTE
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
***************
*** 1127,1137 ****
      int	    flags = 0;
      int	    down;
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
--- 1103,1112 ----
      int	    flags = 0;
      int	    down;
  
! # ifdef FEAT_MBYTE
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
***************
*** 1279,1285 ****
      }
  }
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
--- 1254,1260 ----
      }
  }
  
! #if defined(FEAT_MBYTE) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
***************
*** 1586,1595 ****
  
      static SysColorTable sys_table[] =
      {
- #ifdef WIN3264
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifndef __MINGW32__
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
--- 1561,1569 ----
  
      static SysColorTable sys_table[] =
      {
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifdef COLOR_3DHIGHLIGHT
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
***************
*** 1600,1606 ****
  	{"SYS_INFOBK", COLOR_INFOBK},
  	{"SYS_INFOTEXT", COLOR_INFOTEXT},
  	{"SYS_3DFACE", COLOR_3DFACE},
- #endif
  	{"SYS_BTNFACE", COLOR_BTNFACE},
  	{"SYS_BTNSHADOW", COLOR_BTNSHADOW},
  	{"SYS_ACTIVEBORDER", COLOR_ACTIVEBORDER},
--- 1574,1579 ----
***************
*** 2094,2104 ****
  
  	if (s_need_activate)
  	{
- #ifdef WIN32
  	    (void)SetForegroundWindow(s_hwnd);
- #else
- 	    (void)SetActiveWindow(s_hwnd);
- #endif
  	    s_need_activate = FALSE;
  	}
  
--- 2067,2073 ----
***************
*** 2421,2427 ****
  {
  #ifdef FEAT_MBYTE
      WCHAR	*wn = NULL;
-     int		n;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
--- 2390,2395 ----
***************
*** 2438,2448 ****
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    n = InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
- 	    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		/* Failed, try using non-wide function. */
- 		wn = NULL;
  	}
      }
  
--- 2406,2413 ----
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
  	}
      }
  
***************
*** 2563,2569 ****
      if (s_tabhwnd == NULL)
  	return;
  
! #if defined(FEAT_MBYTE)
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
--- 2528,2534 ----
      if (s_tabhwnd == NULL)
  	return;
  
! #ifdef FEAT_MBYTE
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
***************
*** 2708,2725 ****
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
- 	int	n;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    n = SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
- 	    if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 		return;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
--- 2673,2687 ----
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
  	}
+ 	return;
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
***************
*** 2737,2747 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
--- 2699,2708 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
***************
*** 2774,2782 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
--- 2735,2742 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
***************
*** 3466,3476 ****
      IDC_SIZEWE,			/* leftright */
      IDC_SIZEWE,			/* lrsizing */
      IDC_WAIT,			/* busy */
- #ifdef WIN3264
      IDC_NO,			/* no */
- #else
-     IDC_ICON,			/* no */
- #endif
      IDC_ARROW,			/* crosshair */
      IDC_ARROW,			/* hand1 */
      IDC_ARROW,			/* hand2 */
--- 3426,3432 ----
***************
*** 3497,3507 ****
  #ifdef SetClassLongPtr
  	SetClassLongPtr(s_textArea, GCLP_HCURSOR, (__int3264)(LONG_PTR)LoadCursor(NULL, idc));
  #else
- # ifdef WIN32
  	SetClassLong(s_textArea, GCL_HCURSOR, (long_u)LoadCursor(NULL, idc));
- # else /* Win16 */
- 	SetClassWord(s_textArea, GCW_HCURSOR, (WORD)LoadCursor(NULL, idc));
- # endif
  #endif
  	if (!p_mh)
  	{
--- 3453,3459 ----
***************
*** 3523,3529 ****
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * Wide version of convert_filter().
   */
--- 3475,3481 ----
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # ifdef FEAT_MBYTE
  /*
   * Wide version of convert_filter().
   */
***************
*** 3728,3744 ****
  	char_u *initdir,
  	char_u *filter)
  {
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
- # if defined(FEAT_MBYTE) && defined(WIN3264)
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
- 	return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
- # endif
- 
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
--- 3680,3694 ----
  	char_u *initdir,
  	char_u *filter)
  {
+ # ifdef FEAT_MBYTE
+     return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
+ # else
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
***************
*** 3748,3759 ****
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #else
      fileStruct.lStructSize = sizeof(fileStruct);
! #endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
--- 3698,3709 ----
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #  ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #  else
      fileStruct.lStructSize = sizeof(fileStruct);
! #  endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
***************
*** 3783,3792 ****
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
--- 3733,3742 ----
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #  ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #  endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
***************
*** 3806,3811 ****
--- 3756,3762 ----
  
      /* Shorten the file name if possible */
      return vim_strsave(shorten_fname1((char_u *)fileBuf));
+ # endif
  }
  #endif /* FEAT_BROWSE */
  
***************
*** 3816,3831 ****
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
- #ifdef WIN3264
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! #else
! # define BUFPATHLEN MAXPATHL
! # define DRAGQVAL 0xFFFF
! #endif
! #ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! #endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
--- 3767,3777 ----
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! # ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! # endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
***************
*** 3846,3856 ****
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
--- 3792,3802 ----
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! # ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! # endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
***************
*** 3888,3901 ****
      long	val;
      int		dragging = FALSE;
      int		dont_scroll_save = dont_scroll;
- #ifndef WIN3264
-     int		nPos;
- #else
      SCROLLINFO	si;
  
      si.cbSize = sizeof(si);
      si.fMask = SIF_POS;
- #endif
  
      sb = gui_mswin_find_scrollbar(hwndCtl);
      if (sb == NULL)
--- 3834,3843 ----
***************
*** 3960,3972 ****
      }
      prev_code = code;
  
- #ifdef WIN3264
      si.nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
      SetScrollInfo(hwndCtl, SB_CTL, &si, TRUE);
- #else
-     nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
-     SetScrollPos(hwndCtl, SB_CTL, nPos, TRUE);
- #endif
  
      /*
       * When moving a vertical scrollbar, move the other vertical scrollbar too.
--- 3902,3909 ----
***************
*** 3976,3986 ****
  	scrollbar_T *sba = sb->wp->w_scrollbars;
  	HWND    id = sba[ (sb == sba + SBAR_LEFT) ? SBAR_RIGHT : SBAR_LEFT].id;
  
- #ifdef WIN3264
  	SetScrollInfo(id, SB_CTL, &si, TRUE);
- #else
- 	SetScrollPos(id, SB_CTL, nPos, TRUE);
- #endif
      }
  
      /* Don't let us be interrupted here by another message. */
--- 3913,3919 ----
***************
*** 4448,4454 ****
  
  /* Intellimouse support */
  static int mouse_scroll_lines = 0;
- static UINT msh_msgmousewheel = 0;
  
  static int	s_usenewlook;	    /* emulate W95/NT4 non-bold dialogs */
  #ifdef FEAT_TOOLBAR
--- 4381,4386 ----
***************
*** 4505,4538 ****
  # define pImmSetConversionStatus  ImmSetConversionStatus
  #endif
  
- /* multi monitor support */
- typedef struct _MONITORINFOstruct
- {
-     DWORD cbSize;
-     RECT rcMonitor;
-     RECT rcWork;
-     DWORD dwFlags;
- } _MONITORINFO;
- 
- typedef HANDLE _HMONITOR;
- typedef _HMONITOR (WINAPI *TMonitorFromWindow)(HWND, DWORD);
- typedef BOOL (WINAPI *TGetMonitorInfo)(_HMONITOR, _MONITORINFO *);
- 
- static TMonitorFromWindow   pMonitorFromWindow = NULL;
- static TGetMonitorInfo	    pGetMonitorInfo = NULL;
- static HANDLE		    user32_lib = NULL;
- /*
-  * Return TRUE when running under Windows NT 3.x or Win32s, both of which have
-  * less fancy GUI APIs.
-  */
-     static int
- is_winnt_3(void)
- {
-     return ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		&& os_version.dwMajorVersion == 3)
- 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32s));
- }
- 
  #ifdef FEAT_MENU
  /*
   * Figure out how high the menu bar is at the moment.
--- 4437,4442 ----
***************
*** 4564,4608 ****
      }
      else
      {
! 	if (is_winnt_3())	/* for NT 3.xx */
  	{
! 	    if (gui.starting)
! 		menu_height = GetSystemMetrics(SM_CYMENU);
! 	    else
! 	    {
! 		RECT r1, r2;
! 		int frameht = GetSystemMetrics(SM_CYFRAME);
! 		int capht = GetSystemMetrics(SM_CYCAPTION);
! 
! 		/* get window rect of s_hwnd
! 		 * get client rect of s_hwnd
! 		 * get cap height
! 		 * subtract from window rect, the sum of client height,
! 		 * (if not maximized)frame thickness, and caption height.
! 		 */
! 		GetWindowRect(s_hwnd, &r1);
! 		GetClientRect(s_hwnd, &r2);
! 		menu_height = r1.bottom - r1.top - (r2.bottom - r2.top
! 				 + 2 * frameht * (!IsZoomed(s_hwnd)) + capht);
! 	    }
! 	}
! 	else			/* win95 and variants (NT 4.0, I guess) */
! 	{
! 	    /*
! 	     * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	     * seem to have been set yet, so menu wraps in default window
! 	     * width which is very narrow.  Instead just return height of a
! 	     * single menu item.  Will still be wrong when the menu really
! 	     * should wrap over more than one line.
! 	     */
! 	    GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	    if (gui.starting)
! 		menu_height = rc1.bottom - rc1.top + 1;
! 	    else
! 	    {
! 		GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 		menu_height = rc2.bottom - rc1.top + 1;
! 	    }
  	}
      }
  
--- 4468,4487 ----
      }
      else
      {
! 	/*
! 	 * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	 * seem to have been set yet, so menu wraps in default window
! 	 * width which is very narrow.  Instead just return height of a
! 	 * single menu item.  Will still be wrong when the menu really
! 	 * should wrap over more than one line.
! 	 */
! 	GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	if (gui.starting)
! 	    menu_height = rc1.bottom - rc1.top + 1;
! 	else
  	{
! 	    GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 	    menu_height = rc2.bottom - rc1.top + 1;
  	}
      }
  
***************
*** 4636,4677 ****
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
-     HWND hdl_mswheel;
-     UINT msh_msgscrolllines;
- 
-     msh_msgmousewheel = 0;
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     if ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion >= 4)
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 		&& ((os_version.dwMajorVersion == 4
! 			&& os_version.dwMinorVersion >= 10)
! 		    || os_version.dwMajorVersion >= 5)))
!     {
! 	/* if NT 4.0+ (or Win98) get scroll lines directly from system */
! 	SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 		&mouse_scroll_lines, 0);
!     }
!     else if (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion < 4))
!     {	/*
! 	 * If Win95 or NT 3.51,
! 	 * try to find the hidden point32 window.
! 	 */
! 	hdl_mswheel = FindWindow(VMOUSEZ_CLASSNAME, VMOUSEZ_TITLE);
! 	if (hdl_mswheel)
! 	{
! 	    msh_msgscrolllines = RegisterWindowMessage(VMSH_SCROLL_LINES);
! 	    if (msh_msgscrolllines)
! 	    {
! 		mouse_scroll_lines = (int)SendMessage(hdl_mswheel,
! 			msh_msgscrolllines, 0, 0);
! 		msh_msgmousewheel  = RegisterWindowMessage(VMSH_MOUSEWHEEL);
! 	    }
! 	}
!     }
  }
  
  
--- 4515,4525 ----
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     /* if NT 4.0+ (or Win98) get scroll lines directly from system */
!     SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 	    &mouse_scroll_lines, 0);
  }
  
  
***************
*** 5210,5222 ****
  #endif
  
      default:
- 	if (uMsg == msh_msgmousewheel && msh_msgmousewheel != 0)
- 	{   /* handle MSH_MOUSEWHEEL messages for Intellimouse */
- 	    _OnMouseWheel(hwnd, HIWORD(wParam));
- 	    return 0L;
- 	}
  #ifdef MSWIN_FIND_REPLACE
! 	else if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
--- 5058,5065 ----
  #endif
  
      default:
  #ifdef MSWIN_FIND_REPLACE
! 	if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
***************
*** 5376,5417 ****
  	    }
      }
  #endif
- 
-     /* get the OS version info */
-     os_version.dwOSVersionInfoSize = sizeof(os_version);
-     GetVersionEx(&os_version); /* this call works on Win32s, Win95 and WinNT */
- 
-     /* try and load the user32.dll library and get the entry points for
-      * multi-monitor-support. */
-     if ((user32_lib = vimLoadLib("User32.dll")) != NULL)
-     {
- 	pMonitorFromWindow = (TMonitorFromWindow)GetProcAddress(user32_lib,
- 							 "MonitorFromWindow");
- 
- 	/* there are ...A and ...W version of GetMonitorInfo - looking at
- 	 * winuser.h, they have exactly the same declaration. */
- 	pGetMonitorInfo = (TGetMonitorInfo)GetProcAddress(user32_lib,
- 							  "GetMonitorInfoA");
-     }
- 
- #ifdef FEAT_MBYTE
-     /* If the OS is Windows NT, use wide functions;
-      * this enables common dialogs input unicode from IME. */
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
-     {
- 	pDispatchMessage = DispatchMessageW;
- 	pGetMessage = GetMessageW;
- 	pIsDialogMessage = IsDialogMessageW;
- 	pPeekMessage = PeekMessageW;
-     }
-     else
-     {
- 	pDispatchMessage = DispatchMessageA;
- 	pGetMessage = GetMessageA;
- 	pIsDialogMessage = IsDialogMessageA;
- 	pPeekMessage = PeekMessageA;
-     }
- #endif
  }
  
  /*
--- 5219,5224 ----
***************
*** 5475,5486 ****
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	{
! 	    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return FAIL;
! 
! 	    /* Must be Windows 98, fall back to non-wide function. */
! 	}
  	else
  	    wide_WindowProc = TRUE;
      }
--- 5282,5288 ----
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	    return FAIL;
  	else
  	    wide_WindowProc = TRUE;
      }
***************
*** 5710,5716 ****
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
--- 5512,5518 ----
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # ifdef FEAT_MBYTE
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
***************
*** 5753,5774 ****
      static void
  get_work_area(RECT *spi_rect)
  {
!     _HMONITOR	    mon;
!     _MONITORINFO    moninfo;
  
!     /* use these functions only if available */
!     if (pMonitorFromWindow != NULL && pGetMonitorInfo != NULL)
      {
! 	/* work out which monitor the window is on, and get *it's* work area */
! 	mon = pMonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
! 	if (mon != NULL)
  	{
! 	    moninfo.cbSize = sizeof(_MONITORINFO);
! 	    if (pGetMonitorInfo(mon, &moninfo))
! 	    {
! 		*spi_rect = moninfo.rcWork;
! 		return;
! 	    }
  	}
      }
      /* this is the old method... */
--- 5555,5572 ----
      static void
  get_work_area(RECT *spi_rect)
  {
!     HMONITOR	    mon;
!     MONITORINFO	    moninfo;
  
!     /* work out which monitor the window is on, and get *it's* work area */
!     mon = MonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
!     if (mon != NULL)
      {
! 	moninfo.cbSize = sizeof(MONITORINFO);
! 	if (GetMonitorInfo(mon, &moninfo))
  	{
! 	    *spi_rect = moninfo.rcWork;
! 	    return;
  	}
      }
      /* this is the old method... */
***************
*** 6307,6335 ****
  	CONST INT *padding)
  {
      int		ix;
-     static int	special = -1;
- 
-     if (special == -1)
-     {
- 	/* Check windows version: special treatment is needed if it is NT 5 or
- 	 * Win98 or higher. */
- 	if  ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		    && os_version.dwMajorVersion >= 5)
- 		|| (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
- 		    && (os_version.dwMajorVersion > 4
- 			|| (os_version.dwMajorVersion == 4
- 			    && os_version.dwMinorVersion > 0))))
- 	    special = 1;
- 	else
- 	    special = 0;
-     }
  
!     if (special)
! 	for (ix = 0; ix < (int)len; ++ix)
! 	    ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					    pcliprect, text + ix, 1, padding);
!     else
! 	ExtTextOut(s_hdc, col, row, foptions, pcliprect, text, len, padding);
  }
  #endif
  
--- 6105,6114 ----
  	CONST INT *padding)
  {
      int		ix;
  
!     for (ix = 0; ix < (int)len; ++ix)
! 	ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					pcliprect, text + ix, 1, padding);
  }
  #endif
  
***************
*** 6718,6780 ****
  
      if (menu_is_menubar(menu->name))
      {
- 	if (is_winnt_3())
- 	{
- 	    InsertMenu((parent == NULL) ? s_menuBar : parent->submenu_id,
- 		    (UINT)pos, MF_POPUP | MF_STRING | MF_BYPOSITION,
- 		    (long_u)menu->submenu_id, (LPCTSTR) menu->name);
- 	}
- 	else
- 	{
  #ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
! 	    int		n;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
! 		/* 'encoding' differs from active codepage: convert menu name
! 		 * and use wide function */
! 		wn = enc_to_utf16(menu->name, NULL);
! 		if (wn != NULL)
! 		{
! 		    MENUITEMINFOW	infow;
  
! 		    infow.cbSize = sizeof(infow);
! 		    infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 							       | MIIM_SUBMENU;
! 		    infow.dwItemData = (long_u)menu;
! 		    infow.wID = menu->id;
! 		    infow.fType = MFT_STRING;
! 		    infow.dwTypeData = wn;
! 		    infow.cch = (UINT)wcslen(wn);
! 		    infow.hSubMenu = menu->submenu_id;
! 		    n = InsertMenuItemW((parent == NULL)
! 					    ? s_menuBar : parent->submenu_id,
! 					    (UINT)pos, TRUE, &infow);
! 		    vim_free(wn);
! 		    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 			/* Failed, try using non-wide function. */
! 			wn = NULL;
! 		}
  	    }
  
! 	    if (wn == NULL)
  #endif
! 	    {
! 		MENUITEMINFO	info;
  
! 		info.cbSize = sizeof(info);
! 		info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 		info.dwItemData = (long_u)menu;
! 		info.wID = menu->id;
! 		info.fType = MFT_STRING;
! 		info.dwTypeData = (LPTSTR)menu->name;
! 		info.cch = (UINT)STRLEN(menu->name);
! 		info.hSubMenu = menu->submenu_id;
! 		InsertMenuItem((parent == NULL)
! 					? s_menuBar : parent->submenu_id,
! 					(UINT)pos, TRUE, &info);
! 	    }
  	}
      }
  
--- 6497,6546 ----
  
      if (menu_is_menubar(menu->name))
      {
  #ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	{
! 	    /* 'encoding' differs from active codepage: convert menu name
! 	     * and use wide function */
! 	    wn = enc_to_utf16(menu->name, NULL);
! 	    if (wn != NULL)
  	    {
! 		MENUITEMINFOW	infow;
  
! 		infow.cbSize = sizeof(infow);
! 		infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 		    | MIIM_SUBMENU;
! 		infow.dwItemData = (long_u)menu;
! 		infow.wID = menu->id;
! 		infow.fType = MFT_STRING;
! 		infow.dwTypeData = wn;
! 		infow.cch = (UINT)wcslen(wn);
! 		infow.hSubMenu = menu->submenu_id;
! 		InsertMenuItemW((parent == NULL)
! 			? s_menuBar : parent->submenu_id,
! 			(UINT)pos, TRUE, &infow);
! 		vim_free(wn);
  	    }
+ 	}
  
! 	if (wn == NULL)
  #endif
! 	{
! 	    MENUITEMINFO	info;
  
! 	    info.cbSize = sizeof(info);
! 	    info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 	    info.dwItemData = (long_u)menu;
! 	    info.wID = menu->id;
! 	    info.fType = MFT_STRING;
! 	    info.dwTypeData = (LPTSTR)menu->name;
! 	    info.cch = (UINT)STRLEN(menu->name);
! 	    info.hSubMenu = menu->submenu_id;
! 	    InsertMenuItem((parent == NULL)
! 		    ? s_menuBar : parent->submenu_id,
! 		    (UINT)pos, TRUE, &info);
  	}
      }
  
***************
*** 6890,6896 ****
      {
  #ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
- 	int	n;
  
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
--- 6656,6661 ----
***************
*** 6899,6912 ****
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		n = InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
- 		if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		    /* Failed, try using non-wide function. */
- 		    wn = NULL;
  	    }
  	}
  	if (wn == NULL)
--- 6664,6674 ----
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
  	    }
  	}
  	if (wn == NULL)
***************
*** 7105,7115 ****
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
--- 6867,6876 ----
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
***************
*** 7866,7903 ****
  
      s_usenewlook = FALSE;
  
-     /*
-      * For NT3.51 and Win32s, we stick with the old look
-      * because it matches everything else.
-      */
-     if (!is_winnt_3())
-     {
  #ifdef USE_SYSMENU_FONT
! 	if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	    hfontTools = CreateFontIndirect(&lfSysmenu);
! 	else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
! 	if (hfontTools)
! 	{
! 	    hdc = GetDC(s_hwnd);
! 	    SelectObject(hdc, hfontTools);
! 	    /*
! 	     * GetTextMetrics() doesn't return the right value in
! 	     * tmAveCharWidth, so we have to figure out the dialog base units
! 	     * ourselves.
! 	     */
! 	    GetTextExtentPoint(hdc,
! 		    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		    52, &size);
! 	    ReleaseDC(s_hwnd, hdc);
! 
! 	    s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	    s_dlgfntheight = (WORD)size.cy;
! 	    s_usenewlook = TRUE;
! 	}
      }
  
      if (!s_usenewlook)
--- 7627,7657 ----
  
      s_usenewlook = FALSE;
  
  #ifdef USE_SYSMENU_FONT
!     if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	hfontTools = CreateFontIndirect(&lfSysmenu);
!     else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
!     if (hfontTools)
!     {
! 	hdc = GetDC(s_hwnd);
! 	SelectObject(hdc, hfontTools);
! 	/*
! 	 * GetTextMetrics() doesn't return the right value in
! 	 * tmAveCharWidth, so we have to figure out the dialog base units
! 	 * ourselves.
! 	 */
! 	GetTextExtentPoint(hdc,
! 		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		52, &size);
! 	ReleaseDC(s_hwnd, hdc);
! 
! 	s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	s_dlgfntheight = (WORD)size.cy;
! 	s_usenewlook = TRUE;
      }
  
      if (!s_usenewlook)
***************
*** 8044,8053 ****
  	dlgwidth = textWidth;
      dlgwidth += 2 * TEAROFF_PADDING_X + TEAROFF_BUTTON_PAD_X;
  
-     /* W95 can't do thin dialogs, they look v. weird! */
-     if (mch_windows95() && dlgwidth < TEAROFF_MIN_WIDTH)
- 	dlgwidth = TEAROFF_MIN_WIDTH;
- 
      /* start to fill in the dlgtemplate information.  addressing by WORDs */
      if (s_usenewlook)
  	lStyle = DS_MODALFRAME | WS_CAPTION| WS_SYSMENU |DS_SETFONT| WS_VISIBLE;
--- 7798,7803 ----
***************
*** 8299,8305 ****
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!is_winnt_3() && !menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
--- 8049,8055 ----
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
***************
*** 8556,8567 ****
      signicon_t	sign, *psign;
      char_u	*ext;
  
-     if (is_winnt_3())
-     {
- 	EMSG(_(e_signdata));
- 	return NULL;
-     }
- 
      sign.hImage = NULL;
      ext = signfile + STRLEN(signfile) - 4; /* get extension */
      if (ext > signfile)
--- 8306,8311 ----
*** ../vim-8.0.0028/src/if_cscope.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_cscope.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 839,852 ****
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # ifdef __BORLANDC__
! #  define OPEN_OH_ARGTYPE long
  # else
! #  if (_MSC_VER >= 1300) || defined(__MINGW32__)
! #   define OPEN_OH_ARGTYPE intptr_t
! #  else
! #   define OPEN_OH_ARGTYPE long
! #  endif
  # endif
  #endif
  
--- 839,848 ----
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
! #  define OPEN_OH_ARGTYPE intptr_t
  # else
! #  define OPEN_OH_ARGTYPE long
  # endif
  #endif
  
***************
*** 1427,1437 ****
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     /* On windows 9x GetFileInformationByHandle doesn't work, so skip it */
!     if (!mch_windows95())
      {
- 	switch (win32_fileinfo((char_u *)fname, &bhfi))
- 	{
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
--- 1423,1430 ----
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     switch (win32_fileinfo((char_u *)fname, &bhfi))
      {
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
***************
*** 1454,1460 ****
  	    if (p_csverbose)
  		(void)EMSG(_("E626: cannot get cscope database information"));
  	    return -1;
- 	}
      }
  #endif
  
--- 1447,1452 ----
***************
*** 1468,1476 ****
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file attributes too */
! 		|| (!mch_windows95()
! 		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
--- 1460,1467 ----
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* test index file attributes too */
! 		|| (csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
*** ../vim-8.0.0028/src/misc1.c	2016-09-10 15:43:04.000000000 +0200
--- src/misc1.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 9450,9459 ****
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! #ifdef WIN3264
! 	if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	    stoptermcap();
  	out_flush();
      }
  }
--- 9450,9456 ----
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! 	stoptermcap();
  	out_flush();
      }
  }
*** ../vim-8.0.0028/src/misc2.c	2016-09-04 20:34:12.000000000 +0200
--- src/misc2.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 1420,1426 ****
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	{
  	    if (*p == '"')
--- 1420,1426 ----
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # ifdef WIN32
  	if (!p_ssl)
  	{
  	    if (*p == '"')
***************
*** 1451,1457 ****
  	d = escaped_string;
  
  	/* add opening quote */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1451,1457 ----
  	d = escaped_string;
  
  	/* add opening quote */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
***************
*** 1460,1466 ****
  
  	for (p = string; *p != NUL; )
  	{
! # if defined(WIN32) || defined(DOS)
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
--- 1460,1466 ----
  
  	for (p = string; *p != NUL; )
  	{
! # ifdef WIN32
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
***************
*** 1503,1509 ****
  	}
  
  	/* add terminating quote and finish with a NUL */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1503,1509 ----
  	}
  
  	/* add terminating quote and finish with a NUL */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
*** ../vim-8.0.0028/src/option.c	2016-09-12 19:51:07.685659713 +0200
--- src/option.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 22,28 ****
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/help.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
--- 22,28 ----
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/quickref.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
***************
*** 9944,9956 ****
      if (gui.starting)
  	clear_xterm_clip();
  #endif
! #ifdef WIN3264
!     /*
!      * Check if this is allowed now.
!      */
!     if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
--- 9944,9950 ----
      if (gui.starting)
  	clear_xterm_clip();
  #endif
!     stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
*** ../vim-8.0.0028/src/os_mswin.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_mswin.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 38,48 ****
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  ifdef WIN3264
! #   include <winspool.h>
! #  else
! #   include <print.h>
! #  endif
  #  include <commdlg.h>
  #endif
  
--- 38,44 ----
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  include <winspool.h>
  #  include <commdlg.h>
  #endif
  
***************
*** 130,139 ****
  FILE* fdDump = NULL;
  #endif
  
- #ifdef WIN3264
- extern DWORD g_PlatformId;
- #endif
- 
  #ifndef FEAT_GUI_MSWIN
  extern char g_szOrigTitle[];
  #endif
--- 126,131 ----
***************
*** 248,267 ****
  {
      int		i;
  
- #ifdef WIN3264
      PlatformId();
- #endif
  
      /* Init the tables for toupper() and tolower() */
      for (i = 0; i < 256; ++i)
  	toupper_tab[i] = tolower_tab[i] = i;
- #ifdef WIN3264
      CharUpperBuff((LPSTR)toupper_tab, 256);
      CharLowerBuff((LPSTR)tolower_tab, 256);
- #else
-     AnsiUpperBuff((LPSTR)toupper_tab, 256);
-     AnsiLowerBuff((LPSTR)tolower_tab, 256);
- #endif
  }
  
  
--- 240,252 ----
***************
*** 299,312 ****
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
- 	    int	n;
  
  	    if (wp != NULL)
  	    {
! 		n = SetConsoleTitleW(wp);
  		vim_free(wp);
! 		if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		    return;
  	    }
  	}
  #  endif
--- 284,295 ----
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
  
  	    if (wp != NULL)
  	    {
! 		SetConsoleTitleW(wp);
  		vim_free(wp);
! 		return;
  	    }
  	}
  #  endif
***************
*** 379,390 ****
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 		/* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 		&& g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
! 	   )
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
--- 362,368 ----
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
***************
*** 641,652 ****
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
--- 619,625 ----
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
***************
*** 655,665 ****
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    if (n >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wstat() fails for missing wide functions. */
  	}
      }
  #endif
--- 628,634 ----
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    return n;
  	}
      }
  #endif
***************
*** 823,831 ****
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    if (n == 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 792,798 ----
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    return n;
  	}
      }
  #endif
***************
*** 834,860 ****
  }
  
  
- /*
-  * Switching off termcap mode is only allowed when Columns is 80, otherwise a
-  * crash may result.  It's always allowed on NT or when running the GUI.
-  */
- /*ARGSUSED*/
-     int
- can_end_termcap_mode(
-     int give_msg)
- {
- #ifdef FEAT_GUI_MSWIN
-     return TRUE;	/* GUI starts a new console anyway */
- #else
-     if (g_PlatformId == VER_PLATFORM_WIN32_NT || Columns == 80)
- 	return TRUE;
-     if (give_msg)
- 	msg((char_u *)
- 		_("'columns' is not 80, cannot execute external commands"));
-     return FALSE;
- #endif
- }
- 
  #ifdef FEAT_GUI_MSWIN
  /*
   * return non-zero if a character is available
--- 801,806 ----
***************
*** 887,903 ****
   * and returns an allocated string.
   * Return OK if it worked, FAIL if not.
   */
- # ifdef WIN3264
  typedef LPTSTR (*MYSTRPROCSTR)(LPTSTR);
  typedef LPTSTR (*MYINTPROCSTR)(int);
  typedef int (*MYSTRPROCINT)(LPTSTR);
  typedef int (*MYINTPROCINT)(int);
- # else
- typedef LPSTR (*MYSTRPROCSTR)(LPSTR);
- typedef LPSTR (*MYINTPROCSTR)(int);
- typedef int (*MYSTRPROCINT)(LPSTR);
- typedef int (*MYINTPROCINT)(int);
- # endif
  
  /*
   * Check if a pointer points to a valid NUL terminated string.
--- 833,842 ----
***************
*** 1093,1099 ****
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # if defined(FEAT_TITLE) && defined(WIN3264)
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
--- 1032,1038 ----
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # ifdef FEAT_TITLE
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
***************
*** 1114,1120 ****
      if (s_hwnd != 0)
  	return;
  
! # if defined(FEAT_TITLE) && defined(WIN3264)
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
--- 1053,1059 ----
      if (s_hwnd != 0)
  	return;
  
! # ifdef FEAT_TITLE
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
***************
*** 1539,1545 ****
  	    )
      {
  	prt_dlg.Flags |= PD_RETURNDEFAULT;
- #ifdef WIN3264
  	/*
  	 * MSDN suggests setting the first parameter to WINSPOOL for
  	 * NT, but NULL appears to work just as well.
--- 1478,1483 ----
***************
*** 1547,1553 ****
  	if (*p_pdev != NUL)
  	    prt_dlg.hDC = CreateDC(NULL, (LPCSTR)p_pdev, NULL, NULL);
  	else
- #endif
  	{
  	    prt_dlg.Flags |= PD_RETURNDEFAULT;
  	    if (PrintDlg(&prt_dlg) == 0)
--- 1485,1490 ----
***************
*** 1593,1602 ****
      mem = (DEVMODE *)GlobalLock(prt_dlg.hDevMode);
      if (mem != NULL)
      {
- #ifdef WIN3264
  	if (mem->dmCopies != 1)
  	    stored_nCopies = mem->dmCopies;
- #endif
  	if ((mem->dmFields & DM_DUPLEX) && (mem->dmDuplex & ~DMDUP_SIMPLEX))
  	    psettings->duplex = TRUE;
  	if ((mem->dmFields & DM_COLOR) && (mem->dmColor & DMCOLOR_COLOR))
--- 1530,1537 ----
***************
*** 1953,1959 ****
  		goto shortcut_end;
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  # endif
      // create a link manager object and request its interface
--- 1888,1894 ----
  		goto shortcut_end;
  	    }
  	}
! 	goto shortcut_end;
      }
  # endif
      // create a link manager object and request its interface
***************
*** 2681,2687 ****
      {"OEM",		OEM_CHARSET},
      {"SHIFTJIS",	SHIFTJIS_CHARSET},
      {"SYMBOL",		SYMBOL_CHARSET},
- #ifdef WIN3264
      {"ARABIC",		ARABIC_CHARSET},
      {"BALTIC",		BALTIC_CHARSET},
      {"EASTEUROPE",	EASTEUROPE_CHARSET},
--- 2616,2621 ----
***************
*** 2693,2702 ****
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! # if (!defined(_MSC_VER) || (_MSC_VER > 1010)) \
! 	&& (!defined(__BORLANDC__) || (__BORLANDC__ > 0x0500))
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
- # endif
  #endif
      {NULL,		0}
  };
--- 2627,2634 ----
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! #ifdef VIETNAMESE_CHARSET
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
  #endif
      {NULL,		0}
  };
*** ../vim-8.0.0028/src/os_win32.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_win32.c	2016-10-12 14:00:10.242811549 +0200
***************
*** 141,183 ****
  # define __stdcall /* empty */
  #endif
  
- #ifndef FEAT_GUI_W32
- /* Undocumented API in kernel32.dll needed to work around dead key bug in
-  * console-mode applications in NT 4.0.  If you switch keyboard layouts
-  * in a console app to a layout that includes dead keys and then hit a
-  * dead key, a call to ToAscii will trash the stack.  My thanks to Ian James
-  * and Michael Dietrich for helping me figure out this workaround.
-  */
- 
- /* WINAPI BOOL WINAPI GetConsoleKeyboardLayoutNameA(LPSTR); */
- #ifndef WINAPI
- # define WINAPI __stdcall
- #endif
- #if defined(__BORLANDC__)
- typedef BOOL (__stdcall *PFNGCKLN)(LPSTR);
- #else
- typedef BOOL (WINAPI *PFNGCKLN)(LPSTR);
- #endif
- static PFNGCKLN    s_pfnGetConsoleKeyboardLayoutName = NULL;
- #endif
- 
  #if defined(__BORLANDC__)
  /* Strangely Borland uses a non-standard name. */
  # define wcsicmp(a, b) wcscmpi((a), (b))
  #endif
  
- #ifndef PROTO
- 
- /* Enable common dialogs input unicode from IME if possible. */
- #ifdef FEAT_MBYTE
- LRESULT (WINAPI *pDispatchMessage)(CONST MSG *) = DispatchMessage;
- BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT) = GetMessage;
- BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG) = IsDialogMessage;
- BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT) = PeekMessage;
- #endif
- 
- #endif /* PROTO */
- 
  #ifndef FEAT_GUI_W32
  /* Win32 Console handles for input and output */
  static HANDLE g_hConIn  = INVALID_HANDLE_VALUE;
--- 141,151 ----
***************
*** 430,436 ****
  vimLoadLib(char *name)
  {
      HINSTANCE	dll = NULL;
-     char	old_dir[MAXPATHL];
  
      /* NOTE: Do not use mch_dirname() and mch_chdir() here, they may call
       * vimLoadLib() recursively, which causes a stack overflow. */
--- 398,403 ----
***************
*** 438,444 ****
  	get_exe_name();
      if (exe_path != NULL)
      {
- #ifdef FEAT_MBYTE
  	WCHAR old_dirw[MAXPATHL];
  
  	if (GetCurrentDirectoryW(MAXPATHL, old_dirw) != 0)
--- 405,410 ----
***************
*** 451,468 ****
  	    SetCurrentDirectoryW(old_dirw);
  	    return dll;
  	}
- 	/* Retry with non-wide function (for Windows 98). */
- 	if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- #endif
- 	    if (GetCurrentDirectory(MAXPATHL, old_dir) != 0)
- 	    {
- 		/* Change directory to where the executable is, both to make
- 		 * sure we find a .dll there and to avoid looking for a .dll
- 		 * in the current directory. */
- 		SetCurrentDirectory((LPCSTR)exe_path);
- 		dll = LoadLibrary(name);
- 		SetCurrentDirectory(old_dir);
- 	    }
      }
      return dll;
  }
--- 417,422 ----
***************
*** 621,658 ****
  # ifndef PROTECTED_DACL_SECURITY_INFORMATION
  #  define PROTECTED_DACL_SECURITY_INFORMATION	0x80000000L
  # endif
- 
- /*
-  * These are needed to dynamically load the ADVAPI DLL, which is not
-  * implemented under Windows 95 (and causes VIM to crash)
-  */
- typedef DWORD (WINAPI *PSNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # ifdef FEAT_MBYTE
- typedef DWORD (WINAPI *PSNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # endif
- 
- static HANDLE advapi_lib = NULL;	/* Handle for ADVAPI library */
- static PSNSECINFO pSetNamedSecurityInfo;
- static PGNSECINFO pGetNamedSecurityInfo;
- # ifdef FEAT_MBYTE
- static PSNSECINFOW pSetNamedSecurityInfoW;
- static PGNSECINFOW pGetNamedSecurityInfoW;
- # endif
  #endif
  
- typedef BOOL (WINAPI *PSETHANDLEINFORMATION)(HANDLE, DWORD, DWORD);
- 
- static BOOL allowPiping = FALSE;
- static PSETHANDLEINFORMATION pSetHandleInformation;
- 
  #ifdef HAVE_ACL
  /*
   * Enables or disables the specified privilege.
--- 575,582 ----
***************
*** 712,804 ****
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/*
! 	 * Load the ADVAPI runtime if we are on anything
! 	 * other than Windows 95
! 	 */
! 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	{
! 	    /*
! 	     * do this load.  Problems: Doesn't unload at end of run (this is
! 	     * theoretically okay, since Windows should unload it when VIM
! 	     * terminates).  Should we be using the 'mch_libcall' routines?
! 	     * Seems like a lot of overhead to load/unload ADVAPI32.DLL each
! 	     * time we verify security...
! 	     */
! 	    advapi_lib = vimLoadLib("ADVAPI32.DLL");
! 	    if (advapi_lib != NULL)
! 	    {
! 		pSetNamedSecurityInfo = (PSNSECINFO)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoA");
! 		pGetNamedSecurityInfo = (PGNSECINFO)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoA");
! # ifdef FEAT_MBYTE
! 		pSetNamedSecurityInfoW = (PSNSECINFOW)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoW");
! 		pGetNamedSecurityInfoW = (PGNSECINFOW)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoW");
! # endif
! 		if (pSetNamedSecurityInfo == NULL
! 			|| pGetNamedSecurityInfo == NULL
! # ifdef FEAT_MBYTE
! 			|| pSetNamedSecurityInfoW == NULL
! 			|| pGetNamedSecurityInfoW == NULL
! # endif
! 			)
! 		{
! 		    /* If we can't get the function addresses, set advapi_lib
! 		     * to NULL so that we don't use them. */
! 		    FreeLibrary(advapi_lib);
! 		    advapi_lib = NULL;
! 		}
! 		/* Enable privilege for getting or setting SACLs. */
! 		win32_enable_privilege(SE_SECURITY_NAME, TRUE);
! 	    }
! 	}
  #endif
- 	/*
- 	 * If we are on windows NT, try to load the pipe functions, only
- 	 * available from Win2K.
- 	 */
- 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
- 	{
- 	    HANDLE kernel32 = GetModuleHandle("kernel32");
- 	    pSetHandleInformation = (PSETHANDLEINFORMATION)GetProcAddress(
- 					    kernel32, "SetHandleInformation");
- 
- 	    allowPiping = pSetHandleInformation != NULL;
- 	}
  	done = TRUE;
      }
  }
  
- /*
-  * Return TRUE when running on Windows 95 (or 98 or ME).
-  * Only to be used after mch_init().
-  */
-     int
- mch_windows95(void)
- {
-     return g_PlatformId == VER_PLATFORM_WIN32_WINDOWS;
- }
- 
- #ifdef FEAT_GUI_W32
- /*
-  * Used to work around the "can't do synchronous spawn"
-  * problem on Win32s, without resorting to Universal Thunk.
-  */
- static int old_num_windows;
- static int num_windows;
- 
- /*ARGSUSED*/
-     static BOOL CALLBACK
- win32ssynch_cb(HWND hwnd, LPARAM lparam)
- {
-     num_windows++;
-     return TRUE;
- }
- #endif
- 
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
--- 636,648 ----
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/* Enable privilege for getting or setting SACLs. */
! 	win32_enable_privilege(SE_SECURITY_NAME, TRUE);
  #endif
  	done = TRUE;
      }
  }
  
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
***************
*** 926,940 ****
  
      vim_memset(abKeystate, 0, sizeof (abKeystate));
  
-     // Should only be non-NULL on NT 4.0
-     if (s_pfnGetConsoleKeyboardLayoutName != NULL)
-     {
- 	CHAR szKLID[KL_NAMELENGTH];
- 
- 	if ((*s_pfnGetConsoleKeyboardLayoutName)(szKLID))
- 	    (void)LoadKeyboardLayout(szKLID, KLF_ACTIVATE);
-     }
- 
      /* Clear any pending dead keys */
      ToUnicode(VK_SPACE, MapVirtualKey(VK_SPACE, 0), abKeystate, awAnsiCode, 2, 0);
  
--- 770,775 ----
***************
*** 1977,1993 ****
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n > 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		if (n == 0)
! 		    return FALSE;
! 		if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		    return FALSE;
! 		if (path != NULL)
! 		    *path = utf16_to_enc(fnamew, NULL);
! 		return TRUE;
! 	    }
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 1812,1824 ----
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n == 0)
! 		return FALSE;
! 	    if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		return FALSE;
! 	    if (path != NULL)
! 		*path = utf16_to_enc(fnamew, NULL);
! 	    return TRUE;
  	}
      }
  #endif
***************
*** 2462,2469 ****
      static void
  SaveConsoleTitleAndIcon(void)
  {
-     GETCONSOLEWINDOWPROC GetConsoleWindowProc;
- 
      /* Save the original title. */
      if (!GetConsoleTitle(g_szOrigTitle, sizeof(g_szOrigTitle)))
  	return;
--- 2293,2298 ----
***************
*** 2475,2486 ****
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     if ((GetConsoleWindowProc = (GETCONSOLEWINDOWPROC)
! 	    GetProcAddress(GetModuleHandle("KERNEL32.DLL"),
! 		    "GetConsoleWindow")) != NULL)
!     {
! 	g_hWnd = (*GetConsoleWindowProc)();
!     }
      if (g_hWnd == NULL)
  	return;
  
--- 2304,2310 ----
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     g_hWnd = GetConsoleWindow();
      if (g_hWnd == NULL)
  	return;
  
***************
*** 2589,2599 ****
  #ifdef FEAT_CLIPBOARD
      win_clip_init();
  #endif
- 
-     /* This will be NULL on anything but NT 4.0 */
-     s_pfnGetConsoleKeyboardLayoutName =
- 	(PFNGCKLN) GetProcAddress(GetModuleHandle("kernel32.dll"),
- 				  "GetConsoleKeyboardLayoutNameA");
  }
  
  /*
--- 2413,2418 ----
***************
*** 2775,2783 ****
  	    *porig = c;
  	    ptrue = ptruePrev + wcslen(ptruePrev);
  	}
- 	else if (hFind == INVALID_HANDLE_VALUE
- 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
      }
  
      wcscpy(name, szTrueName);
--- 2594,2599 ----
***************
*** 2836,2842 ****
  		}
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
--- 2652,2658 ----
  		}
  	    }
  	}
! 	return;
      }
  #endif
  
***************
*** 2966,2974 ****
  		return OK;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (GetUserName(szUserName, &cch))
--- 2782,2787 ----
***************
*** 3008,3016 ****
  		return;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (!GetComputerName((LPSTR)s, &cch))
--- 2821,2826 ----
***************
*** 3059,3067 ****
  		return OK;
  	    }
  	}
! 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return FAIL;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
--- 2869,2875 ----
  		return OK;
  	    }
  	}
! 	return FAIL;
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
***************
*** 3101,3109 ****
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1 && g_PlatformId == VER_PLATFORM_WIN32_NT)
  		return FAIL;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
      if (n == -1)
--- 2909,2916 ----
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1)
  		return FAIL;
  	}
      }
      if (n == -1)
***************
*** 3251,3268 ****
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind == INVALID_HANDLE_VALUE
! 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    hFind = FindFirstFile((LPCSTR)name, &findDataA);
! 	    if (hFind != INVALID_HANDLE_VALUE)
! 	    {
! 		fileFlags = findDataA.dwFileAttributes;
! 		reparseTag = findDataA.dwReserved0;
! 	    }
! 	}
! 	else
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
--- 3058,3064 ----
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind != INVALID_HANDLE_VALUE)
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
***************
*** 3321,3327 ****
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    res = FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
--- 3117,3123 ----
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    return FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
***************
*** 3332,3346 ****
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(wn);
! 	    wn = NULL;
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
--- 3128,3136 ----
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
***************
*** 3359,3367 ****
  	CloseHandle(hFile);
      }
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      return res;
  }
  
--- 3149,3154 ----
***************
*** 3383,3401 ****
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	if (attr < 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	attr = GetFileAttributes((char *)name);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return attr;
  }
  
--- 3170,3181 ----
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	vim_free(p);
      }
!     else
  #endif
  	attr = GetFileAttributes((char *)name);
! 
      return attr;
  }
  
***************
*** 3418,3437 ****
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	if (res == FALSE
! 	    && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return res ? 0 : -1;
  }
  
--- 3198,3209 ----
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	vim_free(p);
      }
!     else
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! 
      return res ? 0 : -1;
  }
  
***************
*** 3539,3565 ****
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-     {
  	wn = enc_to_utf16(name, NULL);
! 	if (wn != NULL)
! 	{
! 	    hFile = CreateFileW(wn,	/* file name */
! 			GENERIC_WRITE,	/* access mode */
! 			0,		/* share mode */
! 			NULL,		/* security descriptor */
! 			OPEN_EXISTING,	/* creation disposition */
! 			0,		/* file attributes */
! 			NULL);		/* handle to template file */
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
--- 3311,3330 ----
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	wn = enc_to_utf16(name, NULL);
! 
!     if (wn != NULL)
!     {
! 	hFile = CreateFileW(wn,		    /* file name */
! 		    GENERIC_WRITE,	    /* access mode */
! 		    0,			    /* share mode */
! 		    NULL,		    /* security descriptor */
! 		    OPEN_EXISTING,	    /* creation disposition */
! 		    0,			    /* file attributes */
! 		    NULL);		    /* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
***************
*** 3569,3577 ****
  		    0,			    /* file attributes */
  		    NULL);		    /* handle to template file */
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      if (hFile == INVALID_HANDLE_VALUE)
  	return NODE_NORMAL;
  
--- 3334,3339 ----
***************
*** 3608,3695 ****
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     /* This only works on Windows NT and 2000. */
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT && advapi_lib != NULL)
      {
- 	p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
- 	if (p != NULL)
- 	{
  # ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 		wn = enc_to_utf16(fname, NULL);
! 	    if (wn != NULL)
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfoW(
! 			    wn,			// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfoW(
! 			    wn,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
! 		vim_free(wn);
  	    }
! 	    else
  # endif
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfo(
! 			    (LPSTR)fname,	// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfo(
! 			    (LPSTR)fname,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
  	    }
  	}
      }
--- 3370,3453 ----
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	    wn = enc_to_utf16(fname, NULL);
! 	if (wn != NULL)
! 	{
! 	    /* Try to retrieve the entire security descriptor. */
! 	    err = GetNamedSecurityInfoW(
! 		    wn,			// Abstract filename
! 		    SE_FILE_OBJECT,	// File Object
! 		    OWNER_SECURITY_INFORMATION |
! 		    GROUP_SECURITY_INFORMATION |
! 		    DACL_SECURITY_INFORMATION |
! 		    SACL_SECURITY_INFORMATION,
! 		    &p->pSidOwner,	// Ownership information.
! 		    &p->pSidGroup,	// Group membership.
! 		    &p->pDacl,		// Discretionary information.
! 		    &p->pSacl,		// For auditing purposes.
! 		    &p->pSecurityDescriptor);
! 	    if (err == ERROR_ACCESS_DENIED ||
! 		    err == ERROR_PRIVILEGE_NOT_HELD)
! 	    {
! 		/* Retrieve only DACL. */
! 		(void)GetNamedSecurityInfoW(
! 			wn,
! 			SE_FILE_OBJECT,
! 			DACL_SECURITY_INFORMATION,
! 			NULL,
! 			NULL,
! 			&p->pDacl,
! 			NULL,
! 			&p->pSecurityDescriptor);
! 	    }
! 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
! 	    vim_free(wn);
! 	}
! 	else
  # endif
+ 	{
+ 	    /* Try to retrieve the entire security descriptor. */
+ 	    err = GetNamedSecurityInfo(
+ 		    (LPSTR)fname,	// Abstract filename
+ 		    SE_FILE_OBJECT,	// File Object
+ 		    OWNER_SECURITY_INFORMATION |
+ 		    GROUP_SECURITY_INFORMATION |
+ 		    DACL_SECURITY_INFORMATION |
+ 		    SACL_SECURITY_INFORMATION,
+ 		    &p->pSidOwner,	// Ownership information.
+ 		    &p->pSidGroup,	// Group membership.
+ 		    &p->pDacl,		// Discretionary information.
+ 		    &p->pSacl,		// For auditing purposes.
+ 		    &p->pSecurityDescriptor);
+ 	    if (err == ERROR_ACCESS_DENIED ||
+ 		    err == ERROR_PRIVILEGE_NOT_HELD)
+ 	    {
+ 		/* Retrieve only DACL. */
+ 		(void)GetNamedSecurityInfo(
+ 			(LPSTR)fname,
+ 			SE_FILE_OBJECT,
+ 			DACL_SECURITY_INFORMATION,
+ 			NULL,
+ 			NULL,
+ 			&p->pDacl,
+ 			NULL,
+ 			&p->pSecurityDescriptor);
+ 	    }
+ 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
  	}
      }
***************
*** 3733,3739 ****
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL && advapi_lib != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
--- 3491,3497 ----
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
***************
*** 3761,3767 ****
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)pSetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3519,3525 ----
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)SetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 3775,3781 ****
  	else
  # endif
  	{
! 	    (void)pSetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3533,3539 ----
  	else
  # endif
  	{
! 	    (void)SetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 4076,4082 ****
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #  ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
--- 3834,3840 ----
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
***************
*** 4138,4168 ****
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window, but in
!      * Windows 95 this makes the command MUCH slower.  We can't do it under
!      * Win32s either as it stops the synchronous spawn workaround working.
       * Don't activate the window to keep focus on Vim.
       */
!     if ((options & SHELL_DOOUT) && !mch_windows95())
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
-     /* There is a strange error on Windows 95 when using "c:\command.com".
-      * When the "c:\\" is left out it works OK...? */
-     if (mch_windows95()
- 	    && (STRNICMP(cmd, "c:/command.com", 14) == 0
- 		|| STRNICMP(cmd, "c:\\command.com", 14) == 0))
- 	cmd += 3;
- 
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
-     if (g_PlatformId != VER_PLATFORM_WIN32s)
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
--- 3896,3916 ----
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window.
       * Don't activate the window to keep focus on Vim.
       */
!     if (options & SHELL_DOOUT)
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
***************
*** 4195,4217 ****
  	/* Get the command exit code */
  	GetExitCodeProcess(pi.hProcess, &ret);
      }
-     else
-     {
- 	/*
- 	 * This ugly code is the only quick way of performing
- 	 * a synchronous spawn under Win32s. Yuk.
- 	 */
- 	num_windows = 0;
- 	EnumWindows(win32ssynch_cb, 0);
- 	old_num_windows = num_windows;
- 	do
- 	{
- 	    Sleep(1000);
- 	    num_windows = 0;
- 	    EnumWindows(win32ssynch_cb, 0);
- 	} while (num_windows == old_num_windows);
- 	ret = 0;
-     }
  
      /* Close the handles to the subprocess, so that it goes away */
      CloseHandle(pi.hThread);
--- 3943,3948 ----
***************
*** 4453,4463 ****
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
--- 4184,4194 ----
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
***************
*** 4707,4713 ****
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (allowPiping && !p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
--- 4438,4444 ----
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (!p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
***************
*** 4960,4966 ****
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(allowPiping && !p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
--- 4691,4697 ----
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(!p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
***************
*** 4978,4984 ****
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && (!allowPiping || p_stmp))
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
--- 4709,4715 ----
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && p_stmp)
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
***************
*** 5002,5009 ****
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun
! 						  || (allowPiping && !p_stmp))
  #endif
  	    )
      {
--- 4733,4739 ----
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun || !p_stmp)
  #endif
  	    )
      {
***************
*** 5051,5064 ****
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
              vim_free(wn);
-             if (h == INVALID_HANDLE_VALUE
-                           && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
-                 wn = NULL;
          }
      }
      if (wn == NULL)
  # endif
- 
          h = CreateFile((LPCSTR)fname, dwDesiredAccess, dwShareMode,
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
--- 4781,4790 ----
***************
*** 5127,5133 ****
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
--- 4853,4859 ----
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
***************
*** 5145,5151 ****
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
--- 4871,4877 ----
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
***************
*** 5163,5169 ****
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
--- 4889,4895 ----
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !SetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
***************
*** 6176,6184 ****
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    if (n == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 5902,5908 ----
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    return n;
  	}
      }
  #endif
***************
*** 6203,6209 ****
  
  /* physical RAM to leave for the OS */
  #define WINNT_RESERVE_BYTES     (256*1024*1024)
- #define WIN95_RESERVE_BYTES       (8*1024*1024)
  
  /*
   * How much main memory in KiB that can be used by VIM.
--- 5927,5932 ----
***************
*** 6212,6265 ****
      long_u
  mch_total_mem(int special)
  {
!     PlatformId();
! #if (defined(_MSC_VER) && (WINVER > 0x0400)) || defined(MEMORYSTATUSEX)
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
!     {
! 	MEMORYSTATUSEX  ms;
  
! 	/* Need to use GlobalMemoryStatusEx() when there is more memory than
! 	 * what fits in 32 bits. But it's not always available. */
! 	ms.dwLength = sizeof(MEMORYSTATUSEX);
! 	GlobalMemoryStatusEx(&ms);
! 	if (ms.ullAvailVirtual < ms.ullTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.ullAvailVirtual / 1024);
! 	}
! 	if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
! 	{
! 	    /* Catch old NT box or perverse hardware setup. */
! 	    return (long_u)((ms.ullTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
      }
!     else
! #endif
      {
! 	/* Pre-XP or 95 OS handling. */
! 	MEMORYSTATUS    ms;
! 	long_u		os_reserve_bytes;
! 
! 	ms.dwLength = sizeof(MEMORYSTATUS);
! 	GlobalMemoryStatus(&ms);
! 	if (ms.dwAvailVirtual < ms.dwTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.dwAvailVirtual / 1024);
! 	}
! 	os_reserve_bytes = (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    ? WINNT_RESERVE_BYTES
! 	    : WIN95_RESERVE_BYTES;
! 	if (ms.dwTotalPhys <= os_reserve_bytes)
! 	{
! 	    /* Catch old boxes or perverse hardware setup. */
! 	    return (long_u)((ms.dwTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.dwTotalPhys - os_reserve_bytes) / 1024);
      }
  }
  
  #ifdef FEAT_MBYTE
--- 5935,5959 ----
      long_u
  mch_total_mem(int special)
  {
!     MEMORYSTATUSEX  ms;
  
!     PlatformId();
!     /* Need to use GlobalMemoryStatusEx() when there is more memory than
!      * what fits in 32 bits. But it's not always available. */
!     ms.dwLength = sizeof(MEMORYSTATUSEX);
!     GlobalMemoryStatusEx(&ms);
!     if (ms.ullAvailVirtual < ms.ullTotalPhys)
!     {
! 	/* Process address space fits in physical RAM, use all of it. */
! 	return (long_u)(ms.ullAvailVirtual / 1024);
      }
!     if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
      {
! 	/* Catch old NT box or perverse hardware setup. */
! 	return (long_u)((ms.ullTotalPhys / 2) / 1024);
      }
+     /* Use physical RAM less reserve for OS + data. */
+     return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
  }
  
  #ifdef FEAT_MBYTE
***************
*** 6276,6291 ****
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     if (!mch_windows95())
!     {
! 	p = wold;
! 	for (i = 0; wold[i] != NUL; ++i)
! 	    if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		    && wold[i + 1] != 0)
! 		p = wold + i + 1;
! 	if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	    return (MoveFileW(wold, wnew) == 0);
!     }
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
--- 5970,5982 ----
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     p = wold;
!     for (i = 0; wold[i] != NUL; ++i)
! 	if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		&& wold[i + 1] != 0)
! 	    p = wold + i + 1;
!     if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	return (MoveFileW(wold, wnew) == 0);
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
***************
*** 6363,6384 ****
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	if (retval == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return retval;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
      /*
!      * No need to play tricks if not running Windows 95, unless the file name
!      * contains a "~" as the seventh character.
       */
!     if (!mch_windows95())
!     {
! 	pszFilePart = (char *)gettail((char_u *)pszOldFile);
! 	if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	    return rename(pszOldFile, pszNewFile);
!     }
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
--- 6054,6070 ----
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	return retval;
      }
  #endif
  
      /*
!      * No need to play tricks unless the file name contains a "~" as the
!      * seventh character.
       */
!     pszFilePart = (char *)gettail((char_u *)pszOldFile);
!     if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	return rename(pszOldFile, pszNewFile);
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
***************
*** 6441,6456 ****
      char *
  default_shell(void)
  {
-     char* psz = NULL;
- 
      PlatformId();
  
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)		/* Windows NT */
! 	psz = "cmd.exe";
!     else if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS) /* Windows 95 */
! 	psz = "command.com";
! 
!     return psz;
  }
  
  /*
--- 6127,6135 ----
      char *
  default_shell(void)
  {
      PlatformId();
  
!     return "cmd.exe";
  }
  
  /*
***************
*** 6496,6513 ****
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		char		    *pch;
--- 6175,6185 ----
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		    goto getout;
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    else
  #endif
  	    {
  		char		    *pch;
***************
*** 6537,6554 ****
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
--- 6209,6219 ----
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		    goto getout;
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    else
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
***************
*** 6565,6581 ****
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
- 	{
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
! 	if (wn == NULL)
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
--- 6230,6237 ----
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	else
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
***************
*** 6610,6620 ****
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    if (f >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return f;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wopen() fails for missing wide functions. */
  	}
      }
  # endif
--- 6266,6272 ----
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    return f;
  	}
      }
  # endif
***************
*** 6638,6649 ****
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
--- 6290,6296 ----
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
***************
*** 6667,6678 ****
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 
! 	if (f != NULL || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    return f;
! 	/* Retry with non-wide function (for Windows 98). Can't use
! 	 * GetLastError() here and it's unclear what errno gets set to if
! 	 * the _wfopen() fails for missing wide functions. */
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
--- 6314,6320 ----
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 	return f;
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
***************
*** 6843,6850 ****
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	copy_infostreams(from, to);
  #endif
      return 0;
  }
--- 6485,6491 ----
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     copy_infostreams(from, to);
  #endif
      return 0;
  }
***************
*** 6856,6862 ****
   */
  
  /* These magic numbers are from the MS header files */
- #define MIN_STACK_WIN9X 17
  #define MIN_STACK_WINNT 2
  
  /*
--- 6497,6502 ----
***************
*** 6876,6885 ****
      DWORD	nPageSize;
      DWORD	dummy;
  
-     /* This code will not work on win32s. */
      PlatformId();
-     if (g_PlatformId == VER_PLATFORM_WIN32s)
- 	return 0;
  
      /* We need to know the system page size. */
      GetSystemInfo(&si);
--- 6516,6522 ----
***************
*** 6895,6923 ****
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + ((g_PlatformId == VER_PLATFORM_WIN32_NT)
! 			     ? MIN_STACK_WINNT : MIN_STACK_WIN9X) * nPageSize;
  
-     /* On Win95, we want the next page down from the end of the stack. */
-     if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS)
      {
! 	/* Find the page that's only 1 page down from the page that the stack
! 	 * ptr is in. */
! 	pGuardPage = (BYTE*)((DWORD)nPageSize * (((DWORD)pStackPtr
! 						    / (DWORD)nPageSize) - 1));
! 	if (pGuardPage < pLowestPossiblePage)
! 	    return 0;
! 
! 	/* Apply the noaccess attribute to the page -- there's no guard
! 	 * attribute in win95-type OSes. */
! 	if (!VirtualProtect(pGuardPage, nPageSize, PAGE_NOACCESS, &dummy))
! 	    return 0;
!     }
!     else
!     {
! 	/* On NT, however, we want the first committed page in the stack Start
! 	 * at the stack base and move forward through memory until we find a
! 	 * committed block. */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
--- 6532,6543 ----
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + MIN_STACK_WINNT * nPageSize;
  
      {
! 	/* We want the first committed page in the stack Start at the stack
! 	 * base and move forward through memory until we find a committed block.
! 	 */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
*** ../vim-8.0.0028/src/os_win32.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_win32.h	2016-10-12 14:00:10.242811549 +0200
***************
*** 210,229 ****
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
- #ifndef PROTO
- 
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
!     /* The variables are defined in os_win32.c. */
! extern LRESULT (WINAPI *pDispatchMessage)(CONST MSG *);
! extern BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT);
! extern BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG);
! extern BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT);
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
- 
- #endif /* PROTO */
--- 210,224 ----
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
! # define pDispatchMessage DispatchMessageW
! # define pGetMessage GetMessageW
! # define pIsDialogMessage IsDialogMessageW
! # define pPeekMessage PeekMessageW
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
*** ../vim-8.0.0028/src/proto/os_mswin.pro	2016-09-12 13:04:30.000000000 +0200
--- src/proto/os_mswin.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 19,25 ****
  int mch_has_exp_wildcard(char_u *p);
  int mch_has_wildcard(char_u *p);
  int mch_chdir(char *path);
- int can_end_termcap_mode(int give_msg);
  int mch_screenmode(char_u *arg);
  int mch_icon_load(HANDLE *iconp);
  int mch_libcall(char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result);
--- 19,24 ----
*** ../vim-8.0.0028/src/proto/os_win32.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_win32.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 3,9 ****
  int dyn_libintl_init(void);
  void dyn_libintl_end(void);
  void PlatformId(void);
- int mch_windows95(void);
  void mch_setmouse(int on);
  void mch_update_cursor(void);
  int mch_char_avail(void);
--- 3,8 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 962,976 ****
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  if defined(_MSC_VER) && (_MSC_VER <= 1010)
!     /* Only MS VC 4.1 and earlier can do Win32s */
!     MSG_PUTS(_("\nMS-Windows 16/32-bit GUI version"));
! #  else
! #   ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #   else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
- #   endif
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
--- 964,973 ----
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #  else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
***************
*** 1332,1341 ****
      blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
      if (!p_cp)
  	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
-     if (mch_windows95())
- 	blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
- #endif
  
  #ifdef FEAT_WINDOWS
      /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
--- 1329,1334 ----
***************
*** 1384,1400 ****
  		do_intro_line(row, (char_u *)_(p), i == 2, 0);
  	    ++row;
  	}
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
- 	if (mch_windows95())
- 	{
- 	    do_intro_line(++row,
- 		    (char_u *)_("WARNING: Windows 95/98/ME detected"),
- 							FALSE, hl_attr(HLF_E));
- 	    do_intro_line(++row,
- 		(char_u *)_("type  :help windows95<Enter>  for info on this"),
- 								    FALSE, 0);
- 	}
- #endif
      }
  
      /* Make the wait-return message appear just below the text. */
--- 1377,1382 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
Lose weight, NEVER Diet again with
                  The "Invisible Weight Loss Patch"
						(spam e-mail)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0030
Problem:    Mouse mode is not automatically detected for tmux.
Solution:   Check for 'term' to be "tmux". (Michael Henry)
Files:      src/os_unix.c


*** ../vim-8.0.0029/src/os_unix.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_unix.c	2016-10-12 14:36:03.887453490 +0200
***************
*** 2261,2266 ****
--- 2261,2267 ----
      return (name != NULL
  	    && (term_is_xterm
  		|| STRNICMP(name, "screen", 6) == 0
+ 		|| STRNICMP(name, "tmux", 4) == 0
  		|| STRICMP(name, "st") == 0
  		|| STRNICMP(name, "st-", 3) == 0
  		|| STRNICMP(name, "stterm", 6) == 0));
***************
*** 2324,2329 ****
--- 2325,2331 ----
      return (   STRNICMP(name, "hpterm", 6) == 0
  	    || STRNICMP(name, "sun-cmd", 7) == 0
  	    || STRNICMP(name, "screen", 6) == 0
+ 	    || STRNICMP(name, "tmux", 4) == 0
  	    || STRNICMP(name, "dtterm", 6) == 0);
  }
  
*** ../vim-8.0.0029/src/version.c	2016-10-12 14:19:55.754357695 +0200
--- src/version.c	2016-10-12 14:50:38.049202893 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
Compilation process failed successfully.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0031
Problem:    After ":bwipeout" 'fileformat' is not set to the right default.
Solution:   Get the default from 'fileformats'. (Mike Williams)
Files:      src/option.c, src/Makefile, src/testdir/test_fileformat.vim,
            src/testdir/test_alot.vim


*** ../vim-8.0.0030/src/option.c	2016-10-12 14:19:55.750357722 +0200
--- src/option.c	2016-10-12 17:36:42.482477038 +0200
***************
*** 10729,10735 ****
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		buf->b_p_ff = vim_strsave(p_ff);
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
--- 10729,10747 ----
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		switch (*p_ffs)
! 		{
! 		    case 'm':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;
! 		    case 'd':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;
! 		    case 'u':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;
! 		    default:
! 			buf->b_p_ff = vim_strsave(p_ff);
! 		}
! 		if (buf->b_p_ff != NULL)
! 		    buf->b_start_ffc = *buf->b_p_ff;
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
*** ../vim-8.0.0030/src/Makefile	2016-09-29 20:54:42.399110777 +0200
--- src/Makefile	2016-10-12 16:24:51.984989904 +0200
***************
*** 2081,2086 ****
--- 2081,2087 ----
  	test_farsi \
  	test_feedkeys \
  	test_file_perm \
+ 	test_fileformat \
  	test_filter_cmd \
  	test_filter_map \
  	test_fnameescape \
*** ../vim-8.0.0030/src/testdir/test_fileformat.vim	2016-10-12 17:43:54.755416077 +0200
--- src/testdir/test_fileformat.vim	2016-10-12 16:29:46.522911119 +0200
***************
*** 0 ****
--- 1,17 ----
+ " Test behavior of fileformat after bwipeout of last buffer
+ 
+ func Test_fileformat_after_bw()
+   bwipeout
+   set fileformat&
+   if &fileformat == 'dos'
+     let test_fileformats = 'unix'
+   elseif &fileformat == 'unix'
+     let test_fileformats = 'mac'
+   else  " must be mac
+     let test_fileformats = 'dos'
+   endif
+   exec 'set fileformats='.test_fileformats
+   bwipeout!
+   call assert_equal(test_fileformats, &fileformat)
+   set fileformats&
+ endfunc
*** ../vim-8.0.0030/src/testdir/test_alot.vim	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/test_alot.vim	2016-10-12 16:24:26.933166652 +0200
***************
*** 12,21 ****
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
- source test_fnamemodify.vim
  source test_file_perm.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
--- 12,22 ----
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
  source test_file_perm.vim
+ source test_fileformat.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
+ source test_fnamemodify.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
*** ../vim-8.0.0030/src/version.c	2016-10-12 14:50:50.233115689 +0200
--- src/version.c	2016-10-12 16:27:46.415758987 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
   Arthur pulls Pin out.  The MONK blesses the grenade as ...
ARTHUR:  (quietly) One, two, five ...
GALAHAD: Three, sir!
ARTHUR:  Three.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0032
Problem:    Tests may change the input file when something goes wrong.
Solution:   Avoid writing the input file.
Files:      src/testdir/test51.in, src/testdir/test67.in,
            src/testdir/test97.in, src/testdir/test_tabpage.vim


*** ../vim-8.0.0031/src/testdir/test51.in	2012-11-15 22:30:32.000000000 +0100
--- src/testdir/test51.in	2016-10-12 16:53:02.513047817 +0200
***************
*** 24,30 ****
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
--- 24,30 ----
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e! test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
*** ../vim-8.0.0031/src/testdir/test67.in	2012-11-15 22:30:49.000000000 +0100
--- src/testdir/test67.in	2016-10-12 16:54:27.692445533 +0200
***************
*** 24,30 ****
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e test.out
  :call append(0, results)
  :$d
  :w
--- 24,30 ----
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e! test.out
  :call append(0, results)
  :$d
  :w
*** ../vim-8.0.0031/src/testdir/test97.in	2014-05-08 11:42:37.000000000 +0200
--- src/testdir/test97.in	2016-10-12 16:55:32.683985962 +0200
***************
*** 7,13 ****
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
--- 7,13 ----
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e! test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
*** ../vim-8.0.0031/src/testdir/test_tabpage.vim	2016-09-06 21:31:11.000000000 +0200
--- src/testdir/test_tabpage.vim	2016-09-29 20:07:58.098576056 +0200
***************
*** 11,16 ****
--- 11,17 ----
    0tabnew
    1tabnew
    $tabnew
+   %del
    tabdo call append(line('$'), tabpagenr())
    tabclose! 2
    tabrewind
*** ../vim-8.0.0031/src/version.c	2016-10-12 17:45:13.642857417 +0200
--- src/version.c	2016-10-12 17:51:56.632003323 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
ARTHUR:          What does it say?
BROTHER MAYNARD: It reads ... "Here may be found the last words of Joseph of
                 Aramathea." "He who is valorous and pure of heart may find
                 the Holy Grail in the aaaaarrrrrrggghhh..."
ARTHUR:          What?
BROTHER MAYNARD: "The Aaaaarrrrrrggghhh..."
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0033
Problem:    Cannot use overlapping positions with matchaddpos().
Solution:   Check end of match. (Ozaki Kiichi) Add a test (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0032/src/screen.c	2016-10-02 23:09:27.643153731 +0200
--- src/screen.c	2016-10-15 14:52:51.297854046 +0200
***************
*** 7786,7806 ****
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	if (posmatch->pos[i].lnum == 0)
  	    break;
! 	if (posmatch->pos[i].col < mincol)
  	    continue;
! 	if (posmatch->pos[i].lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (posmatch->pos[i].col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = posmatch->pos[i];
  
! 		    posmatch->pos[i] = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
--- 7786,7808 ----
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	llpos_T	*pos = &posmatch->pos[i];
! 
! 	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
! 	if (pos->lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
*** ../vim-8.0.0032/src/testdir/test_match.vim	2016-08-27 18:28:13.000000000 +0200
--- src/testdir/test_match.vim	2016-10-15 14:50:58.442694482 +0200
***************
*** 181,186 ****
--- 181,196 ----
    redraw!
    call assert_equal(screenattr(2,2), screenattr(1,6))
  
+   " Check overlapping pos
+   call clearmatches()
+   call setline(1, ['1234567890', 'NH'])
+   call matchaddpos('Error', [[1,1,5], [1,3,5], [2,2]])
+   redraw!
+   call assert_notequal(screenattr(2,2), 0)
+   call assert_equal(screenattr(2,2), screenattr(1,5))
+   call assert_equal(screenattr(2,2), screenattr(1,7))
+   call assert_notequal(screenattr(2,2), screenattr(1,8))
+ 
    nohl
    syntax off
    set hlsearch&
*** ../vim-8.0.0032/src/version.c	2016-10-12 17:52:39.199701825 +0200
--- src/version.c	2016-10-15 14:54:57.816912413 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0034
Problem:    No completion for ":messages".
Solution:   Complete "clear" argument. (Hirohito Higashi)
Files:      src/ex_docmd.c, src/ex_getln.c, src/proto/ex_docmd.pro,
            src/testdir/test_cmdline.vim, src/vim.h,
            runtime/doc/eval.txt, runtime/doc/map.txt


*** ../vim-8.0.0033/src/ex_docmd.c	2016-10-12 14:19:55.742357780 +0200
--- src/ex_docmd.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4281,4286 ****
--- 4281,4291 ----
  	    xp->xp_pattern = arg;
  	    break;
  
+ 	case CMD_messages:
+ 	    xp->xp_context = EXPAND_MESSAGES;
+ 	    xp->xp_pattern = arg;
+ 	    break;
+ 
  #if defined(FEAT_CMDHIST)
  	case CMD_history:
  	    xp->xp_context = EXPAND_HISTORY;
***************
*** 5893,5898 ****
--- 5898,5904 ----
  #endif
      {EXPAND_MAPPINGS, "mapping"},
      {EXPAND_MENUS, "menu"},
+     {EXPAND_MESSAGES, "messages"},
      {EXPAND_OWNSYNTAX, "syntax"},
  #if defined(FEAT_PROFILE)
      {EXPAND_SYNTIME, "syntime"},
***************
*** 11901,11906 ****
--- 11907,11924 ----
  	return (char_u *)"xterm";
      return NULL;
  }
+ 
+ /*
+  * Function given to ExpandGeneric() to obtain the possible arguments of the
+  * ":messages {clear}" command.
+  */
+     char_u *
+ get_messages_arg(expand_T *xp UNUSED, int idx)
+ {
+     if (idx == 0)
+ 	return (char_u *)"clear";
+     return NULL;
+ }
  #endif
  
  #ifdef FEAT_AUTOCMD
*** ../vim-8.0.0033/src/ex_getln.c	2016-09-09 21:35:27.000000000 +0200
--- src/ex_getln.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4832,4837 ****
--- 4832,4838 ----
  	{
  	    {EXPAND_COMMANDS, get_command_name, FALSE, TRUE},
  	    {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},
+ 	    {EXPAND_MESSAGES, get_messages_arg, TRUE, TRUE},
  #ifdef FEAT_CMDHIST
  	    {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},
  #endif
*** ../vim-8.0.0033/src/proto/ex_docmd.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_docmd.pro	2016-10-15 15:22:09.672808290 +0200
***************
*** 61,64 ****
--- 61,65 ----
  int put_line(FILE *fd, char *s);
  void dialog_msg(char_u *buff, char *format, char_u *fname);
  char_u *get_behave_arg(expand_T *xp, int idx);
+ char_u *get_messages_arg(expand_T *xp, int idx);
  /* vim: set ft=c : */
*** ../vim-8.0.0033/src/testdir/test_cmdline.vim	2016-08-28 13:34:01.000000000 +0200
--- src/testdir/test_cmdline.vim	2016-10-15 15:22:09.672808290 +0200
***************
*** 129,134 ****
--- 129,139 ----
    let l = getcompletion('dark', 'highlight')
    call assert_equal([], l)
  
+   let l = getcompletion('', 'messages')
+   call assert_true(index(l, 'clear') >= 0)
+   let l = getcompletion('not', 'messages')
+   call assert_equal([], l)
+ 
    if has('cscope')
      let l = getcompletion('', 'cscope')
      let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']
*** ../vim-8.0.0033/src/vim.h	2016-09-04 21:27:13.000000000 +0200
--- src/vim.h	2016-10-15 15:22:09.672808290 +0200
***************
*** 793,798 ****
--- 793,799 ----
  #define EXPAND_SYNTIME		43
  #define EXPAND_USER_ADDR_TYPE	44
  #define EXPAND_PACKADD		45
+ #define EXPAND_MESSAGES		46
  
  /* Values for exmode_active (0 is no exmode) */
  #define EXMODE_NORMAL		1
*** ../vim-8.0.0033/runtime/doc/eval.txt	2016-10-02 16:51:32.748592858 +0200
--- runtime/doc/eval.txt	2016-10-15 15:24:39.175697407 +0200
***************
*** 4281,4287 ****
--- 4287,4295 ----
  		locale		locale names (as output of locale -a)
  		mapping		mapping name
  		menu		menus
+ 		messages	|:messages| suboptions
  		option		options
+ 		packadd		optional package |pack-add| names
  		shellcmd	Shell command
  		sign		|:sign| suboptions
  		syntax		syntax file names |'syntax'|
*** ../vim-8.0.0033/runtime/doc/map.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/map.txt	2016-10-15 15:24:55.571575607 +0200
***************
*** 1280,1285 ****
--- 1280,1286 ----
  	-complete=locale	locale names (as output of locale -a)
  	-complete=mapping	mapping name
  	-complete=menu		menus
+ 	-complete=messages	|:messages| suboptions
  	-complete=option	options
  	-complete=packadd	optional package |pack-add| names
  	-complete=shellcmd	Shell command
*** ../vim-8.0.0033/src/version.c	2016-10-15 14:56:25.868257421 +0200
--- src/version.c	2016-10-15 15:23:36.340164248 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0035 (after 7.4.2013)
Problem:    Order of matches for 'omnifunc' is messed up. (Danny Su)
Solution:   Do not set compl_curr_match when called from complete_check().
            (closes #1168)
Files:      src/edit.c, src/evalfunc.c, src/proto/edit.pro, src/search.c,
            src/spell.c, src/tag.c, src/testdir/test76.in, 
            src/testdir/test76.ok, src/testdir/test_popup.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0034/src/edit.c	2016-09-05 20:53:05.000000000 +0200
--- src/edit.c	2016-10-15 17:01:00.865374961 +0200
***************
*** 179,186 ****
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(void);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
--- 179,186 ----
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(int in_compl_func);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match, int in_compl_func);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
***************
*** 861,867 ****
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert();
  		}
  	    }
  	}
--- 861,867 ----
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert(FALSE);
  		}
  	    }
  	}
***************
*** 3297,3303 ****
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50);
  	    }
  	    fclose(fp);
  	}
--- 3297,3303 ----
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50, FALSE);
  	    }
  	    fclose(fp);
  	}
***************
*** 4036,4043 ****
  }
  
  #ifdef FEAT_COMPL_FUNC
- static void expand_by_function(int type, char_u *base);
- 
  /*
   * Execute user defined complete function 'completefunc' or 'omnifunc', and
   * get matches in "matches".
--- 4036,4041 ----
***************
*** 4596,4602 ****
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
--- 4594,4600 ----
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0, FALSE);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
***************
*** 4653,4661 ****
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /* Insert the new text being completed. */
      static void
! ins_compl_insert(void)
  {
      dict_T	*dict;
  
--- 4651,4662 ----
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /*
!  * Insert the new text being completed.
!  * "in_compl_func" is TRUE when called from complete_check().
!  */
      static void
! ins_compl_insert(int in_compl_func)
  {
      dict_T	*dict;
  
***************
*** 4682,4688 ****
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     compl_curr_match = compl_shown_match;
  }
  
  /*
--- 4683,4690 ----
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     if (!in_compl_func)
! 	compl_curr_match = compl_shown_match;
  }
  
  /*
***************
*** 4706,4712 ****
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match)	/* Insert the newly selected match */
  {
      int	    num_matches = -1;
      int	    i;
--- 4708,4715 ----
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match,	/* Insert the newly selected match */
!     int	    in_compl_func)	/* called from complete_check() */
  {
      int	    num_matches = -1;
      int	    i;
***************
*** 4856,4862 ****
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert();
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
--- 4859,4865 ----
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert(in_compl_func);
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
***************
*** 4921,4929 ****
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
   */
      void
! ins_compl_check_keys(int frequency)
  {
      static int	count = 0;
  
--- 4924,4934 ----
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
+  * "in_compl_func" is TRUE when called from complete_check(), don't set
+  * compl_curr_match.
   */
      void
! ins_compl_check_keys(int frequency, int in_compl_func)
  {
      static int	count = 0;
  
***************
*** 4949,4955 ****
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 						    c != K_UP && c != K_DOWN);
  	}
  	else
  	{
--- 4954,4960 ----
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 				      c != K_UP && c != K_DOWN, in_compl_func);
  	}
  	else
  	{
***************
*** 4972,4978 ****
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE);
      }
  }
  
--- 4977,4983 ----
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE, in_compl_func);
      }
  }
  
***************
*** 5490,5496 ****
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c), ins_compl_use_match(c));
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
--- 5495,5502 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c),
! 						ins_compl_use_match(c), FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
*** ../vim-8.0.0034/src/evalfunc.c	2016-10-12 14:19:55.738357808 +0200
--- src/evalfunc.c	2016-10-15 16:22:08.458346817 +0200
***************
*** 2175,2181 ****
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
--- 2175,2181 ----
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0, TRUE);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
*** ../vim-8.0.0034/src/proto/edit.pro	2016-09-12 13:04:00.000000000 +0200
--- src/proto/edit.pro	2016-10-15 16:23:24.833787216 +0200
***************
*** 15,21 ****
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
--- 15,21 ----
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency, int in_compl_func);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
*** ../vim-8.0.0034/src/search.c	2016-09-09 21:20:55.000000000 +0200
--- src/search.c	2016-10-15 16:26:52.640264523 +0200
***************
*** 5429,5435 ****
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
--- 5429,5435 ----
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30, FALSE);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
*** ../vim-8.0.0034/src/spell.c	2016-08-29 22:42:20.000000000 +0200
--- src/spell.c	2016-10-15 16:27:13.788109555 +0200
***************
*** 8694,8700 ****
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50);
  		}
  		else
  		{
--- 8694,8700 ----
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50, FALSE);
  		}
  		else
  		{
*** ../vim-8.0.0034/src/tag.c	2016-09-06 21:20:44.000000000 +0200
--- src/tag.c	2016-10-15 16:27:34.955954439 +0200
***************
*** 1587,1593 ****
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
--- 1587,1593 ----
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30, FALSE);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
*** ../vim-8.0.0034/src/testdir/test76.in	2010-11-10 16:38:45.000000000 +0100
--- src/testdir/test76.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,46 ****
- Tests for completefunc/omnifunc. vim: set ft=vim :
- 
- STARTTEST
- :"Test that nothing happens if the 'completefunc' opens
- :"a new window (no completion, no crash)
- :so small.vim
- :function! DummyCompleteOne(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    wincmd n
- :    return ['onedef', 'oneDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteOne
- /^one
- A:q!
- :function! DummyCompleteTwo(findstart, base)
- :  if a:findstart
- :    wincmd n
- :    return 0
- :  else
- :    return ['twodef', 'twoDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteTwo
- /^two
- A:q!
- :"Test that 'completefunc' works when it's OK.
- :function! DummyCompleteThree(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    return ['threedef', 'threeDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteThree
- /^three
- A:/^+++/,/^three/w! test.out
- :qa!
- ENDTEST
- 
- +++
- one
- two
- three
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test76.ok	2010-11-10 16:38:58.000000000 +0100
--- src/testdir/test76.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,4 ****
- +++
- 
- two
- threeDEF
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test_popup.vim	2016-09-22 21:27:08.360782126 +0200
--- src/testdir/test_popup.vim	2016-10-15 17:00:08.237755020 +0200
***************
*** 289,292 ****
--- 289,403 ----
    bwipe!
  endfunc
  
+ func DummyCompleteOne(findstart, base)
+   if a:findstart
+     return 0
+   else
+     wincmd n
+     return ['onedef', 'oneDEF']
+   endif
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_one()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteOne
+   call setline(1, 'one')
+   /^one
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E839:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('', getline(1))
+   q!
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func DummyCompleteTwo(findstart, base)
+   if a:findstart
+     wincmd n
+     return 0
+   else
+     return ['twodef', 'twoDEF']
+   endif
+ endfunction
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_two()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteTwo
+   call setline(1, 'two')
+   /^two
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E764:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('two', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteThree(findstart, base)
+   if a:findstart
+     return 0
+   else
+     return ['threedef', 'threeDEF']
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_completefunc_works()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteThree
+   call setline(1, 'three')
+   /^three
+   call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")
+   call assert_equal(winid, win_getid())
+   call assert_equal('threeDEF', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteFour(findstart, base)
+   if a:findstart
+     return 0
+   else
+     call complete_add('four1')
+     call complete_add('four2')
+     call complete_check()
+     call complete_add('four3')
+     call complete_add('four4')
+     call complete_check()
+     call complete_add('four5')
+     call complete_add('four6')
+     return []
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_omnifunc_with_check()
+   new
+   setlocal omnifunc=DummyCompleteFour
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<Esc>", "x")
+   call assert_equal('four2', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four3', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four5', getline(1))
+ 
+   q!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0034/src/Makefile	2016-10-12 17:45:13.642857417 +0200
--- src/Makefile	2016-10-15 16:53:46.808507474 +0200
***************
*** 2047,2053 ****
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test76 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
--- 2047,2053 ----
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
*** ../vim-8.0.0034/src/testdir/Make_all.mak	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/Make_all.mak	2016-10-15 16:53:57.008433920 +0200
***************
*** 55,61 ****
  	test70.out \
  	test73.out \
  	test75.out \
- 	test76.out \
  	test77.out \
  	test79.out \
  	test80.out \
--- 55,60 ----
*** ../vim-8.0.0034/src/version.c	2016-10-15 15:39:34.693059595 +0200
--- src/version.c	2016-10-15 17:05:26.303457035 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0036
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0036
Problem:    Detecting that a job has finished may take a while.
Solution:   Check for a finished job more often (Ozaki Kiichi)
Files:      src/channel.c, src/os_unix.c, src/os_win32.c,
            src/proto/os_unix.pro, src/proto/os_win32.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0035/src/channel.c	2016-10-09 17:27:56.859388538 +0200
--- src/channel.c	2016-10-15 18:34:49.054767438 +0200
***************
*** 4428,4433 ****
--- 4428,4466 ----
      }
  }
  
+     static void
+ job_cleanup(job_T *job)
+ {
+     if (job->jv_status != JOB_ENDED)
+ 	return;
+ 
+     if (job->jv_exit_cb != NULL)
+     {
+ 	typval_T	argv[3];
+ 	typval_T	rettv;
+ 	int		dummy;
+ 
+ 	/* invoke the exit callback; make sure the refcount is > 0 */
+ 	++job->jv_refcount;
+ 	argv[0].v_type = VAR_JOB;
+ 	argv[0].vval.v_job = job;
+ 	argv[1].v_type = VAR_NUMBER;
+ 	argv[1].vval.v_number = job->jv_exitval;
+ 	call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
+ 	    &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
+ 	    job->jv_exit_partial, NULL);
+ 	clear_tv(&rettv);
+ 	--job->jv_refcount;
+ 	channel_need_redraw = TRUE;
+     }
+     if (job->jv_refcount == 0)
+     {
+ 	/* The job was already unreferenced, now that it ended it can be
+ 	 * freed. Careful: caller must not use "job" after this! */
+ 	job_free(job);
+     }
+ }
+ 
  #if defined(EXITFREE) || defined(PROTO)
      void
  job_free_all(void)
***************
*** 4445,4454 ****
      static int
  job_still_useful(job_T *job)
  {
!     return job->jv_status == JOB_STARTED
! 	       && (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 		   || (job->jv_channel != NULL
! 		       && channel_still_useful(job->jv_channel)));
  }
  
  /*
--- 4478,4492 ----
      static int
  job_still_useful(job_T *job)
  {
!     return (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 	    || (job->jv_channel != NULL
! 		&& channel_still_useful(job->jv_channel)));
! }
! 
!     static int
! job_still_alive(job_T *job)
! {
!     return (job->jv_status == JOB_STARTED) && job_still_useful(job);
  }
  
  /*
***************
*** 4462,4468 ****
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_useful(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
--- 4500,4506 ----
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
***************
*** 4478,4484 ****
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_useful(job))
  	{
  	    job_free(job);
  	}
--- 4516,4522 ----
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_alive(job))
  	{
  	    job_free(job);
  	}
***************
*** 4503,4509 ****
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
--- 4541,4547 ----
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
***************
*** 4523,4529 ****
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
--- 4561,4567 ----
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
***************
*** 4614,4647 ****
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job->jv_status == JOB_STARTED && job_still_useful(job))
  	    return TRUE;
      return FALSE;
  }
  
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     static time_t   last_check = 0;
!     time_t	    now;
!     job_T	    *job;
!     job_T	    *next;
  
!     /* Only do this once in 10 seconds. */
!     now = time(NULL);
!     if (last_check + 10 < now)
!     {
! 	last_check = now;
! 	for (job = first_job; job != NULL; job = next)
! 	{
! 	    next = job->jv_next;
! 	    if (job->jv_status == JOB_STARTED && job_still_useful(job))
! 		job_status(job); /* may free "job" */
! 	}
      }
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
--- 4652,4682 ----
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	    return TRUE;
      return FALSE;
  }
  
+ #define MAX_CHECK_ENDED 8
+ 
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     int		i;
  
!     for (i = 0; i < MAX_CHECK_ENDED; ++i)
!     {
! 	job_T	*job = mch_detect_ended_job(first_job);
! 
! 	if (job == NULL)
! 	    break;
! 	if (job_still_useful(job))
! 	    job_cleanup(job); /* may free "job" */
      }
+ 
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
***************
*** 4862,4893 ****
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    ch_log(job->jv_channel, "Job ended");
! 	if (job->jv_status == JOB_ENDED && job->jv_exit_cb != NULL)
! 	{
! 	    typval_T	argv[3];
! 	    typval_T	rettv;
! 	    int		dummy;
! 
! 	    /* invoke the exit callback; make sure the refcount is > 0 */
! 	    ++job->jv_refcount;
! 	    argv[0].v_type = VAR_JOB;
! 	    argv[0].vval.v_job = job;
! 	    argv[1].v_type = VAR_NUMBER;
! 	    argv[1].vval.v_number = job->jv_exitval;
! 	    call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
! 			   &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
! 			   job->jv_exit_partial, NULL);
! 	    clear_tv(&rettv);
! 	    --job->jv_refcount;
! 	    channel_need_redraw = TRUE;
! 	}
! 	if (job->jv_status == JOB_ENDED && job->jv_refcount == 0)
! 	{
! 	    /* The job was already unreferenced, now that it ended it can be
! 	     * freed. Careful: caller must not use "job" after this! */
! 	    job_free(job);
! 	}
      }
      return result;
  }
--- 4897,4903 ----
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    job_cleanup(job);
      }
      return result;
  }
*** ../vim-8.0.0035/src/os_unix.c	2016-10-12 14:50:50.233115689 +0200
--- src/os_unix.c	2016-10-15 18:33:46.303229935 +0200
***************
*** 5294,5301 ****
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (wait_pid == 0)
  	return "run";
--- 5294,5300 ----
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	goto return_dead;
      }
      if (wait_pid == 0)
  	return "run";
***************
*** 5303,5318 ****
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      return "run";
  }
  
      int
--- 5302,5363 ----
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	goto return_dead;
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	goto return_dead;
      }
      return "run";
+ 
+ return_dead:
+     if (job->jv_status != JOB_ENDED)
+     {
+ 	ch_log(job->jv_channel, "Job ended");
+ 	job->jv_status = JOB_ENDED;
+     }
+     return "dead";
+ }
+ 
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+ # ifdef HAVE_UNION_WAIT
+     union wait	status;
+ # else
+     int		status = -1;
+ # endif
+     pid_t	wait_pid = 0;
+     job_T	*job;
+ 
+ # ifdef __NeXT__
+     wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);
+ # else
+     wait_pid = waitpid(-1, &status, WNOHANG);
+ # endif
+     if (wait_pid <= 0)
+ 	/* no process ended */
+ 	return NULL;
+     for (job = job_list; job != NULL; job = job->jv_next)
+     {
+ 	if (job->jv_pid == wait_pid)
+ 	{
+ 	    if (WIFEXITED(status))
+ 		/* LINTED avoid "bitwise operation on signed value" */
+ 		job->jv_exitval = WEXITSTATUS(status);
+ 	    else if (WIFSIGNALED(status))
+ 		job->jv_exitval = -1;
+ 	    if (job->jv_status != JOB_ENDED)
+ 	    {
+ 		ch_log(job->jv_channel, "Job ended");
+ 		job->jv_status = JOB_ENDED;
+ 	    }
+ 	    return job;
+ 	}
+     }
+     return NULL;
+ 
  }
  
      int
*** ../vim-8.0.0035/src/os_win32.c	2016-10-12 14:19:55.754357695 +0200
--- src/os_win32.c	2016-10-15 18:34:13.379030378 +0200
***************
*** 4973,4985 ****
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
- 	job->jv_status = JOB_ENDED;
  	job->jv_exitval = (int)dwExitCode;
  	return "dead";
      }
      return "run";
  }
  
      int
  mch_stop_job(job_T *job, char_u *how)
  {
--- 4973,5025 ----
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
+ 	if (job->jv_status != JOB_ENDED)
+ 	{
+ 	    ch_log(job->jv_channel, "Job ended");
+ 	    job->jv_status = JOB_ENDED;
+ 	}
  	return "dead";
      }
      return "run";
  }
  
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+     HANDLE jobHandles[MAXIMUM_WAIT_OBJECTS];
+     job_T *jobArray[MAXIMUM_WAIT_OBJECTS];
+     job_T *job = job_list;
+ 
+     while (job != NULL)
+     {
+ 	DWORD n;
+ 	DWORD result;
+ 
+ 	for (n = 0; n < MAXIMUM_WAIT_OBJECTS
+ 				       && job != NULL; job = job->jv_next)
+ 	{
+ 	    if (job->jv_status == JOB_STARTED)
+ 	    {
+ 		jobHandles[n] = job->jv_proc_info.hProcess;
+ 		jobArray[n] = job;
+ 		++n;
+ 	    }
+ 	}
+ 	if (n == 0)
+ 	    continue;
+ 	result = WaitForMultipleObjects(n, jobHandles, FALSE, 0);
+ 	if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + n)
+ 	{
+ 	    job_T *wait_job = jobArray[result - WAIT_OBJECT_0];
+ 
+ 	    if (STRCMP(mch_job_status(wait_job), "dead") == 0)
+ 		return wait_job;
+ 	}
+     }
+     return NULL;
+ }
+ 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
*** ../vim-8.0.0035/src/proto/os_unix.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_unix.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 59,64 ****
--- 59,65 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char **argv, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_breakcheck(int force);
*** ../vim-8.0.0035/src/proto/os_win32.pro	2016-10-12 14:19:55.754357695 +0200
--- src/proto/os_win32.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 41,46 ****
--- 41,47 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char *cmd, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_set_normal_colors(void);
*** ../vim-8.0.0035/src/testdir/test_channel.vim	2016-10-09 17:27:56.863388510 +0200
--- src/testdir/test_channel.vim	2016-10-15 18:26:49.770299911 +0200
***************
*** 1362,1367 ****
--- 1362,1385 ----
    endif
  endfunc
  
+ let g:exit_cb_time = {'start': 0, 'end': 0}
+ function MyExitTimeCb(job, status)
+   let g:exit_cb_time.end = reltime(g:exit_cb_time.start)
+ endfunction
+ 
+ func Test_exit_callback_interval()
+   if !has('job')
+     return
+   endif
+ 
+   let g:exit_cb_time.start = reltime()
+   let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
+   call WaitFor('g:exit_cb_time.end != 0')
+   let elapsed = reltimefloat(g:exit_cb_time.end)
+   call assert_true(elapsed > 0.3)
+   call assert_true(elapsed < 1.0)
+ endfunc
+ 
  """""""""
  
  let g:Ch_close_ret = 'alive'
*** ../vim-8.0.0035/src/version.c	2016-10-15 17:06:42.094912699 +0200
--- src/version.c	2016-10-15 18:28:19.269640273 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
It is illegal for a driver to be blindfolded while operating a vehicle.
		[real standing law in Alabama, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0037
Problem:    Get E924 when switching tabs.
Solution:   Use win_valid_any_tab() instead of win_valid(). (Martin Vuille,
            closes #1167, closes #1171)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0036/src/quickfix.c	2016-10-09 16:10:02.135942266 +0200
--- src/quickfix.c	2016-10-15 19:20:23.402614457 +0200
***************
*** 2266,2272 ****
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
--- 2266,2272 ----
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid_any_tab(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
*** ../vim-8.0.0036/src/testdir/test_quickfix.vim	2016-10-09 16:10:02.135942266 +0200
--- src/testdir/test_quickfix.vim	2016-10-15 19:19:46.170888867 +0200
***************
*** 617,622 ****
--- 617,638 ----
      augroup! testgroup
  endfunction
  
+ function Test_locationlist_cross_tab_jump()
+   call writefile(['loclistfoo'], 'loclistfoo')
+   call writefile(['loclistbar'], 'loclistbar')
+   set switchbuf=usetab
+ 
+   edit loclistfoo
+   tabedit loclistbar
+   silent lgrep loclistfoo loclist*
+   call assert_equal(1, tabpagenr())
+ 
+   enew | only | tabonly
+   set switchbuf&vim
+   call delete('loclistfoo')
+   call delete('loclistbar')
+ endfunction
+ 
  " More tests for 'errorformat'
  function! Test_efm1()
      if !has('unix')
*** ../vim-8.0.0036/src/version.c	2016-10-15 18:36:45.353910276 +0200
--- src/version.c	2016-10-15 19:22:55.749491613 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
You can be stopped by the police for biking over 65 miles per hour.
You are not allowed to walk across a street on your hands.
		[real standing laws in Connecticut, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0038
Problem:    OPEN_CHR_FILES not defined for FreeBSD using Debian userland
            files.
Solution:   Check for __FreeBSD_kernel__. (James McCoy, closes #1166)
Files:      src/vim.h


*** ../vim-8.0.0037/src/vim.h	2016-10-15 15:39:34.689059624 +0200
--- src/vim.h	2016-10-15 19:32:06.017435971 +0200
***************
*** 2495,2501 ****
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__)) && defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
--- 2495,2502 ----
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) \
! 	&& defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
*** ../vim-8.0.0037/src/version.c	2016-10-15 19:28:09.243181069 +0200
--- src/version.c	2016-10-15 19:33:06.036993609 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
A special law prohibits unmarried women from parachuting on Sunday or she
shall risk arrest, fine, and/or jailing.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0039
Problem:    When Vim 8 reads an old viminfo and exits, the next time marks are
            not read from viminfo. (Ned Batchelder)
Solution:   Set a mark when it wasn't set before, even when the timestamp is
            zero. (closes #1170)
Files:      src/mark.c, src/testdir/test_viminfo.vim


*** ../vim-8.0.0038/src/mark.c	2016-08-29 22:42:20.000000000 +0200
--- src/mark.c	2016-10-15 20:42:31.522292708 +0200
***************
*** 1597,1603 ****
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
--- 1597,1604 ----
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->fmark.mark.lnum == 0
! 					  || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
*** ../vim-8.0.0038/src/testdir/test_viminfo.vim	2016-08-26 20:35:50.000000000 +0200
--- src/testdir/test_viminfo.vim	2016-10-15 20:38:48.599935714 +0200
***************
*** 1,6 ****
  " Test for reading and writing .viminfo
  
! function Test_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
--- 1,6 ----
  " Test for reading and writing .viminfo
  
! function Test_viminfo_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
***************
*** 17,23 ****
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
--- 17,23 ----
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],' && line !~ '^|<'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
***************
*** 469,475 ****
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
--- 469,495 ----
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_viminfo_file_mark_zero_time()
!   let lines = [
! 	\ '# Viminfo version',
! 	\ '|1,4',
! 	\ '',
! 	\ '*encoding=utf-8',
! 	\ '',
! 	\ '# File marks:',
! 	\ "'B  1  0  /tmp/nothing",
! 	\ '|4,66,1,0,0,"/tmp/nothing"',
! 	\ "",
! 	\ ]
!   call writefile(lines, 'Xviminfo')
!   delmark B
!   rviminfo Xviminfo
!   call delete('Xviminfo')
!   call assert_equal(1, line("'B"))
!   delmark B
! endfunc
! 
! func Test_viminfo_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
*** ../vim-8.0.0038/src/version.c	2016-10-15 19:33:47.264689748 +0200
--- src/version.c	2016-10-15 20:41:39.246677996 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
If an elephant is left tied to a parking meter, the parking fee has to be paid
just as it would for a vehicle.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0040 (after 8.0.0033)
Problem:    Whole line highlighting with matchaddpos() does not work.
Solution:   Check for zero length. (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0039/src/screen.c	2016-10-15 14:56:25.868257421 +0200
--- src/screen.c	2016-10-16 14:28:48.026766302 +0200
***************
*** 7773,7778 ****
--- 7773,7782 ----
      }
  }
  
+ /*
+  * If there is a match fill "shl" and return one.
+  * Return zero otherwise.
+  */
      static int
  next_search_hl_pos(
      match_T	    *shl,	/* points to a match */
***************
*** 7781,7835 ****
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    bot = -1;
  
-     shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (shl->lnum == lnum)
  	    {
! 		/* partially sort positions by column numbers
! 		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
! 		    posmatch->pos[bot] = tmp;
  		}
  	    }
  	    else
! 	    {
! 		bot = i;
! 		shl->lnum = lnum;
! 	    }
  	}
      }
      posmatch->cur = 0;
!     if (shl->lnum == lnum && bot >= 0)
      {
! 	colnr_T	start = posmatch->pos[bot].col == 0
! 					     ? 0 : posmatch->pos[bot].col - 1;
! 	colnr_T	end = posmatch->pos[bot].col == 0
! 				    ? MAXCOL : start + posmatch->pos[bot].len;
  
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = bot + 1;
! 	return TRUE;
      }
!     return FALSE;
  }
  #endif
  
--- 7785,7836 ----
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    found = -1;
  
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->len == 0 && pos->col < mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (found >= 0)
  	    {
! 		/* if this match comes before the one at "found" then swap
! 		 * them */
! 		if (pos->col < posmatch->pos[found].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[found];
! 		    posmatch->pos[found] = tmp;
  		}
  	    }
  	    else
! 		found = i;
  	}
      }
      posmatch->cur = 0;
!     if (found >= 0)
      {
! 	colnr_T	start = posmatch->pos[found].col == 0
! 					    ? 0 : posmatch->pos[found].col - 1;
! 	colnr_T	end = posmatch->pos[found].col == 0
! 				   ? MAXCOL : start + posmatch->pos[found].len;
  
+ 	shl->lnum = lnum;
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = found + 1;
! 	return 1;
      }
!     return 0;
  }
  #endif
  
*** ../vim-8.0.0039/src/testdir/test_match.vim	2016-10-15 14:56:25.868257421 +0200
--- src/testdir/test_match.vim	2016-10-16 14:16:10.376350417 +0200
***************
*** 191,197 ****
--- 191,205 ----
    call assert_equal(screenattr(2,2), screenattr(1,7))
    call assert_notequal(screenattr(2,2), screenattr(1,8))
  
+   call clearmatches()
+   call matchaddpos('Error', [[1], [2,2]])
+   redraw!
+   call assert_equal(screenattr(2,2), screenattr(1,1))
+   call assert_equal(screenattr(2,2), screenattr(1,10))
+   call assert_notequal(screenattr(2,2), screenattr(1,11))
+ 
    nohl
+   call clearmatches()
    syntax off
    set hlsearch&
  endfunc
*** ../vim-8.0.0039/src/version.c	2016-10-15 20:46:13.580656069 +0200
--- src/version.c	2016-10-16 14:30:29.174020816 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     40,
  /**/

-- 
It is illegal for anyone to give lighted cigars to dogs, cats, and other
domesticated animal kept as pets.
		[real standing law in Illinois, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0041
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0041
Problem:    When using Insert mode completion but not actually inserting
            anything an undo item is still created. (Tommy Allen)
Solution:   Do not call stop_arrow() when not inserting anything.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0040/src/edit.c	2016-10-15 17:06:42.086912756 +0200
--- src/edit.c	2016-10-16 15:34:26.985734970 +0200
***************
*** 2799,2807 ****
  	ins_compl_prep(' ');
      ins_compl_clear();
  
-     if (stop_arrow() == FAIL)
- 	return;
- 
      compl_direction = FORWARD;
      if (startcol > curwin->w_cursor.col)
  	startcol = curwin->w_cursor.col;
--- 2799,2804 ----
***************
*** 3876,3882 ****
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		if (stop_arrow() == OK)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
--- 3873,3880 ----
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		/* only format when something was inserted */
! 		if (!arrow_used && !ins_need_undo)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
*** ../vim-8.0.0040/src/testdir/test_popup.vim	2016-10-15 17:06:42.094912699 +0200
--- src/testdir/test_popup.vim	2016-10-16 15:33:41.586069579 +0200
***************
*** 378,384 ****
    endif
  endfunc
  
! :"Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
--- 378,384 ----
    endif
  endfunc
  
! " Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
***************
*** 400,403 ****
--- 400,429 ----
    q!
  endfunc
  
+ function UndoComplete()
+   call complete(1, ['January', 'February', 'March',
+         \ 'April', 'May', 'June', 'July', 'August', 'September',
+         \ 'October', 'November', 'December'])
+   return ''
+ endfunc
+ 
+ " Test that no undo item is created when no completion is inserted
+ func Test_complete_no_undo()
+   set completeopt=menu,preview,noinsert,noselect
+   inoremap <Right> <C-R>=UndoComplete()<CR>
+   new
+   call feedkeys("ixxx\<CR>\<CR>yyy\<Esc>k", 'xt')
+   call feedkeys("iaaa\<Esc>0", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("i\<Right>\<Esc>", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('', getline(2))
+ 
+   iunmap <Right>
+   set completeopt&
+   q!
+ endfunc
+ 
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0040/src/version.c	2016-10-16 14:35:44.547696415 +0200
--- src/version.c	2016-10-16 15:35:09.805419375 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
Sometimes I think the surest sign that intelligent life exists elsewhere
in the universe is that none of it has tried to contact us.     (Calvin)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0042
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0042 (after 8.0.0041)
Problem:    When using Insert mode completion with 'completeopt' containing
            "noinsert" change is not saved for undo.  (Tommy Allen)
Solution:   Call stop_arrow() before inserting for pressing Enter.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0041/src/edit.c	2016-10-16 15:35:43.113173887 +0200
--- src/edit.c	2016-10-17 20:40:11.205738031 +0200
***************
*** 857,864 ****
  
  		/* Pressing CTRL-Y selects the current match.  When
  		 * compl_enter_selects is set the Enter key does the same. */
! 		if (c == Ctrl_Y || (compl_enter_selects
! 				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
  		    ins_compl_insert(FALSE);
--- 857,865 ----
  
  		/* Pressing CTRL-Y selects the current match.  When
  		 * compl_enter_selects is set the Enter key does the same. */
! 		if ((c == Ctrl_Y || (compl_enter_selects
! 				    && (c == CAR || c == K_KENTER || c == NL)))
! 			&& stop_arrow() == OK)
  		{
  		    ins_compl_delete();
  		    ins_compl_insert(FALSE);
*** ../vim-8.0.0041/src/testdir/test_popup.vim	2016-10-16 15:35:43.113173887 +0200
--- src/testdir/test_popup.vim	2016-10-17 20:33:32.300678084 +0200
***************
*** 420,425 ****
--- 420,432 ----
    call feedkeys("u", 'xt')
    call assert_equal('', getline(2))
  
+   call feedkeys("ibbb\<Esc>0", 'xt')
+   call assert_equal('bbb', getline(2))
+   call feedkeys("A\<Right>\<Down>\<CR>\<Esc>", 'xt')
+   call assert_equal('January', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('bbb', getline(2))
+ 
    iunmap <Right>
    set completeopt&
    q!
*** ../vim-8.0.0041/src/version.c	2016-10-16 15:35:43.113173887 +0200
--- src/version.c	2016-10-17 20:43:35.744230520 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     42,
  /**/

-- 
bashian roulette:
$ ((RANDOM%6)) || rm -rf ~

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0043
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0043 (after 8.0.0041)
Problem:    When using Insert mode completion with 'completeopt' containing
            "noinsert" with CTRL-N the change is not saved for undo.  (Tommy
            Allen)
Solution:   Call stop_arrow() before inserting for any key.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0042/src/edit.c	2016-10-17 20:46:59.342729937 +0200
--- src/edit.c	2016-10-18 12:51:59.119990870 +0200
***************
*** 4634,4647 ****
      static void
  ins_compl_delete(void)
  {
!     int	    i;
  
      /*
       * In insert mode: Delete the typed part.
       * In replace mode: Put the old characters back, if any.
       */
!     i = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);
!     backspace_until_column(i);
  
      /* TODO: is this sufficient for redrawing?  Redrawing everything causes
       * flicker, thus we can't do that. */
--- 4634,4652 ----
      static void
  ins_compl_delete(void)
  {
!     int	    col;
  
      /*
       * In insert mode: Delete the typed part.
       * In replace mode: Put the old characters back, if any.
       */
!     col = compl_col + (compl_cont_status & CONT_ADDING ? compl_length : 0);
!     if ((int)curwin->w_cursor.col > col)
!     {
! 	if (stop_arrow() == FAIL)
! 	    return;
! 	backspace_until_column(col);
!     }
  
      /* TODO: is this sufficient for redrawing?  Redrawing everything causes
       * flicker, thus we can't do that. */
***************
*** 5059,5066 ****
--- 5064,5074 ----
      colnr_T	curs_col;	    /* cursor column */
      int		n;
      int		save_w_wrow;
+     int		insert_match;
  
      compl_direction = ins_compl_key2dir(c);
+     insert_match = ins_compl_use_match(c);
+ 
      if (!compl_started)
      {
  	/* First time we hit ^N or ^P (in a row, I mean) */
***************
*** 5486,5491 ****
--- 5494,5501 ----
  	edit_submode_extra = NULL;
  	out_flush();
      }
+     else if (insert_match && stop_arrow() == FAIL)
+ 	return FAIL;
  
      compl_shown_match = compl_curr_match;
      compl_shows_dir = compl_direction;
***************
*** 5494,5501 ****
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c),
! 						ins_compl_use_match(c), FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
--- 5504,5510 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c), insert_match, FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
*** ../vim-8.0.0042/src/testdir/test_popup.vim	2016-10-17 20:46:59.342729937 +0200
--- src/testdir/test_popup.vim	2016-10-18 12:31:27.581067689 +0200
***************
*** 427,432 ****
--- 427,437 ----
    call feedkeys("u", 'xt')
    call assert_equal('bbb', getline(2))
  
+   call feedkeys("A\<Right>\<C-N>\<Esc>", 'xt')
+   call assert_equal('January', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('bbb', getline(2))
+ 
    iunmap <Right>
    set completeopt&
    q!
*** ../vim-8.0.0042/src/version.c	2016-10-17 20:46:59.342729937 +0200
--- src/version.c	2016-10-18 13:01:18.947864767 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     43,
  /**/

-- 
A parent can be arrested if his child cannot hold back a burp during a church
service.
		[real standing law in Nebraska, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0044
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0044
Problem:    In diff mode the cursor may end up below the last line, resulting
            in an ml_get error.
Solution:   Check the line to be valid.
Files:      src/move.c, src/diff.c, src/proto/diff.pro,
            src/testdir/test_diffmode.vim


*** ../vim-8.0.0043/src/move.c	2016-09-04 14:29:37.000000000 +0200
--- src/move.c	2016-10-18 14:28:15.793415019 +0200
***************
*** 2824,2834 ****
  	{
  # ifdef FEAT_DIFF
  	    if (curwin->w_p_diff)
! 		curwin->w_cursor.lnum
! 			= diff_get_corresponding_line(old_curbuf,
! 						      line,
! 						      curbuf,
! 						      curwin->w_cursor.lnum);
  	    else
  # endif
  		curwin->w_cursor.lnum = line;
--- 2824,2831 ----
  	{
  # ifdef FEAT_DIFF
  	    if (curwin->w_p_diff)
! 		curwin->w_cursor.lnum =
! 				 diff_get_corresponding_line(old_curbuf, line);
  	    else
  # endif
  		curwin->w_cursor.lnum = line;
*** ../vim-8.0.0043/src/diff.c	2016-08-29 22:42:20.000000000 +0200
--- src/diff.c	2016-10-18 14:48:59.700247046 +0200
***************
*** 1100,1109 ****
  		if (bufref_valid(&old_curbuf))
  		    /* Move the cursor position to that of the old window. */
  		    curwin->w_cursor.lnum = diff_get_corresponding_line(
! 			    old_curbuf.br_buf,
! 			    old_curwin->w_cursor.lnum,
! 			    curbuf,
! 			    curwin->w_cursor.lnum);
  	    }
  	    /* Now that lines are folded scroll to show the cursor at the same
  	     * relative position. */
--- 1100,1106 ----
  		if (bufref_valid(&old_curbuf))
  		    /* Move the cursor position to that of the old window. */
  		    curwin->w_cursor.lnum = diff_get_corresponding_line(
! 			    old_curbuf.br_buf, old_curwin->w_cursor.lnum);
  	    }
  	    /* Now that lines are folded scroll to show the cursor at the same
  	     * relative position. */
***************
*** 2524,2544 ****
      return OK;
  }
  
!     linenr_T
! diff_get_corresponding_line(
      buf_T	*buf1,
!     linenr_T	lnum1,
!     buf_T	*buf2,
!     linenr_T	lnum3)
  {
      int		idx1;
      int		idx2;
      diff_T	*dp;
      int		baseline = 0;
-     linenr_T	lnum2;
  
      idx1 = diff_buf_idx(buf1);
!     idx2 = diff_buf_idx(buf2);
      if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)
  	return lnum1;
  
--- 2521,2542 ----
      return OK;
  }
  
! /*
!  * Return the line number in the current window that is closest to "lnum1" in
!  * "buf1" in diff mode.
!  */
!     static linenr_T
! diff_get_corresponding_line_int(
      buf_T	*buf1,
!     linenr_T	lnum1)
  {
      int		idx1;
      int		idx2;
      diff_T	*dp;
      int		baseline = 0;
  
      idx1 = diff_buf_idx(buf1);
!     idx2 = diff_buf_idx(curbuf);
      if (idx1 == DB_COUNT || idx2 == DB_COUNT || curtab->tp_first_diff == NULL)
  	return lnum1;
  
***************
*** 2551,2565 ****
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
      {
  	if (dp->df_lnum[idx1] > lnum1)
! 	{
! 	    lnum2 = lnum1 - baseline;
! 	    /* don't end up past the end of the file */
! 	    if (lnum2 > buf2->b_ml.ml_line_count)
! 		lnum2 = buf2->b_ml.ml_line_count;
! 
! 	    return lnum2;
! 	}
! 	else if ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)
  	{
  	    /* Inside the diffblock */
  	    baseline = lnum1 - dp->df_lnum[idx1];
--- 2549,2556 ----
      for (dp = curtab->tp_first_diff; dp != NULL; dp = dp->df_next)
      {
  	if (dp->df_lnum[idx1] > lnum1)
! 	    return lnum1 - baseline;
! 	if ((dp->df_lnum[idx1] + dp->df_count[idx1]) > lnum1)
  	{
  	    /* Inside the diffblock */
  	    baseline = lnum1 - dp->df_lnum[idx1];
***************
*** 2568,2577 ****
  
  	    return dp->df_lnum[idx2] + baseline;
  	}
! 	else if (   (dp->df_lnum[idx1] == lnum1)
! 		 && (dp->df_count[idx1] == 0)
! 		 && (dp->df_lnum[idx2] <= lnum3)
! 		 && ((dp->df_lnum[idx2] + dp->df_count[idx2]) > lnum3))
  	    /*
  	     * Special case: if the cursor is just after a zero-count
  	     * block (i.e. all filler) and the target cursor is already
--- 2559,2569 ----
  
  	    return dp->df_lnum[idx2] + baseline;
  	}
! 	if (    (dp->df_lnum[idx1] == lnum1)
! 	     && (dp->df_count[idx1] == 0)
! 	     && (dp->df_lnum[idx2] <= curwin->w_cursor.lnum)
! 	     && ((dp->df_lnum[idx2] + dp->df_count[idx2])
! 						      > curwin->w_cursor.lnum))
  	    /*
  	     * Special case: if the cursor is just after a zero-count
  	     * block (i.e. all filler) and the target cursor is already
***************
*** 2579,2596 ****
  	     * unmoved. This makes repeated CTRL-W W operations work
  	     * as expected.
  	     */
! 	    return lnum3;
  	baseline = (dp->df_lnum[idx1] + dp->df_count[idx1])
  				   - (dp->df_lnum[idx2] + dp->df_count[idx2]);
      }
  
      /* If we get here then the cursor is after the last diff */
!     lnum2 = lnum1 - baseline;
!     /* don't end up past the end of the file */
!     if (lnum2 > buf2->b_ml.ml_line_count)
! 	lnum2 = buf2->b_ml.ml_line_count;
  
!     return lnum2;
  }
  
  #if defined(FEAT_FOLDING) || defined(PROTO)
--- 2571,2598 ----
  	     * unmoved. This makes repeated CTRL-W W operations work
  	     * as expected.
  	     */
! 	    return curwin->w_cursor.lnum;
  	baseline = (dp->df_lnum[idx1] + dp->df_count[idx1])
  				   - (dp->df_lnum[idx2] + dp->df_count[idx2]);
      }
  
      /* If we get here then the cursor is after the last diff */
!     return lnum1 - baseline;
! }
  
! /*
!  * Return the line number in the current window that is closest to "lnum1" in
!  * "buf1" in diff mode.  Checks the line number to be valid.
!  */
!     linenr_T
! diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1)
! {
!     linenr_T lnum = diff_get_corresponding_line_int(buf1, lnum1);
! 
!     /* don't end up past the end of the file */
!     if (lnum > curbuf->b_ml.ml_line_count)
! 	return curbuf->b_ml.ml_line_count;
!     return lnum;
  }
  
  #if defined(FEAT_FOLDING) || defined(PROTO)
*** ../vim-8.0.0043/src/proto/diff.pro	2016-09-12 13:03:59.000000000 +0200
--- src/proto/diff.pro	2016-10-18 14:30:25.208461191 +0200
***************
*** 22,27 ****
  void ex_diffgetput(exarg_T *eap);
  int diff_mode_buf(buf_T *buf);
  int diff_move_to(int dir, long count);
! linenr_T diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1, buf_T *buf2, linenr_T lnum3);
  linenr_T diff_lnum_win(linenr_T lnum, win_T *wp);
  /* vim: set ft=c : */
--- 22,27 ----
  void ex_diffgetput(exarg_T *eap);
  int diff_mode_buf(buf_T *buf);
  int diff_move_to(int dir, long count);
! linenr_T diff_get_corresponding_line(buf_T *buf1, linenr_T lnum1);
  linenr_T diff_lnum_win(linenr_T lnum, win_T *wp);
  /* vim: set ft=c : */
*** ../vim-8.0.0043/src/testdir/test_diffmode.vim	2016-08-27 22:20:56.000000000 +0200
--- src/testdir/test_diffmode.vim	2016-10-18 14:48:01.108678884 +0200
***************
*** 218,220 ****
--- 218,237 ----
    bwipe!
    bwipe!
  endfunc
+ 
+ func Test_setting_cursor()
+   new Xtest1
+   put =range(1,90)
+   wq
+   new Xtest2
+   put =range(1,100)
+   wq
+   
+   tabe Xtest2
+   $
+   diffsp Xtest1
+   tabclose
+ 
+   call delete('Xtest1')
+   call delete('Xtest2')
+ endfunc
*** ../vim-8.0.0043/src/version.c	2016-10-18 13:06:33.377547323 +0200
--- src/version.c	2016-10-18 14:28:23.337359418 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     44,
  /**/

-- 
Zen Microsystems: we're the om in .commmmmmmmm

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0045
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0045
Problem:    Calling job_stop() right after job_start() does not work.
Solution:   Block signals while fork is still busy. (Ozaki Kiichi, closes
            #1155)
Files:      src/auto/configure, src/config.h.in, src/configure.in,
            src/os_unix.c, src/testdir/test_channel.vim


*** ../vim-8.0.0044/src/auto/configure	2016-08-14 17:30:13.000000000 +0200
--- src/auto/configure	2016-10-18 15:38:10.274500411 +0200
***************
*** 12004,12010 ****
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
  do :
--- 12004,12010 ----
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes
  do :
*** ../vim-8.0.0044/src/config.h.in	2016-04-24 14:48:57.000000000 +0200
--- src/config.h.in	2016-10-18 15:38:10.274500411 +0200
***************
*** 190,195 ****
--- 190,196 ----
  #undef HAVE_SIGSET
  #undef HAVE_SIGSETJMP
  #undef HAVE_SIGSTACK
+ #undef HAVE_SIGPROCMASK
  #undef HAVE_SIGVEC
  #undef HAVE_SMACK
  #undef HAVE_STRCASECMP
*** ../vim-8.0.0044/src/configure.in	2016-08-14 17:30:09.000000000 +0200
--- src/configure.in	2016-10-18 15:38:10.274500411 +0200
***************
*** 3598,3604 ****
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
  AC_FUNC_FSEEKO
--- 3598,3604 ----
  	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
  	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
  	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
! 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
  	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
  	usleep utime utimes)
  AC_FUNC_FSEEKO
*** ../vim-8.0.0044/src/os_unix.c	2016-10-15 18:36:45.349910306 +0200
--- src/os_unix.c	2016-10-18 16:27:09.580836824 +0200
***************
*** 211,216 ****
--- 211,225 ----
  static void catch_int_signal(void);
  static void set_signals(void);
  static void catch_signals(RETSIGTYPE (*func_deadly)(), RETSIGTYPE (*func_other)());
+ #ifdef HAVE_SIGPROCMASK
+ # define SIGSET_DECL(set)	sigset_t set;
+ # define BLOCK_SIGNALS(set)	block_signals(set)
+ # define UNBLOCK_SIGNALS(set)	unblock_signals(set)
+ #else
+ # define SIGSET_DECL(set)
+ # define BLOCK_SIGNALS(set)	do { /**/ } while (0)
+ # define UNBLOCK_SIGNALS(set)	do { /**/ } while (0)
+ #endif
  static int  have_wildcard(int, char_u **);
  static int  have_dollars(int, char_u **);
  
***************
*** 1468,1473 ****
--- 1477,1509 ----
  	    signal(signal_info[i].sig, func_other);
  }
  
+ #ifdef HAVE_SIGPROCMASK
+     static void
+ block_signals(sigset_t *set)
+ {
+     sigset_t	newset;
+     int		i;
+ 
+     sigemptyset(&newset);
+ 
+     for (i = 0; signal_info[i].sig != -1; i++)
+ 	sigaddset(&newset, signal_info[i].sig);
+ 
+ # if defined(_REENTRANT) && defined(SIGCONT)
+     /* SIGCONT isn't in the list, because its default action is ignore */
+     sigaddset(&newset, SIGCONT);
+ # endif
+ 
+     sigprocmask(SIG_BLOCK, &newset, set);
+ }
+ 
+     static void
+ unblock_signals(sigset_t *set)
+ {
+     sigprocmask(SIG_SETMASK, set, NULL);
+ }
+ #endif
+ 
  /*
   * Handling of SIGHUP, SIGQUIT and SIGTERM:
   * "when" == a signal:       when busy, postpone and return FALSE, otherwise
***************
*** 4283,4294 ****
  
      if (!pipe_error)			/* pty or pipe opened or not used */
      {
  # ifdef __BEOS__
  	beos_cleanup_read_thread();
  # endif
  
! 	if ((pid = fork()) == -1)	/* maybe we should use vfork() */
  	{
  	    MSG_PUTS(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
--- 4319,4336 ----
  
      if (!pipe_error)			/* pty or pipe opened or not used */
      {
+ 	SIGSET_DECL(curset)
+ 
  # ifdef __BEOS__
  	beos_cleanup_read_thread();
  # endif
  
! 	BLOCK_SIGNALS(&curset);
! 	pid = fork();	/* maybe we should use vfork() */
! 	if (pid == -1)
  	{
+ 	    UNBLOCK_SIGNALS(&curset);
+ 
  	    MSG_PUTS(_("\nCannot fork\n"));
  	    if ((options & (SHELL_READ|SHELL_WRITE))
  # ifdef FEAT_GUI
***************
*** 4315,4320 ****
--- 4357,4363 ----
  	else if (pid == 0)	/* child */
  	{
  	    reset_signals();		/* handle signals normally */
+ 	    UNBLOCK_SIGNALS(&curset);
  
  	    if (!show_shell_mess || (options & SHELL_EXPAND))
  	    {
***************
*** 4458,4463 ****
--- 4501,4507 ----
  	     */
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
+ 	    UNBLOCK_SIGNALS(&curset);
  
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
***************
*** 5069,5074 ****
--- 5113,5119 ----
      int		use_file_for_out = options->jo_io[PART_OUT] == JIO_FILE;
      int		use_file_for_err = options->jo_io[PART_ERR] == JIO_FILE;
      int		use_out_for_err = options->jo_io[PART_ERR] == JIO_OUT;
+     SIGSET_DECL(curset)
  
      if (use_out_for_err && use_null_for_out)
  	use_null_for_err = TRUE;
***************
*** 5140,5152 ****
  	    goto failed;
      }
  
      pid = fork();	/* maybe we should use vfork() */
!     if (pid  == -1)
      {
  	/* failed to fork */
  	goto failed;
      }
- 
      if (pid == 0)
      {
  	int	null_fd = -1;
--- 5185,5198 ----
  	    goto failed;
      }
  
+     BLOCK_SIGNALS(&curset);
      pid = fork();	/* maybe we should use vfork() */
!     if (pid == -1)
      {
  	/* failed to fork */
+ 	UNBLOCK_SIGNALS(&curset);
  	goto failed;
      }
      if (pid == 0)
      {
  	int	null_fd = -1;
***************
*** 5154,5159 ****
--- 5200,5206 ----
  
  	/* child */
  	reset_signals();		/* handle signals normally */
+ 	UNBLOCK_SIGNALS(&curset);
  
  # ifdef HAVE_SETSID
  	/* Create our own process group, so that the child and all its
***************
*** 5234,5239 ****
--- 5281,5288 ----
      }
  
      /* parent */
+     UNBLOCK_SIGNALS(&curset);
+ 
      job->jv_pid = pid;
      job->jv_status = JOB_STARTED;
      job->jv_channel = channel;  /* ch_refcount was set above */
***************
*** 5357,5363 ****
  	}
      }
      return NULL;
- 
  }
  
      int
--- 5406,5411 ----
*** ../vim-8.0.0044/src/testdir/test_channel.vim	2016-10-15 18:36:45.353910276 +0200
--- src/testdir/test_channel.vim	2016-10-18 15:38:10.274500411 +0200
***************
*** 1433,1438 ****
--- 1433,1453 ----
    call assert_fails('call job_start("")', 'E474:')
  endfunc
  
+ func Test_job_stop_immediately()
+   if !has('job')
+     return
+   endif
+ 
+   let job = job_start([s:python, '-c', 'import time;time.sleep(10)'])
+   try
+     call job_stop(job)
+     call WaitFor('"dead" == job_status(job)')
+     call assert_equal('dead', job_status(job))
+   finally
+     call job_stop(job, 'kill')
+   endtry
+ endfunc
+ 
  " This was leaking memory.
  func Test_partial_in_channel_cycle()
    let d = {}
*** ../vim-8.0.0044/src/version.c	2016-10-18 14:50:14.731694041 +0200
--- src/version.c	2016-10-18 16:25:17.693661467 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     45,
  /**/

-- 
Females are strictly forbidden to appear unshaven in public.
		[real standing law in New Mexico, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0046
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0046
Problem:    Using NUL instead of NULL.
Solution:   Change to NULL. (Dominique Pelle)
Files:      src/ex_cmds.c, src/json.c


*** ../vim-8.0.0045/src/ex_cmds.c	2016-10-12 14:19:55.742357780 +0200
--- src/ex_cmds.c	2016-10-21 20:33:45.713617892 +0200
***************
*** 6908,6914 ****
  				    continue;
  				e1 = vim_strrchr(t1, '.');
  				e2 = vim_strrchr(gettail(f2), '.');
! 				if (e1 == NUL || e2 == NUL)
  				    continue;
  				if (fnamecmp(e1, ".txt") != 0
  				    && fnamecmp(e1, fname + 4) != 0)
--- 6908,6914 ----
  				    continue;
  				e1 = vim_strrchr(t1, '.');
  				e2 = vim_strrchr(gettail(f2), '.');
! 				if (e1 == NULL || e2 == NULL)
  				    continue;
  				if (fnamecmp(e1, ".txt") != 0
  				    && fnamecmp(e1, fname + 4) != 0)
***************
*** 8205,8211 ****
      /* :sign define {name} {args}... {last}=
       *				     |	   |
       *				  last	   p */
!     if (p == NUL)
      {
  	/* Expand last argument name (before equal sign). */
  	xp->xp_pattern = last;
--- 8205,8211 ----
      /* :sign define {name} {args}... {last}=
       *				     |	   |
       *				  last	   p */
!     if (p == NULL)
      {
  	/* Expand last argument name (before equal sign). */
  	xp->xp_pattern = last;
*** ../vim-8.0.0045/src/json.c	2016-08-29 22:42:20.000000000 +0200
--- src/json.c	2016-10-21 20:33:45.717617866 +0200
***************
*** 861,867 ****
  	    break;
      }
  
!     if (res != NUL)
      {
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
--- 861,867 ----
  	    break;
      }
  
!     if (res != NULL)
      {
  	res->v_type = VAR_SPECIAL;
  	res->vval.v_number = VVAL_NONE;
*** ../vim-8.0.0045/src/version.c	2016-10-18 16:27:20.544756017 +0200
--- src/version.c	2016-10-21 20:34:37.841288951 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     46,
  /**/

-- 
"I love deadlines.  I especially like the whooshing sound they
make as they go flying by."
                         -- Douglas Adams

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0047
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0047
Problem:    Crash when using the preview window from an unnamed buffer.
            (lifepillar)
Solution:   Do not clear the wrong buffer. (closes #1200)
Files:      src/popupmnu.c


*** ../vim-8.0.0046/src/popupmnu.c	2016-08-29 22:42:20.000000000 +0200
--- src/popupmnu.c	2016-10-27 14:29:30.530187340 +0200
***************
*** 582,588 ****
  
  	    if (curwin->w_p_pvw)
  	    {
! 		if (curbuf->b_fname == NULL
  			&& curbuf->b_p_bt[0] == 'n' && curbuf->b_p_bt[2] == 'f'
  			&& curbuf->b_p_bh[0] == 'w')
  		{
--- 582,590 ----
  
  	    if (curwin->w_p_pvw)
  	    {
! 		if (!resized
! 			&& curbuf->b_nwindows == 1
! 			&& curbuf->b_fname == NULL
  			&& curbuf->b_p_bt[0] == 'n' && curbuf->b_p_bt[2] == 'f'
  			&& curbuf->b_p_bh[0] == 'w')
  		{
*** ../vim-8.0.0046/src/version.c	2016-10-21 20:35:32.632943225 +0200
--- src/version.c	2016-10-27 14:48:11.623357275 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     47,
  /**/

-- 
"I've been teaching myself to play the piano for about 5 years and now write
most of my songs on it, mainly because I can never find any paper."
		Jeff Lynne, ELO's greatest hits

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0048
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0048
Problem:    On Windows job_stop() stops cmd.exe, not the processes it runs.
            (Linwei)
Solution:   Iterate over all processes and terminate the one where the parent
            is the job process. (Yasuhiro Matsumoto, closes #1184)
Files:      src/os_win32.c, src/structs.h


*** ../vim-8.0.0047/src/os_win32.c	2016-10-15 18:36:45.353910276 +0200
--- src/os_win32.c	2016-10-27 16:42:55.597417857 +0200
***************
*** 50,55 ****
--- 50,59 ----
  # endif
  #endif
  
+ #ifdef FEAT_JOB_CHANNEL
+ # include <tlhelp32.h>
+ #endif
+ 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
***************
*** 4796,4802 ****
  {
      STARTUPINFO		si;
      PROCESS_INFORMATION	pi;
-     HANDLE		jo;
      SECURITY_ATTRIBUTES saAttr;
      channel_T		*channel = NULL;
      HANDLE		ifd[2];
--- 4800,4805 ----
***************
*** 4821,4833 ****
      efd[0] = INVALID_HANDLE_VALUE;
      efd[1] = INVALID_HANDLE_VALUE;
  
-     jo = CreateJobObject(NULL, NULL);
-     if (jo == NULL)
-     {
- 	job->jv_status = JOB_FAILED;
- 	goto failed;
-     }
- 
      ZeroMemory(&pi, sizeof(pi));
      ZeroMemory(&si, sizeof(si));
      si.cb = sizeof(si);
--- 4824,4829 ----
***************
*** 4912,4939 ****
      }
  
      if (!vim_create_process(cmd, TRUE,
- 	    CREATE_SUSPENDED |
  	    CREATE_DEFAULT_ERROR_MODE |
  	    CREATE_NEW_PROCESS_GROUP |
  	    CREATE_NEW_CONSOLE,
  	    &si, &pi))
      {
- 	CloseHandle(jo);
  	job->jv_status = JOB_FAILED;
  	goto failed;
      }
  
-     if (!AssignProcessToJobObject(jo, pi.hProcess))
-     {
- 	/* if failing, switch the way to terminate
- 	 * process with TerminateProcess. */
- 	CloseHandle(jo);
- 	jo = NULL;
-     }
-     ResumeThread(pi.hThread);
      CloseHandle(pi.hThread);
      job->jv_proc_info = pi;
-     job->jv_job_object = jo;
      job->jv_status = JOB_STARTED;
  
      CloseHandle(ifd[0]);
--- 4908,4924 ----
***************
*** 5020,5025 ****
--- 5005,5048 ----
      return NULL;
  }
  
+     static BOOL
+ terminate_all(HANDLE process, int code)
+ {
+     PROCESSENTRY32  pe;
+     HANDLE	    h = INVALID_HANDLE_VALUE;
+     DWORD	    pid = GetProcessId(process);
+ 
+     if (pid != 0)
+     {
+ 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+ 	if (h == INVALID_HANDLE_VALUE)
+ 	    goto theend;
+ 
+ 	pe.dwSize = sizeof(PROCESSENTRY32);
+ 	if (Process32First(h, &pe))
+ 	{
+ 	    do
+ 	    {
+ 		if (pe.th32ParentProcessID == pid)
+ 		{
+ 		    HANDLE ph = OpenProcess(
+ 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
+ 		    if (ph != NULL)
+ 		    {
+ 			terminate_all(ph, code);
+ 			CloseHandle(ph);
+ 		    }
+ 		}
+ 	    } while (Process32Next(h, &pe));
+ 	}
+ 
+ 	CloseHandle(h);
+     }
+ 
+ theend:
+     return TerminateProcess(process, code);
+ }
+ 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
***************
*** 5027,5036 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	if (job->jv_job_object != NULL)
! 	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5050,5056 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
***************
*** 5051,5058 ****
  {
      if (job->jv_status != JOB_FAILED)
      {
- 	if (job->jv_job_object != NULL)
- 	    CloseHandle(job->jv_job_object);
  	CloseHandle(job->jv_proc_info.hProcess);
      }
  }
--- 5071,5076 ----
*** ../vim-8.0.0047/src/structs.h	2016-10-09 17:27:56.863388510 +0200
--- src/structs.h	2016-10-27 16:36:49.151650364 +0200
***************
*** 1437,1443 ****
  #endif
  #ifdef WIN32
      PROCESS_INFORMATION	jv_proc_info;
-     HANDLE		jv_job_object;
  #endif
      jobstatus_T	jv_status;
      char_u	*jv_stoponexit; /* allocated */
--- 1437,1442 ----
*** ../vim-8.0.0047/src/version.c	2016-10-27 14:49:11.022995393 +0200
--- src/version.c	2016-10-27 16:38:42.722958450 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     48,
  /**/

-- 
FIRST SOLDIER:  So they wouldn't be able to bring a coconut back anyway.
SECOND SOLDIER: Wait a minute! Suppose two swallows carried it together?
FIRST SOLDIER:  No, they'd have to have it on a line.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0049
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0049
Problem:    When a match ends in part of concealed text highlighting, it might
            mess up concealing by resetting prev_syntax_id.
Solution:   Do not reset prev_syntax_id and add a test to verify. (Christian
            Brabandt, closes #1092)
Files:      src/screen.c, src/testdir/test_matchadd_conceal.vim


*** ../vim-8.0.0048/src/screen.c	2016-10-16 14:35:44.543696445 +0200
--- src/screen.c	2016-10-27 17:26:54.065343448 +0200
***************
*** 3981,3989 ****
  			else if (v == (long)shl->endcol)
  			{
  			    shl->attr_cur = 0;
- #ifdef FEAT_CONCEAL
- 			    prev_syntax_id = 0;
- #endif
  			    next_search_hl(wp, shl, lnum, (colnr_T)v,
  					       shl == &search_hl ? NULL : cur);
  			    pos_inprogress = cur == NULL || cur->pos.cur == 0
--- 3981,3986 ----
*** ../vim-8.0.0048/src/testdir/test_matchadd_conceal.vim	2016-04-14 17:59:07.000000000 +0200
--- src/testdir/test_matchadd_conceal.vim	2016-10-27 17:20:24.939714129 +0200
***************
*** 264,266 ****
--- 264,288 ----
  
    quit!
  endfunction
+ 
+ function! Test_matchadd_and_syn_conceal()
+   new
+   let cnt='Inductive bool : Type := | true : bool | false : bool.'
+   let expect = 'Inductive - : Type := | true : - | false : -.'
+   0put =cnt
+   " set filetype and :syntax on to change screenattr()
+   set cole=1 cocu=nv
+   hi link CheckedByCoq WarningMsg
+   syntax on
+   syntax keyword coqKwd bool conceal cchar=-
+   redraw!
+   call assert_equal(expect, s:screenline(1))
+   call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
+   call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
+   call assert_equal(screenattr(1, 11) , screenattr(1, 32))
+   call matchadd('CheckedByCoq', '\%<2l\%>9c\%<16c')
+   call assert_equal(expect, s:screenline(1))
+   call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
+   call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
+   call assert_equal(screenattr(1, 11) , screenattr(1, 32))
+ endfunction
*** ../vim-8.0.0048/src/version.c	2016-10-27 16:46:49.423993309 +0200
--- src/version.c	2016-10-27 17:20:49.627563722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     49,
  /**/

-- 
If you don't get everything you want, think of
everything you didn't get and don't want.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0050
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0050
Problem:    An exiting job is detected with a large latency.
Solution:   Check for pending job more often. (Ozaki Kiichi)  Change the
            double loop in mch_inchar() into one.
Files:      src/channel.c, src/os_unix.c, src/testdir/shared.vim,
            src/testdir/test_channel.vim


*** ../vim-8.0.0049/src/channel.c	2016-10-15 18:36:45.341910365 +0200
--- src/channel.c	2016-10-27 19:49:15.597305647 +0200
***************
*** 4643,4650 ****
  }
  
  /*
!  * Return TRUE when there is any job that might exit, which means
!  * job_check_ended() should be called once in a while.
   */
      int
  has_pending_job(void)
--- 4643,4650 ----
  }
  
  /*
!  * Return TRUE when there is any job that has an exit callback and might exit,
!  * which means job_check_ended() should be called more often.
   */
      int
  has_pending_job(void)
***************
*** 4652,4658 ****
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	    return TRUE;
      return FALSE;
  }
--- 4652,4662 ----
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	/* Only should check if the channel has been closed, if the channel is
! 	 * open the job won't exit. */
! 	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 		&& (job->jv_channel == NULL
! 		    || !channel_still_useful(job->jv_channel)))
  	    return TRUE;
      return FALSE;
  }
*** ../vim-8.0.0049/src/os_unix.c	2016-10-18 16:27:20.544756017 +0200
--- src/os_unix.c	2016-10-27 19:43:31.019404929 +0200
***************
*** 404,542 ****
  {
      int		len;
      int		interrupted = FALSE;
      long	wait_time;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
      struct timeval  start_tv;
  
      gettimeofday(&start_tv, NULL);
  #endif
  
! #ifdef MESSAGE_QUEUE
!     parse_queued_messages();
! #endif
! 
!     /* Check if window changed size while we were busy, perhaps the ":set
!      * columns=99" command was used. */
!     while (do_resize)
! 	handle_resize();
! 
      for (;;)
      {
! 	if (wtime >= 0)
! 	    wait_time = wtime;
! 	else
! 	    wait_time = p_ut;
! #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	wait_time -= elapsed(&start_tv);
! 	if (wait_time >= 0)
! 	{
! #endif
! 	    if (WaitForChar(wait_time, &interrupted))
! 		break;
  
- 	    /* no character available */
- 	    if (do_resize)
- 	    {
- 		handle_resize();
- 		continue;
- 	    }
- #ifdef FEAT_CLIENTSERVER
- 	    if (server_waiting())
- 	    {
- 		parse_queued_messages();
- 		continue;
- 	    }
- #endif
  #ifdef MESSAGE_QUEUE
! 	    if (interrupted)
! 	    {
! 		parse_queued_messages();
! 		continue;
! 	    }
  #endif
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	}
  #endif
! 	if (wtime >= 0)
! 	    /* no character available within "wtime" */
! 	    return 0;
! 
! 	/* wtime == -1: no character available within 'updatetime' */
  #ifdef FEAT_AUTOCMD
! 	if (trigger_cursorhold() && maxlen >= 3
! 					   && !typebuf_changed(tb_change_cnt))
! 	{
! 	    buf[0] = K_SPECIAL;
! 	    buf[1] = KS_EXTRA;
! 	    buf[2] = (int)KE_CURSORHOLD;
! 	    return 3;
  	}
- #endif
- 	/*
- 	 * If there is no character available within 'updatetime' seconds
- 	 * flush all the swap files to disk.
- 	 * Also done when interrupted by SIGWINCH.
- 	 */
- 	before_blocking();
- 	break;
-     }
- 
-     /* repeat until we got a character */
-     for (;;)
-     {
- 	long	wtime_now = -1L;
- 
- 	while (do_resize)    /* window changed size */
- 	    handle_resize();
- 
- #ifdef MESSAGE_QUEUE
- 	parse_queued_messages();
  
! # ifdef FEAT_JOB_CHANNEL
! 	if (has_pending_job())
! 	{
! 	    /* Don't wait longer than a few seconds, checking for a finished
! 	     * job requires polling. */
! 	    if (p_ut > 9000L)
! 		wtime_now = 1000L;
! 	    else
! 		wtime_now = 10000L - p_ut;
! 	}
! # endif
  #endif
  	/*
  	 * We want to be interrupted by the winch signal
  	 * or by an event on the monitored file descriptors.
  	 */
! 	if (!WaitForChar(wtime_now, &interrupted))
  	{
! 	    if (do_resize)	    /* interrupted by SIGWINCH signal */
! 		continue;
! #ifdef MESSAGE_QUEUE
! 	    if (interrupted || wtime_now > 0)
! 	    {
! 		parse_queued_messages();
! 		continue;
! 	    }
! #endif
! 	    return 0;
  	}
  
! 	/* If input was put directly in typeahead buffer bail out here. */
! 	if (typebuf_changed(tb_change_cnt))
! 	    return 0;
  
! 	/*
! 	 * For some terminals we only get one character at a time.
! 	 * We want the get all available characters, so we could keep on
! 	 * trying until none is available
! 	 * For some other terminals this is quite slow, that's why we don't do
! 	 * it.
! 	 */
! 	len = read_from_input_buf(buf, (long)maxlen);
! 	if (len > 0)
! 	    return len;
      }
  }
  
      static void
--- 404,524 ----
  {
      int		len;
      int		interrupted = FALSE;
+     int		did_start_blocking = FALSE;
      long	wait_time;
+     long	elapsed_time = 0;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
      struct timeval  start_tv;
  
      gettimeofday(&start_tv, NULL);
  #endif
  
!     /* repeat until we got a character or waited long enough */
      for (;;)
      {
! 	/* Check if window changed size while we were busy, perhaps the ":set
! 	 * columns=99" command was used. */
! 	while (do_resize)
! 	    handle_resize();
  
  #ifdef MESSAGE_QUEUE
! 	parse_queued_messages();
  #endif
+ 	if (wtime < 0 && did_start_blocking)
+ 	    /* blocking and already waited for p_ut */
+ 	    wait_time = -1;
+ 	else
+ 	{
+ 	    if (wtime >= 0)
+ 		wait_time = wtime;
+ 	    else
+ 		/* going to block after p_ut */
+ 		wait_time = p_ut;
  #if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
! 	    elapsed_time = elapsed(&start_tv);
  #endif
! 	    wait_time -= elapsed_time;
! 	    if (wait_time < 0)
! 	    {
! 		if (wtime >= 0)
! 		    /* no character available within "wtime" */
! 		    return 0;
! 
! 		if (wtime < 0)
! 		{
! 		    /* no character available within 'updatetime' */
! 		    did_start_blocking = TRUE;
  #ifdef FEAT_AUTOCMD
! 		    if (trigger_cursorhold() && maxlen >= 3
! 					    && !typebuf_changed(tb_change_cnt))
! 		    {
! 			buf[0] = K_SPECIAL;
! 			buf[1] = KS_EXTRA;
! 			buf[2] = (int)KE_CURSORHOLD;
! 			return 3;
! 		    }
! #endif
! 		    /*
! 		     * If there is no character available within 'updatetime'
! 		     * seconds flush all the swap files to disk.
! 		     * Also done when interrupted by SIGWINCH.
! 		     */
! 		    before_blocking();
! 		    continue;
! 		}
! 	    }
  	}
  
! #ifdef FEAT_JOB_CHANNEL
! 	/* Checking if a job ended requires polling.  Do this every 100 msec. */
! 	if (has_pending_job() && (wait_time < 0 || wait_time > 100L))
! 	    wait_time = 100L;
  #endif
+ 
  	/*
  	 * We want to be interrupted by the winch signal
  	 * or by an event on the monitored file descriptors.
  	 */
! 	if (WaitForChar(wait_time, &interrupted))
  	{
! 	    /* If input was put directly in typeahead buffer bail out here. */
! 	    if (typebuf_changed(tb_change_cnt))
! 		return 0;
! 
! 	    /*
! 	     * For some terminals we only get one character at a time.
! 	     * We want the get all available characters, so we could keep on
! 	     * trying until none is available
! 	     * For some other terminals this is quite slow, that's why we don't
! 	     * do it.
! 	     */
! 	    len = read_from_input_buf(buf, (long)maxlen);
! 	    if (len > 0)
! 		return len;
! 	    continue;
  	}
  
! 	/* no character available */
! #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
! 	/* estimate the elapsed time */
! 	elapsed += wait_time;
! #endif
  
! 	if (do_resize	    /* interrupted by SIGWINCH signal */
! #ifdef FEAT_CLIENTSERVER
! 		|| server_waiting()
! #endif
! #ifdef MESSAGE_QUEUE
! 		|| interrupted
! #endif
! 		|| wait_time > 0
! 		|| !did_start_blocking)
! 	    continue;
! 
! 	/* no character available or interrupted */
! 	break;
      }
+     return 0;
  }
  
      static void
*** ../vim-8.0.0049/src/testdir/shared.vim	2016-08-22 21:30:05.000000000 +0200
--- src/testdir/shared.vim	2016-10-27 19:51:53.040346452 +0200
***************
*** 136,141 ****
--- 136,169 ----
    return 1000
  endfunc
  
+ " Wait for up to a given milliseconds.
+ " With the +timers feature this waits for key-input by getchar(), Resume()
+ " feeds key-input and resumes process. Return time waited in milliseconds.
+ " Without +timers it uses simply :sleep.
+ func Standby(msec)
+   if has('timers')
+     let start = reltime()
+     let g:_standby_timer = timer_start(a:msec, function('s:feedkeys'))
+     call getchar()
+     return float2nr(reltimefloat(reltime(start)) * 1000)
+   else
+     execute 'sleep ' a:msec . 'm'
+     return a:msec
+   endif
+ endfunc
+ 
+ func Resume()
+   if exists('g:_standby_timer')
+     call timer_stop(g:_standby_timer)
+     call s:feedkeys(0)
+     unlet g:_standby_timer
+   endif
+ endfunc
+ 
+ func s:feedkeys(timer)
+   call feedkeys('x', 'nt')
+ endfunc
+ 
  " Run Vim, using the "vimcmd" file and "-u NORC".
  " "before" is a list of Vim commands to be executed before loading plugins.
  " "after" is a list of Vim commands to be executed after loading plugins.
*** ../vim-8.0.0049/src/testdir/test_channel.vim	2016-10-18 16:27:20.544756017 +0200
--- src/testdir/test_channel.vim	2016-10-27 18:09:46.713670034 +0200
***************
*** 1362,1370 ****
    endif
  endfunc
  
- let g:exit_cb_time = {'start': 0, 'end': 0}
  function MyExitTimeCb(job, status)
!   let g:exit_cb_time.end = reltime(g:exit_cb_time.start)
  endfunction
  
  func Test_exit_callback_interval()
--- 1362,1372 ----
    endif
  endfunc
  
  function MyExitTimeCb(job, status)
!   if job_info(a:job).process == g:exit_cb_val.process
!     let g:exit_cb_val.end = reltime(g:exit_cb_val.start)
!   endif
!   call Resume()
  endfunction
  
  func Test_exit_callback_interval()
***************
*** 1372,1382 ****
      return
    endif
  
!   let g:exit_cb_time.start = reltime()
    let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   call WaitFor('g:exit_cb_time.end != 0')
!   let elapsed = reltimefloat(g:exit_cb_time.end)
!   call assert_true(elapsed > 0.3)
    call assert_true(elapsed < 1.0)
  endfunc
  
--- 1374,1403 ----
      return
    endif
  
!   let g:exit_cb_val = {'start': reltime(), 'end': 0, 'process': 0}
    let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   let g:exit_cb_val.process = job_info(job).process
!   call WaitFor('type(g:exit_cb_val.end) != v:t_number || g:exit_cb_val.end != 0')
!   let elapsed = reltimefloat(g:exit_cb_val.end)
!   call assert_true(elapsed > 0.5)
!   call assert_true(elapsed < 1.0)
! 
!   " case: unreferenced job, using timer
!   if !has('timers')
!     return
!   endif
! 
!   let g:exit_cb_val = {'start': reltime(), 'end': 0, 'process': 0}
!   let g:job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
!   let g:exit_cb_val.process = job_info(g:job).process
!   unlet g:job
!   call Standby(1000)
!   if type(g:exit_cb_val.end) != v:t_number || g:exit_cb_val.end != 0
!     let elapsed = reltimefloat(g:exit_cb_val.end)
!   else
!     let elapsed = 1.0
!   endif
!   call assert_true(elapsed > 0.5)
    call assert_true(elapsed < 1.0)
  endfunc
  
*** ../vim-8.0.0049/src/version.c	2016-10-27 17:27:38.269074145 +0200
--- src/version.c	2016-10-27 19:54:19.827452177 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     50,
  /**/

-- 
CART DRIVER: Bring out your dead!
   We follow the cart through a wretched, impoverished plague-ridden village.
   A few starved mongrels run about in the mud scavenging.  In the open
   doorway of one house perhaps we jug glimpse a pair of legs dangling from
   the ceiling.  In another doorway an OLD WOMAN is beating a cat against a
   wall rather like one does with a mat.  The cart passes round a dead donkey
   or cow in the mud.  And a MAN tied to a cart is being hammered to death by
   four NUNS with huge mallets.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0051
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0051 (after 8.0.0048)
Problem:    New code for job_stop() breaks channel test on AppVeyor.
Solution:   Revert the change.
Files:      src/os_win32.c, src/structs.h


*** ../vim-8.0.0050/src/os_win32.c	2016-10-27 16:46:49.419993332 +0200
--- src/os_win32.c	2016-10-27 21:11:18.235315329 +0200
***************
*** 50,59 ****
  # endif
  #endif
  
- #ifdef FEAT_JOB_CHANNEL
- # include <tlhelp32.h>
- #endif
- 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
--- 50,55 ----
***************
*** 4800,4805 ****
--- 4796,4802 ----
  {
      STARTUPINFO		si;
      PROCESS_INFORMATION	pi;
+     HANDLE		jo;
      SECURITY_ATTRIBUTES saAttr;
      channel_T		*channel = NULL;
      HANDLE		ifd[2];
***************
*** 4824,4829 ****
--- 4821,4833 ----
      efd[0] = INVALID_HANDLE_VALUE;
      efd[1] = INVALID_HANDLE_VALUE;
  
+     jo = CreateJobObject(NULL, NULL);
+     if (jo == NULL)
+     {
+ 	job->jv_status = JOB_FAILED;
+ 	goto failed;
+     }
+ 
      ZeroMemory(&pi, sizeof(pi));
      ZeroMemory(&si, sizeof(si));
      si.cb = sizeof(si);
***************
*** 4908,4924 ****
--- 4912,4939 ----
      }
  
      if (!vim_create_process(cmd, TRUE,
+ 	    CREATE_SUSPENDED |
  	    CREATE_DEFAULT_ERROR_MODE |
  	    CREATE_NEW_PROCESS_GROUP |
  	    CREATE_NEW_CONSOLE,
  	    &si, &pi))
      {
+ 	CloseHandle(jo);
  	job->jv_status = JOB_FAILED;
  	goto failed;
      }
  
+     if (!AssignProcessToJobObject(jo, pi.hProcess))
+     {
+ 	/* if failing, switch the way to terminate
+ 	 * process with TerminateProcess. */
+ 	CloseHandle(jo);
+ 	jo = NULL;
+     }
+     ResumeThread(pi.hThread);
      CloseHandle(pi.hThread);
      job->jv_proc_info = pi;
+     job->jv_job_object = jo;
      job->jv_status = JOB_STARTED;
  
      CloseHandle(ifd[0]);
***************
*** 5005,5048 ****
      return NULL;
  }
  
-     static BOOL
- terminate_all(HANDLE process, int code)
- {
-     PROCESSENTRY32  pe;
-     HANDLE	    h = INVALID_HANDLE_VALUE;
-     DWORD	    pid = GetProcessId(process);
- 
-     if (pid != 0)
-     {
- 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
- 	if (h == INVALID_HANDLE_VALUE)
- 	    goto theend;
- 
- 	pe.dwSize = sizeof(PROCESSENTRY32);
- 	if (Process32First(h, &pe))
- 	{
- 	    do
- 	    {
- 		if (pe.th32ParentProcessID == pid)
- 		{
- 		    HANDLE ph = OpenProcess(
- 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
- 		    if (ph != NULL)
- 		    {
- 			terminate_all(ph, code);
- 			CloseHandle(ph);
- 		    }
- 		}
- 	    } while (Process32Next(h, &pe));
- 	}
- 
- 	CloseHandle(h);
-     }
- 
- theend:
-     return TerminateProcess(process, code);
- }
- 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
--- 5020,5025 ----
***************
*** 5050,5056 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5027,5036 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
! 	if (job->jv_job_object != NULL)
! 	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
***************
*** 5071,5076 ****
--- 5051,5058 ----
  {
      if (job->jv_status != JOB_FAILED)
      {
+ 	if (job->jv_job_object != NULL)
+ 	    CloseHandle(job->jv_job_object);
  	CloseHandle(job->jv_proc_info.hProcess);
      }
  }
*** ../vim-8.0.0050/src/structs.h	2016-10-27 16:46:49.423993309 +0200
--- src/structs.h	2016-10-27 21:11:27.439259254 +0200
***************
*** 1437,1442 ****
--- 1437,1443 ----
  #endif
  #ifdef WIN32
      PROCESS_INFORMATION	jv_proc_info;
+     HANDLE		jv_job_object;
  #endif
      jobstatus_T	jv_status;
      char_u	*jv_stoponexit; /* allocated */
*** ../vim-8.0.0050/src/version.c	2016-10-27 20:00:03.665357405 +0200
--- src/version.c	2016-10-27 21:12:22.526923642 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     51,
  /**/

-- 
BODY:        I'm not dead!
CART DRIVER: 'Ere.  He says he's not dead.
LARGE MAN:   Yes he is.
BODY:        I'm not!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0052
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0052 (after 8.0.0049)
Problem:    Conceal test passes even without the bug fix.
Solution:   Add a redraw command. (Christian Brabandt)
Files:      src/testdir/test_matchadd_conceal.vim


*** ../vim-8.0.0051/src/testdir/test_matchadd_conceal.vim	2016-10-27 17:27:38.265074170 +0200
--- src/testdir/test_matchadd_conceal.vim	2016-10-28 22:06:28.144773262 +0200
***************
*** 281,286 ****
--- 281,287 ----
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
    call assert_equal(screenattr(1, 11) , screenattr(1, 32))
    call matchadd('CheckedByCoq', '\%<2l\%>9c\%<16c')
+   redraw!
    call assert_equal(expect, s:screenline(1))
    call assert_notequal(screenattr(1, 10) , screenattr(1, 11))
    call assert_notequal(screenattr(1, 11) , screenattr(1, 12))
*** ../vim-8.0.0051/src/version.c	2016-10-27 21:13:04.886665573 +0200
--- src/version.c	2016-10-28 22:09:12.539771714 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     52,
  /**/

-- 
"Lisp has all the visual appeal of oatmeal with nail clippings thrown in."
                                                         -- Larry Wall

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0053
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0053 (after 8.0.0047)
Problem:    No test for what 8.0.0047 fixes.
Solution:   Add a test. (Hirohito Higashi)
Files:      src/testdir/test_popup.vim


*** ../vim-8.0.0052/src/testdir/test_popup.vim	2016-10-18 13:06:33.377547323 +0200
--- src/testdir/test_popup.vim	2016-10-29 14:36:20.406936205 +0200
***************
*** 378,384 ****
    endif
  endfunc
  
! " Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
--- 378,384 ----
    endif
  endfunc
  
! " Test that 'omnifunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
***************
*** 437,441 ****
--- 437,467 ----
    q!
  endfunc
  
+ function! DummyCompleteFive(findstart, base)
+   if a:findstart
+     return 0
+   else
+     return [
+           \   { 'word': 'January', 'info': "info1-1\n1-2\n1-3" },
+           \   { 'word': 'February', 'info': "info2-1\n2-2\n2-3" },
+           \   { 'word': 'March', 'info': "info3-1\n3-2\n3-3" },
+           \   { 'word': 'April', 'info': "info4-1\n4-2\n4-3" },
+           \   { 'word': 'May', 'info': "info5-1\n5-2\n5-3" },
+           \ ]
+   endif
+ endfunc
+ 
+ " Test that 'completefunc' on Scratch buffer with preview window works when
+ " it's OK.
+ func Test_completefunc_with_scratch_buffer()
+   new +setlocal\ buftype=nofile\ bufhidden=wipe\ noswapfile
+   set completeopt+=preview
+   setlocal completefunc=DummyCompleteFive
+   call feedkeys("A\<C-X>\<C-U>\<C-N>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal(['April'], getline(1, '$'))
+   pclose
+   q!
+   set completeopt&
+ endfunc
  
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0052/src/version.c	2016-10-28 22:10:22.775343816 +0200
--- src/version.c	2016-10-29 14:37:30.574508722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     53,
  /**/

-- 
ARTHUR:    ... and I am your king ....
OLD WOMAN: Ooooh!  I didn't know we had a king.  I thought we were an
           autonomous collective ...
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0054
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0054 (after 8.0.0051)
Problem:    On Windows job_stop() stops cmd.exe, not the processes it runs.
            (Linwei)
Solution:   Iterate over all processes and terminate the one where the parent
            is the job process. Now only when there is no job object.
            (Yasuhiro Matsumoto, closes #1203)
Files:      src/os_win32.c


*** ../vim-8.0.0053/src/os_win32.c	2016-10-27 21:13:04.882665596 +0200
--- src/os_win32.c	2016-10-29 14:52:48.832914391 +0200
***************
*** 50,55 ****
--- 50,59 ----
  # endif
  #endif
  
+ #ifdef FEAT_JOB_CHANNEL
+ # include <tlhelp32.h>
+ #endif
+ 
  #ifdef __MINGW32__
  # ifndef FROM_LEFT_1ST_BUTTON_PRESSED
  #  define FROM_LEFT_1ST_BUTTON_PRESSED    0x0001
***************
*** 5020,5025 ****
--- 5024,5071 ----
      return NULL;
  }
  
+     static BOOL
+ terminate_all(HANDLE process, int code)
+ {
+     PROCESSENTRY32  pe;
+     HANDLE	    h = INVALID_HANDLE_VALUE;
+     DWORD	    pid = GetProcessId(process);
+ 
+     if (pid != 0)
+     {
+ 	h = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+ 	if (h != INVALID_HANDLE_VALUE)
+ 	{
+ 	    pe.dwSize = sizeof(PROCESSENTRY32);
+ 	    if (!Process32First(h, &pe))
+ 		goto theend;
+ 
+ 	    do
+ 	    {
+ 		if (pe.th32ParentProcessID == pid)
+ 		{
+ 		    HANDLE ph = OpenProcess(
+ 				  PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
+ 		    if (ph != NULL)
+ 		    {
+ 			terminate_all(ph, code);
+ 			CloseHandle(ph);
+ 		    }
+ 		}
+ 	    } while (Process32Next(h, &pe));
+ 
+ 	    CloseHandle(h);
+ 	}
+     }
+ 
+ theend:
+     return TerminateProcess(process, code);
+ }
+ 
+ /*
+  * Send a (deadly) signal to "job".
+  * Return FAIL if it didn't work.
+  */
      int
  mch_stop_job(job_T *job, char_u *how)
  {
***************
*** 5027,5036 ****
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
  	if (job->jv_job_object != NULL)
  	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	else
! 	    return TerminateProcess(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
--- 5073,5082 ----
  
      if (STRCMP(how, "term") == 0 || STRCMP(how, "kill") == 0 || *how == NUL)
      {
+ 	/* deadly signal */
  	if (job->jv_job_object != NULL)
  	    return TerminateJobObject(job->jv_job_object, 0) ? OK : FAIL;
! 	return terminate_all(job->jv_proc_info.hProcess, 0) ? OK : FAIL;
      }
  
      if (!AttachConsole(job->jv_proc_info.dwProcessId))
*** ../vim-8.0.0053/src/version.c	2016-10-29 14:37:51.970378370 +0200
--- src/version.c	2016-10-29 14:54:23.980334722 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     54,
  /**/

-- 
OLD WOMAN: Well, how did you become king, then?
ARTHUR: The Lady of the Lake, her arm clad in the purest shimmering samite,
        held Excalibur aloft from the bosom of the water to signify by Divine
        Providence ...  that I, Arthur, was to carry Excalibur ...  That is
        why I am your king!
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0055
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0055
Problem:    Minor comment and style deficiencies.
Solution:   Update comments and fix style.
Files:      src/buffer.c, src/misc2.c, src/os_unix.c


*** ../vim-8.0.0054/src/buffer.c	2016-09-11 14:36:14.000000000 +0200
--- src/buffer.c	2016-10-08 16:28:50.059483141 +0200
***************
*** 451,457 ****
      int		nwindows;
      bufref_T	bufref;
  # ifdef FEAT_WINDOWS
!     int		is_curwin = (curwin!= NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
  # endif
--- 451,457 ----
      int		nwindows;
      bufref_T	bufref;
  # ifdef FEAT_WINDOWS
!     int		is_curwin = (curwin != NULL && curwin->w_buffer == buf);
      win_T	*the_curwin = curwin;
      tabpage_T	*the_curtab = curtab;
  # endif
***************
*** 1649,1658 ****
  #ifdef FEAT_AUTOCMD
      if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)
  # ifdef FEAT_EVAL
! 	    || (bufref_valid(&bufref) && !aborting()))
  # else
! 	    || bufref_valid(&bufref))
  # endif
  #endif
      {
  #ifdef FEAT_SYN_HL
--- 1649,1659 ----
  #ifdef FEAT_AUTOCMD
      if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)
  # ifdef FEAT_EVAL
! 	    || (bufref_valid(&bufref) && !aborting())
  # else
! 	    || bufref_valid(&bufref)
  # endif
+        )
  #endif
      {
  #ifdef FEAT_SYN_HL
*** ../vim-8.0.0054/src/misc2.c	2016-10-12 14:19:55.746357751 +0200
--- src/misc2.c	2016-10-27 18:27:13.667291651 +0200
***************
*** 6256,6261 ****
--- 6256,6262 ----
  #if defined(MESSAGE_QUEUE) || defined(PROTO)
  /*
   * Process messages that have been queued for netbeans or clientserver.
+  * Also check if any jobs have ended.
   * These functions can call arbitrary vimscript and should only be called when
   * it is safe to do so.
   */
*** ../vim-8.0.0054/src/os_unix.c	2016-10-27 20:00:03.661357429 +0200
--- src/os_unix.c	2016-10-29 14:50:00.921937360 +0200
***************
*** 5390,5395 ****
--- 5390,5399 ----
      return NULL;
  }
  
+ /*
+  * Send a (deadly) signal to "job".
+  * Return FAIL if "how" is not a valid name.
+  */
      int
  mch_stop_job(job_T *job, char_u *how)
  {
*** ../vim-8.0.0054/src/version.c	2016-10-29 14:54:56.628135821 +0200
--- src/version.c	2016-10-30 21:57:08.786668736 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     55,
  /**/

-- 
Any resemblance between the above views and those of my employer, my terminal,
or the view out my window are purely coincidental.  Any resemblance between
the above and my own views is non-deterministic.  The question of the
existence of views in the absence of anyone to hold them is left as an
exercise for the reader.  The question of the existence of the reader is left
as an exercise for the second god coefficient.  (A discussion of
non-orthogonal, non-integral polytheism is beyond the scope of this article.)
						(Ralph Jennings)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0056
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0056
Problem:    When setting 'filetype' there is no check for a valid name.
Solution:   Only allow valid characters in 'filetype', 'syntax' and 'keymap'.
Files:      src/option.c, src/testdir/test_options.vim


*** ../vim-8.0.0055/src/option.c	2016-10-12 17:45:13.638857445 +0200
--- src/option.c	2016-11-04 15:15:21.485747398 +0100
***************
*** 5823,5828 ****
--- 5823,5843 ----
  }
  
  /*
+  * Return TRUE if "val" is a valid 'filetype' name.
+  * Also used for 'syntax' and 'keymap'.
+  */
+     static int
+ valid_filetype(char_u *val)
+ {
+     char_u *s;
+ 
+     for (s = val; *s != NUL; ++s)
+ 	if (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)".-_", *s) == NULL)
+ 	    return FALSE;
+     return TRUE;
+ }
+ 
+ /*
   * Handle string options that need some action to perform when changed.
   * Returns NULL for success, or an error message for an error.
   */
***************
*** 6235,6242 ****
  #ifdef FEAT_KEYMAP
      else if (varp == &curbuf->b_p_keymap)
      {
! 	/* load or unload key mapping tables */
! 	errmsg = keymap_init();
  
  	if (errmsg == NULL)
  	{
--- 6250,6260 ----
  #ifdef FEAT_KEYMAP
      else if (varp == &curbuf->b_p_keymap)
      {
! 	if (!valid_filetype(*varp))
! 	    errmsg = e_invarg;
! 	else
! 	    /* load or unload key mapping tables */
! 	    errmsg = keymap_init();
  
  	if (errmsg == NULL)
  	{
***************
*** 7221,7226 ****
--- 7239,7260 ----
  	    errmsg = e_invarg;
      }
  #endif
+ 
+ #ifdef FEAT_AUTOCMD
+     else if (gvarp == &p_ft)
+     {
+ 	if (!valid_filetype(*varp))
+ 	    errmsg = e_invarg;
+     }
+ #endif
+ 
+ #ifdef FEAT_SYN_HL
+     else if (gvarp == &p_syn)
+     {
+ 	if (!valid_filetype(*varp))
+ 	    errmsg = e_invarg;
+     }
+ #endif
  
      /* Options that are a list of flags. */
      else
*** ../vim-8.0.0055/src/testdir/test_options.vim	2016-08-12 19:14:36.000000000 +0200
--- src/testdir/test_options.vim	2016-11-04 15:16:04.909425894 +0100
***************
*** 48,50 ****
--- 48,99 ----
    endif
  endfunc
  
+ func Test_filetype_valid()
+   set ft=valid_name
+   call assert_equal("valid_name", &filetype)
+   set ft=valid-name
+   call assert_equal("valid-name", &filetype)
+ 
+   call assert_fails(":set ft=wrong;name", "E474:")
+   call assert_fails(":set ft=wrong\\\\name", "E474:")
+   call assert_fails(":set ft=wrong\\|name", "E474:")
+   call assert_fails(":set ft=wrong/name", "E474:")
+   call assert_fails(":set ft=wrong\\\nname", "E474:")
+   call assert_equal("valid-name", &filetype)
+ 
+   exe "set ft=trunc\x00name"
+   call assert_equal("trunc", &filetype)
+ endfunc
+ 
+ func Test_syntax_valid()
+   set syn=valid_name
+   call assert_equal("valid_name", &syntax)
+   set syn=valid-name
+   call assert_equal("valid-name", &syntax)
+ 
+   call assert_fails(":set syn=wrong;name", "E474:")
+   call assert_fails(":set syn=wrong\\\\name", "E474:")
+   call assert_fails(":set syn=wrong\\|name", "E474:")
+   call assert_fails(":set syn=wrong/name", "E474:")
+   call assert_fails(":set syn=wrong\\\nname", "E474:")
+   call assert_equal("valid-name", &syntax)
+ 
+   exe "set syn=trunc\x00name"
+   call assert_equal("trunc", &syntax)
+ endfunc
+ 
+ func Test_keymap_valid()
+   call assert_fails(":set kmp=valid_name", "E544:")
+   call assert_fails(":set kmp=valid_name", "valid_name")
+   call assert_fails(":set kmp=valid-name", "E544:")
+   call assert_fails(":set kmp=valid-name", "valid-name")
+ 
+   call assert_fails(":set kmp=wrong;name", "E474:")
+   call assert_fails(":set kmp=wrong\\\\name", "E474:")
+   call assert_fails(":set kmp=wrong\\|name", "E474:")
+   call assert_fails(":set kmp=wrong/name", "E474:")
+   call assert_fails(":set kmp=wrong\\\nname", "E474:")
+ 
+   call assert_fails(":set kmp=trunc\x00name", "E544:")
+   call assert_fails(":set kmp=trunc\x00name", "trunc")
+ endfunc
*** ../vim-8.0.0055/src/version.c	2016-10-30 21:57:48.074395566 +0100
--- src/version.c	2016-11-04 14:34:35.299868887 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     56,
  /**/

-- 
Team-building exercises come in many forms but they all trace their roots back
to the prison system.  In your typical team-building exercise the employees
are subjected to a variety of unpleasant situations until they become either a
cohesive team or a ring of car jackers.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0057
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0057 (after 8.0.0056)
Problem:    Tests fail without the 'keymap' features.
Solution:   Check for feature in test.
Files:      src/testdir/test_options.vim


*** ../vim-8.0.0056/src/testdir/test_options.vim	2016-11-04 15:23:41.609967769 +0100
--- src/testdir/test_options.vim	2016-11-04 16:39:27.595960265 +0100
***************
*** 49,54 ****
--- 49,57 ----
  endfunc
  
  func Test_filetype_valid()
+   if !has('autocmd')
+     return
+   endif
    set ft=valid_name
    call assert_equal("valid_name", &filetype)
    set ft=valid-name
***************
*** 66,71 ****
--- 69,77 ----
  endfunc
  
  func Test_syntax_valid()
+   if !has('syntax')
+     return
+   endif
    set syn=valid_name
    call assert_equal("valid_name", &syntax)
    set syn=valid-name
***************
*** 83,88 ****
--- 89,97 ----
  endfunc
  
  func Test_keymap_valid()
+   if !has('keymap')
+     return
+   endif
    call assert_fails(":set kmp=valid_name", "E544:")
    call assert_fails(":set kmp=valid_name", "valid_name")
    call assert_fails(":set kmp=valid-name", "E544:")
*** ../vim-8.0.0056/src/version.c	2016-11-04 15:23:41.609967769 +0100
--- src/version.c	2016-11-04 16:40:11.219637484 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     57,
  /**/

-- 
The acknowledged parents of reengineering are Michael Hammer and James Champy.
When I say they're the "parents" I don't mean they had sex - and I apologize
for making you think about it.  I mean they wrote the best-selling business
book _Reengineering the Corporation_, which was published in 1993.
   Businesses flocked to reengineering like frat boys to a drunken
cheerleader.  (This analogy wasn't necessary, but I'm trying to get my mind
off that Hammer and Champy thing.)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0058
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0058
Problem:    Positioning of the popup menu is not good.
Solution:   Position it better. (Hirohito Higashi)
Files:      src/popupmnu.c


*** ../vim-8.0.0057/src/popupmnu.c	2016-10-27 14:49:11.022995393 +0200
--- src/popupmnu.c	2016-11-04 20:03:00.299805506 +0100
***************
*** 54,71 ****
      int		kind_width;
      int		extra_width;
      int		i;
-     int		top_clear;
      int		row;
      int		context_lines;
      int		col;
!     int		above_row = cmdline_row;
      int		redo_count = 0;
  
  redo:
      def_width = PUM_DEF_WIDTH;
      max_width = 0;
      kind_width = 0;
      extra_width = 0;
  
      /* Pretend the pum is already there to avoid that must_redraw is set when
       * 'cuc' is on. */
--- 54,74 ----
      int		kind_width;
      int		extra_width;
      int		i;
      int		row;
      int		context_lines;
      int		col;
!     int		above_row;
!     int		below_row;
      int		redo_count = 0;
+     win_T	*pvwin;
  
  redo:
      def_width = PUM_DEF_WIDTH;
      max_width = 0;
      kind_width = 0;
      extra_width = 0;
+     above_row = 0;
+     below_row = cmdline_row;
  
      /* Pretend the pum is already there to avoid that must_redraw is set when
       * 'cuc' is on. */
***************
*** 76,93 ****
      row = curwin->w_wrow + W_WINROW(curwin);
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     if (firstwin->w_p_pvw)
! 	top_clear = firstwin->w_height;
!     else
! #endif
! 	top_clear = 0;
! 
! #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* When the preview window is at the bottom stop just above it.  Also
!      * avoid drawing over the status line so that it's clear there is a window
!      * boundary. */
!     if (lastwin->w_p_pvw)
! 	above_row -= lastwin->w_height + lastwin->w_status_height + 1;
  #endif
  
      /*
--- 79,94 ----
      row = curwin->w_wrow + W_WINROW(curwin);
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     FOR_ALL_WINDOWS(pvwin)
! 	if (pvwin->w_p_pvw)
! 	    break;
!     if (pvwin != NULL)
!     {
! 	if (W_WINROW(pvwin) < W_WINROW(curwin))
! 	    above_row = W_WINROW(pvwin) + pvwin->w_height;
! 	else if (W_WINROW(pvwin) > W_WINROW(curwin) + curwin->w_height)
! 	    below_row = W_WINROW(pvwin);
!     }
  #endif
  
      /*
***************
*** 102,109 ****
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row  + 2 >= above_row - pum_height
! 					 && row > (above_row - top_clear) / 2)
      {
  	/* pum above "row" */
  
--- 103,109 ----
  
      /* Put the pum below "row" if possible.  If there are few lines decide on
       * where there is more room. */
!     if (row - above_row >= below_row - row)
      {
  	/* pum above "row" */
  
***************
*** 141,148 ****
  				+ curwin->w_cline_height - curwin->w_wrow;
  
  	pum_row = row + context_lines;
! 	if (size > above_row - pum_row)
! 	    pum_height = above_row - pum_row;
  	else
  	    pum_height = size;
  	if (p_ph > 0 && pum_height > p_ph)
--- 141,148 ----
  				+ curwin->w_cline_height - curwin->w_wrow;
  
  	pum_row = row + context_lines;
! 	if (size > below_row - pum_row)
! 	    pum_height = below_row - pum_row;
  	else
  	    pum_height = size;
  	if (p_ph > 0 && pum_height > p_ph)
***************
*** 154,166 ****
  	return;
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* If there is a preview window at the top avoid drawing over it. */
!     if (firstwin->w_p_pvw
! 	    && pum_row < firstwin->w_height
! 	    && pum_height > firstwin->w_height + 4)
      {
! 	pum_row += firstwin->w_height;
! 	pum_height -= firstwin->w_height;
      }
  #endif
  
--- 154,164 ----
  	return;
  
  #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
!     /* If there is a preview window at the above avoid drawing over it. */
!     if (pvwin != NULL && pum_row < above_row && pum_height > above_row)
      {
! 	pum_row += above_row;
! 	pum_height -= above_row;
      }
  #endif
  
*** ../vim-8.0.0057/src/version.c	2016-11-04 16:41:16.559153991 +0100
--- src/version.c	2016-11-04 20:03:57.851368163 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     58,
  /**/

-- 
Your company is doomed if your primary product is overhead transparencies.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0059
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0059
Problem:    Vim does not build on VMS systems.
Solution:   Various changes for VMS. (Zoltan Arpadffy)
Files:      src/json.c, src/macros.h, src/Make_vms.mms, src/os_unix.c,
            src/os_unix.h, src/os_vms.c, src/os_vms_conf.h,
            src/proto/os_vms.pro, src/testdir/Make_vms.mms


*** ../vim-8.0.0058/src/json.c	2016-10-21 20:35:32.632943225 +0200
--- src/json.c	2016-11-04 20:12:47.107346775 +0100
***************
*** 16,21 ****
--- 16,25 ----
  
  #include "vim.h"
  
+ #ifdef VAX
+ # undef FEAT_FLOAT // VAX does not handle well the Infinities
+ #endif
+ 
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int json_encode_item(garray_T *gap, typval_T *val, int copyID, int options);
*** ../vim-8.0.0058/src/macros.h	2016-08-29 22:42:20.000000000 +0200
--- src/macros.h	2016-11-04 20:13:34.310988154 +0100
***************
*** 177,182 ****
--- 177,183 ----
  # define mch_fstat(n, p)	fstat(vms_fixfilename(n), (p))
  	/* VMS does not have lstat() */
  # define mch_stat(n, p)		stat(vms_fixfilename(n), (p))
+ # define mch_rmdir(n)		rmdir(vms_fixfilename(n))
  #else
  # ifndef WIN32
  #   define mch_access(n, p)	access((n), (p))
*** ../vim-8.0.0058/src/Make_vms.mms	2016-07-02 19:59:17.000000000 +0200
--- src/Make_vms.mms	2016-11-04 20:18:44.880628815 +0100
***************
*** 2,8 ****
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Jul 02
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
--- 2,8 ----
  # Makefile for Vim on OpenVMS
  #
  # Maintainer:   Zoltan Arpadffy <arpadffy@polarhome.com>
! # Last change:  2016 Nov 04
  #
  # This has script been tested on VMS 6.2 to 8.2 on DEC Alpha, VAX and IA64
  # with MMS and MMK
***************
*** 38,44 ****
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
  # GUI with Motif
! # GUI = YES
  
  # GUI with GTK
  # If you have GTK installed you might want to enable this option.
--- 38,44 ----
  # GUI or terminal mode executable.
  # Comment out if you want just the character terminal mode only.
  # GUI with Motif
! GUI = YES
  
  # GUI with GTK
  # If you have GTK installed you might want to enable this option.
***************
*** 299,320 ****
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
  	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
  
! SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c, crypt_zip.c diff.c digraph.c edit.c eval.c ex_cmds.c ex_cmds2.c \
! 	ex_docmd.c ex_eval.c ex_getln.c if_xcmdsrv.c farsi.c fileio.c fold.c getchar.c \
! 	hardcopy.c hashtab.c json.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
! 	spell.c syntax.c tag.c term.c termlib.c ui.c undo.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
  	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
! OBJ =	arabic.obj blowfish.obj buffer.obj charset.obj crypt.obj, crypt_zip.obj diff.obj digraph.obj edit.obj eval.obj \
! 	ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj \
! 	if_xcmdsrv.obj farsi.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj json.obj main.obj mark.obj \
  	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
  	move.obj mbyte.obj normal.obj ops.obj option.obj popupmnu.obj quickfix.obj \
! 	regexp.obj search.obj sha256.obj spell.obj syntax.obj tag.obj term.obj termlib.obj \
! 	ui.obj undo.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
  	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
--- 299,320 ----
  ALL_LIBS = $(LIBS) $(GUI_LIB_DIR) $(GUI_LIB) \
  	   $(PERL_LIB) $(PYTHON_LIB) $(TCL_LIB) $(RUBY_LIB)
  
! SRC =	arabic.c blowfish.c buffer.c charset.c crypt.c crypt_zip.c dict.c diff.c digraph.c edit.c eval.c evalfunc.c \
! 	ex_cmds.c ex_cmds2.c ex_docmd.c ex_eval.c ex_getln.c if_cscope.c if_xcmdsrv.c farsi.c fileio.c fold.c getchar.c \
! 	hardcopy.c hashtab.c json.c list.c main.c mark.c menu.c mbyte.c memfile.c memline.c message.c misc1.c \
  	misc2.c move.c normal.c ops.c option.c popupmnu.c quickfix.c regexp.c search.c sha256.c\
! 	spell.c spellfile.c syntax.c tag.c term.c termlib.c ui.c undo.c userfunc.c version.c screen.c \
  	window.c os_unix.c os_vms.c pathdef.c \
  	$(GUI_SRC) $(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) \
  	$(RUBY_SRC) $(HANGULIN_SRC) $(MZSCH_SRC)
  
! OBJ = 	arabic.obj blowfish.obj buffer.obj charset.obj crypt.obj crypt_zip.obj dict.obj diff.obj digraph.obj edit.obj eval.obj \
! 	evalfunc.obj ex_cmds.obj ex_cmds2.obj ex_docmd.obj ex_eval.obj ex_getln.obj if_cscope.obj \
! 	if_xcmdsrv.obj farsi.obj fileio.obj fold.obj getchar.obj hardcopy.obj hashtab.obj json.obj list.obj main.obj mark.obj \
  	menu.obj memfile.obj memline.obj message.obj misc1.obj misc2.obj \
  	move.obj mbyte.obj normal.obj ops.obj option.obj popupmnu.obj quickfix.obj \
! 	regexp.obj search.obj sha256.obj spell.obj spellfile.obj syntax.obj tag.obj term.obj termlib.obj \
! 	ui.obj undo.obj userfunc.obj screen.obj version.obj window.obj os_unix.obj \
  	os_vms.obj pathdef.obj if_mzsch.obj\
  	$(GUI_OBJ) $(PERL_OBJ) $(PYTHON_OBJ) $(TCL_OBJ) \
  	$(RUBY_OBJ) $(HANGULIN_OBJ) $(MZSCH_OBJ)
***************
*** 496,501 ****
--- 496,513 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ crypt.obj : crypt.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
+ crypt_zip.obj : crypt_zip.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
+ dict.obj : dict.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  diff.obj : diff.c vim.h [.auto]config.h feature.h os_unix.h   \
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
***************
*** 512,517 ****
--- 524,533 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h version.h
+ evalfunc.obj : evalfunc.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h version.h
  ex_cmds.obj : ex_cmds.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
***************
*** 569,574 ****
--- 585,594 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h version.h
+ list.obj : list.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  main.obj : main.c vim.h [.auto]config.h feature.h os_unix.h   \
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
***************
*** 653,662 ****
--- 673,690 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ sha256.obj : sha256.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
+  gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h proto.h \
+  globals.h farsi.h arabic.h
  spell.obj : spell.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
   globals.h farsi.h arabic.h
+ spellfile.obj : spellfile.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
  syntax.obj : syntax.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
***************
*** 681,686 ****
--- 709,718 ----
   ascii.h keymap.h term.h macros.h structs.h regexp.h gui.h gui_beval.h \
   [.proto]gui_beval.pro option.h ex_cmds.h proto.h globals.h farsi.h \
   arabic.h
+ userfunc.obj : userfunc.c vim.h [.auto]config.h feature.h os_unix.h \
+  ascii.h keymap.h term.h macros.h option.h structs.h \
+  regexp.h gui.h gui_beval.h [.proto]gui_beval.pro alloc.h ex_cmds.h spell.h \
+  proto.h globals.h farsi.h arabic.h
  version.obj : version.c vim.h [.auto]config.h feature.h os_unix.h \
   ascii.h keymap.h term.h macros.h structs.h regexp.h \
   gui.h gui_beval.h [.proto]gui_beval.pro option.h ex_cmds.h proto.h \
*** ../vim-8.0.0058/src/os_unix.c	2016-10-30 21:57:48.074395566 +0100
--- src/os_unix.c	2016-11-04 20:21:15.359474394 +0100
***************
*** 501,507 ****
  	/* no character available */
  #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
  	/* estimate the elapsed time */
! 	elapsed += wait_time;
  #endif
  
  	if (do_resize	    /* interrupted by SIGWINCH signal */
--- 501,507 ----
  	/* no character available */
  #if !(defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H))
  	/* estimate the elapsed time */
! 	elapsed_time += wait_time;
  #endif
  
  	if (do_resize	    /* interrupted by SIGWINCH signal */
***************
*** 2644,2650 ****
      DIR		*dirp;
      struct dirent *dp;
  
!     if (lstat((char *)name, &st) >= 0)
      {
  	/* Open the directory where the file is located. */
  	slash = vim_strrchr(name, '/');
--- 2644,2650 ----
      DIR		*dirp;
      struct dirent *dp;
  
!     if (mch_lstat((char *)name, &st) >= 0)
      {
  	/* Open the directory where the file is located. */
  	slash = vim_strrchr(name, '/');
***************
*** 2677,2683 ****
  		    vim_strncpy(newname, name, MAXPATHL);
  		    vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,
  						    MAXPATHL - (tail - name));
! 		    if (lstat((char *)newname, &st2) >= 0
  			    && st.st_ino == st2.st_ino
  			    && st.st_dev == st2.st_dev)
  		    {
--- 2677,2683 ----
  		    vim_strncpy(newname, name, MAXPATHL);
  		    vim_strncpy(newname + (tail - name), (char_u *)dp->d_name,
  						    MAXPATHL - (tail - name));
! 		    if (mch_lstat((char *)newname, &st2) >= 0
  			    && st.st_ino == st2.st_ino
  			    && st.st_dev == st2.st_dev)
  		    {
***************
*** 3040,3046 ****
  
      if (*name == NUL)	    /* Some stat()s don't flag "" as an error. */
  	return FALSE;
!     if (lstat((char *)name, &statb))
  	return FALSE;
  #ifdef _POSIX_SOURCE
      return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);
--- 3040,3046 ----
  
      if (*name == NUL)	    /* Some stat()s don't flag "" as an error. */
  	return FALSE;
!     if (mch_lstat((char *)name, &statb))
  	return FALSE;
  #ifdef _POSIX_SOURCE
      return (S_ISDIR(statb.st_mode) ? TRUE : FALSE);
***************
*** 4098,4103 ****
--- 4098,4104 ----
      int		tmode = cur_tmode;
  #ifdef USE_SYSTEM	/* use system() to start the shell: simple but slow */
      char_u	*newcmd;	/* only needed for unix */
+     int		x;
  
      out_flush();
  
*** ../vim-8.0.0058/src/os_unix.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_unix.h	2016-11-04 20:11:03.284135575 +0100
***************
*** 75,84 ****
  # ifdef VMS
  #  define mch_remove(x) delete((char *)(x))
  #  define vim_mkdir(x, y) mkdir((char *)(x), y)
- #  ifdef VAX
- #  else
- #   define mch_rmdir(x) rmdir((char *)(x))
- #  endif
  # else
  #  define vim_mkdir(x, y) mkdir((char *)(x), y)
  #  define mch_rmdir(x) rmdir((char *)(x))
--- 75,80 ----
*** ../vim-8.0.0058/src/os_vms.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_vms.c	2016-11-04 20:22:07.923071226 +0100
***************
*** 726,732 ****
  RealWaitForChar(
      int		fd UNUSED, /* always read from iochan */
      long	msec,
!     int		*check_for_gpm UNUSED)
  {
      int status;
      struct _generic_64 time_curr;
--- 726,733 ----
  RealWaitForChar(
      int		fd UNUSED, /* always read from iochan */
      long	msec,
!     int		*check_for_gpm UNUSED,
!     int		*interrupted)
  {
      int status;
      struct _generic_64 time_curr;
*** ../vim-8.0.0058/src/os_vms_conf.h	2016-01-30 21:37:24.000000000 +0100
--- src/os_vms_conf.h	2016-11-04 20:23:23.210493858 +0100
***************
*** 141,146 ****
--- 141,147 ----
  #undef	HAVE_SYS_POLL_H
  #undef	HAVE_PWD_H
  #undef  HAVE_FCHDIR
+ #undef  HAVE_LSTAT
  
  /* Hardware specific */
  #ifdef  VAX
***************
*** 148,160 ****
  #undef  HAVE_USLEEP
  #undef  HAVE_STRCASECMP
  #undef  HAVE_STRINGS_H
! #undef	HAVE_SIGSETJMP
  #else
  #define HAVE_GETTIMEOFDAY
  #define HAVE_USLEEP
  #define HAVE_STRCASECMP
  #define HAVE_STRINGS_H
! #define	HAVE_SIGSETJMP
  #endif
  
  /* Compiler specific */
--- 149,163 ----
  #undef  HAVE_USLEEP
  #undef  HAVE_STRCASECMP
  #undef  HAVE_STRINGS_H
! #undef  HAVE_SIGSETJMP
! #undef  HAVE_ISNAN
  #else
  #define HAVE_GETTIMEOFDAY
  #define HAVE_USLEEP
  #define HAVE_STRCASECMP
  #define HAVE_STRINGS_H
! #define HAVE_SIGSETJMP
! #define HAVE_ISNAN
  #endif
  
  /* Compiler specific */
*** ../vim-8.0.0058/src/proto/os_vms.pro	2016-09-12 13:04:31.000000000 +0200
--- src/proto/os_vms.pro	2016-11-04 20:11:03.284135575 +0100
***************
*** 12,16 ****
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  void *vms_fixfilename(void *instring);
  void vms_remove_version(void *fname);
! int RealWaitForChar(int fd, long msec, int *check_for_gpm);
  /* vim: set ft=c : */
--- 12,16 ----
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  void *vms_fixfilename(void *instring);
  void vms_remove_version(void *fname);
! int RealWaitForChar(int fd, long msec, int *check_for_gpm, int *interrupted);
  /* vim: set ft=c : */
*** ../vim-8.0.0058/src/testdir/Make_vms.mms	2016-08-04 20:03:47.000000000 +0200
--- src/testdir/Make_vms.mms	2016-11-04 20:26:17.725155965 +0100
***************
*** 4,10 ****
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2016 Aug 04
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
--- 4,10 ----
  # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
  #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
  #
! # Last change:  2016 Nov 04
  #
  # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
  # Edit the lines in the Configuration section below to select.
***************
*** 74,87 ****
  
  VIMPROG = <->vim.exe
  
- default : all
- 
- # This probably doesn't work, please fix.
- .INCLUDE Make_all.mak
- 
  .SUFFIXES : .out .in
  
! SCRIPT = $(SCRIPTS_ALL) $(SCRIPTS_MORE3)
  
  # Known problems:
  # test17: ?
--- 74,118 ----
  
  VIMPROG = <->vim.exe
  
  .SUFFIXES : .out .in
  
! SCRIPT = test1.out  test3.out  test4.out  test5.out  \
!        test7.out  test8.out  test9.out  \
!        test14.out test15.out \
!        test19.out test20.out test22.out \
!        test23.out test24.out test26.out \
!        test28.out test29.out test30.out test31.out test32.out \
!        test33.out test34.out test36.out test37.out \
!        test38.out test39.out test40.out test41.out test42.out \
!        test43.out test44.out test45.out \
!        test48.out test49.out test51.out test53.out test54.out \
!        test55.out test56.out test57.out test60.out \
!        test64.out test65.out \
!        test66.out test67.out test68.out test69.out \
!        test72.out test75.out \
!        test77a.out test78.out test79.out test80.out \
!        test82.out test84.out test88.out test89.out \
!        test90.out test91.out test92.out test93.out test94.out \
!        test95.out test98.out test99.out \
!        test103.out test104.out \
!        test107.out test108.out\
!        test_autocmd_option.out \
!        test_autoformat_join.out \
!        test_breakindent.out \
!        test_changelist.out \
!        test_close_count.out \
!        test_comparators.out \
!        test_erasebackword.out \
!        test_eval.out \
!        test_fixeol.out \
!        test_getcwd.out \
!        test_insertcount.out \
!        test_listchars.out \
!        test_listlbr.out \
!        test_listlbr_utf8.out \
!        test_search_mbyte.out \
!        test_utf8.out \
!        test_wordcount.out
  
  # Known problems:
  # test17: ?
***************
*** 104,115 ****
  # On ODS-2 tests fail. 
  
  .IFDEF WANT_GUI
! SCRIPT_GUI = 
  GUI_OPTION = -g
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test12.out test17.out test25.out test27.out test49.out test73.out
  .ENDIF
  
  .IFDEF WANT_WIN
--- 135,146 ----
  # On ODS-2 tests fail. 
  
  .IFDEF WANT_GUI
! SCRIPT_GUI = test16.out
  GUI_OPTION = -g
  .ENDIF
  
  .IFDEF WANT_UNIX
! SCRIPT_UNIX = test10.out test12.out test17.out test25.out test27.out test49.out test73.out
  .ENDIF
  
  .IFDEF WANT_WIN
***************
*** 163,169 ****
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ !run the test
! 	-@ create/term/wait/nodetach mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim $(NO_PLUGIN) -s dotest.in $*.in
  	-@ !analyse the result
  	-@ directory /size/date test.out
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename/nolog test.out $*.out 
--- 194,200 ----
  	-@ write sys$output "                "$*" "
  	-@ write sys$output "-----------------------------------------------"
  	-@ !run the test
! 	-@ create/term/wait/nodetach mcr $(VIMPROG) $(GUI_OPTION) -u vms.vim --noplugin -s dotest.in $*.in
  	-@ !analyse the result
  	-@ directory /size/date test.out
  	-@ if "''F$SEARCH("test.out.*")'" .NES. "" then rename/nolog test.out $*.out 
***************
*** 172,178 ****
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  	-@ if "''F$SEARCH("Xtest.*")'"    .NES. "" then delete/noconfirm/nolog Xtest.*.*
  
! all : clean nolog $(SCRIPTS_FIRST) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_ODS5) $(SCRIPT_GZIP) \
      $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) $(SCRIPT_CKSUM) $(SCRIPT_ICONV) $(SCRIPT_LUA) $(SCRIPT_PYTHON) nolog 
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
--- 203,209 ----
  	-@ if "''F$SEARCH("Xdotest.*")'"  .NES. "" then delete/noconfirm/nolog Xdotest.*.*
  	-@ if "''F$SEARCH("Xtest.*")'"    .NES. "" then delete/noconfirm/nolog Xtest.*.*
  
! all : clean nolog $(START_WITH) $(SCRIPT) $(SCRIPT_GUI) $(SCRIPT_UNIX) $(SCRIPT_WIN) $(SCRIPT_SPELL) $(SCRIPT_ODS5) $(SCRIPT_GZIP) \
      $(SCRIPT_GDIFF) $(SCRIPT_MZSCH) $(SCRIPT_CKSUM) $(SCRIPT_ICONV) $(SCRIPT_LUA) $(SCRIPT_PYTHON) nolog 
  	-@ write sys$output " "
  	-@ write sys$output "-----------------------------------------------"
*** ../vim-8.0.0058/src/version.c	2016-11-04 20:08:48.281161315 +0100
--- src/version.c	2016-11-04 20:26:57.472851325 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     59,
  /**/

-- 
"You're fired." (1980)
"You're laid off." (1985)
"You're downsized." (1990)
"You're rightsized." (1992)
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0060
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0060
Problem:    When using an Ex command for 'keywordprg' it is escaped as with a
            shell command. (Romain Lafourcade)
Solution:   Escape for an Ex command. (closes #1175)
Files:      src/normal.c, src/testdir/test_normal.vim


*** ../vim-8.0.0059/src/normal.c	2016-10-08 19:21:26.079230055 +0200
--- src/normal.c	2016-11-04 21:10:40.832732253 +0100
***************
*** 5713,5721 ****
       */
      if (cmdchar == 'K' && !kp_help)
      {
- 	/* Escape the argument properly for a shell command */
  	ptr = vim_strnsave(ptr, n);
! 	p = vim_strsave_shellescape(ptr, TRUE, TRUE);
  	vim_free(ptr);
  	if (p == NULL)
  	{
--- 5713,5725 ----
       */
      if (cmdchar == 'K' && !kp_help)
      {
  	ptr = vim_strnsave(ptr, n);
! 	if (kp_ex)
! 	    /* Escape the argument properly for an Ex command */
! 	    p = vim_strsave_fnameescape(ptr, FALSE);
! 	else
! 	    /* Escape the argument properly for a shell command */
! 	    p = vim_strsave_shellescape(ptr, TRUE, TRUE);
  	vim_free(ptr);
  	if (p == NULL)
  	{
*** ../vim-8.0.0059/src/testdir/test_normal.vim	2016-09-09 16:54:46.000000000 +0200
--- src/testdir/test_normal.vim	2016-11-04 21:13:39.267361314 +0100
***************
*** 1222,1228 ****
  func! Test_normal23_K()
    " Test for K command
    new
!   call append(0, ['version8.txt', 'man'])
    let k = &keywordprg
    set keywordprg=:help
    1
--- 1222,1228 ----
  func! Test_normal23_K()
    " Test for K command
    new
!   call append(0, ['version8.txt', 'man', 'aa%bb', 'cc|dd'])
    let k = &keywordprg
    set keywordprg=:help
    1
***************
*** 1237,1242 ****
--- 1237,1260 ----
    call assert_match('\*version8\.0\*', getline('.'))
    helpclose
  
+   set keywordprg=:new
+   set iskeyword+=%
+   set iskeyword+=\|
+   2
+   norm! K
+   call assert_equal('man', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   3
+   norm! K
+   call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   4
+   norm! K
+   call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
+   bwipe!
+   set iskeyword-=%
+   set iskeyword-=\|
+ 
    " Only expect "man" to work on Unix
    if !has("unix")
      let &keywordprg = k
*** ../vim-8.0.0059/src/version.c	2016-11-04 20:35:27.352945991 +0100
--- src/version.c	2016-11-04 21:16:20.930121967 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     60,
  /**/

-- 
If your company is not involved in something called "ISO 9000" you probably
have no idea what it is.  If your company _is_ involved in ISO 9000 then you
definitely have no idea what it is.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0061
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0061 (after 8.0.0058)
Problem:    Compiler warning for unused variable.
Solution:   Add #ifdef. (John Marriott)
Files:      src/popupmnu.c


*** ../vim-8.0.0060/src/popupmnu.c	2016-11-04 20:08:48.277161346 +0100
--- src/popupmnu.c	2016-11-04 22:06:22.479024095 +0100
***************
*** 60,66 ****
--- 60,68 ----
      int		above_row;
      int		below_row;
      int		redo_count = 0;
+ #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
      win_T	*pvwin;
+ #endif
  
  redo:
      def_width = PUM_DEF_WIDTH;
*** ../vim-8.0.0060/src/version.c	2016-11-04 21:22:33.323268841 +0100
--- src/version.c	2016-11-04 22:07:26.686534879 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     61,
  /**/

-- 
The only way the average employee can speak to an executive is by taking a
second job as a golf caddie.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0062
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0062
Problem:    No digraph for HORIZONTAL ELLIPSIS.
Solution:   Use ",.". (Hans Ginzel, closes #1226)
Files:      src/digraph.c, runtime/doc/digraph.txt


*** ../vim-8.0.0061/src/digraph.c	2016-08-29 22:42:20.000000000 +0200
--- src/digraph.c	2016-11-04 22:15:15.382964392 +0100
***************
*** 1312,1317 ****
--- 1312,1318 ----
  	{'/', '-', 0x2020},
  	{'/', '=', 0x2021},
  	{'.', '.', 0x2025},
+ 	{',', '.', 0x2026},
  	{'%', '0', 0x2030},
  	{'1', '\'', 0x2032},
  	{'2', '\'', 0x2033},
*** ../vim-8.0.0061/runtime/doc/digraph.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/digraph.txt	2016-11-04 22:14:55.827113346 +0100
***************
*** 147,153 ****
  	Two			2	Hook
  	Nine			9	Horn
  
! 	Equals			=	Cyrillic (= used as second char) 
  	Asterisk		*	Greek
  	Percent sign		%	Greek/Cyrillic special
  	Plus			+	smalls: Arabic, capitals: Hebrew
--- 147,153 ----
  	Two			2	Hook
  	Nine			9	Horn
  
! 	Equals			=	Cyrillic (= used as second char)
  	Asterisk		*	Greek
  	Percent sign		%	Greek/Cyrillic special
  	Plus			+	smalls: Arabic, capitals: Hebrew
***************
*** 926,931 ****
--- 926,932 ----
  †	/-	2020	8224	DAGGER
  ‡	/=	2021	8225	DOUBLE DAGGER
  ‥	..	2025	8229	TWO DOT LEADER
+ …	,.	2026	8230	HORIZONTAL ELLIPSIS
  ‰	%0	2030	8240	PER MILLE SIGN
  ′	1'	2032	8242	PRIME
  ″	2'	2033	8243	DOUBLE PRIME
*** ../vim-8.0.0061/src/version.c	2016-11-04 22:08:26.014082864 +0100
--- src/version.c	2016-11-04 22:16:28.018411161 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     62,
  /**/

-- 
A salesperson says:            Translation:
"backward compatible"          Old technology
"Premium"                      Overpriced
"Can't keep it on the shelf"   Unavailable
"Stands alone"                 Piece of shit
"Proprietary"                  Incompatible
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0063
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0063
Problem:    Compiler warning for comparing with unsigned. (Zoltan Arpadffy)
Solution:   Change <= to ==.
Files:      src/undo.c


*** ../vim-8.0.0062/src/undo.c	2016-08-29 22:42:20.000000000 +0200
--- src/undo.c	2016-11-05 14:56:19.176297387 +0100
***************
*** 1076,1082 ****
  	    if (bi->bi_used >= bi->bi_avail)
  	    {
  		n = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);
! 		if (n <= 0)
  		{
  		    /* Error may be checked for only later.  Fill with zeros,
  		     * so that the reader won't use garbage. */
--- 1076,1082 ----
  	    if (bi->bi_used >= bi->bi_avail)
  	    {
  		n = fread(bi->bi_buffer, 1, (size_t)CRYPT_BUF_SIZE, bi->bi_fp);
! 		if (n == 0)
  		{
  		    /* Error may be checked for only later.  Fill with zeros,
  		     * so that the reader won't use garbage. */
*** ../vim-8.0.0062/src/version.c	2016-11-04 22:17:10.654086435 +0100
--- src/version.c	2016-11-05 14:58:22.639291038 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     63,
  /**/

-- 
If the Universe is constantly expanding, why can't I ever find a parking space?

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0064
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0064 (after 8.0.0060)
Problem:    Normal test fails on MS-Windows.
Solution:   Don't try using an illegal file name.
Files:      src/testdir/test_normal.vim


*** ../vim-8.0.0063/src/testdir/test_normal.vim	2016-11-04 21:22:33.323268841 +0100
--- src/testdir/test_normal.vim	2016-11-05 19:51:32.362651582 +0100
***************
*** 1248,1257 ****
    norm! K
    call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
    bwipe!
!   4
!   norm! K
!   call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
!   bwipe!
    set iskeyword-=%
    set iskeyword-=\|
  
--- 1248,1259 ----
    norm! K
    call assert_equal('aa%bb', fnamemodify(bufname('%'), ':t'))
    bwipe!
!   if !has('win32')
!     4
!     norm! K
!     call assert_equal('cc|dd', fnamemodify(bufname('%'), ':t'))
!     bwipe!
!   endif
    set iskeyword-=%
    set iskeyword-=\|
  
*** ../vim-8.0.0063/src/version.c	2016-11-05 14:58:30.767225798 +0100
--- src/version.c	2016-11-05 19:53:43.165839035 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     64,
  /**/

-- 
The budget process was invented by an alien race of sadistic beings who
resemble large cats.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0065
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0065 (after 8.0.0056)
Problem:    Compiler warning for unused function in tiny build. (Tony
            Mechelynck)
Solution:   Add #ifdef.
Files:      src/option.c


*** ../vim-8.0.0064/src/option.c	2016-11-04 15:23:41.609967769 +0100
--- src/option.c	2016-11-05 20:11:28.643203745 +0100
***************
*** 5822,5827 ****
--- 5822,5828 ----
      return r;
  }
  
+ #if defined(FEAT_KEYMAP) || defined(FEAT_AUTOCMD) || defined(FEAT_SYN_HL)
  /*
   * Return TRUE if "val" is a valid 'filetype' name.
   * Also used for 'syntax' and 'keymap'.
***************
*** 5836,5841 ****
--- 5837,5843 ----
  	    return FALSE;
      return TRUE;
  }
+ #endif
  
  /*
   * Handle string options that need some action to perform when changed.
*** ../vim-8.0.0064/src/version.c	2016-11-05 19:53:57.049752758 +0100
--- src/version.c	2016-11-05 20:12:19.538886188 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     65,
  /**/

-- 
The fastest way to get an engineer to solve a problem is to declare that the
problem is unsolvable.  No engineer can walk away from an unsolvable problem
until it's solved.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0066
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0066
Problem:    when calling an operator function when 'linebreak' is set, it is
            internally reset before calling the operator function.
Solution:   Restore 'linebreak' before calling op_function(). (Christian
            Brabandt)
Files:      src/normal.c, src/testdir/test_normal.vim


*** ../vim-8.0.0065/src/normal.c	2016-11-04 21:22:33.323268841 +0100
--- src/normal.c	2016-11-05 21:54:33.644438077 +0100
***************
*** 1995,2000 ****
--- 1995,2005 ----
  	    break;
  
  	case OP_FUNCTION:
+ #ifdef FEAT_LINEBREAK
+ 	    /* Restore linebreak, so that when the user edits it looks as
+ 	     * before. */
+ 	    curwin->w_p_lbr = lbr_saved;
+ #endif
  	    op_function(oap);		/* call 'operatorfunc' */
  	    break;
  
*** ../vim-8.0.0065/src/testdir/test_normal.vim	2016-11-05 19:53:57.049752758 +0100
--- src/testdir/test_normal.vim	2016-11-05 21:50:29.141989667 +0100
***************
*** 35,42 ****
    let @@ = reg_save
  endfunc
  
! func! IsWindows()
!   return has("win32") || has("win64") || has("win95")
  endfunc
  
  fun! Test_normal00_optrans()
--- 35,54 ----
    let @@ = reg_save
  endfunc
  
! func! OpfuncDummy(type, ...)
!   " for testing operatorfunc
!   let g:opt=&linebreak
! 
!   if a:0  " Invoked from Visual mode, use gv command.
!     silent exe "normal! gvy"
!   elseif a:type == 'line'
!     silent exe "normal! '[V']y"
!   else
!     silent exe "normal! `[v`]y"
!   endif
!   " Create a new dummy window
!   new
!   let g:bufnr=bufnr('%')
  endfunc
  
  fun! Test_normal00_optrans()
***************
*** 147,153 ****
  func! Test_normal04_filter()
    " basic filter test
    " only test on non windows platform
!   if IsWindows()
      return
    endif
    call Setup_NewWindow()
--- 159,165 ----
  func! Test_normal04_filter()
    " basic filter test
    " only test on non windows platform
!   if has('win32')
      return
    endif
    call Setup_NewWindow()
***************
*** 210,216 ****
  func! Test_normal06_formatprg()
    " basic test for formatprg
    " only test on non windows platform
!   if IsWindows()
      return
    else
      " uses sed to number non-empty lines
--- 222,228 ----
  func! Test_normal06_formatprg()
    " basic test for formatprg
    " only test on non windows platform
!   if has('win32')
      return
    else
      " uses sed to number non-empty lines
***************
*** 328,334 ****
--- 340,373 ----
    " clean up
    unmap <buffer> ,,
    set opfunc=
+   unlet! g:a
+   bw!
+ endfunc
+ 
+ func! Test_normal09a_operatorfunc()
+   " Test operatorfunc
+   call Setup_NewWindow()
+   " Add some spaces for counting
+   50,60s/$/  /
+   unlet! g:opt
+   set linebreak
+   nmap <buffer><silent> ,, :set opfunc=OpfuncDummy<CR>g@
+   50
+   norm ,,j
+   exe "bd!" g:bufnr
+   call assert_true(&linebreak)
+   call assert_equal(g:opt, &linebreak)
+   set nolinebreak
+   norm ,,j
+   exe "bd!" g:bufnr
+   call assert_false(&linebreak)
+   call assert_equal(g:opt, &linebreak)
+ 
+   " clean up
+   unmap <buffer> ,,
+   set opfunc=
    bw!
+   unlet! g:opt
  endfunc
  
  func! Test_normal10_expand()
*** ../vim-8.0.0065/src/version.c	2016-11-05 20:13:29.146451807 +0100
--- src/version.c	2016-11-05 21:53:05.184999344 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     66,
  /**/

-- 
While it's true that many normal people whould prefer not to _date_ an
engineer, most normal people harbor an intense desire to _mate_ with them,
thus producing engineerlike children who will have high-paying jobs long
before losing their virginity.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0067
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0067
Problem:    VMS has a problem with infinity.
Solution:   Avoid an overflow. (Zoltan Arpadffy)
Files:      src/json.c, src/macros.h


*** ../vim-8.0.0066/src/json.c	2016-11-04 20:35:27.348946021 +0100
--- src/json.c	2016-11-06 14:14:03.760136140 +0100
***************
*** 16,25 ****
  
  #include "vim.h"
  
- #ifdef VAX
- # undef FEAT_FLOAT // VAX does not handle well the Infinities
- #endif
- 
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static int json_encode_item(garray_T *gap, typval_T *val, int copyID, int options);
--- 16,21 ----
*** ../vim-8.0.0066/src/macros.h	2016-11-04 20:35:27.348946021 +0100
--- src/macros.h	2016-11-06 14:15:05.207758686 +0100
***************
*** 345,351 ****
  #  endif
  #  if !defined(INFINITY)
  #   if defined(DBL_MAX)
! #    define INFINITY (DBL_MAX+DBL_MAX)
  #   else
  #    define INFINITY (1.0 / 0.0)
  #   endif
--- 345,355 ----
  #  endif
  #  if !defined(INFINITY)
  #   if defined(DBL_MAX)
! #    ifdef VMS
! #     define INFINITY DBL_MAX
! #    else
! #     define INFINITY (DBL_MAX+DBL_MAX)
! #    endif
  #   else
  #    define INFINITY (1.0 / 0.0)
  #   endif
*** ../vim-8.0.0066/src/version.c	2016-11-05 21:55:09.844208420 +0100
--- src/version.c	2016-11-06 14:13:30.924337877 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     67,
  /**/

-- 
An alien life briefly visits earth.  Just before departing it leaves a
message in the dust on the back of a white van.  The world is shocked
and wants to know what it means.  After months of studies the worlds
best linguistic scientists are able to decipher the message: "Wash me!".

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0068
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0068
Problem:    Checking did_throw after executing autocommands is wrong. (Daniel
            Hahler)
Solution:   Call aborting() instead, and only when autocommands were executed.
Files:      src/quickfix.c, src/if_cscope.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0067/src/quickfix.c	2016-10-15 19:28:09.239181100 +0200
--- src/quickfix.c	2016-11-05 20:29:05.956598800 +0100
***************
*** 3446,3457 ****
  	case CMD_lgrepadd:  au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 3446,3456 ----
  	case CMD_lgrepadd:  au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 3970,3981 ****
  	case CMD_lgrepadd:    au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
! 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf);
! 	if (did_throw || force_abort)
  	    return;
      }
  #endif
  
--- 3969,3981 ----
  	case CMD_lgrepadd:    au_name = (char_u *)"lgrepadd"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
! # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
+ # endif
      }
  #endif
  
***************
*** 4875,4886 ****
  	case CMD_laddbuffer:	au_name = (char_u *)"laddbuffer"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 4875,4885 ----
  	case CMD_laddbuffer:	au_name = (char_u *)"laddbuffer"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 4966,4977 ****
  	case CMD_laddexpr:  au_name = (char_u *)"laddexpr"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
- 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
- 					       curbuf->b_fname, TRUE, curbuf);
  # ifdef FEAT_EVAL
! 	if (did_throw || force_abort)
  	    return;
  # endif
      }
--- 4965,4975 ----
  	case CMD_laddexpr:  au_name = (char_u *)"laddexpr"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
  # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
  # endif
      }
***************
*** 5042,5053 ****
  	case CMD_lhelpgrep: au_name = (char_u *)"lhelpgrep"; break;
  	default: break;
      }
!     if (au_name != NULL)
      {
! 	apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf);
! 	if (did_throw || force_abort)
  	    return;
      }
  #endif
  
--- 5040,5052 ----
  	case CMD_lhelpgrep: au_name = (char_u *)"lhelpgrep"; break;
  	default: break;
      }
!     if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,
! 					       curbuf->b_fname, TRUE, curbuf))
      {
! # ifdef FEAT_EVAL
! 	if (aborting())
  	    return;
+ # endif
      }
  #endif
  
*** ../vim-8.0.0067/src/if_cscope.c	2016-10-12 14:19:55.746357751 +0200
--- src/if_cscope.c	2016-11-06 14:37:33.399497314 +0100
***************
*** 1178,1189 ****
  	}
  
  # ifdef FEAT_AUTOCMD
! 	if (*qfpos != '0')
  	{
- 	    apply_autocmds(EVENT_QUICKFIXCMDPRE, (char_u *)"cscope",
- 					       curbuf->b_fname, TRUE, curbuf);
  #  ifdef FEAT_EVAL
! 	    if (did_throw || force_abort)
  		return FALSE;
  #  endif
  	}
--- 1178,1189 ----
  	}
  
  # ifdef FEAT_AUTOCMD
! 	if (*qfpos != '0'
! 		&& apply_autocmds(EVENT_QUICKFIXCMDPRE, (char_u *)"cscope",
! 					       curbuf->b_fname, TRUE, curbuf))
  	{
  #  ifdef FEAT_EVAL
! 	    if (aborting())
  		return FALSE;
  #  endif
  	}
*** ../vim-8.0.0067/src/testdir/test_quickfix.vim	2016-10-15 19:28:09.243181069 +0200
--- src/testdir/test_quickfix.vim	2016-11-06 14:40:38.522365572 +0100
***************
*** 1631,1633 ****
--- 1631,1650 ----
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
  endfunction
+ 
+ function! Test_Autocmd_Exception()
+   set efm=%m
+   lgetexpr '?'
+ 
+   try
+     call DoesNotExit()
+   catch
+     lgetexpr '1'
+   finally
+     lgetexpr '1'
+   endtry
+ 
+   call assert_equal('1', getloclist(0)[0].text)
+ 
+   set efm&vim
+ endfunction
*** ../vim-8.0.0067/src/version.c	2016-11-06 14:17:13.182972857 +0100
--- src/version.c	2016-11-06 14:44:51.388820574 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     68,
  /**/

-- 
Engineers understand that their appearance only bothers other people and
therefore it is not worth optimizing.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0069
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0069
Problem:    Compiler warning for self-comparison.
Solution:   Define ONE_WINDOW and add #ifdef.
Files:      src/globals.h, src/buffer.c, src/ex_docmd.c, src/move.c,
            src/screen.c, src/quickfix.c, src/window.c


*** ../vim-8.0.0068/src/globals.h	2016-08-29 22:42:20.000000000 +0200
--- src/globals.h	2016-11-06 15:18:10.068418172 +0100
***************
*** 546,551 ****
--- 546,552 ----
  EXTERN win_T	*firstwin;		/* first window */
  EXTERN win_T	*lastwin;		/* last window */
  EXTERN win_T	*prevwin INIT(= NULL);	/* previous window */
+ # define ONE_WINDOW (firstwin == lastwin)
  # define W_NEXT(wp) ((wp)->w_next)
  # define FOR_ALL_WINDOWS(wp) for (wp = firstwin; wp != NULL; wp = wp->w_next)
  # define FOR_ALL_TABPAGES(tp) for (tp = first_tabpage; tp != NULL; tp = tp->tp_next)
***************
*** 563,568 ****
--- 564,570 ----
  #else
  # define firstwin curwin
  # define lastwin curwin
+ # define ONE_WINDOW 1
  # define W_NEXT(wp) NULL
  # define FOR_ALL_WINDOWS(wp) wp = curwin;
  # define FOR_ALL_TABPAGES(tp) for (;FALSE;)
*** ../vim-8.0.0068/src/buffer.c	2016-10-30 21:57:48.070395594 +0100
--- src/buffer.c	2016-11-06 15:20:32.491532716 +0100
***************
*** 4935,4941 ****
  		    }
  #ifdef FEAT_WINDOWS
  		    /* don't close last window */
! 		    if (firstwin == lastwin
  			    && (first_tabpage->tp_next == NULL || !had_tab))
  #endif
  			use_firstwin = TRUE;
--- 4935,4941 ----
  		    }
  #ifdef FEAT_WINDOWS
  		    /* don't close last window */
! 		    if (ONE_WINDOW
  			    && (first_tabpage->tp_next == NULL || !had_tab))
  #endif
  			use_firstwin = TRUE;
*** ../vim-8.0.0068/src/ex_docmd.c	2016-10-15 15:39:34.685059653 +0200
--- src/ex_docmd.c	2016-11-06 15:21:01.243353096 +0100
***************
*** 7239,7245 ****
  	 * :h|wincmd w|1q     - don't quit
  	 * :h|wincmd w|q      - quit
  	 */
! 	if (only_one_window() && (firstwin == lastwin || eap->addr_count == 0))
  #endif
  	    getout(0);
  #ifdef FEAT_WINDOWS
--- 7239,7245 ----
  	 * :h|wincmd w|1q     - don't quit
  	 * :h|wincmd w|q      - quit
  	 */
! 	if (only_one_window() && (ONE_WINDOW || eap->addr_count == 0))
  #endif
  	    getout(0);
  #ifdef FEAT_WINDOWS
*** ../vim-8.0.0068/src/move.c	2016-10-18 14:50:14.731694041 +0200
--- src/move.c	2016-11-06 15:18:38.896239173 +0100
***************
*** 2311,2317 ****
  #endif
  	if (dir == FORWARD)
  	{
! 	    if (firstwin == lastwin && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling */
  		if (p_window <= 2)
--- 2311,2317 ----
  #endif
  	if (dir == FORWARD)
  	{
! 	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling */
  		if (p_window <= 2)
***************
*** 2361,2367 ****
  		continue;
  	    }
  #endif
! 	    if (firstwin == lastwin && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling (sort of) */
  		if (p_window <= 2)
--- 2361,2367 ----
  		continue;
  	    }
  #endif
! 	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
  		/* Vi compatible scrolling (sort of) */
  		if (p_window <= 2)
*** ../vim-8.0.0068/src/screen.c	2016-10-27 17:27:38.265074170 +0200
--- src/screen.c	2016-11-06 15:21:34.503145348 +0100
***************
*** 1510,1516 ****
  	if (mid_start == 0)
  	{
  	    mid_end = wp->w_height;
! 	    if (lastwin == firstwin)
  	    {
  		/* Clear the screen when it was not done by win_del_lines() or
  		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
--- 1510,1516 ----
  	if (mid_start == 0)
  	{
  	    mid_end = wp->w_height;
! 	    if (ONE_WINDOW)
  	    {
  		/* Clear the screen when it was not done by win_del_lines() or
  		 * win_ins_lines() above, "screen_cleared" is FALSE or MAYBE
***************
*** 5670,5676 ****
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! 		     && W_WIDTH(wp) == Columns)
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
--- 5670,5679 ----
  #ifdef FEAT_DIFF
  		     && filler_todo <= 0
  #endif
! #ifdef FEAT_WINDOWS
! 		     && W_WIDTH(wp) == Columns
! #endif
! 		     )
  	    {
  		/* Remember that the line wraps, used for modeless copy. */
  		LineWraps[screen_row - 1] = TRUE;
***************
*** 10524,10530 ****
       * window differs, or the fillchars differ, or this is not the
       * current window */
      if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
! 			|| !is_curwin || firstwin == lastwin)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
      if (is_curwin)
--- 10527,10533 ----
       * window differs, or the fillchars differ, or this is not the
       * current window */
      if (*attr != 0 && ((hl_attr(HLF_S) != hl_attr(HLF_SNC)
! 			|| !is_curwin || ONE_WINDOW)
  		    || (fill_stl != fill_stlnc)))
  	return fill;
      if (is_curwin)
*** ../vim-8.0.0068/src/quickfix.c	2016-11-06 14:46:40.644143343 +0100
--- src/quickfix.c	2016-11-06 15:21:15.663263021 +0100
***************
*** 2137,2143 ****
  	 * If there is only one window and it is the quickfix window, create a
  	 * new one above the quickfix window.
  	 */
! 	if (((firstwin == lastwin) && bt_quickfix(curbuf)) || !usable_win)
  	{
  	    flags = WSP_ABOVE;
  	    if (ll_ref != NULL)
--- 2137,2143 ----
  	 * If there is only one window and it is the quickfix window, create a
  	 * new one above the quickfix window.
  	 */
! 	if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win)
  	{
  	    flags = WSP_ABOVE;
  	    if (ll_ref != NULL)
*** ../vim-8.0.0068/src/window.c	2016-09-04 17:24:16.000000000 +0200
--- src/window.c	2016-11-06 15:22:39.882737085 +0100
***************
*** 234,240 ****
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (firstwin == lastwin && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
--- 234,240 ----
  /* cursor to previous window with wrap around */
      case 'W':
  		CHECK_CMDWIN
! 		if (ONE_WINDOW && Prenum != 1)	/* just one window */
  		    beep_flush();
  		else
  		{
***************
*** 1593,1599 ****
      frame_T	*frp;
      int		n;
  
!     if (firstwin == lastwin)		/* nothing to do */
      {
  	beep_flush();
  	return;
--- 1593,1599 ----
      frame_T	*frp;
      int		n;
  
!     if (ONE_WINDOW)		/* nothing to do */
      {
  	beep_flush();
  	return;
***************
*** 2206,2212 ****
      }
      return TRUE;
  #else
!     return firstwin == lastwin;
  #endif
  }
  
--- 2206,2212 ----
      }
      return TRUE;
  #else
!     return ONE_WINDOW;
  #endif
  }
  
***************
*** 2220,2226 ****
      int		free_buf,
      tabpage_T   *prev_curtab)
  {
!     if (firstwin == lastwin)
      {
  #ifdef FEAT_AUTOCMD
  	buf_T	*old_curbuf = curbuf;
--- 2220,2226 ----
      int		free_buf,
      tabpage_T   *prev_curtab)
  {
!     if (ONE_WINDOW)
      {
  #ifdef FEAT_AUTOCMD
  	buf_T	*old_curbuf = curbuf;
***************
*** 2625,2631 ****
      /*
       * If there is only one window there is nothing to remove.
       */
!     if (tp == NULL ? firstwin == lastwin : tp->tp_firstwin == tp->tp_lastwin)
  	return NULL;
  
      /*
--- 2625,2631 ----
      /*
       * If there is only one window there is nothing to remove.
       */
!     if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)
  	return NULL;
  
      /*
***************
*** 2780,2786 ****
      frame_T	*frp;
      int		b;
  
!     if (tp == NULL ? firstwin == lastwin : tp->tp_firstwin == tp->tp_lastwin)
  	/* Last window in this tab page, will go to next tab page. */
  	return alt_tabpage()->tp_curwin->w_frame;
  
--- 2780,2786 ----
      frame_T	*frp;
      int		b;
  
!     if (tp == NULL ? ONE_WINDOW : tp->tp_firstwin == tp->tp_lastwin)
  	/* Last window in this tab page, will go to next tab page. */
  	return alt_tabpage()->tp_curwin->w_frame;
  
*** ../vim-8.0.0068/src/version.c	2016-11-06 14:46:40.644143343 +0100
--- src/version.c	2016-11-06 15:24:12.094161516 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     69,
  /**/

-- 
Imagine a world without hypothetical situations.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0070
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0070
Problem:    Tests referred in Makefile that no longer exist.
Solution:   Remove test71 and test74 entries. (Michael Soyka)
Files:      src/testdir/Make_ming.mak


*** ../vim-8.0.0069/src/testdir/Make_ming.mak	2016-08-06 20:34:08.000000000 +0200
--- src/testdir/Make_ming.mak	2016-11-07 22:11:19.136749981 +0100
***************
*** 68,74 ****
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=unix|upd" +q \
! 		dotest.in test60.ok test71.ok test74.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
  clean:
--- 68,74 ----
  fixff:
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=dos|upd" +q *.in *.ok
  	-$(VIMPROG) -u dos.vim $(NO_PLUGIN) "+argdo set ff=unix|upd" +q \
! 		dotest.in test60.ok test_listchars.ok \
  		test_getcwd.ok test_wordcount.ok
  
  clean:
*** ../vim-8.0.0069/src/version.c	2016-11-06 15:25:37.701627423 +0100
--- src/version.c	2016-11-07 22:12:07.920428900 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     70,
  /**/

-- 
The average life of an organization chart is six months.  You can safely
ignore any order from your boss that would take six months to complete.
				(Scott Adams - The Dilbert principle)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0071
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0071
Problem:    Exit value from a shell command is wrong. (Hexchain Tong)
Solution:   Do not check for ended jobs while waiting for a shell command.
            (ichizok, closes #1196)
Files:      src/os_unix.c


*** ../vim-8.0.0070/src/os_unix.c	2016-11-04 20:35:27.352945991 +0100
--- src/os_unix.c	2016-11-07 22:35:15.711318293 +0100
***************
*** 238,243 ****
--- 238,247 ----
  /* volatile because it is used in signal handler deathtrap(). */
  static volatile int in_mch_delay = FALSE;    /* sleeping in mch_delay() */
  
+ #if defined(FEAT_JOB_CHANNEL) && !defined(USE_SYSTEM)
+ static int dont_check_job_ended = 0;
+ #endif
+ 
  static int curr_tmode = TMODE_COOK;	/* contains current terminal mode */
  
  #ifdef USE_XSMP
***************
*** 4485,4491 ****
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
  	    UNBLOCK_SIGNALS(&curset);
! 
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
  	     * This is also used to pipe stdin/stdout to/from the external
--- 4489,4497 ----
  	    catch_signals(SIG_IGN, SIG_ERR);
  	    catch_int_signal();
  	    UNBLOCK_SIGNALS(&curset);
! # ifdef FEAT_JOB_CHANNEL
! 	    ++dont_check_job_ended;
! # endif
  	    /*
  	     * For the GUI we redirect stdin, stdout and stderr to our window.
  	     * This is also used to pipe stdin/stdout to/from the external
***************
*** 5030,5035 ****
--- 5036,5045 ----
  		wait4pid(wpid, NULL);
  	    }
  
+ # ifdef FEAT_JOB_CHANNEL
+ 	    --dont_check_job_ended;
+ # endif
+ 
  	    /*
  	     * Set to raw mode right now, otherwise a CTRL-C after
  	     * catch_signals() will kill Vim.
***************
*** 5363,5368 ****
--- 5373,5386 ----
      pid_t	wait_pid = 0;
      job_T	*job;
  
+ # ifndef USE_SYSTEM
+     /* Do not do this when waiting for a shell command to finish, we would get
+      * the exit value here (and discard it), the exit value obtained there
+      * would then be wrong.  */
+     if (dont_check_job_ended > 0)
+ 	return NULL;
+ # endif
+ 
  # ifdef __NeXT__
      wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);
  # else
*** ../vim-8.0.0070/src/version.c	2016-11-07 22:13:29.171894387 +0100
--- src/version.c	2016-11-07 22:36:59.566637376 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     71,
  /**/

-- 
An operatingsystem is just a name you give to the rest of bloating
idiosyncratic machine-based-features you left out of your editor.
			(author unknown)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0072
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0072
Problem:    MS-Windows: Crash with long font name. (Henry Hu)
Solution:   Fix comparing with LF_FACESIZE. (Ken Takata, closes #1243)
Files:      src/os_mswin.c


*** ../vim-8.0.0071/src/os_mswin.c	2016-10-12 14:19:55.750357722 +0200
--- src/os_mswin.c	2016-11-10 17:09:00.686845213 +0100
***************
*** 2893,2899 ****
       */
      for (p = name; *p && *p != ':'; p++)
      {
! 	if (p - name + 1 > LF_FACESIZE)
  	    goto theend;			/* Name too long */
  	lf->lfFaceName[p - name] = *p;
      }
--- 2893,2899 ----
       */
      for (p = name; *p && *p != ':'; p++)
      {
! 	if (p - name + 1 >= LF_FACESIZE)
  	    goto theend;			/* Name too long */
  	lf->lfFaceName[p - name] = *p;
      }
*** ../vim-8.0.0071/src/version.c	2016-11-07 22:42:48.828350757 +0100
--- src/version.c	2016-11-10 17:10:11.414402898 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     72,
  /**/

-- 
The Feynman problem solving Algorithm:
	1) Write down the problem
	2) Think real hard
	3) Write down the answer

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0073
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0073 (after 8.0.0069)
Problem:    More comparisons between firstwin and lastwin.
Solution:   Use ONE_WINDOW for consistency. (Hirohito Higashi)
Files:      src/buffer.c, src/ex_cmds.c, src/ex_docmd.c, src/option.c,
            src/window.c


*** ../vim-8.0.0072/src/buffer.c	2016-11-06 15:25:37.689627497 +0100
--- src/buffer.c	2016-11-10 17:42:03.550441517 +0100
***************
*** 1412,1418 ****
  # ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
  # endif
! 		   && (firstwin != lastwin || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
--- 1412,1418 ----
  # ifdef FEAT_AUTOCMD
  		   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)
  # endif
! 		   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))
  	{
  	    if (win_close(curwin, FALSE) == FAIL)
  		break;
***************
*** 5140,5146 ****
  			: wp->w_width != Columns)
  		    || (had_tab > 0 && wp != firstwin)
  #endif
! 		    ) && firstwin != lastwin
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
--- 5140,5146 ----
  			: wp->w_width != Columns)
  		    || (had_tab > 0 && wp != firstwin)
  #endif
! 		    ) && !ONE_WINDOW
  #ifdef FEAT_AUTOCMD
  		    && !(wp->w_closing || wp->w_buffer->b_locked > 0)
  #endif
*** ../vim-8.0.0072/src/ex_cmds.c	2016-10-21 20:35:32.632943225 +0200
--- src/ex_cmds.c	2016-11-10 17:42:17.082356600 +0100
***************
*** 4577,4583 ****
      if (eap->forceit)
  	bigness = curwin->w_height;
  #ifdef FEAT_WINDOWS
!     else if (firstwin != lastwin)
  	bigness = curwin->w_height - 3;
  #endif
      else
--- 4577,4583 ----
      if (eap->forceit)
  	bigness = curwin->w_height;
  #ifdef FEAT_WINDOWS
!     else if (!ONE_WINDOW)
  	bigness = curwin->w_height - 3;
  #endif
      else
*** ../vim-8.0.0072/src/ex_docmd.c	2016-11-06 15:25:37.693627473 +0100
--- src/ex_docmd.c	2016-11-10 17:39:17.259485131 +0100
***************
*** 7488,7496 ****
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
!     if (lastwin != firstwin)
  	close_others(TRUE, forceit);
!     if (lastwin == firstwin)
  	ex_win_close(forceit, curwin, NULL);
  # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
--- 7488,7496 ----
  {
      /* First close all the windows but the current one.  If that worked then
       * close the last window in this tab, that will close it. */
!     if (!ONE_WINDOW)
  	close_others(TRUE, forceit);
!     if (ONE_WINDOW)
  	ex_win_close(forceit, curwin, NULL);
  # ifdef FEAT_GUI
      need_mouse_correct = TRUE;
*** ../vim-8.0.0072/src/option.c	2016-11-05 20:13:29.142451833 +0100
--- src/option.c	2016-11-10 17:42:51.762138974 +0100
***************
*** 8551,8557 ****
  	}
  
  	/* Change window height NOW */
! 	if (lastwin != firstwin)
  	{
  	    if (pp == &p_wh && curwin->w_height < p_wh)
  		win_setheight((int)p_wh);
--- 8551,8557 ----
  	}
  
  	/* Change window height NOW */
! 	if (!ONE_WINDOW)
  	{
  	    if (pp == &p_wh && curwin->w_height < p_wh)
  		win_setheight((int)p_wh);
***************
*** 8591,8597 ****
  	}
  
  	/* Change window width NOW */
! 	if (lastwin != firstwin && curwin->w_width < p_wiw)
  	    win_setwidth((int)p_wiw);
      }
  
--- 8591,8597 ----
  	}
  
  	/* Change window width NOW */
! 	if (!ONE_WINDOW && curwin->w_width < p_wiw)
  	    win_setwidth((int)p_wiw);
      }
  
***************
*** 10075,10081 ****
  comp_col(void)
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
!     int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
  
      sc_col = 0;
      ru_col = 0;
--- 10075,10081 ----
  comp_col(void)
  {
  #if defined(FEAT_CMDL_INFO) && defined(FEAT_WINDOWS)
!     int last_has_status = (p_ls == 2 || (p_ls == 1 && !ONE_WINDOW));
  
      sc_col = 0;
      ru_col = 0;
*** ../vim-8.0.0072/src/window.c	2016-11-06 15:25:37.697627447 +0100
--- src/window.c	2016-11-10 17:39:17.263485105 +0100
***************
*** 791,797 ****
  	oldwin = curwin;
  
      /* add a status line when p_ls == 1 and splitting the first window */
!     if (lastwin == firstwin && p_ls == 1 && oldwin->w_status_height == 0)
      {
  	if (oldwin->w_height <= p_wmh && new_wp == NULL)
  	{
--- 791,797 ----
  	oldwin = curwin;
  
      /* add a status line when p_ls == 1 and splitting the first window */
!     if (ONE_WINDOW && p_ls == 1 && oldwin->w_status_height == 0)
      {
  	if (oldwin->w_height <= p_wmh && new_wp == NULL)
  	{
***************
*** 1492,1498 ****
      win_T	*wp2;
      int		temp;
  
!     if (lastwin == firstwin)	    /* just one window */
      {
  	beep_flush();
  	return;
--- 1492,1498 ----
      win_T	*wp2;
      int		temp;
  
!     if (ONE_WINDOW)	    /* just one window */
      {
  	beep_flush();
  	return;
***************
*** 1674,1680 ****
      int		dir;
      int		height = curwin->w_height;
  
!     if (lastwin == firstwin)
      {
  	beep_flush();
  	return;
--- 1674,1680 ----
      int		dir;
      int		height = curwin->w_height;
  
!     if (ONE_WINDOW)
      {
  	beep_flush();
  	return;
***************
*** 2123,2129 ****
  
      ++RedrawingDisabled;
  
!     for (wp = firstwin; wp != NULL && lastwin != firstwin; )
      {
  	if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)
  #ifdef FEAT_AUTOCMD
--- 2123,2129 ----
  
      ++RedrawingDisabled;
  
!     for (wp = firstwin; wp != NULL && !ONE_WINDOW; )
      {
  	if (wp->w_buffer == buf && (!keep_curwin || wp != curwin)
  #ifdef FEAT_AUTOCMD
***************
*** 3373,3379 ****
  	}
      }
  
!     if (message && lastwin != firstwin)
  	EMSG(_("E445: Other window contains changes"));
  }
  
--- 3373,3379 ----
  	}
      }
  
!     if (message && !ONE_WINDOW)
  	EMSG(_("E445: Other window contains changes"));
  }
  
***************
*** 5971,5977 ****
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
! 			  || (p_ls == 1 && (morewin || lastwin != firstwin))));
  }
  
      static void
--- 5971,5977 ----
  {
      /* Don't make a difference between horizontal or vertical split. */
      last_status_rec(topframe, (p_ls == 2
! 			  || (p_ls == 1 && (morewin || !ONE_WINDOW))));
  }
  
      static void
*** ../vim-8.0.0072/src/version.c	2016-11-10 17:10:47.494177267 +0100
--- src/version.c	2016-11-10 17:39:46.535301392 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     73,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
11. You find yourself typing "com" after every period when using a word
    processor.com

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0074
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0074
Problem:    Cannot make Vim fail on an internal error.
Solution:   Add IEMSG() and IEMSG2(). (Domenique Pelle)  Avoid reporting an
            internal error without mentioning where.
Files:      src/globals.h, src/blowfish.c, src/dict.c, src/edit.c, src/eval.c,
            src/evalfunc.c, src/ex_eval.c, src/getchar.c, src/gui_beval.c,
            src/gui_w32.c, src/hangulin.c, src/hashtab.c, src/if_cscope.c,
            src/json.c, src/memfile.c, src/memline.c, src/message.c,
            src/misc2.c, src/option.c, src/quickfix.c, src/regexp.c,
            src/spell.c, src/undo.c, src/userfunc.c, src/vim.h, src/window.c,
            src/proto/misc2.pro, src/proto/message.pro, src/Makefile


*** ../vim-8.0.0073/src/globals.h	2016-11-06 15:25:37.689627497 +0100
--- src/globals.h	2016-11-10 18:19:43.448260941 +0100
***************
*** 1440,1445 ****
--- 1440,1446 ----
  EXTERN char_u e_fontwidth[]	INIT(= N_("E236: Font \"%s\" is not fixed-width"));
  #endif
  EXTERN char_u e_internal[]	INIT(= N_("E473: Internal error"));
+ EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_interr[]	INIT(= N_("Interrupted"));
  EXTERN char_u e_invaddr[]	INIT(= N_("E14: Invalid address"));
  EXTERN char_u e_invarg[]	INIT(= N_("E474: Invalid argument"));
***************
*** 1589,1595 ****
  EXTERN char_u e_guarded[]	INIT(= N_("E463: Region is guarded, cannot modify"));
  EXTERN char_u e_nbreadonly[]	INIT(= N_("E744: NetBeans does not allow changes in read-only files"));
  #endif
- EXTERN char_u e_intern2[]	INIT(= N_("E685: Internal error: %s"));
  EXTERN char_u e_maxmempat[]	INIT(= N_("E363: pattern uses more memory than 'maxmempattern'"));
  EXTERN char_u e_emptybuf[]	INIT(= N_("E749: empty buffer"));
  EXTERN char_u e_nobufnr[]	INIT(= N_("E86: Buffer %ld does not exist"));
--- 1590,1595 ----
*** ../vim-8.0.0073/src/blowfish.c	2016-08-29 22:42:20.000000000 +0200
--- src/blowfish.c	2016-11-10 18:24:37.542411483 +0100
***************
*** 426,432 ****
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	EMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
--- 426,432 ----
      keylen = (int)STRLEN(key) / 2;
      if (keylen == 0)
      {
! 	IEMSG(_("E831: bf_key_init() called with empty password"));
  	return;
      }
      for (i = 0; i < keylen; i++)
*** ../vim-8.0.0073/src/dict.c	2016-08-29 22:42:20.000000000 +0200
--- src/dict.c	2016-11-10 18:30:42.356117872 +0100
***************
*** 214,220 ****
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	EMSG2(_(e_intern2), "dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
--- 214,220 ----
  
      hi = hash_find(&dict->dv_hashtab, item->di_key);
      if (HASHITEM_EMPTY(hi))
! 	internal_error("dictitem_remove()");
      else
  	hash_remove(&dict->dv_hashtab, hi);
      dictitem_free(item);
*** ../vim-8.0.0073/src/edit.c	2016-10-18 13:06:33.377547323 +0200
--- src/edit.c	2016-11-10 19:21:36.688859519 +0100
***************
*** 2299,2305 ****
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     EMSG(_(e_internal));
      return FALSE;
  }
  
--- 2299,2305 ----
  	case CTRL_X_EVAL:
  	    return (c == Ctrl_P || c == Ctrl_N);
      }
!     internal_error("vim_is_ctrl_x_key()");
      return FALSE;
  }
  
***************
*** 5431,5437 ****
  	}
  	else
  	{
! 	    EMSG2(_(e_intern2), "ins_complete()");
  	    return FAIL;
  	}
  
--- 5431,5437 ----
  	}
  	else
  	{
! 	    internal_error("ins_complete()");
  	    return FAIL;
  	}
  
*** ../vim-8.0.0073/src/eval.c	2016-10-09 17:27:56.863388510 +0200
--- src/eval.c	2016-11-10 18:31:29.847819176 +0100
***************
*** 839,845 ****
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    EMSG2(_(e_intern2), "restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
--- 839,845 ----
      {
  	hi = hash_find(&vimvarht, vimvars[idx].vv_di.di_key);
  	if (HASHITEM_EMPTY(hi))
! 	    internal_error("restore_vimvar()");
  	else
  	    hash_remove(&vimvarht, hi);
      }
***************
*** 1308,1314 ****
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    EMSG2(_(e_intern2), "ex_let_vars()");
  	    return FAIL;
  	}
      }
--- 1308,1314 ----
  	}
  	else if (*arg != ',' && *arg != ']')
  	{
! 	    internal_error("ex_let_vars()");
  	    return FAIL;
  	}
      }
***************
*** 2830,2836 ****
  	    }
  	    if (d == NULL)
  	    {
! 		EMSG2(_(e_intern2), "do_unlet()");
  		return FAIL;
  	    }
  	}
--- 2830,2836 ----
  	    }
  	    if (d == NULL)
  	    {
! 		internal_error("do_unlet()");
  		return FAIL;
  	    }
  	}
***************
*** 5678,5684 ****
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     EMSG2(_(e_intern2), "get_var_special_name()");
      return "42";
  }
  
--- 5678,5684 ----
  	case VVAL_NONE:  return "v:none";
  	case VVAL_NULL:  return "v:null";
      }
!     internal_error("get_var_special_name()");
      return "42";
  }
  
***************
*** 7152,7158 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
--- 7152,7158 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_number(UNKNOWN)");
  	    break;
      }
      if (denote == NULL)		/* useful for values that must be unsigned */
***************
*** 7199,7205 ****
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
--- 7199,7205 ----
  	    break;
  # endif
  	case VAR_UNKNOWN:
! 	    internal_error("get_tv_float(UNKNOWN)");
  	    break;
      }
      return 0;
***************
*** 7733,7739 ****
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		EMSG2(_(e_intern2), "set_var()");
  	}
  
  	clear_tv(&v->di_tv);
--- 7733,7739 ----
  		return;
  	    }
  	    else if (v->di_tv.v_type != tv->v_type)
! 		internal_error("set_var()");
  	}
  
  	clear_tv(&v->di_tv);
***************
*** 7962,7968 ****
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "copy_tv(UNKNOWN)");
  	    break;
      }
  }
--- 7962,7968 ----
  	    }
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("copy_tv(UNKNOWN)");
  	    break;
      }
  }
***************
*** 8036,8042 ****
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
--- 8036,8042 ----
  		ret = FAIL;
  	    break;
  	case VAR_UNKNOWN:
! 	    internal_error("item_copy(UNKNOWN)");
  	    ret = FAIL;
      }
      --recurse;
*** ../vim-8.0.0073/src/evalfunc.c	2016-10-15 17:06:42.090912729 +0200
--- src/evalfunc.c	2016-11-10 18:31:36.215779091 +0100
***************
*** 2644,2650 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
--- 2644,2650 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("f_empty(UNKNOWN)");
  	    n = TRUE;
  	    break;
      }
***************
*** 12695,12701 ****
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     EMSG2(_(e_intern2), "f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
--- 12695,12701 ----
  	case VAR_JOB:     n = VAR_TYPE_JOB; break;
  	case VAR_CHANNEL: n = VAR_TYPE_CHANNEL; break;
  	case VAR_UNKNOWN:
! 	     internal_error("f_type(UNKNOWN)");
  	     n = -1;
  	     break;
      }
*** ../vim-8.0.0073/src/ex_eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/ex_eval.c	2016-11-10 19:26:49.226873434 +0100
***************
*** 595,601 ****
  
      if (excp == NULL)
      {
! 	EMSG(_(e_internal));
  	return;
      }
  
--- 595,601 ----
  
      if (excp == NULL)
      {
! 	internal_error("discard_exception()");
  	return;
      }
  
***************
*** 700,706 ****
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	EMSG(_(e_internal));
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
--- 700,706 ----
  finish_exception(except_T *excp)
  {
      if (excp != caught_stack)
! 	internal_error("finish_exception()");
      caught_stack = caught_stack->caught;
      if (caught_stack != NULL)
      {
***************
*** 1603,1609 ****
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		EMSG(_(e_internal));
  	}
  	else
  	{
--- 1603,1609 ----
  	     * ":break", ":return", ":finish", error, interrupt, or another
  	     * exception. */
  	    if (cstack->cs_exception[cstack->cs_idx] != current_exception)
! 		internal_error("ex_catch()");
  	}
  	else
  	{
***************
*** 1737,1743 ****
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    EMSG(_(e_internal));
  	    }
  
  	    /*
--- 1737,1743 ----
  		 * exception will be discarded. */
  		if (did_throw && cstack->cs_exception[cstack->cs_idx]
  							 != current_exception)
! 		    internal_error("ex_finally()");
  	    }
  
  	    /*
*** ../vim-8.0.0073/src/getchar.c	2016-08-29 22:42:20.000000000 +0200
--- src/getchar.c	2016-11-10 18:31:44.727725510 +0100
***************
*** 250,256 ****
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	EMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
--- 250,256 ----
      }
      else if (buf->bh_curr == NULL)	/* buffer has already been read */
      {
! 	IEMSG(_("E222: Add to read buffer"));
  	return;
      }
      else if (buf->bh_index != 0)
***************
*** 1321,1331 ****
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	EMSG2(_(e_intern2), "Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
--- 1321,1331 ----
  free_typebuf(void)
  {
      if (typebuf.tb_buf == typebuf_init)
! 	internal_error("Free typebuf 1");
      else
  	vim_free(typebuf.tb_buf);
      if (typebuf.tb_noremap == noremapbuf_init)
! 	internal_error("Free typebuf 2");
      else
  	vim_free(typebuf.tb_noremap);
  }
***************
*** 4868,4874 ****
  			c1 = 'l';
  			break;
  		    default:
! 			EMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
--- 4868,4874 ----
  			c1 = 'l';
  			break;
  		    default:
! 			IEMSG(_("E228: makemap: Illegal mode"));
  			return FAIL;
  		}
  		do	/* do this twice if c2 is set, 3 times with c3 */
*** ../vim-8.0.0073/src/gui_beval.c	2016-09-09 22:00:25.000000000 +0200
--- src/gui_beval.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 218,224 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 218,224 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/gui_w32.c	2016-10-12 14:19:55.746357751 +0200
--- src/gui_w32.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 8620,8626 ****
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	EMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
--- 8620,8626 ----
  
      if (mesg != NULL && mesgCB != NULL)
      {
! 	IEMSG(_("E232: Cannot create BalloonEval with both message and callback"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/hangulin.c	2016-08-29 22:42:20.000000000 +0200
--- src/hangulin.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 590,596 ****
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    EMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
--- 590,596 ----
  	    return AUTOMATA_CORRECT_NEW;
  
  	default:
! 	    IEMSG(_("E256: Hangul automata ERROR"));
  	    break;
      }
      return AUTOMATA_ERROR; /* RrEeAaLlLlYy EeRrRrOoRr */
*** ../vim-8.0.0073/src/hashtab.c	2016-08-29 22:42:20.000000000 +0200
--- src/hashtab.c	2016-11-10 18:31:48.775700031 +0100
***************
*** 210,216 ****
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	EMSG2(_(e_intern2), "hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
--- 210,216 ----
      hi = hash_lookup(ht, key, hash);
      if (!HASHITEM_EMPTY(hi))
      {
! 	internal_error("hash_add()");
  	return FAIL;
      }
      return hash_add_item(ht, hi, key, hash);
*** ../vim-8.0.0073/src/if_cscope.c	2016-11-06 14:46:40.644143343 +0100
--- src/if_cscope.c	2016-11-10 19:59:00.346602378 +0100
***************
*** 1792,1798 ****
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	(void)EMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
--- 1792,1798 ----
  	cs_print_tags_priv(mp, cp, cnt);
  	break;
      default:	/* should not reach here */
! 	IEMSG(_("E570: fatal error in cs_manage_matches"));
  	return NULL;
      }
  
*** ../vim-8.0.0073/src/json.c	2016-11-06 14:17:13.182972857 +0100
--- src/json.c	2016-11-10 18:31:52.663675557 +0100
***************
*** 328,334 ****
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    EMSG2(_(e_intern2), "json_encode_item()");
  	    return FAIL;
      }
      return OK;
--- 328,334 ----
  	    break;
  #endif
  	case VAR_UNKNOWN:
! 	    internal_error("json_encode_item()");
  	    return FAIL;
      }
      return OK;
*** ../vim-8.0.0073/src/memfile.c	2016-08-29 22:42:20.000000000 +0200
--- src/memfile.c	2016-11-10 18:24:37.550411433 +0100
***************
*** 482,488 ****
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	EMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
--- 482,488 ----
      flags = hp->bh_flags;
  
      if ((flags & BH_LOCKED) == 0)
! 	IEMSG(_("E293: block was not locked"));
      flags &= ~BH_LOCKED;
      if (dirty)
      {
*** ../vim-8.0.0073/src/memline.c	2016-08-29 22:42:20.000000000 +0200
--- src/memline.c	2016-11-10 19:28:51.582093727 +0100
***************
*** 333,339 ****
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	EMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
--- 333,339 ----
  	goto error;
      if (hp->bh_bnum != 0)
      {
! 	IEMSG(_("E298: Didn't get block nr 0?"));
  	goto error;
      }
      b0p = (ZERO_BL *)(hp->bh_data);
***************
*** 383,389 ****
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	EMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
--- 383,389 ----
  	goto error;
      if (hp->bh_bnum != 1)
      {
! 	IEMSG(_("E298: Didn't get block nr 1?"));
  	goto error;
      }
      pp = (PTR_BL *)(hp->bh_data);
***************
*** 401,407 ****
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	EMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
--- 401,407 ----
  	goto error;
      if (hp->bh_bnum != 2)
      {
! 	IEMSG(_("E298: Didn't get block nr 2?"));
  	goto error;
      }
  
***************
*** 950,956 ****
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	EMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
--- 950,956 ----
  
      b0p = (ZERO_BL *)(hp->bh_data);
      if (ml_check_b0_id(b0p) == FAIL)
! 	IEMSG(_("E304: ml_upd_block0(): Didn't get block 0??"));
      else
      {
  	if (what == UB_FNAME)
***************
*** 2450,2456 ****
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    EMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
--- 2450,2456 ----
  	    /* Avoid giving this message for a recursive call, may happen when
  	     * the GUI redraws part of the text. */
  	    ++recursive;
! 	    IEMSGN(_("E315: ml_get: invalid lnum: %ld"), lnum);
  	    --recursive;
  	}
  errorret:
***************
*** 2485,2491 ****
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		EMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
--- 2485,2491 ----
  		/* Avoid giving this message for a recursive call, may happen
  		 * when the GUI redraws part of the text. */
  		++recursive;
! 		IEMSGN(_("E316: ml_get: cannot find line %ld"), lnum);
  		--recursive;
  	    }
  	    goto errorret;
***************
*** 2900,2906 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 2900,2906 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 3"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3042,3048 ****
  	 */
  	if (stack_idx < 0)
  	{
! 	    EMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
--- 3042,3048 ----
  	 */
  	if (stack_idx < 0)
  	{
! 	    IEMSG(_("E318: Updated too many blocks?"));
  	    buf->b_ml.ml_stack_top = 0;	/* invalidate stack */
  	}
      }
***************
*** 3220,3226 ****
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		EMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
--- 3220,3226 ----
  	    pp = (PTR_BL *)(hp->bh_data);   /* must be pointer block */
  	    if (pp->pb_id != PTR_ID)
  	    {
! 		IEMSG(_("E317: pointer block id wrong 4"));
  		mf_put(mfp, hp, FALSE, FALSE);
  		return FAIL;
  	    }
***************
*** 3432,3438 ****
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    EMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
--- 3432,3438 ----
  
  	hp = ml_find_line(buf, lnum, ML_FIND);
  	if (hp == NULL)
! 	    IEMSGN(_("E320: Cannot find line %ld"), lnum);
  	else
  	{
  	    dp = (DATA_BL *)(hp->bh_data);
***************
*** 3674,3680 ****
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    EMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
--- 3674,3680 ----
  	pp = (PTR_BL *)(dp);		/* must be pointer block */
  	if (pp->pb_id != PTR_ID)
  	{
! 	    IEMSG(_("E317: pointer block id wrong"));
  	    goto error_block;
  	}
  
***************
*** 3719,3729 ****
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		EMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		EMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
--- 3719,3729 ----
  	if (idx >= (int)pp->pb_count)	    /* past the end: something wrong! */
  	{
  	    if (lnum > buf->b_ml.ml_line_count)
! 		IEMSGN(_("E322: line number out of range: %ld past the end"),
  					      lnum - buf->b_ml.ml_line_count);
  
  	    else
! 		IEMSGN(_("E323: line count wrong in block %ld"), bnum);
  	    goto error_block;
  	}
  	if (action == ML_DELETE)
***************
*** 3817,3823 ****
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    EMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
--- 3817,3823 ----
  	if (pp->pb_id != PTR_ID)
  	{
  	    mf_put(mfp, hp, FALSE, FALSE);
! 	    IEMSG(_("E317: pointer block id wrong 2"));
  	    break;
  	}
  	pp->pb_pointer[ip->ip_index].pe_line_count += count;
*** ../vim-8.0.0073/src/message.c	2016-09-09 14:10:47.000000000 +0200
--- src/message.c	2016-11-10 19:31:12.797194172 +0100
***************
*** 662,667 ****
--- 662,668 ----
      return msg_attr(s, attr);
  }
  
+ 
  /*
   * Print an error message with one "%s" and one string argument.
   */
***************
*** 671,676 ****
--- 672,755 ----
      return emsg3(s, a1, NULL);
  }
  
+ /*
+  * Print an error message with one or two "%s" and one or two string arguments.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsg3(char_u *s, char_u *a1, char_u *a2)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Print an error message with one "%ld" and one long int argument.
+  * This is not in message.c to avoid a warning for prototypes.
+  */
+     int
+ emsgn(char_u *s, long n)
+ {
+     if (emsg_not_now())
+ 	return TRUE;		/* no error messages at the moment */
+     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
+     return emsg(IObuff);
+ }
+ 
+ /*
+  * Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg(char_u *s)
+ {
+     msg(s);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ 
+ /*
+  * Same as emsg2(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsg2(char_u *s, char_u *a1)
+ {
+     emsg2(s, a1);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Same as emsgn(...) but abort on error when ABORT_ON_INTERNAL_ERROR is
+  * defined. It is used for internal errors only, so that they can be
+  * detected when fuzzing vim.
+  */
+     void
+ iemsgn(char_u *s, long n)
+ {
+     emsgn(s, n);
+ #ifdef ABORT_ON_INTERNAL_ERROR
+     abort();
+ #endif
+ }
+ 
+ /*
+  * Give an "Internal error" message.
+  */
+     void
+ internal_error(char *where)
+ {
+     IEMSG2(_(e_intern2), where);
+ }
+ 
  /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
  
      void
*** ../vim-8.0.0073/src/misc2.c	2016-10-30 21:57:48.074395566 +0100
--- src/misc2.c	2016-11-10 18:25:56.829912944 +0100
***************
*** 918,924 ****
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	EMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
--- 918,924 ----
      {
  	/* Don't hide this message */
  	emsg_silent = 0;
! 	IEMSGN(_("E341: Internal error: lalloc(%ld, )"), size);
  	return NULL;
      }
  
***************
*** 1075,1081 ****
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (firstwin != lastwin)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
--- 1075,1081 ----
      p_ea = FALSE;
      if (first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
!     if (!ONE_WINDOW)
  	do_cmdline_cmd((char_u *)"only!");
  # endif
  
***************
*** 6040,6071 ****
  }
  #endif
  
- /*
-  * Print an error message with one or two "%s" and one or two string arguments.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsg3(char_u *s, char_u *a1, char_u *a2)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, a1, a2);
-     return emsg(IObuff);
- }
- 
- /*
-  * Print an error message with one "%ld" and one long int argument.
-  * This is not in message.c to avoid a warning for prototypes.
-  */
-     int
- emsgn(char_u *s, long n)
- {
-     if (emsg_not_now())
- 	return TRUE;		/* no error messages at the moment */
-     vim_snprintf((char *)IObuff, IOSIZE, (char *)s, n);
-     return emsg(IObuff);
- }
- 
  #if defined(FEAT_SPELL) || defined(FEAT_PERSISTENT_UNDO) || defined(PROTO)
  /*
   * Read 2 bytes from "fd" and turn them into an int, MSB first.
--- 6040,6045 ----
*** ../vim-8.0.0073/src/option.c	2016-11-10 18:16:30.081477202 +0100
--- src/option.c	2016-11-10 18:32:36.615398904 +0100
***************
*** 5615,5621 ****
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     EMSG2(_(e_intern2), "was_set_insecurely()");
      return -1;
  }
  
--- 5615,5621 ----
  	flagp = insecure_flag(idx, opt_flags);
  	return (*flagp & P_INSECURE) != 0;
      }
!     internal_error("was_set_insecurely()");
      return -1;
  }
  
***************
*** 5696,5702 ****
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    EMSG2(_("For option %s"), name);
  	    return;
  	}
      }
--- 5696,5702 ----
  	if (idx < 0)	/* not found (should not happen) */
  	{
  	    EMSG2(_(e_intern2), "set_string_option_direct()");
! 	    IEMSG2(_("For option %s"), name);
  	    return;
  	}
      }
***************
*** 9375,9381 ****
  		    ret = NULL;
  		break;
  	    default:
! 		EMSG2(_(e_intern2), "option_iter_next()");
  		return NULL;
  	}
      }
--- 9375,9381 ----
  		    ret = NULL;
  		break;
  	    default:
! 		internal_error("option_iter_next()");
  		return NULL;
  	}
      }
***************
*** 10496,10502 ****
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	EMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
--- 10496,10502 ----
  #ifdef FEAT_SIGNS
  	case PV_SCL:	return (char_u *)&(curwin->w_p_scl);
  #endif
! 	default:	IEMSG(_("E356: get_varp ERROR"));
      }
      /* always return a valid pointer to avoid a crash! */
      return (char_u *)&(curbuf->b_p_wm);
*** ../vim-8.0.0073/src/quickfix.c	2016-11-06 15:25:37.697627447 +0100
--- src/quickfix.c	2016-11-10 18:32:41.083370781 +0100
***************
*** 3231,3237 ****
      {
  	if (buf != curbuf)
  	{
! 	    EMSG2(_(e_intern2), "qf_fill_buffer()");
  	    return;
  	}
  
--- 3231,3237 ----
      {
  	if (buf != curbuf)
  	{
! 	    internal_error("qf_fill_buffer()");
  	    return;
  	}
  
*** ../vim-8.0.0073/src/regexp.c	2016-10-02 16:51:32.744592886 +0200
--- src/regexp.c	2016-11-10 19:30:29.309471156 +0100
***************
*** 335,345 ****
--- 335,347 ----
  /* Used for an error (down from) vim_regcomp(): give the error message, set
   * rc_did_emsg and return NULL */
  #define EMSG_RET_NULL(m) return (EMSG(m), rc_did_emsg = TRUE, (void *)NULL)
+ #define IEMSG_RET_NULL(m) return (IEMSG(m), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG_RET_FAIL(m) return (EMSG(m), rc_did_emsg = TRUE, FAIL)
  #define EMSG2_RET_NULL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, (void *)NULL)
  #define EMSG2_RET_FAIL(m, c) return (EMSG2((m), (c) ? "" : "\\"), rc_did_emsg = TRUE, FAIL)
  #define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_("E369: invalid item in %s%%[]"), reg_magic == MAGIC_ALL)
  
+ 
  #define MAX_LIMIT	(32767L << 16L)
  
  static int re_multi_type(int);
***************
*** 2043,2049 ****
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	EMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
--- 2045,2051 ----
        case Magic(')'):
  	if (one_exactly)
  	    EMSG_ONE_RET_NULL;
! 	IEMSG_RET_NULL(_(e_internal));	/* Supposed to be caught earlier. */
  	/* NOTREACHED */
  
        case Magic('='):
***************
*** 5070,5076 ****
  		}
  		else
  		{
! 		    EMSG(_(e_internal));	    /* Shouldn't happen */
  		    status = RA_FAIL;
  		}
  	    }
--- 5072,5078 ----
  		}
  		else
  		{
! 		    internal_error("BRACE_LIMITS");
  		    status = RA_FAIL;
  		}
  	    }
*** ../vim-8.0.0073/src/spell.c	2016-10-15 17:06:42.090912729 +0200
--- src/spell.c	2016-11-10 18:32:45.507342935 +0100
***************
*** 6428,6434 ****
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	EMSG2(_(e_intern2), "add_sound_suggest()");
  	return;
      }
  
--- 6428,6434 ----
      sfwordnr = soundfold_find(slang, goodword);
      if (sfwordnr < 0)
      {
! 	internal_error("add_sound_suggest()");
  	return;
      }
  
*** ../vim-8.0.0073/src/undo.c	2016-11-05 14:58:30.767225798 +0100
--- src/undo.c	2016-11-10 18:33:12.555172690 +0100
***************
*** 2582,2588 ****
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		EMSG2(_(e_intern2), "undo_time()");
  		break;
  	    }
  	}
--- 2582,2588 ----
  	    if (uhp == NULL || uhp->uh_walk != mark)
  	    {
  		/* Need to redo more but can't find it... */
! 		internal_error("undo_time()");
  		break;
  	    }
  	}
***************
*** 2654,2660 ****
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    EMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
--- 2654,2660 ----
  #ifdef FEAT_AUTOCMD
  	    unblock_autocmds();
  #endif
! 	    IEMSG(_("E438: u_undo: line numbers wrong"));
  	    changed();		/* don't want UNCHANGED now */
  	    return;
  	}
***************
*** 3234,3240 ****
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	EMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
--- 3234,3240 ----
  {
      if (curbuf->b_u_newhead == NULL || curbuf->b_u_newhead->uh_entry == NULL)
      {
! 	IEMSG(_("E439: undo list corrupt"));
  	return NULL;
      }
      return curbuf->b_u_newhead->uh_entry;
***************
*** 3266,3272 ****
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    EMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
--- 3266,3272 ----
  	uep->ue_bot = uep->ue_top + uep->ue_size + 1 + extra;
  	if (uep->ue_bot < 1 || uep->ue_bot > curbuf->b_ml.ml_line_count)
  	{
! 	    IEMSG(_("E440: undo line missing"));
  	    uep->ue_bot = uep->ue_top + 1;  /* assume all lines deleted, will
  					     * get all the old lines back
  					     * without deleting the current
*** ../vim-8.0.0073/src/userfunc.c	2016-08-29 22:42:21.000000000 +0200
--- src/userfunc.c	2016-11-10 18:33:33.335041901 +0100
***************
*** 2771,2777 ****
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    EMSG2(_(e_intern2), "func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
--- 2771,2777 ----
  #ifdef EXITFREE
  	if (!entered_free_all_mem)
  #endif
! 	    internal_error("func_unref()");
      }
      if (fp != NULL && --fp->uf_refcount <= 0)
      {
***************
*** 2814,2820 ****
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	EMSG2(_(e_intern2), "func_ref()");
  }
  
  /*
--- 2814,2820 ----
      else if (isdigit(*name))
  	/* Only give an error for a numbered function.
  	 * Fail silently, when named or lambda function isn't found. */
! 	internal_error("func_ref()");
  }
  
  /*
*** ../vim-8.0.0073/src/vim.h	2016-10-15 19:33:47.264689748 +0200
--- src/vim.h	2016-11-10 18:24:37.562411357 +0100
***************
*** 1623,1628 ****
--- 1623,1631 ----
  #define EMSG3(s, p, q)		    emsg3((char_u *)(s), (char_u *)(p), (char_u *)(q))
  #define EMSGN(s, n)		    emsgn((char_u *)(s), (long)(n))
  #define EMSGU(s, n)		    emsgu((char_u *)(s), (long_u)(n))
+ #define IEMSG(s)		    iemsg((char_u *)(s))
+ #define IEMSG2(s, p)		    iemsg2((char_u *)(s), (char_u *)(p))
+ #define IEMSGN(s, n)		    iemsgn((char_u *)(s), (long)(n))
  #define OUT_STR(s)		    out_str((char_u *)(s))
  #define OUT_STR_NF(s)		    out_str_nf((char_u *)(s))
  #define MSG_PUTS(s)		    msg_puts((char_u *)(s))
*** ../vim-8.0.0073/src/window.c	2016-11-10 18:16:30.085477176 +0100
--- src/window.c	2016-11-10 18:33:40.198998700 +0100
***************
*** 2538,2544 ****
  		;
  	    if (ptp == NULL)
  	    {
! 		EMSG2(_(e_intern2), "win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
--- 2538,2544 ----
  		;
  	    if (ptp == NULL)
  	    {
! 		internal_error("win_close_othertab()");
  		return;
  	    }
  	    ptp->tp_next = tp->tp_next;
*** ../vim-8.0.0073/src/proto/misc2.pro	2016-09-12 13:04:13.000000000 +0200
--- src/proto/misc2.pro	2016-11-10 18:33:58.170885586 +0100
***************
*** 99,106 ****
  void sort_strings(char_u **files, int count);
  int pathcmp(const char *p, const char *q, int maxlen);
  int filewritable(char_u *fname);
- int emsg3(char_u *s, char_u *a1, char_u *a2);
- int emsgn(char_u *s, long n);
  int get2c(FILE *fd);
  int get3c(FILE *fd);
  int get4c(FILE *fd);
--- 99,104 ----
*** ../vim-8.0.0073/src/proto/message.pro	2016-09-12 13:04:12.000000000 +0200
--- src/proto/message.pro	2016-11-10 19:31:16.885168138 +0100
***************
*** 11,16 ****
--- 11,22 ----
  void do_perror(char *msg);
  int emsg(char_u *s);
  int emsg2(char_u *s, char_u *a1);
+ int emsg3(char_u *s, char_u *a1, char_u *a2);
+ int emsgn(char_u *s, long n);
+ void iemsg(char_u *s);
+ void iemsg2(char_u *s, char_u *a1);
+ void iemsgn(char_u *s, long n);
+ void internal_error(char *where);
  void emsg_invreg(int name);
  char_u *msg_trunc_attr(char_u *s, int force, int attr);
  char_u *msg_may_trunc(int force, char_u *s);
*** ../vim-8.0.0073/src/Makefile	2016-10-15 17:06:42.094912699 +0200
--- src/Makefile	2016-11-10 19:56:03.919720882 +0100
***************
*** 681,686 ****
--- 681,690 ----
  #LEAK_CFLAGS = -DEXITFREE
  #LEAK_LIBS = -lccmalloc
  
+ # Uncomment this line to have Vim call abort() when an internal error is
+ # detected.  Useful when using a tool to find errors.
+ #ABORT_CLFAGS = -DABORT_ON_INTERNAL_ERROR
+ 
  #####################################################
  ###  Specific systems, check if yours is listed!  ### {{{
  #####################################################
***************
*** 1409,1415 ****
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
--- 1413,1419 ----
  PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
  POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(EXTRA_DEFS)
  
! ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(SANITIZER_CFLAGS) $(LEAK_CFLAGS) $(ABORT_CLFAGS) $(POST_DEFS)
  
  # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
  # with "-E".
*** ../vim-8.0.0073/src/version.c	2016-11-10 18:16:30.085477176 +0100
--- src/version.c	2016-11-10 19:41:18.085342236 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     74,
  /**/

-- 
Me?  A skeptic?  I trust you have proof.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0075
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0075
Problem:    Using number for exception type lacks type checking.
Solution:   Use an enum.
Files:      src/structs.h, src/ex_docmd.c, src/ex_eval.c,
            src/proto/ex_eval.pro


*** ../vim-8.0.0074/src/structs.h	2016-10-27 21:13:04.886665573 +0200
--- src/structs.h	2016-11-10 20:12:36.997428856 +0100
***************
*** 815,827 ****
  };
  
  /*
   * Structure describing an exception.
   * (don't use "struct exception", it's used by the math library).
   */
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     int			type;		/* exception type */
      char_u		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
--- 815,837 ----
  };
  
  /*
+  * The exception types.
+  */
+ typedef enum
+ {
+     ET_USER,		/* exception caused by ":throw" command */
+     ET_ERROR,		/* error exception */
+     ET_INTERRUPT	/* interrupt exception triggered by Ctrl-C */
+ } except_type_T;
+ 
+ /*
   * Structure describing an exception.
   * (don't use "struct exception", it's used by the math library).
   */
  typedef struct vim_exception except_T;
  struct vim_exception
  {
!     except_type_T	type;		/* exception type */
      char_u		*value;		/* exception value */
      struct msglist	*messages;	/* message(s) causing error exception */
      char_u		*throw_name;	/* name of the throw point */
***************
*** 830,842 ****
  };
  
  /*
-  * The exception types.
-  */
- #define ET_USER		0	/* exception caused by ":throw" command */
- #define ET_ERROR	1	/* error exception */
- #define ET_INTERRUPT	2	/* interrupt exception triggered by Ctrl-C */
- 
- /*
   * Structure to save the error/interrupt/exception state between calls to
   * enter_cleanup() and leave_cleanup().  Must be allocated as an automatic
   * variable by the (common) caller of these functions.
--- 840,845 ----
*** ../vim-8.0.0074/src/ex_docmd.c	2016-11-10 18:16:30.081477202 +0100
--- src/ex_docmd.c	2016-11-10 20:09:12.926721098 +0100
***************
*** 1388,1395 ****
  		    break;
  		case ET_INTERRUPT:
  		    break;
- 		default:
- 		    p = vim_strsave((char_u *)_(e_internal));
  	    }
  
  	    saved_sourcing_name = sourcing_name;
--- 1388,1393 ----
*** ../vim-8.0.0074/src/ex_eval.c	2016-11-10 20:01:41.189582944 +0100
--- src/ex_eval.c	2016-11-10 20:10:32.982214119 +0100
***************
*** 16,22 ****
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static void	free_msglist(struct msglist *l);
! static int	throw_exception(void *, int, char_u *);
  static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
--- 16,22 ----
  #if defined(FEAT_EVAL) || defined(PROTO)
  
  static void	free_msglist(struct msglist *l);
! static int	throw_exception(void *, except_type_T, char_u *);
  static char_u	*get_end_emsg(struct condstack *cstack);
  
  /*
***************
*** 422,428 ****
      char_u *
  get_exception_string(
      void	*value,
!     int		type,
      char_u	*cmdname,
      int		*should_free)
  {
--- 422,428 ----
      char_u *
  get_exception_string(
      void	*value,
!     except_type_T type,
      char_u	*cmdname,
      int		*should_free)
  {
***************
*** 503,509 ****
   * error exception.
   */
      static int
! throw_exception(void *value, int type, char_u *cmdname)
  {
      except_T	*excp;
      int		should_free;
--- 503,509 ----
   * error exception.
   */
      static int
! throw_exception(void *value, except_type_T type, char_u *cmdname)
  {
      except_T	*excp;
      int		should_free;
*** ../vim-8.0.0074/src/proto/ex_eval.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_eval.pro	2016-11-10 20:12:48.261357539 +0100
***************
*** 7,13 ****
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char_u *get_exception_string(void *value, int type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
--- 7,13 ----
  void free_global_msglist(void);
  void do_errthrow(struct condstack *cstack, char_u *cmdname);
  int do_intthrow(struct condstack *cstack);
! char_u *get_exception_string(void *value, except_type_T type, char_u *cmdname, int *should_free);
  void discard_current_exception(void);
  void report_make_pending(int pending, void *value);
  void report_resume_pending(int pending, void *value);
*** ../vim-8.0.0074/src/version.c	2016-11-10 20:01:41.201582868 +0100
--- src/version.c	2016-11-10 20:19:35.890768627 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     75,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
12. You turn off your modem and get this awful empty feeling, like you just
    pulled the plug on a loved one.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0076
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0076
Problem:    Channel log has double parens ()().
Solution:   Remove () for write_buf_line. (Yasuhiro Matsumoto)
Files:      src/channel.c


*** ../vim-8.0.0075/src/channel.c	2016-10-27 20:00:03.661357429 +0200
--- src/channel.c	2016-11-11 21:12:04.681464310 +0100
***************
*** 1341,1347 ****
  
      p[len] = NL;
      p[len + 1] = NUL;
!     channel_send(channel, PART_IN, p, len + 1, "write_buf_line()");
      vim_free(p);
  }
  
--- 1341,1347 ----
  
      p[len] = NL;
      p[len + 1] = NUL;
!     channel_send(channel, PART_IN, p, len + 1, "write_buf_line");
      vim_free(p);
  }
  
***************
*** 3450,3456 ****
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
--- 3450,3461 ----
   * Return FAIL or OK.
   */
      int
! channel_send(
! 	channel_T *channel,
! 	ch_part_T part,
! 	char_u	  *buf,
! 	int	  len,
! 	char	  *fun)
  {
      int		res;
      sock_T	fd;
*** ../vim-8.0.0075/src/version.c	2016-11-10 20:20:01.874602675 +0100
--- src/version.c	2016-11-11 21:12:53.829152426 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     76,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
14. You start introducing yourself as "Jim at I-I-Net dot net dot au"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0077
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0077
Problem:    The GUI code is not tested by Travis.
Solution:   Install the virtual framebuffer.
Files:      .travis.yml


*** ../vim-8.0.0076/.travis.yml	2016-01-03 23:04:38.000000000 +0100
--- .travis.yml	2016-11-11 21:53:37.469393214 +0100
***************
*** 32,37 ****
--- 32,43 ----
  before_install:
    - pip install --user cpp-coveralls
  
+ # Start virtual framebuffer to be able to test the GUI.
+ before_script:
+   - "export DISPLAY=:99.0"
+   - "sh -e /etc/init.d/xvfb start"
+   - sleep 3 # give xvfb some time to start
+ 
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
    - if [ "$CHECK_AUTOCONF" = "yes" -a "$CC" = "gcc" ]; then make -C src autoconf; fi
*** ../vim-8.0.0076/src/version.c	2016-11-11 21:13:56.836753930 +0100
--- src/version.c	2016-11-11 21:57:08.388039500 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     77,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
15. Your heart races faster and beats irregularly each time you see a new WWW
    site address in print or on TV, even though you've never had heart
    problems before.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0078
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0078
Problem:    Accessing freed memory in quickfix.
Solution:   Reset pointer when freeing 'errorformat'. (Domenique Pelle)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0077/src/quickfix.c	2016-11-10 20:01:41.197582893 +0100
--- src/quickfix.c	2016-11-12 15:32:55.305622514 +0100
***************
*** 114,119 ****
--- 114,121 ----
      int		    conthere;	/* %> used */
  };
  
+ static efm_T	*fmt_start = NULL; /* cached across qf_parse_line() calls */
+ 
  static int	qf_init_ext(qf_info_T *qi, char_u *efile, buf_T *buf, typval_T *tv, char_u *errorformat, int newlist, linenr_T lnumfirst, linenr_T lnumlast, char_u *qf_title);
  static void	qf_store_title(qf_info_T *qi, char_u *title);
  static void	qf_new_list(qf_info_T *qi, char_u *qf_title);
***************
*** 389,394 ****
--- 391,397 ----
  	vim_regfree(efm_ptr->prog);
  	vim_free(efm_ptr);
      }
+     fmt_start = NULL;
  }
  
  /* Parse 'errorformat' option */
***************
*** 786,792 ****
  	qffields_T	*fields)
  {
      efm_T		*fmt_ptr;
-     static efm_T	*fmt_start = NULL; /* cached across calls */
      char_u		*ptr;
      int			len;
      int			i;
--- 789,794 ----
*** ../vim-8.0.0077/src/testdir/test_quickfix.vim	2016-11-06 14:46:40.644143343 +0100
--- src/testdir/test_quickfix.vim	2016-11-12 15:27:04.183936416 +0100
***************
*** 1648,1650 ****
--- 1648,1660 ----
  
    set efm&vim
  endfunction
+ 
+ function Test_caddbuffer()
+   " This used to cause a memory access in freed memory
+   let save_efm = &efm
+   set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
+   cgetexpr ['WWWW', 'EEEE', 'CCCC']
+   let &efm = save_efm
+   cad
+   bwipe!
+ endfunc
*** ../vim-8.0.0077/src/version.c	2016-11-11 21:57:42.339822540 +0100
--- src/version.c	2016-11-12 15:33:58.377207364 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     78,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
19. All of your friends have an @ in their names.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0079
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0079
Problem:    Accessing freed memory in quickfix. (Domenique Pelle)
Solution:   Do not free the current list when adding to it.
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0078/src/quickfix.c	2016-11-12 15:36:50.284076568 +0100
--- src/quickfix.c	2016-11-12 18:11:19.331186720 +0100
***************
*** 1112,1117 ****
--- 1112,1118 ----
      qffields_T	    fields = {NULL, NULL, 0, 0L, 0, FALSE, NULL, 0, 0, 0};
  #ifdef FEAT_WINDOWS
      qfline_T	    *old_last = NULL;
+     int		    adding = FALSE;
  #endif
      static efm_T    *fmt_first = NULL;
      char_u	    *efm;
***************
*** 1140,1145 ****
--- 1141,1147 ----
      else if (qi->qf_lists[qi->qf_curlist].qf_count > 0)
      {
  	/* Adding to existing list, use last entry. */
+ 	adding = TRUE;
  	old_last = qi->qf_lists[qi->qf_curlist].qf_last;
      }
  #endif
***************
*** 1266,1275 ****
      }
      EMSG(_(e_readerrf));
  error2:
!     qf_free(qi, qi->qf_curlist);
!     qi->qf_listcount--;
!     if (qi->qf_curlist > 0)
! 	--qi->qf_curlist;
  qf_init_end:
      if (state.fd != NULL)
  	fclose(state.fd);
--- 1268,1280 ----
      }
      EMSG(_(e_readerrf));
  error2:
!     if (!adding)
!     {
! 	qf_free(qi, qi->qf_curlist);
! 	qi->qf_listcount--;
! 	if (qi->qf_curlist > 0)
! 	    --qi->qf_curlist;
!     }
  qf_init_end:
      if (state.fd != NULL)
  	fclose(state.fd);
*** ../vim-8.0.0078/src/testdir/test_quickfix.vim	2016-11-12 15:36:50.288076542 +0100
--- src/testdir/test_quickfix.vim	2016-11-12 18:09:29.515893989 +0100
***************
*** 6,12 ****
  
  set encoding=utf-8
  
! function! s:setup_commands(cchar)
    if a:cchar == 'c'
      command! -nargs=* -bang Xlist <mods>clist<bang> <args>
      command! -nargs=* Xgetexpr <mods>cgetexpr <args>
--- 6,12 ----
  
  set encoding=utf-8
  
! func s:setup_commands(cchar)
    if a:cchar == 'c'
      command! -nargs=* -bang Xlist <mods>clist<bang> <args>
      command! -nargs=* Xgetexpr <mods>cgetexpr <args>
***************
*** 68,77 ****
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
    endif
! endfunction
  
  " Tests for the :clist and :llist commands
! function XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
    " With an empty list, command should return error
--- 68,77 ----
      let g:Xgetlist = function('getloclist', [0])
      let g:Xsetlist = function('setloclist', [0])
    endif
! endfunc
  
  " Tests for the :clist and :llist commands
! func XlistTests(cchar)
    call s:setup_commands(a:cchar)
  
    " With an empty list, command should return error
***************
*** 128,144 ****
    let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
! endfunction
  
! function Test_clist()
    call XlistTests('c')
    call XlistTests('l')
! endfunction
  
  " Tests for the :colder, :cnewer, :lolder and :lnewer commands
  " Note that this test assumes that a quickfix/location list is
  " already set by the caller.
! function XageTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Jumping to a non existent list should return error
--- 128,144 ----
    let l = split(result, "\n")
    call assert_equal([' 2 Xtestfile1:1 col 3: Line1',
  		   \ ' 3: non-error 2', ' 4 Xtestfile2:2 col 2: Line2'], l)
! endfunc
  
! func Test_clist()
    call XlistTests('c')
    call XlistTests('l')
! endfunc
  
  " Tests for the :colder, :cnewer, :lolder and :lnewer commands
  " Note that this test assumes that a quickfix/location list is
  " already set by the caller.
! func XageTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Jumping to a non existent list should return error
***************
*** 171,190 ****
    Xnewer 2
    let l = g:Xgetlist()
    call assert_equal('Line3', l[0].text)
! endfunction
  
! function Test_cage()
    let list = [{'bufnr': 1, 'lnum': 1}]
    call setqflist(list)
    call XageTests('c')
  
    call setloclist(0, list)
    call XageTests('l')
! endfunction
  
  " Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen
  " commands
! function XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Create a list with no valid entries
--- 171,190 ----
    Xnewer 2
    let l = g:Xgetlist()
    call assert_equal('Line3', l[0].text)
! endfunc
  
! func Test_cage()
    let list = [{'bufnr': 1, 'lnum': 1}]
    call setqflist(list)
    call XageTests('c')
  
    call setloclist(0, list)
    call XageTests('l')
! endfunc
  
  " Tests for the :cwindow, :lwindow :cclose, :lclose, :copen and :lopen
  " commands
! func XwindowTests(cchar)
    call s:setup_commands(a:cchar)
  
    " Create a list with no valid entries
***************
*** 227,242 ****
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
! endfunction
  
! function Test_cwindow()
    call XwindowTests('c')
    call XwindowTests('l')
! endfunction
  
  " Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile
  " commands.
! function XfileTests(cchar)
    call s:setup_commands(a:cchar)
  
    call writefile(['Xtestfile1:700:10:Line 700',
--- 227,242 ----
    " Calling cwindow should close the quickfix window with no valid errors
    Xwindow
    call assert_true(winnr('$') == 1)
! endfunc
  
! func Test_cwindow()
    call XwindowTests('c')
    call XwindowTests('l')
! endfunc
  
  " Tests for the :cfile, :lfile, :caddfile, :laddfile, :cgetfile and :lgetfile
  " commands.
! func XfileTests(cchar)
    call s:setup_commands(a:cchar)
  
    call writefile(['Xtestfile1:700:10:Line 700',
***************
*** 275,290 ****
  	\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')
  
    call delete('Xqftestfile1')
! endfunction
  
! function Test_cfile()
    call XfileTests('c')
    call XfileTests('l')
! endfunction
  
  " Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and
  " :lgetbuffer commands.
! function XbufferTests(cchar)
    call s:setup_commands(a:cchar)
  
    enew!
--- 275,290 ----
  	\ l[1].lnum == 333 && l[1].col == 88 && l[1].text ==# 'Line 333')
  
    call delete('Xqftestfile1')
! endfunc
  
! func Test_cfile()
    call XfileTests('c')
    call XfileTests('l')
! endfunc
  
  " Tests for the :cbuffer, :lbuffer, :caddbuffer, :laddbuffer, :cgetbuffer and
  " :lgetbuffer commands.
! func XbufferTests(cchar)
    call s:setup_commands(a:cchar)
  
    enew!
***************
*** 316,341 ****
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
! endfunction
  
! function Test_cbuffer()
    call XbufferTests('c')
    call XbufferTests('l')
! endfunction
  
! function XexprTests(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails('Xexpr 10', 'E777:')
! endfunction
  
! function Test_cexpr()
    call XexprTests('c')
    call XexprTests('l')
! endfunction
  
  " Tests for :cnext, :cprev, :cfirst, :clast commands
! function Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
    call s:create_test_file('Xqftestfile1')
--- 316,341 ----
  	\ l[3].lnum == 750 && l[3].col == 25 && l[3].text ==# 'Line 750')
    enew!
  
! endfunc
  
! func Test_cbuffer()
    call XbufferTests('c')
    call XbufferTests('l')
! endfunc
  
! func XexprTests(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails('Xexpr 10', 'E777:')
! endfunc
  
! func Test_cexpr()
    call XexprTests('c')
    call XexprTests('l')
! endfunc
  
  " Tests for :cnext, :cprev, :cfirst, :clast commands
! func Xtest_browse(cchar)
    call s:setup_commands(a:cchar)
  
    call s:create_test_file('Xqftestfile1')
***************
*** 366,379 ****
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
! endfunction
  
! function Test_browse()
    call Xtest_browse('c')
    call Xtest_browse('l')
! endfunction
  
! function Test_nomem()
    call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)
    call assert_fails('vimgrep vim runtest.vim', 'E342:')
  
--- 366,379 ----
  
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
! endfunc
  
! func Test_browse()
    call Xtest_browse('c')
    call Xtest_browse('l')
! endfunc
  
! func Test_nomem()
    call test_alloc_fail(GetAllocId('qf_dirname_start'), 0, 0)
    call assert_fails('vimgrep vim runtest.vim', 'E342:')
  
***************
*** 391,397 ****
  
  endfunc
  
! function! s:test_xhelpgrep(cchar)
    call s:setup_commands(a:cchar)
    Xhelpgrep quickfix
    Xopen
--- 391,397 ----
  
  endfunc
  
! func s:test_xhelpgrep(cchar)
    call s:setup_commands(a:cchar)
    Xhelpgrep quickfix
    Xopen
***************
*** 403,411 ****
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
! endfunction
  
! function Test_helpgrep()
    call s:test_xhelpgrep('c')
    helpclose
    call s:test_xhelpgrep('l')
--- 403,411 ----
    call assert_true(w:quickfix_title =~ title_text, w:quickfix_title)
    " This wipes out the buffer, make sure that doesn't cause trouble.
    Xclose
! endfunc
  
! func Test_helpgrep()
    call s:test_xhelpgrep('c')
    helpclose
    call s:test_xhelpgrep('l')
***************
*** 443,449 ****
    augroup! QfBufWinEnter
  endfunc
  
! function XqfTitleTests(cchar)
    call s:setup_commands(a:cchar)
  
    Xgetexpr ['file:1:1:message']
--- 443,449 ----
    augroup! QfBufWinEnter
  endfunc
  
! func XqfTitleTests(cchar)
    call s:setup_commands(a:cchar)
  
    Xgetexpr ['file:1:1:message']
***************
*** 462,477 ****
    endif
    call assert_equal(title, w:quickfix_title)
    Xclose
! endfunction
  
  " Tests for quickfix window's title
! function Test_qf_title()
    call XqfTitleTests('c')
    call XqfTitleTests('l')
! endfunction
  
  " Tests for 'errorformat'
! function Test_efm()
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
--- 462,477 ----
    endif
    call assert_equal(title, w:quickfix_title)
    Xclose
! endfunc
  
  " Tests for quickfix window's title
! func Test_qf_title()
    call XqfTitleTests('c')
    call XqfTitleTests('l')
! endfunc
  
  " Tests for 'errorformat'
! func Test_efm()
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW%m,%+CCCC%.%#,%-GGGG%.%#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
***************
*** 484,490 ****
    let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
    call assert_equal("[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]", l)
    let &efm = save_efm
! endfunction
  
  " This will test for problems in quickfix:
  " A. incorrectly copying location lists which caused the location list to show
--- 484,490 ----
    let l = strtrans(string(map(getqflist(), '[v:val.text, v:val.valid]')))
    call assert_equal("[['W', 1], ['ZZZZ', 0], ['E^@CCCC', 1], ['YYYY', 0]]", l)
    let &efm = save_efm
! endfunc
  
  " This will test for problems in quickfix:
  " A. incorrectly copying location lists which caused the location list to show
***************
*** 495,501 ****
  "    window it belongs to.
  "
  " Set up the test environment:
! function! ReadTestProtocol(name)
    let base = substitute(a:name, '\v^test://(.*)%(\.[^.]+)?', '\1', '')
    let word = substitute(base, '\v(.*)\..*', '\1', '')
  
--- 495,501 ----
  "    window it belongs to.
  "
  " Set up the test environment:
! func ReadTestProtocol(name)
    let base = substitute(a:name, '\v^test://(.*)%(\.[^.]+)?', '\1', '')
    let word = substitute(base, '\v(.*)\..*', '\1', '')
  
***************
*** 514,522 ****
    setl nomodifiable
    setl readonly
    exe 'doautocmd BufRead ' . substitute(a:name, '\v^test://(.*)', '\1', '')
! endfunction
  
! function Test_locationlist()
      enew
  
      augroup testgroup
--- 514,522 ----
    setl nomodifiable
    setl readonly
    exe 'doautocmd BufRead ' . substitute(a:name, '\v^test://(.*)', '\1', '')
! endfunc
  
! func Test_locationlist()
      enew
  
      augroup testgroup
***************
*** 596,610 ****
      wincmd n | only
  
      augroup! testgroup
! endfunction
  
! function Test_locationlist_curwin_was_closed()
      augroup testgroup
        au!
        autocmd BufReadCmd test_curwin.txt call R(expand("<amatch>"))
      augroup END
  
!     function! R(n)
        quit
      endfunc
  
--- 596,610 ----
      wincmd n | only
  
      augroup! testgroup
!   endfunc
  
! func Test_locationlist_curwin_was_closed()
      augroup testgroup
        au!
        autocmd BufReadCmd test_curwin.txt call R(expand("<amatch>"))
      augroup END
  
!     func! R(n)
        quit
      endfunc
  
***************
*** 615,623 ****
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
! endfunction
  
! function Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
    call writefile(['loclistbar'], 'loclistbar')
    set switchbuf=usetab
--- 615,623 ----
      call assert_fails('lrewind', 'E924:')
  
      augroup! testgroup
!   endfunc
  
! func Test_locationlist_cross_tab_jump()
    call writefile(['loclistfoo'], 'loclistfoo')
    call writefile(['loclistbar'], 'loclistbar')
    set switchbuf=usetab
***************
*** 631,640 ****
    set switchbuf&vim
    call delete('loclistfoo')
    call delete('loclistbar')
! endfunction
  
  " More tests for 'errorformat'
! function! Test_efm1()
      if !has('unix')
  	" The 'errorformat' setting is different on non-Unix systems.
  	" This test works only on Unix-like systems.
--- 631,640 ----
    set switchbuf&vim
    call delete('loclistfoo')
    call delete('loclistbar')
! endfunc
  
  " More tests for 'errorformat'
! func Test_efm1()
      if !has('unix')
  	" The 'errorformat' setting is different on non-Unix systems.
  	" This test works only on Unix-like systems.
***************
*** 752,761 ****
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
! endfunction
  
  " Test for quickfix directory stack support
! function! s:dir_stack_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm=&efm
--- 752,761 ----
      call delete('Xerrorfile1')
      call delete('Xerrorfile2')
      call delete('Xtestfile')
!   endfunc
  
  " Test for quickfix directory stack support
! func s:dir_stack_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm=&efm
***************
*** 797,806 ****
    call assert_equal(5, qf[11].lnum)
  
    let &efm=save_efm
! endfunction
  
  " Tests for %D and %X errorformat options
! function! Test_efm_dirstack()
    " Create the directory stack and files
    call mkdir('dir1')
    call mkdir('dir1/a')
--- 797,806 ----
    call assert_equal(5, qf[11].lnum)
  
    let &efm=save_efm
! endfunc
  
  " Tests for %D and %X errorformat options
! func Test_efm_dirstack()
    " Create the directory stack and files
    call mkdir('dir1')
    call mkdir('dir1/a')
***************
*** 832,841 ****
    call delete('dir1', 'rf')
    call delete('dir2', 'rf')
    call delete('habits1.txt')
! endfunction
  
  " Test for resync after continuing an ignored message
! function! Xefm_ignore_continuations(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
--- 832,841 ----
    call delete('dir1', 'rf')
    call delete('dir2', 'rf')
    call delete('habits1.txt')
! endfunc
  
  " Test for resync after continuing an ignored message
! func Xefm_ignore_continuations(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
***************
*** 850,864 ****
    call assert_equal([['resync', 1, 4, 'E']], l)
  
    let &efm = save_efm
! endfunction
  
! function! Test_efm_ignore_continuations()
    call Xefm_ignore_continuations('c')
    call Xefm_ignore_continuations('l')
! endfunction
  
  " Tests for invalid error format specifies
! function Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
--- 850,864 ----
    call assert_equal([['resync', 1, 4, 'E']], l)
  
    let &efm = save_efm
! endfunc
  
! func Test_efm_ignore_continuations()
    call Xefm_ignore_continuations('c')
    call Xefm_ignore_continuations('l')
! endfunc
  
  " Tests for invalid error format specifies
! func Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
  
    let save_efm = &efm
***************
*** 891,907 ****
    call assert_fails('Xexpr ["Entering dir abc", "abc.txt:1:Hello world"]', 'E379:')
  
    let &efm = save_efm
! endfunction
  
! function Test_invalid_efm()
    call Xinvalid_efm_Tests('c')
    call Xinvalid_efm_Tests('l')
! endfunction
  
  " TODO:
  " Add tests for the following formats in 'errorformat'
  "	%r  %O
! function! Test_efm2()
    let save_efm = &efm
  
    " Test for %s format in efm
--- 891,907 ----
    call assert_fails('Xexpr ["Entering dir abc", "abc.txt:1:Hello world"]', 'E379:')
  
    let &efm = save_efm
! endfunc
  
! func Test_invalid_efm()
    call Xinvalid_efm_Tests('c')
    call Xinvalid_efm_Tests('l')
! endfunc
  
  " TODO:
  " Add tests for the following formats in 'errorformat'
  "	%r  %O
! func Test_efm2()
    let save_efm = &efm
  
    " Test for %s format in efm
***************
*** 987,1005 ****
    call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))
  
    let &efm = save_efm
! endfunction
  
! function XquickfixChangedByAutocmd(cchar)
    call s:setup_commands(a:cchar)
    if a:cchar == 'c'
      let ErrorNr = 'E925'
!     function! ReadFunc()
        colder
        cgetexpr []
      endfunc
    else
      let ErrorNr = 'E926'
!     function! ReadFunc()
        lolder
        lgetexpr []
      endfunc
--- 987,1005 ----
    call assert_equal('unittests/dbfacadeTest.py', bufname(l[4].bufnr))
  
    let &efm = save_efm
! endfunc
  
! func XquickfixChangedByAutocmd(cchar)
    call s:setup_commands(a:cchar)
    if a:cchar == 'c'
      let ErrorNr = 'E925'
!     func! ReadFunc()
        colder
        cgetexpr []
      endfunc
    else
      let ErrorNr = 'E926'
!     func! ReadFunc()
        lolder
        lgetexpr []
      endfunc
***************
*** 1022,1031 ****
    augroup! testgroup
  endfunc
  
! function Test_quickfix_was_changed_by_autocmd()
    call XquickfixChangedByAutocmd('c')
    call XquickfixChangedByAutocmd('l')
! endfunction
  
  func Test_caddbuffer_to_empty()
    helpgr quickfix
--- 1022,1031 ----
    augroup! testgroup
  endfunc
  
! func Test_quickfix_was_changed_by_autocmd()
    call XquickfixChangedByAutocmd('c')
    call XquickfixChangedByAutocmd('l')
! endfunc
  
  func Test_caddbuffer_to_empty()
    helpgr quickfix
***************
*** 1047,1053 ****
  endfunc
  
  " Tests for the setqflist() and setloclist() functions
! function SetXlistTests(cchar, bnum)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},
--- 1047,1053 ----
  endfunc
  
  " Tests for the setqflist() and setloclist() functions
! func SetXlistTests(cchar, bnum)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'bufnr': a:bnum, 'lnum': 1},
***************
*** 1082,1090 ****
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
! endfunction
  
! function Test_setqflist()
    new Xtestfile | only
    let bnum = bufnr('%')
    call setline(1, range(1,5))
--- 1082,1090 ----
    call g:Xsetlist([])
    let l = g:Xgetlist()
    call assert_equal(0, len(l))
! endfunc
  
! func Test_setqflist()
    new Xtestfile | only
    let bnum = bufnr('%')
    call setline(1, range(1,5))
***************
*** 1094,1102 ****
  
    enew!
    call delete('Xtestfile')
! endfunction
  
! function Xlist_empty_middle(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
--- 1094,1102 ----
  
    enew!
    call delete('Xtestfile')
! endfunc
  
! func Xlist_empty_middle(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
***************
*** 1119,1130 ****
    call assert_equal(matchlen, len(g:Xgetlist()))
  endfunc
  
! function Test_setqflist_empty_middle()
    call Xlist_empty_middle('c')
    call Xlist_empty_middle('l')
! endfunction
  
! function Xlist_empty_older(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
--- 1119,1130 ----
    call assert_equal(matchlen, len(g:Xgetlist()))
  endfunc
  
! func Test_setqflist_empty_middle()
    call Xlist_empty_middle('c')
    call Xlist_empty_middle('l')
! endfunc
  
! func Xlist_empty_older(cchar)
    call s:setup_commands(a:cchar)
  
    " create three quickfix lists
***************
*** 1145,1158 ****
    call assert_equal(twolen, len(g:Xgetlist()))
    Xnewer
    call assert_equal(threelen, len(g:Xgetlist()))
! endfunction
  
! function Test_setqflist_empty_older()
    call Xlist_empty_older('c')
    call Xlist_empty_older('l')
! endfunction
  
! function! XquickfixSetListWithAct(cchar)
    call s:setup_commands(a:cchar)
  
    let list1 = [{'filename': 'fnameA', 'text': 'A'},
--- 1145,1158 ----
    call assert_equal(twolen, len(g:Xgetlist()))
    Xnewer
    call assert_equal(threelen, len(g:Xgetlist()))
! endfunc
  
! func Test_setqflist_empty_older()
    call Xlist_empty_older('c')
    call Xlist_empty_older('l')
! endfunc
  
! func XquickfixSetListWithAct(cchar)
    call s:setup_commands(a:cchar)
  
    let list1 = [{'filename': 'fnameA', 'text': 'A'},
***************
*** 1226,1237 ****
    call assert_fails("call g:Xsetlist(list1, 0)", 'E928:')
  endfunc
  
! function Test_quickfix_set_list_with_act()
    call XquickfixSetListWithAct('c')
    call XquickfixSetListWithAct('l')
! endfunction
  
! function XLongLinesTests(cchar)
    let l = g:Xgetlist()
  
    call assert_equal(4, len(l))
--- 1226,1237 ----
    call assert_fails("call g:Xsetlist(list1, 0)", 'E928:')
  endfunc
  
! func Test_quickfix_set_list_with_act()
    call XquickfixSetListWithAct('c')
    call XquickfixSetListWithAct('l')
! endfunc
  
! func XLongLinesTests(cchar)
    let l = g:Xgetlist()
  
    call assert_equal(4, len(l))
***************
*** 1249,1257 ****
    call assert_equal(10, len(l[3].text))
  
    call g:Xsetlist([], 'r')
! endfunction
  
! function s:long_lines_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let testfile = 'samples/quickfix.txt'
--- 1249,1257 ----
    call assert_equal(10, len(l[3].text))
  
    call g:Xsetlist([], 'r')
! endfunc
  
! func s:long_lines_tests(cchar)
    call s:setup_commands(a:cchar)
  
    let testfile = 'samples/quickfix.txt'
***************
*** 1272,1293 ****
    exe 'edit' testfile
    exe 'Xbuffer' bufnr('%')
    call XLongLinesTests(a:cchar)
! endfunction
  
! function Test_long_lines()
    call s:long_lines_tests('c')
    call s:long_lines_tests('l')
! endfunction
  
! function! s:create_test_file(filename)
    let l = []
    for i in range(1, 20)
        call add(l, 'Line' . i)
    endfor
    call writefile(l, a:filename)
! endfunction
  
! function! Test_switchbuf()
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
    call s:create_test_file('Xqftestfile3')
--- 1272,1293 ----
    exe 'edit' testfile
    exe 'Xbuffer' bufnr('%')
    call XLongLinesTests(a:cchar)
! endfunc
  
! func Test_long_lines()
    call s:long_lines_tests('c')
    call s:long_lines_tests('l')
! endfunc
  
! func s:create_test_file(filename)
    let l = []
    for i in range(1, 20)
        call add(l, 'Line' . i)
    endfor
    call writefile(l, a:filename)
! endfunc
  
! func Test_switchbuf()
    call s:create_test_file('Xqftestfile1')
    call s:create_test_file('Xqftestfile2')
    call s:create_test_file('Xqftestfile3')
***************
*** 1374,1382 ****
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
    call delete('Xqftestfile3')
! endfunction
  
! function! Xadjust_qflnum(cchar)
    call s:setup_commands(a:cchar)
  
    enew | only
--- 1374,1382 ----
    call delete('Xqftestfile1')
    call delete('Xqftestfile2')
    call delete('Xqftestfile3')
! endfunc
  
! func Xadjust_qflnum(cchar)
    call s:setup_commands(a:cchar)
  
    enew | only
***************
*** 1401,1417 ****
  
    enew!
    call delete(fname)
! endfunction
  
! function! Test_adjust_lnum()
    call setloclist(0, [])
    call Xadjust_qflnum('c')
    call setqflist([])
    call Xadjust_qflnum('l')
! endfunction
  
  " Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands
! function! s:test_xgrep(cchar)
    call s:setup_commands(a:cchar)
  
    " The following lines are used for the grep test. Don't remove.
--- 1401,1417 ----
  
    enew!
    call delete(fname)
! endfunc
  
! func Test_adjust_lnum()
    call setloclist(0, [])
    call Xadjust_qflnum('c')
    call setqflist([])
    call Xadjust_qflnum('l')
! endfunc
  
  " Tests for the :grep/:lgrep and :grepadd/:lgrepadd commands
! func s:test_xgrep(cchar)
    call s:setup_commands(a:cchar)
  
    " The following lines are used for the grep test. Don't remove.
***************
*** 1430,1438 ****
    set makeef=Temp_File_##
    silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim
    call assert_true(len(g:Xgetlist()) == 6)
! endfunction
  
! function! Test_grep()
    if !has('unix')
      " The grepprg may not be set on non-Unix systems
      return
--- 1430,1438 ----
    set makeef=Temp_File_##
    silent Xgrepadd GrepAdd_Test_Text: test_quickfix.vim
    call assert_true(len(g:Xgetlist()) == 6)
! endfunc
  
! func Test_grep()
    if !has('unix')
      " The grepprg may not be set on non-Unix systems
      return
***************
*** 1440,1448 ****
  
    call s:test_xgrep('c')
    call s:test_xgrep('l')
! endfunction
  
! function! Test_two_windows()
    " Use one 'errorformat' for two windows.  Add an expression to each of them,
    " make sure they each keep their own state.
    set efm=%DEntering\ dir\ '%f',%f:%l:%m,%XLeaving\ dir\ '%f'
--- 1440,1448 ----
  
    call s:test_xgrep('c')
    call s:test_xgrep('l')
! endfunc
  
! func Test_two_windows()
    " Use one 'errorformat' for two windows.  Add an expression to each of them,
    " make sure they each keep their own state.
    set efm=%DEntering\ dir\ '%f',%f:%l:%m,%XLeaving\ dir\ '%f'
***************
*** 1483,1489 ****
    call delete('Xtwo', 'rf')
  endfunc
  
! function XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
--- 1483,1489 ----
    call delete('Xtwo', 'rf')
  endfunc
  
! func XbottomTests(cchar)
    call s:setup_commands(a:cchar)
  
    call g:Xsetlist([{'filename': 'foo', 'lnum': 42}]) 
***************
*** 1499,1510 ****
  endfunc
  
  " Tests for the :cbottom and :lbottom commands
! function Test_cbottom()
    call XbottomTests('c')
    call XbottomTests('l')
! endfunction
  
! function HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails(a:cchar . 'older 99', 'E380:')
--- 1499,1510 ----
  endfunc
  
  " Tests for the :cbottom and :lbottom commands
! func Test_cbottom()
    call XbottomTests('c')
    call XbottomTests('l')
! endfunc
  
! func HistoryTest(cchar)
    call s:setup_commands(a:cchar)
  
    call assert_fails(a:cchar . 'older 99', 'E380:')
***************
*** 1544,1550 ****
  endfunc
  
  " Quickfix/Location list set/get properties tests
! function Xproperty_tests(cchar)
      call s:setup_commands(a:cchar)
  
      " Error cases
--- 1544,1550 ----
  endfunc
  
  " Quickfix/Location list set/get properties tests
! func Xproperty_tests(cchar)
      call s:setup_commands(a:cchar)
  
      " Error cases
***************
*** 1590,1608 ****
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
! endfunction
  
! function Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
! endfunction
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
! function QfAutoCmdHandler(loc, cmd)
    call add(g:acmds, a:loc . a:cmd)
! endfunction
  
! function Test_Autocmd()
    autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))
    autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))
  
--- 1590,1608 ----
      if a:cchar == 'l'
  	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
!   endfunc
  
! func Test_qf_property()
      call Xproperty_tests('c')
      call Xproperty_tests('l')
!   endfunc
  
  " Tests for the QuickFixCmdPre/QuickFixCmdPost autocommands
! func QfAutoCmdHandler(loc, cmd)
    call add(g:acmds, a:loc . a:cmd)
! endfunc
  
! func Test_Autocmd()
    autocmd QuickFixCmdPre * call QfAutoCmdHandler('pre', expand('<amatch>'))
    autocmd QuickFixCmdPost * call QfAutoCmdHandler('post', expand('<amatch>'))
  
***************
*** 1630,1638 ****
  	      \ 'precaddbuffer',
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
! endfunction
  
! function! Test_Autocmd_Exception()
    set efm=%m
    lgetexpr '?'
  
--- 1630,1638 ----
  	      \ 'precaddbuffer',
  	      \ 'postcaddbuffer']
    call assert_equal(l, g:acmds)
! endfunc
  
! func Test_Autocmd_Exception()
    set efm=%m
    lgetexpr '?'
  
***************
*** 1647,1660 ****
    call assert_equal('1', getloclist(0)[0].text)
  
    set efm&vim
! endfunction
  
! function Test_caddbuffer()
!   " This used to cause a memory access in freed memory
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
    let &efm = save_efm
!   cad
    bwipe!
  endfunc
--- 1647,1671 ----
    call assert_equal('1', getloclist(0)[0].text)
  
    set efm&vim
! endfunc
  
! func Test_caddbuffer_wrong()
!   " This used to cause a memory access in freed memory.
    let save_efm = &efm
    set efm=%EEEE%m,%WWWW,%+CCCC%>%#,%GGGG%.#
    cgetexpr ['WWWW', 'EEEE', 'CCCC']
    let &efm = save_efm
!   caddbuffer
    bwipe!
  endfunc
+ 
+ func Test_caddexpr_wrong()
+   " This used to cause a memory access in freed memory.
+   cbuffer
+   cbuffer
+   copen
+   let save_efm = &efm
+   set efm=%
+   call assert_fails('caddexpr ""', 'E376:')
+   let &efm = save_efm
+ endfunc
*** ../vim-8.0.0078/src/version.c	2016-11-12 15:36:50.288076542 +0100
--- src/version.c	2016-11-12 18:14:08.246098751 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     79,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
20. When looking at a pageful of someone else's links, you notice all of them
    are already highlighted in purple.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0080
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0080
Problem:    The OS X build fails on Travis.
Solution:   Skip the virtual framebuffer on OS X.
Files:      .travis.yml


*** ../vim-8.0.0079/.travis.yml	2016-11-11 21:57:42.339822540 +0100
--- .travis.yml	2016-11-12 18:30:23.331789362 +0100
***************
*** 32,42 ****
  before_install:
    - pip install --user cpp-coveralls
  
! # Start virtual framebuffer to be able to test the GUI.
  before_script:
!   - "export DISPLAY=:99.0"
!   - "sh -e /etc/init.d/xvfb start"
!   - sleep 3 # give xvfb some time to start
  
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
--- 32,40 ----
  before_install:
    - pip install --user cpp-coveralls
  
! # Start virtual framebuffer to be able to test the GUI. Does not work on OS X.
  before_script:
!   - if [ "$TRAVIS_OS_NAME" = "linux" ]; then export DISPLAY=:99.0 && sh -e /etc/init.d/xvfb start && sleep 3; fi
  
  script:
    - NPROC=$(getconf _NPROCESSORS_ONLN)
*** ../vim-8.0.0079/src/version.c	2016-11-12 18:14:39.609896729 +0100
--- src/version.c	2016-11-12 18:29:50.660001461 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     80,
  /**/

-- 
Shift happens.
                -- Doppler

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0081
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0081
Problem:    Inconsistent function names.
Solution:   Rename do_cscope to ex_cscope.  Clean up comments.
Files:      src/ex_cmds.h, src/if_cscope.c, src/ex_docmd.c,
            src/proto/if_cscope.pro


*** ../vim-8.0.0080/src/ex_cmds.h	2016-09-20 21:39:11.354199194 +0200
--- src/ex_cmds.h	2016-11-12 19:05:58.313384777 +0100
***************
*** 391,400 ****
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG,
  			ADDR_LINES),
! EX(CMD_cscope,		"cscope",	do_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
! EX(CMD_cstag,		"cstag",	do_cstag,
  			BANG|TRLBAR|WORD1,
  			ADDR_LINES),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
--- 391,400 ----
  EX(CMD_crewind,		"crewind",	ex_cc,
  			RANGE|NOTADR|COUNT|TRLBAR|BANG,
  			ADDR_LINES),
! EX(CMD_cscope,		"cscope",	ex_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
! EX(CMD_cstag,		"cstag",	ex_cstag,
  			BANG|TRLBAR|WORD1,
  			ADDR_LINES),
  EX(CMD_cunmap,		"cunmap",	ex_unmap,
***************
*** 745,751 ****
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR,
  			ADDR_LINES),
! EX(CMD_lcscope,		"lcscope",	do_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
  EX(CMD_ldo,		"ldo",		ex_listdo,
--- 745,751 ----
  EX(CMD_lclose,		"lclose",	ex_cclose,
  			RANGE|NOTADR|COUNT|TRLBAR,
  			ADDR_LINES),
! EX(CMD_lcscope,		"lcscope",	ex_cscope,
  			EXTRA|NOTRLCOM|XFILE,
  			ADDR_LINES),
  EX(CMD_ldo,		"ldo",		ex_listdo,
***************
*** 1249,1255 ****
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN,
  			ADDR_LINES),
! EX(CMD_scscope,		"scscope",	do_scscope,
  			EXTRA|NOTRLCOM,
  			ADDR_LINES),
  EX(CMD_set,		"set",		ex_set,
--- 1249,1255 ----
  EX(CMD_scriptencoding,	"scriptencoding", ex_scriptencoding,
  			WORD1|TRLBAR|CMDWIN,
  			ADDR_LINES),
! EX(CMD_scscope,		"scscope",	ex_scscope,
  			EXTRA|NOTRLCOM,
  			ADDR_LINES),
  EX(CMD_set,		"set",		ex_set,
*** ../vim-8.0.0080/src/if_cscope.c	2016-11-10 20:01:41.193582919 +0100
--- src/if_cscope.c	2016-11-12 19:13:14.386427848 +0100
***************
*** 201,208 ****
  #endif /* FEAT_CMDL_COMPL */
  
  /*
-  * PRIVATE: do_cscope_general
-  *
   * Find the command, print help if invalid, and then call the corresponding
   * command function.
   */
--- 201,206 ----
***************
*** 242,272 ****
  }
  
  /*
!  * PUBLIC: do_cscope
   */
      void
! do_cscope(exarg_T *eap)
  {
      do_cscope_general(eap, FALSE);
  }
  
  /*
!  * PUBLIC: do_scscope
!  *
!  * same as do_cscope, but splits window, too.
   */
      void
! do_scscope(exarg_T *eap)
  {
      do_cscope_general(eap, TRUE);
  }
  
  /*
!  * PUBLIC: do_cstag
!  *
   */
      void
! do_cstag(exarg_T *eap)
  {
      int ret = FALSE;
  
--- 240,267 ----
  }
  
  /*
!  * Implementation of ":cscope" and ":lcscope"
   */
      void
! ex_cscope(exarg_T *eap)
  {
      do_cscope_general(eap, FALSE);
  }
  
  /*
!  * Implementation of ":scscope". Same as ex_cscope(), but splits window, too.
   */
      void
! ex_scscope(exarg_T *eap)
  {
      do_cscope_general(eap, TRUE);
  }
  
  /*
!  * Implementation of ":cstag"
   */
      void
! ex_cstag(exarg_T *eap)
  {
      int ret = FALSE;
  
***************
*** 336,348 ****
  #endif
      }
  
! } /* do_cscope */
  
  
  /*
!  * PUBLIC: cs_find
!  *
!  * this simulates a vim_fgets(), but for cscope, returns the next line
   * from the cscope output.  should only be called from find_tags()
   *
   * returns TRUE if eof, FALSE otherwise
--- 331,341 ----
  #endif
      }
  
! }
  
  
  /*
!  * This simulates a vim_fgets(), but for cscope, returns the next line
   * from the cscope output.  should only be called from find_tags()
   *
   * returns TRUE if eof, FALSE otherwise
***************
*** 361,369 ****
  
  
  /*
!  * PUBLIC: cs_free_tags
!  *
!  * called only from do_tag(), when popping the tag stack
   */
      void
  cs_free_tags(void)
--- 354,360 ----
  
  
  /*
!  * Called only from do_tag(), when popping the tag stack.
   */
      void
  cs_free_tags(void)
***************
*** 373,381 ****
  
  
  /*
!  * PUBLIC: cs_print_tags
!  *
!  * called from do_tag()
   */
      void
  cs_print_tags(void)
--- 364,370 ----
  
  
  /*
!  * Called from do_tag().
   */
      void
  cs_print_tags(void)
***************
*** 467,478 ****
   ****************************************************************************/
  
  /*
!  * PRIVATE: cs_add
!  *
!  * add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list
!  *
!  * MAXPATHL 256
   */
      static int
  cs_add(exarg_T *eap UNUSED)
--- 456,463 ----
   ****************************************************************************/
  
  /*
!  * Add cscope database or a directory name (to look for cscope.out)
!  * to the cscope connection list.
   */
      static int
  cs_add(exarg_T *eap UNUSED)
***************
*** 508,517 ****
  
  
  /*
!  * PRIVATE: cs_add_common
!  *
!  * the common routine to add a new cscope connection.  called by
!  * cs_add() and cs_reset().  i really don't like to do this, but this
   * routine uses a number of goto statements.
   */
      static int
--- 493,500 ----
  
  
  /*
!  * The common routine to add a new cscope connection.  Called by
!  * cs_add() and cs_reset().  I really don't like to do this, but this
   * routine uses a number of goto statements.
   */
      static int
***************
*** 666,674 ****
  
  
  /*
!  * PRIVATE: cs_cnt_connections
!  *
!  * count the number of cscope connections
   */
      static int
  cs_cnt_connections(void)
--- 649,655 ----
  
  
  /*
!  * Count the number of cscope connections.
   */
      static int
  cs_cnt_connections(void)
***************
*** 693,701 ****
  
  #define	CSREAD_BUFSIZE	2048
  /*
!  * PRIVATE: cs_cnt_matches
!  *
!  * count the number of matches for a given cscope connection.
   */
      static int
  cs_cnt_matches(int idx)
--- 674,680 ----
  
  #define	CSREAD_BUFSIZE	2048
  /*
!  * Count the number of matches for a given cscope connection.
   */
      static int
  cs_cnt_matches(int idx)
***************
*** 754,761 ****
  
  
  /*
-  * PRIVATE: cs_create_cmd
-  *
   * Creates the actual cscope command query from what the user entered.
   */
      static char *
--- 733,738 ----
***************
*** 817,824 ****
  
  
  /*
-  * PRIVATE: cs_create_connection
-  *
   * This piece of code was taken/adapted from nvi.  do we need to add
   * the BSD license notice?
   */
--- 794,799 ----
***************
*** 1056,1063 ****
  
  
  /*
-  * PRIVATE: cs_find
-  *
   * Query cscope using command line interface.  Parse the output and use tselect
   * to allow choices.  Like Nvi, creates a pipe to send to/from query/cscope.
   *
--- 1031,1036 ----
***************
*** 1102,1110 ****
  
  
  /*
!  * PRIVATE: cs_find_common
!  *
!  * common code for cscope find, shared by cs_find() and do_cstag()
   */
      static int
  cs_find_common(
--- 1075,1081 ----
  
  
  /*
!  * Common code for cscope find, shared by cs_find() and ex_cstag().
   */
      static int
  cs_find_common(
***************
*** 1323,1331 ****
  } /* cs_find_common */
  
  /*
!  * PRIVATE: cs_help
!  *
!  * print help
   */
      static int
  cs_help(exarg_T *eap UNUSED)
--- 1294,1300 ----
  } /* cs_find_common */
  
  /*
!  * Print help.
   */
      static int
  cs_help(exarg_T *eap UNUSED)
***************
*** 1408,1416 ****
  #endif
  
  /*
!  * PRIVATE: cs_insert_filelist
!  *
!  * insert a new cscope database filename into the filelist
   */
      static int
  cs_insert_filelist(
--- 1377,1383 ----
  #endif
  
  /*
!  * Insert a new cscope database filename into the filelist.
   */
      static int
  cs_insert_filelist(
***************
*** 1551,1559 ****
  
  
  /*
!  * PRIVATE: cs_lookup_cmd
!  *
!  * find cscope command in command table
   */
      static cscmd_T *
  cs_lookup_cmd(exarg_T *eap)
--- 1518,1524 ----
  
  
  /*
!  * Find cscope command in command table.
   */
      static cscmd_T *
  cs_lookup_cmd(exarg_T *eap)
***************
*** 1582,1590 ****
  
  
  /*
!  * PRIVATE: cs_kill
!  *
!  * nuke em
   */
      static int
  cs_kill(exarg_T *eap UNUSED)
--- 1547,1553 ----
  
  
  /*
!  * Nuke em.
   */
      static int
  cs_kill(exarg_T *eap UNUSED)
***************
*** 1639,1646 ****
  
  
  /*
-  * PRIVATE: cs_kill_execute
-  *
   * Actually kills a specific cscope connection.
   */
      static void
--- 1602,1607 ----
***************
*** 1659,1680 ****
  
  
  /*
!  * PRIVATE: cs_make_vim_style_matches
!  *
!  * convert the cscope output into a ctags style entry (as might be found
   * in a ctags tags file).  there's one catch though: cscope doesn't tell you
   * the type of the tag you are looking for.  for example, in Darren Hiebert's
   * ctags (the one that comes with vim), #define's use a line number to find the
   * tag in a file while function definitions use a regexp search pattern.
   *
!  * i'm going to always use the line number because cscope does something
   * quirky (and probably other things i don't know about):
   *
   *     if you have "#  define" in your source file, which is
   *     perfectly legal, cscope thinks you have "#define".  this
   *     will result in a failed regexp search. :(
   *
!  * besides, even if this particular case didn't happen, the search pattern
   * would still have to be modified to escape all the special regular expression
   * characters to comply with ctags formatting.
   */
--- 1620,1639 ----
  
  
  /*
!  * Convert the cscope output into a ctags style entry (as might be found
   * in a ctags tags file).  there's one catch though: cscope doesn't tell you
   * the type of the tag you are looking for.  for example, in Darren Hiebert's
   * ctags (the one that comes with vim), #define's use a line number to find the
   * tag in a file while function definitions use a regexp search pattern.
   *
!  * I'm going to always use the line number because cscope does something
   * quirky (and probably other things i don't know about):
   *
   *     if you have "#  define" in your source file, which is
   *     perfectly legal, cscope thinks you have "#define".  this
   *     will result in a failed regexp search. :(
   *
!  * Besides, even if this particular case didn't happen, the search pattern
   * would still have to be modified to escape all the special regular expression
   * characters to comply with ctags formatting.
   */
***************
*** 1721,1729 ****
  
  
  /*
!  * PRIVATE: cs_manage_matches
!  *
!  * this is kind of hokey, but i don't see an easy way round this..
   *
   * Store: keep a ptr to the (malloc'd) memory of matches originally
   * generated from cs_find().  the matches are originally lines directly
--- 1680,1686 ----
  
  
  /*
!  * This is kind of hokey, but i don't see an easy way round this.
   *
   * Store: keep a ptr to the (malloc'd) memory of matches originally
   * generated from cs_find().  the matches are originally lines directly
***************
*** 1801,1809 ****
  
  
  /*
!  * PRIVATE: cs_parse_results
!  *
!  * parse cscope output
   */
      static char *
  cs_parse_results(
--- 1758,1764 ----
  
  
  /*
!  * Parse cscope output.
   */
      static char *
  cs_parse_results(
***************
*** 1864,1872 ****
  
  #ifdef FEAT_QUICKFIX
  /*
!  * PRIVATE: cs_file_results
!  *
!  * write cscope find results to file
   */
      static void
  cs_file_results(FILE *f, int *nummatches_a)
--- 1819,1825 ----
  
  #ifdef FEAT_QUICKFIX
  /*
!  * Write cscope find results to file.
   */
      static void
  cs_file_results(FILE *f, int *nummatches_a)
***************
*** 1919,1928 ****
  #endif
  
  /*
!  * PRIVATE: cs_fill_results
!  *
!  * get parsed cscope output and calls cs_make_vim_style_matches to convert
!  * into ctags format
   * When there are no matches sets "*matches_p" to NULL.
   */
      static void
--- 1872,1879 ----
  #endif
  
  /*
!  * Get parsed cscope output and calls cs_make_vim_style_matches to convert
!  * into ctags format.
   * When there are no matches sets "*matches_p" to NULL.
   */
      static void
***************
*** 2032,2040 ****
  }
  
  /*
!  * PRIVATE: cs_print_tags_priv
!  *
!  * called from cs_manage_matches()
   */
      static void
  cs_print_tags_priv(char **matches, char **cntxts, int num_matches)
--- 1983,1989 ----
  }
  
  /*
!  * Called from cs_manage_matches().
   */
      static void
  cs_print_tags_priv(char **matches, char **cntxts, int num_matches)
***************
*** 2182,2190 ****
  
  
  /*
!  * PRIVATE: cs_read_prompt
!  *
!  * read a cscope prompt (basically, skip over the ">> ")
   */
      static int
  cs_read_prompt(int i)
--- 2131,2137 ----
  
  
  /*
!  * Read a cscope prompt (basically, skip over the ">> ").
   */
      static int
  cs_read_prompt(int i)
***************
*** 2280,2287 ****
  #endif
  
  /*
-  * PRIVATE: cs_release_csp
-  *
   * Does the actual free'ing for the cs ptr with an optional flag of whether
   * or not to free the filename.  Called by cs_kill and cs_reset.
   */
--- 2227,2232 ----
***************
*** 2408,2416 ****
  
  
  /*
!  * PRIVATE: cs_reset
!  *
!  * calls cs_kill on all cscope connections then reinits
   */
      static int
  cs_reset(exarg_T *eap UNUSED)
--- 2353,2359 ----
  
  
  /*
!  * Calls cs_kill on all cscope connections then reinits.
   */
      static int
  cs_reset(exarg_T *eap UNUSED)
***************
*** 2474,2481 ****
  
  
  /*
-  * PRIVATE: cs_resolve_file
-  *
   * Construct the full pathname to a file found in the cscope database.
   * (Prepends ppath, if there is one and if it's not already prepended,
   * otherwise just uses the name found.)
--- 2417,2422 ----
***************
*** 2544,2552 ****
  
  
  /*
!  * PRIVATE: cs_show
!  *
!  * show all cscope connections
   */
      static int
  cs_show(exarg_T *eap UNUSED)
--- 2485,2491 ----
  
  
  /*
!  * Show all cscope connections.
   */
      static int
  cs_show(exarg_T *eap UNUSED)
***************
*** 2579,2586 ****
  
  
  /*
-  * PUBLIC: cs_end
-  *
   * Only called when VIM exits to quit any cscope sessions.
   */
      void
--- 2518,2523 ----
*** ../vim-8.0.0080/src/ex_docmd.c	2016-11-10 20:20:01.874602675 +0100
--- src/ex_docmd.c	2016-11-12 19:05:37.725523650 +0100
***************
*** 243,251 ****
  # define ex_helpfind		ex_ni
  #endif
  #ifndef FEAT_CSCOPE
! # define do_cscope		ex_ni
! # define do_scscope		ex_ni
! # define do_cstag		ex_ni
  #endif
  #ifndef FEAT_SYN_HL
  # define ex_syntax		ex_ni
--- 243,251 ----
  # define ex_helpfind		ex_ni
  #endif
  #ifndef FEAT_CSCOPE
! # define ex_cscope		ex_ni
! # define ex_scscope		ex_ni
! # define ex_cstag		ex_ni
  #endif
  #ifndef FEAT_SYN_HL
  # define ex_syntax		ex_ni
***************
*** 10427,10433 ****
  #ifdef FEAT_CSCOPE
  		  if (p_cst && *eap->arg != NUL)
  		  {
! 		      do_cstag(eap);
  		      return;
  		  }
  #endif
--- 10427,10433 ----
  #ifdef FEAT_CSCOPE
  		  if (p_cst && *eap->arg != NUL)
  		  {
! 		      ex_cstag(eap);
  		      return;
  		  }
  #endif
*** ../vim-8.0.0080/src/proto/if_cscope.pro	2016-09-12 13:04:06.000000000 +0200
--- src/proto/if_cscope.pro	2016-11-12 19:06:02.421357070 +0100
***************
*** 1,9 ****
  /* if_cscope.c */
  char_u *get_cscope_name(expand_T *xp, int idx);
  void set_context_in_cscope_cmd(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
! void do_cscope(exarg_T *eap);
! void do_scscope(exarg_T *eap);
! void do_cstag(exarg_T *eap);
  int cs_fgets(char_u *buf, int size);
  void cs_free_tags(void);
  void cs_print_tags(void);
--- 1,9 ----
  /* if_cscope.c */
  char_u *get_cscope_name(expand_T *xp, int idx);
  void set_context_in_cscope_cmd(expand_T *xp, char_u *arg, cmdidx_T cmdidx);
! void ex_cscope(exarg_T *eap);
! void ex_scscope(exarg_T *eap);
! void ex_cstag(exarg_T *eap);
  int cs_fgets(char_u *buf, int size);
  void cs_free_tags(void);
  void cs_print_tags(void);
*** ../vim-8.0.0080/src/version.c	2016-11-12 18:30:35.115712865 +0100
--- src/version.c	2016-11-12 19:15:58.557299522 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     81,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
25. You believe nothing looks sexier than a man in boxer shorts illuminated
    only by a 17" inch svga monitor.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0082
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0082
Problem:    Extension for configure should be ".ac".
Solution:   Rename configure.in to configure.ac. (James McCoy, closes #1173)
Files:      src/configure.in, src/configure.ac, Filelist, src/Makefile,
            src/blowfish.c, src/channel.c, src/config.h.in, src/main.aap,
            src/os_unix.c, src/INSTALL, src/mysign


*** ../vim-8.0.0081/src/configure.in	2016-10-18 16:27:20.544756017 +0200
--- src/configure.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,4314 ****
- dnl configure.in: autoconf script for Vim
- 
- dnl Process this file with autoconf 2.12 or 2.13 to produce "configure".
- dnl Should also work with autoconf 2.54 and later.
- 
- AC_INIT(vim.h)
- AC_CONFIG_HEADER(auto/config.h:config.h.in)
- 
- dnl Being able to run configure means the system is Unix (compatible).
- AC_DEFINE(UNIX)
- AC_PROG_MAKE_SET
- 
- dnl Checks for programs.
- AC_PROG_CC	dnl required by almost everything
- AC_PROG_CPP	dnl required by header file checks
- AC_PROGRAM_EGREP dnl required by AC_EGREP_CPP
- AC_PROG_FGREP	dnl finds working grep -F
- AC_ISC_POSIX	dnl required by AC_C_CROSS
- AC_PROG_AWK	dnl required for "make html" in ../doc
- 
- dnl Don't strip if we don't have it
- AC_CHECK_PROG(STRIP, strip, strip, :)
- 
- dnl Check for extension of executables
- AC_EXEEXT
- 
- dnl Check for standard headers.  We don't use this in Vim but other stuff
- dnl in autoconf needs it, where it uses STDC_HEADERS.
- AC_HEADER_STDC
- AC_HEADER_SYS_WAIT
- 
- dnl Check for the flag that fails if stuff are missing.
- 
- AC_MSG_CHECKING(--enable-fail-if-missing argument)
- AC_ARG_ENABLE(fail_if_missing,
- 	[  --enable-fail-if-missing    Fail if dependencies on additional features
-      specified on the command line are missing.], 
- 	[fail_if_missing="yes"],
- 	[fail_if_missing="no"])
- AC_MSG_RESULT($fail_if_missing)
- 
- dnl Set default value for CFLAGS if none is defined or it's empty
- if test -z "$CFLAGS"; then
-   CFLAGS="-O"
-   test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
- fi
- if test "$GCC" = yes; then
-   dnl method that should work for nearly all versions
-   gccversion=`$CC -dumpversion`
-   if test "x$gccversion" = "x"; then
-     dnl old method; fall-back for when -dumpversion doesn't work
-     gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
-   fi
-   dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
-   if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
-     echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling "-O#"'
-     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-O/'`
-   else
-     if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
-       echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
-       CFLAGS="$CFLAGS -fno-strength-reduce"
-     fi
-   fi
- fi
- 
- dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
- dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
- dnl the version number of the clang in use.
- dnl Note that this does not work to get the version of clang 3.1 or 3.2.
- AC_MSG_CHECKING(for recent clang version)
- CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
- if test x"$CLANG_VERSION_STRING" != x"" ; then
-   CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
-   CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
-   CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
-   CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
-   AC_MSG_RESULT($CLANG_VERSION)
-   dnl If you find the same issue with versions earlier than 500.2.75,
-   dnl change the constant 500002075 below appropriately.  To get the
-   dnl integer corresponding to a version number, refer to the
-   dnl definition of CLANG_VERSION above.
-   if test "$CLANG_VERSION" -ge 500002075 ; then
-     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
-   fi
- else
-   AC_MSG_RESULT(no)
- fi
- 
- dnl If configure thinks we are cross compiling, there might be something
- dnl wrong with the CC or CFLAGS settings, give a useful warning message
- CROSS_COMPILING=
- if test "$cross_compiling" = yes; then
-   AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])
-   CROSS_COMPILING=1
- fi
- AC_SUBST(CROSS_COMPILING)
- 
- dnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.
- dnl But gcc 3.1 changed the meaning!  See near the end.
- test "$GCC" = yes && CPP_MM=M; AC_SUBST(CPP_MM)
- 
- if test -f ./toolcheck; then
-   AC_CHECKING(for buggy tools)
-   sh ./toolcheck 1>&AC_FD_MSG
- fi
- 
- OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
- 
- dnl Check for BeOS, which needs an extra source file
- AC_MSG_CHECKING(for BeOS)
- case `uname` in
-     BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
- 		BEOS=yes; AC_MSG_RESULT(yes);;
-     *)		BEOS=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl If QNX is found, assume we don't want to use Xphoton
- dnl unless it was specifically asked for (--with-x)
- AC_MSG_CHECKING(for QNX)
- case `uname` in
-     QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
- 		test -z "$with_x" && with_x=no
- 		QNX=yes; AC_MSG_RESULT(yes);;
-     *)		QNX=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl Check for Darwin and MacOS X
- dnl We do a check for MacOS X in the very beginning because there
- dnl are a lot of other things we need to change besides GUI stuff
- AC_MSG_CHECKING([for Darwin (Mac OS X)])
- if test "`(uname) 2>/dev/null`" = Darwin; then
-   AC_MSG_RESULT(yes)
- 
-   AC_MSG_CHECKING(--disable-darwin argument)
-   AC_ARG_ENABLE(darwin,
- 	  [  --disable-darwin        Disable Darwin (Mac OS X) support.],
- 	  , [enable_darwin="yes"])
-   if test "$enable_darwin" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_MSG_CHECKING(if Darwin files are there)
-     if test -f os_macosx.m; then
-       AC_MSG_RESULT(yes)
-     else
-       AC_MSG_RESULT([no, Darwin support disabled])
-       enable_darwin=no
-     fi
-   else
-     AC_MSG_RESULT([yes, Darwin support excluded])
-   fi
- 
-   AC_MSG_CHECKING(--with-mac-arch argument)
-   AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
- 	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
- 	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
- 
-   AC_MSG_CHECKING(--with-developer-dir argument)
-   AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
- 	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
-         AC_MSG_RESULT(not present))
-   
-   if test "x$DEVELOPER_DIR" = "x"; then
-     AC_PATH_PROG(XCODE_SELECT, xcode-select)
-     if test "x$XCODE_SELECT" != "x"; then
-       AC_MSG_CHECKING(for developer dir using xcode-select)
-       DEVELOPER_DIR=`$XCODE_SELECT -print-path`
-       AC_MSG_RESULT([$DEVELOPER_DIR])
-     else
-       DEVELOPER_DIR=/Developer
-     fi
-   fi
- 
-   if test "x$MACARCH" = "xboth"; then
-     AC_MSG_CHECKING(for 10.4 universal SDK)
-     dnl There is a terrible inconsistency (but we appear to get away with it):
-     dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
-     dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
-     dnl tests using the preprocessor are actually done with the wrong header
-     dnl files. $LDFLAGS is set at the end, because configure uses it together
-     dnl with $CFLAGS and we can only have one -sysroot argument.
-     save_cppflags="$CPPFLAGS"
-     save_cflags="$CFLAGS"
-     save_ldflags="$LDFLAGS"
-     CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
-     AC_TRY_LINK([ ], [ ],
- 	AC_MSG_RESULT(found, will make universal binary),
- 
- 	AC_MSG_RESULT(not found)
- 	CFLAGS="$save_cflags"
- 	AC_MSG_CHECKING(if Intel architecture is supported)
- 	CPPFLAGS="$CPPFLAGS -arch i386"
- 	LDFLAGS="$save_ldflags -arch i386"
- 	AC_TRY_LINK([ ], [ ],
- 	    AC_MSG_RESULT(yes); MACARCH="intel",
- 	    AC_MSG_RESULT(no, using PowerPC)
- 		MACARCH="ppc"
- 		CPPFLAGS="$save_cppflags -arch ppc"
- 		LDFLAGS="$save_ldflags -arch ppc"))
-   elif test "x$MACARCH" = "xintel"; then
-     CPPFLAGS="$CPPFLAGS -arch intel"
-     LDFLAGS="$LDFLAGS -arch intel"
-   elif test "x$MACARCH" = "xppc"; then
-     CPPFLAGS="$CPPFLAGS -arch ppc"
-     LDFLAGS="$LDFLAGS -arch ppc"
-   fi
- 
-   if test "$enable_darwin" = "yes"; then
-     MACOSX=yes
-     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
-     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
-     dnl TODO: use -arch i386 on Intel machines
-     dnl Removed -no-cpp-precomp, only for very old compilers.
-     CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
- 
-     dnl If Carbon is found, assume we don't want X11
-     dnl unless it was specifically asked for (--with-x)
-     dnl or Motif, Athena or GTK GUI is used.
-     AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)
-     if test "x$CARBON" = "xyes"; then
-       if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
- 	with_x=no
-       fi
-     fi
-   fi
- 
-   dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double
-   dnl free.  This happens in expand_filename(), because the optimizer swaps
-   dnl two blocks of code, both using "repl", that can't be swapped.
-   if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
-     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-Oz/'`
-   fi
- 
- else
-   AC_MSG_RESULT(no)
- fi
- 
- dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
- dnl so we need to include it to have access to version macros.
- AC_CHECK_HEADERS(AvailabilityMacros.h)
- 
- AC_SUBST(OS_EXTRA_SRC)
- AC_SUBST(OS_EXTRA_OBJ)
- 
- dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
- dnl Only when the directory exists and it wasn't there yet.
- dnl For gcc don't do this when it is already in the default search path.
- dnl Skip all of this when cross-compiling.
- if test "$cross_compiling" = no; then
-   AC_MSG_CHECKING(--with-local-dir argument)
-   have_local_include=''
-   have_local_lib=''
-   AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
-   --without-local-dir     do not search /usr/local for local libraries.], [
-     local_dir="$withval"
-     case "$withval" in
-     */*) ;;
-     no)
-       # avoid adding local dir to LDFLAGS and CPPFLAGS
-       have_local_include=yes
-       have_local_lib=yes
-       ;;
-     *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;
-     esac
- 	AC_MSG_RESULT($local_dir)
-   ], [
-     local_dir=/usr/local
-     AC_MSG_RESULT(Defaulting to $local_dir)
-   ])
-   if test "$GCC" = yes -a "$local_dir" != no; then
-     echo 'void f(){}' > conftest.c
-     dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
-     have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
-     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
-     rm -f conftest.c conftest.o
-   fi
-   if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
-     tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
-     if test "$tt" = "$LDFLAGS"; then
-       LDFLAGS="$LDFLAGS -L${local_dir}/lib"
-     fi
-   fi
-   if test -z "$have_local_include" -a -d "${local_dir}/include"; then
-     tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
-     if test "$tt" = "$CPPFLAGS"; then
-       CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
-     fi
-   fi
- fi
- 
- AC_MSG_CHECKING(--with-vim-name argument)
- AC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],
- 	VIMNAME="$withval"; AC_MSG_RESULT($VIMNAME),
- 	VIMNAME="vim"; AC_MSG_RESULT(Defaulting to $VIMNAME))
- AC_SUBST(VIMNAME)
- AC_MSG_CHECKING(--with-ex-name argument)
- AC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],
- 	EXNAME="$withval"; AC_MSG_RESULT($EXNAME),
- 	EXNAME="ex"; AC_MSG_RESULT(Defaulting to ex))
- AC_SUBST(EXNAME)
- AC_MSG_CHECKING(--with-view-name argument)
- AC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],
- 	VIEWNAME="$withval"; AC_MSG_RESULT($VIEWNAME),
- 	VIEWNAME="view"; AC_MSG_RESULT(Defaulting to view))
- AC_SUBST(VIEWNAME)
- 
- AC_MSG_CHECKING(--with-global-runtime argument)
- AC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],
- 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, "$withval"),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING(--with-modified-by argument)
- AC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],
- 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, "$withval"),
- 	AC_MSG_RESULT(no))
- 
- dnl Check for EBCDIC stolen from the LYNX port to z/OS Unix
- AC_MSG_CHECKING(if character set is EBCDIC)
- AC_TRY_COMPILE([ ],
- [ /* TryCompile function for CharSet.
-    Treat any failure as ASCII for compatibility with existing art.
-    Use compile-time rather than run-time tests for cross-compiler
-    tolerance.  */
- #if '0'!=240
- make an error "Character set is not EBCDIC"
- #endif ],
- [ # TryCompile action if true
- cf_cv_ebcdic=yes ],
- [ # TryCompile action if false
- cf_cv_ebcdic=no])
- # end of TryCompile ])
- # end of CacheVal CvEbcdic
- AC_MSG_RESULT($cf_cv_ebcdic)
- case "$cf_cv_ebcdic" in  #(vi
-     yes)	AC_DEFINE(EBCDIC)
- 		line_break='"\\n"'
- 		;;
-     *)		line_break='"\\012"';;
- esac
- AC_SUBST(line_break)
- 
- if test "$cf_cv_ebcdic" = "yes"; then
- dnl If we have EBCDIC we most likely have z/OS Unix, let's test it!
- AC_MSG_CHECKING(for z/OS Unix)
- case `uname` in
-     OS/390)	zOSUnix="yes";
- 		dnl If using cc the environment variable _CC_CCMODE must be
- 		dnl set to "1", so that some compiler extensions are enabled.
- 		dnl If using c89 the environment variable is named _CC_C89MODE.
- 		dnl Note: compile with c89 never tested.
- 		if test "$CC" = "cc"; then
- 		  ccm="$_CC_CCMODE"
- 		  ccn="CC"
- 		else
- 		  if test "$CC" = "c89"; then
- 		    ccm="$_CC_C89MODE"
- 		    ccn="C89"
- 		  else
- 		    ccm=1
- 		  fi
- 		fi
- 		if test "$ccm" != "1"; then
- 		  echo ""
- 		  echo "------------------------------------------"
- 		  echo " On z/OS Unix, the environment variable"
- 		  echo " _CC_${ccn}MODE must be set to \"1\"!"
- 		  echo " Do:"
- 		  echo "    export _CC_${ccn}MODE=1"
- 		  echo " and then call configure again."
- 		  echo "------------------------------------------"
- 		  exit 1
- 		fi
- 		# Set CFLAGS for configure process.
- 		# This will be reset later for config.mk.
- 		# Use haltonmsg to force error for missing H files.
- 		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
- 		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
- 		AC_MSG_RESULT(yes)
- 		;;
-     *)		zOSUnix="no";
- 		AC_MSG_RESULT(no)
- 		;;
- esac
- fi
- 
- dnl Set QUOTESED. Needs additional backslashes on zOS
- if test "$zOSUnix" = "yes"; then
-     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
- else
-     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
- fi
- AC_SUBST(QUOTESED)
- 
- 
- dnl Link with -lsmack for Smack stuff; if not found
- AC_MSG_CHECKING(--disable-smack argument)
- AC_ARG_ENABLE(smack,
- 	[  --disable-smack	  Do not check for Smack support.],
- 	, enable_smack="yes")
- if test "$enable_smack" = "yes"; then
-   AC_MSG_RESULT(no)
-   AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
- else
-   AC_MSG_RESULT(yes)
- fi
- if test "$enable_smack" = "yes"; then
-   AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
- fi
- if test "$enable_smack" = "yes"; then
-   AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
-   AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
- 	       AC_MSG_RESULT(yes),
- 	       AC_MSG_RESULT(no); enable_smack="no")
- fi
- if test "$enable_smack" = "yes"; then
-   AC_CHECK_LIB(attr, setxattr,
- 	  [LIBS="$LIBS -lattr"
- 	   found_smack="yes"
- 	   AC_DEFINE(HAVE_SMACK)])
- fi
- 
- dnl When smack was found don't search for SELinux
- if test "x$found_smack" = "x"; then
-   dnl Link with -lselinux for SELinux stuff; if not found
-   AC_MSG_CHECKING(--disable-selinux argument)
-   AC_ARG_ENABLE(selinux,
- 	  [  --disable-selinux	  Do not check for SELinux support.],
- 	  , enable_selinux="yes")
-   if test "$enable_selinux" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_CHECK_LIB(selinux, is_selinux_enabled,
- 	    [LIBS="$LIBS -lselinux"
- 	     AC_DEFINE(HAVE_SELINUX)])
-   else
-      AC_MSG_RESULT(yes)
-   fi
- fi
- 
- dnl Check user requested features.
- 
- AC_MSG_CHECKING(--with-features argument)
- AC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],
- 	features="$withval"; AC_MSG_RESULT($features),
- 	features="huge"; AC_MSG_RESULT(Defaulting to huge))
- 
- dovimdiff=""
- dogvimdiff=""
- case "$features" in
-   tiny)		AC_DEFINE(FEAT_TINY) ;;
-   small)	AC_DEFINE(FEAT_SMALL) ;;
-   normal)	AC_DEFINE(FEAT_NORMAL) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   big)		AC_DEFINE(FEAT_BIG) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   huge)		AC_DEFINE(FEAT_HUGE) dovimdiff="installvimdiff";
- 			dogvimdiff="installgvimdiff" ;;
-   *)		AC_MSG_RESULT([Sorry, $features is not supported]) ;;
- esac
- 
- AC_SUBST(dovimdiff)
- AC_SUBST(dogvimdiff)
- 
- AC_MSG_CHECKING(--with-compiledby argument)
- AC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],
- 	compiledby="$withval"; AC_MSG_RESULT($withval),
- 	compiledby=""; AC_MSG_RESULT(no))
- AC_SUBST(compiledby)
- 
- AC_MSG_CHECKING(--disable-xsmp argument)
- AC_ARG_ENABLE(xsmp,
- 	[  --disable-xsmp          Disable XSMP session management],
- 	, enable_xsmp="yes")
- 
- if test "$enable_xsmp" = "yes"; then
-   AC_MSG_RESULT(no)
-   AC_MSG_CHECKING(--disable-xsmp-interact argument)
-   AC_ARG_ENABLE(xsmp-interact,
- 	  [  --disable-xsmp-interact Disable XSMP interaction],
- 	  , enable_xsmp_interact="yes")
-   if test "$enable_xsmp_interact" = "yes"; then
-     AC_MSG_RESULT(no)
-     AC_DEFINE(USE_XSMP_INTERACT)
-   else
-     AC_MSG_RESULT(yes)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl Check for Lua feature.
- AC_MSG_CHECKING(--enable-luainterp argument)
- AC_ARG_ENABLE(luainterp,
- 	[  --enable-luainterp[=OPTS]     Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_luainterp="no"])
- AC_MSG_RESULT($enable_luainterp)
- 
- if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Lua with tiny or small features])
-   fi
- 
-   dnl -- find the lua executable
-   AC_SUBST(vi_cv_path_lua)
- 
-   AC_MSG_CHECKING(--with-lua-prefix argument)
-   AC_ARG_WITH(lua_prefix,
- 	[  --with-lua-prefix=PFX   Prefix where Lua is installed.],
- 	with_lua_prefix="$withval"; AC_MSG_RESULT($with_lua_prefix),
- 	with_lua_prefix="";AC_MSG_RESULT(no))
- 
-   if test "X$with_lua_prefix" != "X"; then
-        vi_cv_path_lua_pfx="$with_lua_prefix"
-   else
-     AC_MSG_CHECKING(LUA_PREFIX environment var)
-     if test "X$LUA_PREFIX" != "X"; then
- 	AC_MSG_RESULT("$LUA_PREFIX")
- 	vi_cv_path_lua_pfx="$LUA_PREFIX"
-     else
- 	AC_MSG_RESULT([not set, default to /usr])
- 	vi_cv_path_lua_pfx="/usr"
-     fi
-   fi
- 
-   AC_MSG_CHECKING(--with-luajit)
-   AC_ARG_WITH(luajit,
- 	[  --with-luajit           Link with LuaJIT instead of Lua.],
- 	[vi_cv_with_luajit="$withval"],
- 	[vi_cv_with_luajit="no"])
-   AC_MSG_RESULT($vi_cv_with_luajit)
- 
-   LUA_INC=
-   if test "X$vi_cv_path_lua_pfx" != "X"; then
-     if test "x$vi_cv_with_luajit" != "xno"; then
-       dnl -- try to find LuaJIT executable
-       AC_PATH_PROG(vi_cv_path_luajit, luajit)
-       if test "X$vi_cv_path_luajit" != "X"; then
- 	dnl -- find LuaJIT version
- 	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
- 	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
- 	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
- 	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
- 	vi_cv_path_lua="$vi_cv_path_luajit"
- 	vi_cv_version_lua="$vi_cv_version_lua_luajit"
-       fi
-     else
-       dnl -- try to find Lua executable
-       AC_PATH_PROG(vi_cv_path_plain_lua, lua)
-       if test "X$vi_cv_path_plain_lua" != "X"; then
- 	dnl -- find Lua version
- 	AC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,
- 	[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'` ])
-       fi
-       vi_cv_path_lua="$vi_cv_path_plain_lua"
-       vi_cv_version_lua="$vi_cv_version_plain_lua"
-     fi
-     if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
-       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)
-       if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
- 	AC_MSG_RESULT(yes)
- 	LUA_INC=/luajit-$vi_cv_version_luajit
-       fi
-     fi
-     if test "X$LUA_INC" = "X"; then
-       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)
-       if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
- 	AC_MSG_RESULT(yes)
-       else
- 	AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)
- 	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
- 	  AC_MSG_RESULT(yes)
- 	  LUA_INC=/lua$vi_cv_version_lua
- 	else
- 	  AC_MSG_RESULT(no)
- 	  vi_cv_path_lua_pfx=
- 	fi
-       fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_lua_pfx" != "X"; then
-     if test "x$vi_cv_with_luajit" != "xno"; then
-       multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
-       if test "X$multiarch" != "X"; then
- 	lib_multiarch="lib/${multiarch}"
-       else
- 	lib_multiarch="lib"
-       fi
-       if test "X$vi_cv_version_lua" = "X"; then
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
-       else
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
-       fi
-     else
-       if test "X$LUA_INC" != "X"; then
- 	dnl Test alternate location using version
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
-       else
- 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
-       fi
-     fi
-     if test "$enable_luainterp" = "dynamic"; then
-       lua_ok="yes"
-     else
-       AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])
-       libs_save=$LIBS
-       LIBS="$LIBS $LUA_LIBS"
-       AC_TRY_LINK(,[ ],
- 	AC_MSG_RESULT(yes); lua_ok="yes",
- 	AC_MSG_RESULT(no); lua_ok="no"; LUA_LIBS="")
-       LIBS=$libs_save
-     fi
-     if test "x$lua_ok" = "xyes"; then
-       LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
-       LUA_SRC="if_lua.c"
-       LUA_OBJ="objects/if_lua.o"
-       LUA_PRO="if_lua.pro"
-       AC_DEFINE(FEAT_LUA)
-     fi
-     if test "$enable_luainterp" = "dynamic"; then
-       if test "x$vi_cv_with_luajit" != "xno"; then
- 	luajit="jit"
-       fi
-       if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
- 	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
-       else
- 	if test "x$MACOSX" = "xyes"; then
- 	  ext="dylib"
- 	  indexes=""
- 	else
- 	  ext="so"
- 	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
- 	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
- 	  if test "X$multiarch" != "X"; then
- 	    lib_multiarch="lib/${multiarch}"
- 	  fi
- 	fi
- 	dnl Determine the sover for the current version, but fallback to
- 	dnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.
- 	AC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)
- 	for subdir in "${lib_multiarch}" lib64 lib; do
- 	  if test -z "$subdir"; then
- 	    continue
- 	  fi
- 	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
- 	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
- 	    for i in $indexes ""; do
- 	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
- 		sover2="$i"
- 		break 3
- 	      fi
- 	    done
- 	  done
- 	  sover=""
- 	done
- 	if test "X$sover" = "X"; then
- 	  AC_MSG_RESULT(no)
- 	  lua_ok="no"
- 	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
- 	else
- 	  AC_MSG_RESULT(yes)
- 	  lua_ok="yes"
- 	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
- 	fi
-       fi
-       AC_DEFINE(DYNAMIC_LUA)
-       LUA_LIBS=""
-       LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
-     fi
-     if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
-        test "x$MACOSX" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
-        test "`(uname -m) 2>/dev/null`" = "x86_64"; then
-       dnl OSX/x64 requires these flags. See http://luajit.org/install.html
-       LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure lua])
-   fi
-   AC_SUBST(LUA_SRC)
-   AC_SUBST(LUA_OBJ)
-   AC_SUBST(LUA_PRO)
-   AC_SUBST(LUA_LIBS)
-   AC_SUBST(LUA_CFLAGS)
- fi
- 
- 
- dnl Check for MzScheme feature.
- AC_MSG_CHECKING(--enable-mzschemeinterp argument)
- AC_ARG_ENABLE(mzschemeinterp,
- 	[  --enable-mzschemeinterp   Include MzScheme interpreter.], ,
- 	[enable_mzschemeinterp="no"])
- AC_MSG_RESULT($enable_mzschemeinterp)
- 
- if test "$enable_mzschemeinterp" = "yes"; then
-   dnl -- find the mzscheme executable
-   AC_SUBST(vi_cv_path_mzscheme)
- 
-   AC_MSG_CHECKING(--with-plthome argument)
-   AC_ARG_WITH(plthome,
- 	[  --with-plthome=PLTHOME   Use PLTHOME.],
- 	with_plthome="$withval"; AC_MSG_RESULT($with_plthome),
- 	with_plthome="";AC_MSG_RESULT("no"))
- 
-   if test "X$with_plthome" != "X"; then
-        vi_cv_path_mzscheme_pfx="$with_plthome"
-        vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
-   else
-     AC_MSG_CHECKING(PLTHOME environment var)
-     if test "X$PLTHOME" != "X"; then
- 	AC_MSG_RESULT("$PLTHOME")
- 	vi_cv_path_mzscheme_pfx="$PLTHOME"
- 	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
-     else
- 	AC_MSG_RESULT(not set)
- 	dnl -- try to find MzScheme executable
- 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
- 
- 	dnl resolve symbolic link, the executable is often elsewhere and there
- 	dnl are no links for the include files.
- 	if test "X$vi_cv_path_mzscheme" != "X"; then
- 	  lsout=`ls -l $vi_cv_path_mzscheme`
- 	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
- 	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
- 	  fi
- 	fi
- 
- 	if test "X$vi_cv_path_mzscheme" != "X"; then
- 	    dnl -- find where MzScheme thinks it was installed
- 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
- 	    dnl different versions of MzScheme differ in command line processing
- 	    dnl use universal approach
- 	    echo "(display (simplify-path		\
- 	       (build-path (call-with-values	\
- 		(lambda () (split-path (find-system-path (quote exec-file)))) \
- 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
- 	    dnl Remove a trailing slash
- 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
- 		sed -e 's+/$++'` ])
- 	    rm -f mzdirs.scm
- 	fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
-     AC_MSG_CHECKING(for racket include directory)
-     SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_INC" != "X"; then
-       AC_MSG_RESULT(${SCHEME_INC})
-     else
-       AC_MSG_RESULT(not found)
-       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
-       if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
- 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
- 	AC_MSG_RESULT(yes)
-       else
- 	AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
- 	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
- 	  AC_MSG_RESULT(yes)
- 	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
- 	else
- 	  AC_MSG_RESULT(no)
- 	  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
- 	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
- 	    AC_MSG_RESULT(yes)
- 	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
- 	  else
- 	    AC_MSG_RESULT(no)
- 	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
- 	    if test -f /usr/include/plt/scheme.h; then
- 	      AC_MSG_RESULT(yes)
- 	      SCHEME_INC=/usr/include/plt
- 	    else
- 	      AC_MSG_RESULT(no)
- 	      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
- 	      if test -f /usr/include/racket/scheme.h; then
- 		AC_MSG_RESULT(yes)
- 		SCHEME_INC=/usr/include/racket
- 	      else
- 		AC_MSG_RESULT(no)
- 		vi_cv_path_mzscheme_pfx=
- 	      fi
- 	    fi
- 	  fi
- 	fi
-       fi
-     fi
-   fi
- 
-   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
- 
-     AC_MSG_CHECKING(for racket lib directory)
-     SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_LIB" != "X"; then
-       AC_MSG_RESULT(${SCHEME_LIB})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
-       if test "X$path" != "X"; then
- 	if test "x$MACOSX" = "xyes"; then
- 	  MZSCHEME_LIBS="-framework Racket"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libmzscheme3m.a"; then
- 	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libracket3m.a"; then
- 	  MZSCHEME_LIBS="${path}/libracket3m.a"
- 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	elif test -f "${path}/libracket.a"; then
- 	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
- 	elif test -f "${path}/libmzscheme.a"; then
- 	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
- 	else
- 	  dnl Using shared objects
- 	  if test -f "${path}/libmzscheme3m.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
- 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	  elif test -f "${path}/libracket3m.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lracket3m"
- 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
- 	  elif test -f "${path}/libracket.so"; then
- 	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
- 	  else
- 	    dnl try next until last
- 	    if test "$path" != "$SCHEME_LIB"; then
- 	      continue
- 	    fi
- 	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
- 	  fi
- 	  if test "$GCC" = yes; then
- 	    dnl Make Vim remember the path to the library.  For when it's not in
- 	    dnl $LD_LIBRARY_PATH.
- 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
- 	  elif test "`(uname) 2>/dev/null`" = SunOS &&
- 				   uname -r | grep '^5' >/dev/null; then
- 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
- 	  fi
- 	fi
-       fi
-       if test "X$MZSCHEME_LIBS" != "X"; then
- 	break
-       fi
-     done
- 
-     AC_MSG_CHECKING([if racket requires -pthread])
-     if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
-       AC_MSG_RESULT(yes)
-       MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
-     else
-       AC_MSG_RESULT(no)
-     fi
- 
-     AC_MSG_CHECKING(for racket config directory)
-     SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
-     if test "X$SCHEME_CONFIGDIR" != "X"; then
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
-       AC_MSG_RESULT(${SCHEME_CONFIGDIR})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     AC_MSG_CHECKING(for racket collects directory)
-     SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
-     if test "X$SCHEME_COLLECTS" = "X"; then
-       if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
- 	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
-       else
- 	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
- 	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
- 	else
- 	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
- 	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
- 	  else
- 	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
- 	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
- 	    fi
- 	  fi
- 	fi
-       fi
-     fi
-     if test "X$SCHEME_COLLECTS" != "X" ; then
-       AC_MSG_RESULT(${SCHEME_COLLECTS})
-     else
-       AC_MSG_RESULT(not found)
-     fi
- 
-     AC_MSG_CHECKING(for mzscheme_base.c)
-     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-       MZSCHEME_EXTRA="mzscheme_base.c"
-       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
-       MZSCHEME_MOD="++lib scheme/base"
-     else
-       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
- 	MZSCHEME_EXTRA="mzscheme_base.c"
- 	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
- 	MZSCHEME_MOD="++lib scheme/base"
-       else
- 	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
- 	  MZSCHEME_EXTRA="mzscheme_base.c"
- 	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
- 	  MZSCHEME_MOD=""
- 	fi
-       fi
-     fi
-     if test "X$MZSCHEME_EXTRA" != "X" ; then
-       dnl need to generate bytecode for MzScheme base
-       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
-       AC_MSG_RESULT(needed)
-     else
-       AC_MSG_RESULT(not needed)
-     fi
- 
-     dnl On Ubuntu this fixes "undefined reference to symbol 'ffi_type_void'".
-     AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"])
- 
-     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
-       -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
- 
-     dnl Test that we can compile a simple program with these CFLAGS and LIBS.
-     AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])
-     cflags_save=$CFLAGS
-     libs_save=$LIBS
-     CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
-     LIBS="$LIBS $MZSCHEME_LIBS"
-     AC_TRY_LINK(,[ ],
- 	   AC_MSG_RESULT(yes); mzs_ok=yes,
- 	   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)
-     CFLAGS=$cflags_save
-     LIBS=$libs_save
-     if test $mzs_ok = yes; then
-       MZSCHEME_SRC="if_mzsch.c"
-       MZSCHEME_OBJ="objects/if_mzsch.o"
-       MZSCHEME_PRO="if_mzsch.pro"
-       AC_DEFINE(FEAT_MZSCHEME)
-     else
-       MZSCHEME_CFLAGS=
-       MZSCHEME_LIBS=
-       MZSCHEME_EXTRA=
-       MZSCHEME_MZC=
-     fi
-   fi
-   AC_SUBST(MZSCHEME_SRC)
-   AC_SUBST(MZSCHEME_OBJ)
-   AC_SUBST(MZSCHEME_PRO)
-   AC_SUBST(MZSCHEME_LIBS)
-   AC_SUBST(MZSCHEME_CFLAGS)
-   AC_SUBST(MZSCHEME_EXTRA)
-   AC_SUBST(MZSCHEME_MZC)
- fi
- 
- 
- AC_MSG_CHECKING(--enable-perlinterp argument)
- AC_ARG_ENABLE(perlinterp,
- 	[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_perlinterp="no"])
- AC_MSG_RESULT($enable_perlinterp)
- if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Perl with tiny or small features])
-   fi
-   AC_SUBST(vi_cv_path_perl)
-   AC_PATH_PROG(vi_cv_path_perl, perl)
-   if test "X$vi_cv_path_perl" != "X"; then
-     AC_MSG_CHECKING(Perl version)
-     if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
-      eval `$vi_cv_path_perl -V:usethreads`
-      eval `$vi_cv_path_perl -V:libperl`
-      if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
-        badthreads=no
-      else
-        if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
- 	 eval `$vi_cv_path_perl -V:use5005threads`
- 	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
- 	   badthreads=no
- 	 else
- 	   badthreads=yes
- 	   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)
- 	 fi
-        else
- 	 badthreads=yes
- 	 AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)
-        fi
-      fi
-      if test $badthreads = no; then
-       AC_MSG_RESULT(OK)
-       eval `$vi_cv_path_perl -V:shrpenv`
-       if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
- 	shrpenv=""
-       fi
-       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
-       AC_SUBST(vi_cv_perllib)
-       vi_cv_perl_extutils=unknown_perl_extutils_path
-       for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
- 	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
- 	if test -f "$xsubpp_path"; then
- 	  vi_cv_perl_xsubpp="$xsubpp_path"
- 	fi
-       done
-       AC_SUBST(vi_cv_perl_xsubpp)
-       dnl Remove "-fno-something", it breaks using cproto.
-       dnl Remove "-fdebug-prefix-map", it isn't supported by clang.
-       perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
- 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//' \
- 			-e 's/-fdebug-prefix-map[[^ ]]*//g'`
-       dnl Remove "-lc", it breaks on FreeBSD when using "-pthread".
-       perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
- 		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
- 			-e 's/-bE:perl.exp//' -e 's/-lc //'`
-       dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH
-       dnl a test in configure may fail because of that.
-       perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
- 		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
- 
-       dnl check that compiling a simple program still works with the flags
-       dnl added for Perl.
-       AC_MSG_CHECKING([if compile and link flags for Perl are sane])
-       cflags_save=$CFLAGS
-       libs_save=$LIBS
-       ldflags_save=$LDFLAGS
-       CFLAGS="$CFLAGS $perlcppflags"
-       LIBS="$LIBS $perllibs"
-       perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
-       LDFLAGS="$perlldflags $LDFLAGS"
-       AC_TRY_LINK(,[ ],
- 	     AC_MSG_RESULT(yes); perl_ok=yes,
- 	     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)
-       CFLAGS=$cflags_save
-       LIBS=$libs_save
-       LDFLAGS=$ldflags_save
-       if test $perl_ok = yes; then
- 	if test "X$perlcppflags" != "X"; then
- 	  dnl remove -pipe and -Wxxx, it confuses cproto
- 	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`
- 	fi
- 	if test "X$perlldflags" != "X"; then
- 	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
- 	    LDFLAGS="$perlldflags $LDFLAGS"
- 	  fi
- 	fi
- 	PERL_LIBS=$perllibs
- 	PERL_SRC="auto/if_perl.c if_perlsfio.c"
- 	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
- 	PERL_PRO="if_perl.pro if_perlsfio.pro"
- 	AC_DEFINE(FEAT_PERL)
-       fi
-      fi
-     else
-       AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)
-     fi
-   fi
- 
-   if test "x$MACOSX" = "xyes"; then
-     dnl Mac OS X 10.2 or later
-     dir=/System/Library/Perl
-     darwindir=$dir/darwin
-     if test -d $darwindir; then
-       PERL=/usr/bin/perl
-     else
-       dnl Mac OS X 10.3
-       dir=/System/Library/Perl/5.8.1
-       darwindir=$dir/darwin-thread-multi-2level
-       if test -d $darwindir; then
- 	PERL=/usr/bin/perl
-       fi
-     fi
-     if test -n "$PERL"; then
-       PERL_DIR="$dir"
-       PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
-       PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
-       PERL_LIBS="-L$darwindir/CORE -lperl"
-     fi
-     dnl Perl on Mac OS X 10.5 adds "-arch" flags but these should only
-     dnl be included if requested by passing --with-mac-arch to
-     dnl configure, so strip these flags first (if present)
-     PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
-     PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
-   fi
-   if test "$enable_perlinterp" = "dynamic"; then
-     if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
-       AC_DEFINE(DYNAMIC_PERL)
-       PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure perl])
-   fi
- fi
- AC_SUBST(shrpenv)
- AC_SUBST(PERL_SRC)
- AC_SUBST(PERL_OBJ)
- AC_SUBST(PERL_PRO)
- AC_SUBST(PERL_CFLAGS)
- AC_SUBST(PERL_LIBS)
- 
- AC_MSG_CHECKING(--enable-pythoninterp argument)
- AC_ARG_ENABLE(pythoninterp,
- 	[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_pythoninterp="no"])
- AC_MSG_RESULT($enable_pythoninterp)
- if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Python with tiny or small features])
-   fi
- 
-   dnl -- find the python executable
-   AC_PATH_PROGS(vi_cv_path_python, python2 python)
-   if test "X$vi_cv_path_python" != "X"; then
- 
-     dnl -- get its version number
-     AC_CACHE_CHECK(Python version,vi_cv_var_python_version,
-     [[vi_cv_var_python_version=`
- 	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
-     ]])
- 
-     dnl -- it must be at least version 2.3
-     AC_MSG_CHECKING(Python is 2.3 or better)
-     if ${vi_cv_path_python} -c \
- 	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
-     then
-       AC_MSG_RESULT(yep)
- 
-       dnl -- find where python thinks it was installed
-       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,
-       [ vi_cv_path_python_pfx=`
- 	    ${vi_cv_path_python} -c \
- 		"import sys; print sys.prefix"` ])
- 
-       dnl -- and where it thinks it runs
-       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,
-       [ vi_cv_path_python_epfx=`
- 	    ${vi_cv_path_python} -c \
- 		"import sys; print sys.exec_prefix"` ])
- 
-       dnl -- python's internal library path
- 
-       AC_CACHE_VAL(vi_cv_path_pythonpath,
-       [ vi_cv_path_pythonpath=`
- 	    unset PYTHONPATH;
- 	    ${vi_cv_path_python} -c \
- 		"import sys, string; print string.join(sys.path,':')"` ])
- 
-       dnl -- where the Python implementation library archives are
- 
-       AC_ARG_WITH(python-config-dir,
- 	[  --with-python-config-dir=PATH  Python's config directory],
- 	[ vi_cv_path_python_conf="${withval}" ] )
- 
-       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
-       [
- 	vi_cv_path_python_conf=
- 	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
- 	if test -d "$d" && test -f "$d/config.c"; then
- 	  vi_cv_path_python_conf="$d"
- 	else
- 	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
- 	    for subdir in lib64 lib share; do
- 	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
- 	      if test -d "$d" && test -f "$d/config.c"; then
- 		vi_cv_path_python_conf="$d"
- 	      fi
- 	    done
- 	  done
- 	fi
-       ])
- 
-       PYTHON_CONFDIR="${vi_cv_path_python_conf}"
- 
-       if test "X$PYTHON_CONFDIR" = "X"; then
- 	AC_MSG_RESULT([can't find it!])
-       else
- 
- 	dnl -- we need to examine Python's config/Makefile too
- 	dnl    see what the interpreter is built from
- 	AC_CACHE_VAL(vi_cv_path_python_plibs,
- 	[
- 	    pwd=`pwd`
- 	    tmp_mkf="$pwd/config-PyMake$$"
- 	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
- __:
- 	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
- 	@echo "python_LIBS='$(LIBS)'"
- 	@echo "python_SYSLIBS='$(SYSLIBS)'"
- 	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
- 	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
- 	@echo "python_INSTSONAME='$(INSTSONAME)'"
- 	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
- 	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
- 	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
- eof
- 	    dnl -- delete the lines from make about Entering/Leaving directory
- 	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
- 	    rm -f -- "${tmp_mkf}"
- 	    if test "x$MACOSX" = "xyes" && test -n "${python_PYTHONFRAMEWORK}" && ${vi_cv_path_python} -c \
- 		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
- 	      vi_cv_path_python_plibs="-framework Python"
- 	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
- 		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
- 	      fi
- 	    else
- 	      if test "${vi_cv_var_python_version}" = "1.4"; then
- 		  vi_cv_path_python_plibs="${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a"
- 	      else
- 		  vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
- 	      fi
- 	      dnl -- Check if the path contained in python_LINKFORSHARED is
- 	      dnl    usable for vim build. If not, make and try other
- 	      dnl    candidates.
- 	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
- 	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]].*/\1/'`
- 		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]][[ \t]]*\(.*\)/\2/'`
- 	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
- 	          dnl -- The path looks relative. Guess the absolute one using
- 		  dnl    the prefix and try that.
- 	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
- 		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
- 		    dnl -- A last resort.
- 		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
- 	            dnl -- No check is done. The last word is left to the
- 	            dnl    "sanity" test on link flags that follows shortly.
- 		  fi
- 	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
- 	        fi
- 	      fi
- 	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
- 	      dnl remove -ltermcap, it can conflict with an earlier -lncurses
- 	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
- 	    fi
- 	])
- 	AC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,
- 	[
- 	  if test "X$python_DLLLIBRARY" != "X"; then
- 	    vi_cv_dll_name_python="$python_DLLLIBRARY"
- 	  else
- 	    vi_cv_dll_name_python="$python_INSTSONAME"
- 	  fi
- 	])
- 
- 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
- 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
- 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
- 	else
- 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
- 	fi
- 	PYTHON_SRC="if_python.c"
- 	PYTHON_OBJ="objects/if_python.o"
- 	if test "${vi_cv_var_python_version}" = "1.4"; then
- 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
- 	fi
-     PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
- 
- 	dnl On FreeBSD linking with "-pthread" is required to use threads.
- 	dnl _THREAD_SAFE must be used for compiling then.
- 	dnl The "-pthread" is added to $LIBS, so that the following check for
- 	dnl sigaltstack() will look in libc_r (it's there in libc!).
- 	dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
- 	dnl will then define target-specific defines, e.g., -D_REENTRANT.
- 	dnl Don't do this for Mac OSX, -pthread will generate a warning.
- 	AC_MSG_CHECKING([if -pthread should be used])
- 	threadsafe_flag=
- 	thread_lib=
- 	dnl if test "x$MACOSX" != "xyes"; then
-         if test "`(uname) 2>/dev/null`" != Darwin; then
- 	  test "$GCC" = yes && threadsafe_flag="-pthread"
- 	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
- 	    threadsafe_flag="-D_THREAD_SAFE"
- 	    thread_lib="-pthread"
- 	  fi
- 	  if test "`(uname) 2>/dev/null`" = SunOS; then
- 	    threadsafe_flag="-pthreads"
- 	  fi
- 	fi
- 	libs_save_old=$LIBS
- 	if test -n "$threadsafe_flag"; then
- 	  cflags_save=$CFLAGS
- 	  CFLAGS="$CFLAGS $threadsafe_flag"
- 	  LIBS="$LIBS $thread_lib"
- 	  AC_TRY_LINK(,[ ],
- 	     AC_MSG_RESULT(yes); PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag",
- 	     AC_MSG_RESULT(no); LIBS=$libs_save_old
- 	     )
- 	  CFLAGS=$cflags_save
- 	else
- 	  AC_MSG_RESULT(no)
- 	fi
- 
- 	dnl Check that compiling a simple program still works with the flags
- 	dnl added for Python.
- 	AC_MSG_CHECKING([if compile and link flags for Python are sane])
- 	cflags_save=$CFLAGS
- 	libs_save=$LIBS
- 	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
- 	LIBS="$LIBS $PYTHON_LIBS"
- 	AC_TRY_LINK(,[ ],
- 	       AC_MSG_RESULT(yes); python_ok=yes,
- 	       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)
- 	CFLAGS=$cflags_save
- 	LIBS=$libs_save
- 	if test $python_ok = yes; then
- 	  AC_DEFINE(FEAT_PYTHON)
- 	else
- 	  LIBS=$libs_save_old
- 	  PYTHON_SRC=
- 	  PYTHON_OBJ=
- 	  PYTHON_LIBS=
- 	  PYTHON_CFLAGS=
- 	fi
-       fi
-     else
-       AC_MSG_RESULT(too old)
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure python])
-   fi
- fi
- 
- AC_SUBST(PYTHON_CONFDIR)
- AC_SUBST(PYTHON_LIBS)
- AC_SUBST(PYTHON_GETPATH_CFLAGS)
- AC_SUBST(PYTHON_CFLAGS)
- AC_SUBST(PYTHON_SRC)
- AC_SUBST(PYTHON_OBJ)
- 
- 
- AC_MSG_CHECKING(--enable-python3interp argument)
- AC_ARG_ENABLE(python3interp,
- 	[  --enable-python3interp[=OPTS]   Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_python3interp="no"])
- AC_MSG_RESULT($enable_python3interp)
- if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Python with tiny or small features])
-   fi
- 
-   dnl -- find the python3 executable
-   AC_PATH_PROGS(vi_cv_path_python3, python3 python)
-   if test "X$vi_cv_path_python3" != "X"; then
- 
-     dnl -- get its version number
-     AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,
-     [[vi_cv_var_python3_version=`
-           ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
-     ]])
- 
-     dnl -- it must be at least version 3
-     AC_MSG_CHECKING(Python is 3.0 or better)
-     if ${vi_cv_path_python3} -c \
-       "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
-     then
-       AC_MSG_RESULT(yep)
- 
-       dnl -- get abiflags for python 3.2 or higher (PEP 3149)
-       AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,
-       [
-        vi_cv_var_python3_abiflags=
-        if ${vi_cv_path_python3} -c \
-            "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
-        then
-          vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \    
-            "import sys; print(sys.abiflags)"`
-        fi ])
-   
-       dnl -- find where python3 thinks it was installed
-       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,
-       [ vi_cv_path_python3_pfx=`
-        ${vi_cv_path_python3} -c \
-        "import sys; print(sys.prefix)"` ])
-   
-       dnl -- and where it thinks it runs
-       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,
-       [ vi_cv_path_python3_epfx=`
-        ${vi_cv_path_python3} -c \
-        "import sys; print(sys.exec_prefix)"` ])
-   
-       dnl -- python3's internal library path
-   
-       AC_CACHE_VAL(vi_cv_path_python3path,
-       [ vi_cv_path_python3path=`
-        unset PYTHONPATH;
-        ${vi_cv_path_python3} -c \
-        "import sys, string; print(':'.join(sys.path))"` ])
-   
-       dnl -- where the Python implementation library archives are
-   
-       AC_ARG_WITH(python3-config-dir,
-        [  --with-python3-config-dir=PATH  Python's config directory],
-        [ vi_cv_path_python3_conf="${withval}" ] )
-   
-       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,
-       [
-        vi_cv_path_python3_conf=
-        config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
-        d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
-        if test -d "$d" && test -f "$d/config.c"; then
-          vi_cv_path_python3_conf="$d"
-        else
-          for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
- 	   for subdir in lib64 lib share; do
- 	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
- 	     if test -d "$d" && test -f "$d/config.c"; then
- 	       vi_cv_path_python3_conf="$d"
- 	     fi
- 	   done
-          done
-        fi
-       ])
-   
-       PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
-   
-       if test "X$PYTHON3_CONFDIR" = "X"; then
-         AC_MSG_RESULT([can't find it!])
-       else
-   
-         dnl -- we need to examine Python's config/Makefile too
-         dnl    see what the interpreter is built from
-         AC_CACHE_VAL(vi_cv_path_python3_plibs,
-         [
-             pwd=`pwd`
-             tmp_mkf="$pwd/config-PyMake$$"
-             cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
- __:
- 	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
- 	@echo "python3_LIBS='$(LIBS)'"
- 	@echo "python3_SYSLIBS='$(SYSLIBS)'"
- 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
- 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
- eof
- 	    dnl -- delete the lines from make about Entering/Leaving directory
- 	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
- 	    rm -f -- "${tmp_mkf}"
- 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
- 	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
- 	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
- 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
- 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
- 	])
- 	AC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,
- 	[
- 	  if test "X$python3_DLLLIBRARY" != "X"; then
- 	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
- 	  else
- 	    vi_cv_dll_name_python3="$python3_INSTSONAME"
- 	  fi
- 	])
- 
-         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
-         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
-         else
-           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
-         fi
-         PYTHON3_SRC="if_python3.c"
-         PYTHON3_OBJ="objects/if_python3.o"
-   
-         dnl On FreeBSD linking with "-pthread" is required to use threads.
-         dnl _THREAD_SAFE must be used for compiling then.
-         dnl The "-pthread" is added to $LIBS, so that the following check for
-         dnl sigaltstack() will look in libc_r (it's there in libc!).
-         dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
-         dnl will then define target-specific defines, e.g., -D_REENTRANT.
-         dnl Don't do this for Mac OSX, -pthread will generate a warning.
-         AC_MSG_CHECKING([if -pthread should be used])
-         threadsafe_flag=
-         thread_lib=
-         dnl if test "x$MACOSX" != "xyes"; then
-         if test "`(uname) 2>/dev/null`" != Darwin; then
-           test "$GCC" = yes && threadsafe_flag="-pthread"
-           if test "`(uname) 2>/dev/null`" = FreeBSD; then
-             threadsafe_flag="-D_THREAD_SAFE"
-             thread_lib="-pthread"
-           fi
-           if test "`(uname) 2>/dev/null`" = SunOS; then
-             threadsafe_flag="-pthreads"
-           fi
-         fi
-         libs_save_old=$LIBS
-         if test -n "$threadsafe_flag"; then
-           cflags_save=$CFLAGS
-           CFLAGS="$CFLAGS $threadsafe_flag"
-           LIBS="$LIBS $thread_lib"
-           AC_TRY_LINK(,[ ],
-              AC_MSG_RESULT(yes); PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag",
-              AC_MSG_RESULT(no); LIBS=$libs_save_old
-              )
-           CFLAGS=$cflags_save
-         else
-           AC_MSG_RESULT(no)
-         fi
-   
-         dnl check that compiling a simple program still works with the flags
-         dnl added for Python.
-         AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])
-         cflags_save=$CFLAGS
-         libs_save=$LIBS
-         CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
-         LIBS="$LIBS $PYTHON3_LIBS"
-         AC_TRY_LINK(,[ ],
-                AC_MSG_RESULT(yes); python3_ok=yes,
-                AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)
-         CFLAGS=$cflags_save
-         LIBS=$libs_save
-         if test "$python3_ok" = yes; then
-           AC_DEFINE(FEAT_PYTHON3)
-         else
-           LIBS=$libs_save_old
-           PYTHON3_SRC=
-           PYTHON3_OBJ=
-           PYTHON3_LIBS=
-           PYTHON3_CFLAGS=
-         fi
-       fi
-     else
-       AC_MSG_RESULT(too old)
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
-     AC_MSG_ERROR([could not configure python3])
-   fi
- fi
- 
- AC_SUBST(PYTHON3_CONFDIR)
- AC_SUBST(PYTHON3_LIBS)
- AC_SUBST(PYTHON3_CFLAGS)
- AC_SUBST(PYTHON3_SRC)
- AC_SUBST(PYTHON3_OBJ)
- 
- dnl if python2.x and python3.x are enabled one can only link in code
- dnl with dlopen(), dlsym(), dlclose() 
- if test "$python_ok" = yes && test "$python3_ok" = yes; then
-   AC_DEFINE(DYNAMIC_PYTHON)
-   AC_DEFINE(DYNAMIC_PYTHON3)
-   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $PYTHON_CFLAGS"
-   libs_save=$LIBS
-   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
-   LIBS="-ldl $LIBS"
-   AC_RUN_IFELSE([AC_LANG_SOURCE([
-     #include <dlfcn.h>
-     /* If this program fails, then RTLD_GLOBAL is needed.
-      * RTLD_GLOBAL will be used and then it is not possible to
-      * have both python versions enabled in the same vim instance.
-      * Only the first python version used will be switched on.
-      */
- 
-     int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
-     {
-       int needed = 0;
-       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
-       if (pylib != 0)
-       {
-           void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
-           void (*init)(void) = dlsym(pylib, "Py_Initialize");
-           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
-           void (*final)(void) = dlsym(pylib, "Py_Finalize");
-           (*pfx)(prefix);
-           (*init)();
-           needed = (*simple)("import termios") == -1;
-           (*final)();
-           dlclose(pylib);
-       }
-       return !needed;
-     }
- 
-     int main(int argc, char** argv)
-     {
-       int not_needed = 0;
-       if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
-             not_needed = 1;
-       return !not_needed;
-     }])],
-     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- 
-   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
-   libs_save=$LIBS
-   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
-   LIBS="-ldl $LIBS"
-   AC_RUN_IFELSE([AC_LANG_SOURCE([
-     #include <dlfcn.h>
-     #include <wchar.h>
-     /* If this program fails, then RTLD_GLOBAL is needed.
-      * RTLD_GLOBAL will be used and then it is not possible to
-      * have both python versions enabled in the same vim instance.
-      * Only the first python version used will be switched on.
-      */
- 
-     int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
-     {
-       int needed = 0;
-       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
-       if (pylib != 0)
-       {
-           void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
-           void (*init)(void) = dlsym(pylib, "Py_Initialize");
-           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
-           void (*final)(void) = dlsym(pylib, "Py_Finalize");
-           (*pfx)(prefix);
-           (*init)();
-           needed = (*simple)("import termios") == -1;
-           (*final)();
-           dlclose(pylib);
-       }
-       return !needed;
-     }
- 
-     int main(int argc, char** argv)
-     {
-       int not_needed = 0;
-       if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
-             not_needed = 1;
-       return !not_needed;
-     }])],
-     [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- 
-   PYTHON_SRC="if_python.c"
-   PYTHON_OBJ="objects/if_python.o"
-   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
-   PYTHON_LIBS=
-   PYTHON3_SRC="if_python3.c"
-   PYTHON3_OBJ="objects/if_python3.o"
-   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
-   PYTHON3_LIBS=
- elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
-   AC_DEFINE(DYNAMIC_PYTHON)
-   PYTHON_SRC="if_python.c"
-   PYTHON_OBJ="objects/if_python.o"
-   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
-   PYTHON_LIBS=
- elif test "$python_ok" = yes; then
-   dnl Check that adding -fPIE works.  It may be needed when using a static
-   dnl Python library.
-   AC_MSG_CHECKING([if -fPIE can be added for Python])
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
-   LIBS="$LIBS $PYTHON_LIBS"
-   AC_TRY_LINK(,[ ],
- 	 AC_MSG_RESULT(yes); fpie_ok=yes,
- 	 AC_MSG_RESULT(no); fpie_ok=no)
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
-   if test $fpie_ok = yes; then
-     PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
-   fi
- elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
-   AC_DEFINE(DYNAMIC_PYTHON3)
-   PYTHON3_SRC="if_python3.c"
-   PYTHON3_OBJ="objects/if_python3.o"
-   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
-   PYTHON3_LIBS=
- elif test "$python3_ok" = yes; then
-   dnl Check that adding -fPIE works.  It may be needed when using a static
-   dnl Python library.
-   AC_MSG_CHECKING([if -fPIE can be added for Python3])
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
-   LIBS="$LIBS $PYTHON3_LIBS"
-   AC_TRY_LINK(,[ ],
- 	 AC_MSG_RESULT(yes); fpie_ok=yes,
- 	 AC_MSG_RESULT(no); fpie_ok=no)
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
-   if test $fpie_ok = yes; then
-     PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
-   fi
- fi
- 
- AC_MSG_CHECKING(--enable-tclinterp argument)
- AC_ARG_ENABLE(tclinterp,
- 	[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_tclinterp="no"])
- AC_MSG_RESULT($enable_tclinterp)
- 
- if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
- 
-   dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]
-   AC_MSG_CHECKING(--with-tclsh argument)
-   AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],
- 	tclsh_name="$withval"; AC_MSG_RESULT($tclsh_name),
- 	tclsh_name="tclsh8.5"; AC_MSG_RESULT(no))
-   AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   AC_SUBST(vi_cv_path_tcl)
- 
-   dnl when no specific version specified, also try 8.4, 8.2 and 8.0
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
-     tclsh_name="tclsh8.4"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
-     tclsh_name="tclsh8.2"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
-     tclsh_name="tclsh8.0"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   dnl still didn't find it, try without version number
-   if test "X$vi_cv_path_tcl" = "X"; then
-     tclsh_name="tclsh"
-     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
-   fi
-   if test "X$vi_cv_path_tcl" != "X"; then
-     AC_MSG_CHECKING(Tcl version)
-     if echo 'exit [[expr [info tclversion] < 8.0]]' | "$vi_cv_path_tcl" - ; then
-       tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`
-       AC_MSG_RESULT($tclver - OK);
-       tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`
-       tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`
- 
-       AC_MSG_CHECKING(for location of Tcl include)
-       if test "x$MACOSX" != "xyes"; then
- 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
-       else
- 	dnl For Mac OS X 10.3, use the OS-provided framework location
- 	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
-       fi
-       TCL_INC=
-       for try in $tclinc; do
- 	if test -f "$try/tcl.h"; then
- 	  AC_MSG_RESULT($try/tcl.h)
- 	  TCL_INC=$try
- 	  break
- 	fi
-       done
-       if test -z "$TCL_INC"; then
- 	AC_MSG_RESULT(<not found>)
- 	SKIP_TCL=YES
-       fi
-       if test -z "$SKIP_TCL"; then
- 	AC_MSG_CHECKING(for location of tclConfig.sh script)
- 	if test "x$MACOSX" != "xyes"; then
- 	  tclcnf=`echo $tclinc | sed s/include/lib/g`
- 	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
- 	else
- 	  dnl For Mac OS X 10.3, use the OS-provided framework location
- 	  tclcnf="/System/Library/Frameworks/Tcl.framework"
- 	fi
- 	for try in $tclcnf; do
- 	  if test -f "$try/tclConfig.sh"; then
- 	    AC_MSG_RESULT($try/tclConfig.sh)
- 	    . "$try/tclConfig.sh"
- 	    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}
- 	    if test "$enable_tclinterp" = "dynamic"; then
- 	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
- 	    else
- 	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
- 	    fi
- 	    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the
- 	    dnl "-D_ABC" items.  Watch out for -DFOO=long\ long.
- 	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
- 	    break
- 	  fi
- 	done
- 	if test -z "$TCL_LIBS"; then
- 	  AC_MSG_RESULT(<not found>)
- 	  AC_MSG_CHECKING(for Tcl library by myself)
- 	  tcllib=`echo $tclinc | sed s/include/lib/g`
- 	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
- 	  for ext in .so .a ; do
- 	    for ver in "" $tclver ; do
- 	      for try in $tcllib ; do
- 		trylib=tcl$ver$ext
- 		if test -f "$try/lib$trylib" ; then
- 		  AC_MSG_RESULT($try/lib$trylib)
- 		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
- 		  if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
- 		    TCL_LIBS="$TCL_LIBS -R $try"
- 		  fi
- 		  break 3
- 		fi
- 	      done
- 	    done
- 	  done
- 	  if test -z "$TCL_LIBS"; then
- 	    AC_MSG_RESULT(<not found>)
- 	    SKIP_TCL=YES
- 	  fi
- 	fi
- 	if test -z "$SKIP_TCL"; then
- 	  AC_DEFINE(FEAT_TCL)
- 	  TCL_SRC=if_tcl.c
- 	  TCL_OBJ=objects/if_tcl.o
- 	  TCL_PRO=if_tcl.pro
- 	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
- 	fi
-       fi
-     else
-       AC_MSG_RESULT(too old; need Tcl version 8.0 or later)
-     fi
-   fi
-   if test "$enable_tclinterp" = "dynamic"; then
-     if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
-       AC_DEFINE(DYNAMIC_TCL)
-       TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
-     fi
-   fi
-   if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
-     AC_MSG_ERROR([could not configure Tcl])
-   fi
- fi
- AC_SUBST(TCL_SRC)
- AC_SUBST(TCL_OBJ)
- AC_SUBST(TCL_PRO)
- AC_SUBST(TCL_CFLAGS)
- AC_SUBST(TCL_LIBS)
- 
- AC_MSG_CHECKING(--enable-rubyinterp argument)
- AC_ARG_ENABLE(rubyinterp,
- 	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
- 	[enable_rubyinterp="no"])
- AC_MSG_RESULT($enable_rubyinterp)
- if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_ERROR([cannot use Ruby with tiny or small features])
-   fi
- 
-   AC_MSG_CHECKING(--with-ruby-command argument)
-   AC_SUBST(vi_cv_path_ruby)
-   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
- 	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
- 	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
-   AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
-   if test "X$vi_cv_path_ruby" != "X"; then
-     AC_MSG_CHECKING(Ruby version)
-     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
-       AC_MSG_RESULT(OK)
-       AC_MSG_CHECKING(Ruby rbconfig)
-       ruby_rbconfig="RbConfig"
-       if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
- 	ruby_rbconfig="Config"
-       fi
-       AC_MSG_RESULT($ruby_rbconfig)
-       AC_MSG_CHECKING(Ruby header files)
-       rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\$hdrdir" 2>/dev/null`
-       if test "X$rubyhdrdir" != "X"; then
- 	AC_MSG_RESULT($rubyhdrdir)
- 	RUBY_CFLAGS="-I$rubyhdrdir"
-         rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
-         if test -d "$rubyarchdir"; then
-           RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
-         fi
-         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
- 	if test "X$rubyversion" = "X"; then
- 	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[[0,2]]"`
- 	fi
-         RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
- 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LIBS']]"`
- 	if test "X$rubylibs" != "X"; then
- 	  RUBY_LIBS="$rubylibs"
- 	fi
- 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])"`
- 	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])"`
- 	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])"`
- 	if test -f "$rubylibdir/$librubya"; then
- 	  librubyarg="$librubyarg"
- 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
- 	elif test "$librubyarg" = "libruby.a"; then
- 	  dnl required on Mac OS 10.3 where libruby.a doesn't exist
- 	  librubyarg="-lruby"
- 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
- 	fi
- 
- 	if test "X$librubyarg" != "X"; then
- 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
- 	fi
- 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LDFLAGS']]"`
- 	if test "X$rubyldflags" != "X"; then
- 	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
- 	  dnl be included if requested by passing --with-mac-arch to
- 	  dnl configure, so strip these flags first (if present)
- 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
- 	  if test "X$rubyldflags" != "X"; then
- 	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
- 	      LDFLAGS="$rubyldflags $LDFLAGS"
- 	    fi
- 	  fi
- 	fi
- 	RUBY_SRC="if_ruby.c"
- 	RUBY_OBJ="objects/if_ruby.o"
- 	RUBY_PRO="if_ruby.pro"
- 	AC_DEFINE(FEAT_RUBY)
- 	if test "$enable_rubyinterp" = "dynamic"; then
- 	  libruby=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]"`
- 	  AC_DEFINE(DYNAMIC_RUBY)
- 	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
- 	  RUBY_LIBS=
- 	fi
-       else
- 	AC_MSG_RESULT(not found; disabling Ruby)
-       fi
-     else
-       AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
-     fi
-   fi
- 
-   if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
-     AC_MSG_ERROR([could not configure Ruby])
-   fi
- fi
- AC_SUBST(RUBY_SRC)
- AC_SUBST(RUBY_OBJ)
- AC_SUBST(RUBY_PRO)
- AC_SUBST(RUBY_CFLAGS)
- AC_SUBST(RUBY_LIBS)
- 
- AC_MSG_CHECKING(--enable-cscope argument)
- AC_ARG_ENABLE(cscope,
- 	[  --enable-cscope         Include cscope interface.], ,
- 	[enable_cscope="no"])
- AC_MSG_RESULT($enable_cscope)
- if test "$enable_cscope" = "yes"; then
-   AC_DEFINE(FEAT_CSCOPE)
- fi
- 
- AC_MSG_CHECKING(--enable-workshop argument)
- AC_ARG_ENABLE(workshop,
- 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
- 	[enable_workshop="no"])
- AC_MSG_RESULT($enable_workshop)
- if test "$enable_workshop" = "yes"; then
-   AC_DEFINE(FEAT_SUN_WORKSHOP)
-   WORKSHOP_SRC="workshop.c integration.c"
-   AC_SUBST(WORKSHOP_SRC)
-   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
-   AC_SUBST(WORKSHOP_OBJ)
-   if test "${enable_gui-xxx}" = xxx; then
-     enable_gui=motif
-   fi
- fi
- 
- AC_MSG_CHECKING(--disable-netbeans argument)
- AC_ARG_ENABLE(netbeans,
- 	[  --disable-netbeans      Disable NetBeans integration support.],
- 	, [enable_netbeans="yes"])
- if test "$enable_netbeans" = "yes"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_RESULT([cannot use NetBeans with tiny or small features])
-     enable_netbeans="no"
-   else
-     AC_MSG_RESULT(no)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- AC_MSG_CHECKING(--disable-channel argument)
- AC_ARG_ENABLE(channel,
- 	[  --disable-channel      Disable process communication support.],
- 	, [enable_channel="yes"])
- if test "$enable_channel" = "yes"; then
-   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
-     AC_MSG_RESULT([cannot use channels with tiny or small features])
-     enable_channel="no"
-   else
-     AC_MSG_RESULT(no)
-   fi
- else
-   if test "$enable_netbeans" = "yes"; then
-     AC_MSG_RESULT([yes, netbeans also disabled])
-     enable_netbeans="no"
-   else
-     AC_MSG_RESULT(yes)
-   fi
- fi
- 
- if test "$enable_channel" = "yes"; then
-   dnl On Solaris we need the socket and nsl library.
-   AC_CHECK_LIB(socket, socket)
-   AC_CHECK_LIB(nsl, gethostbyname)
-   AC_MSG_CHECKING(whether compiling with process communication is possible)
-   AC_TRY_LINK([
- #include <stdio.h>
- #include <stdlib.h>
- #include <stdarg.h>
- #include <fcntl.h>
- #include <netdb.h>
- #include <netinet/in.h>
- #include <errno.h>
- #include <sys/types.h>
- #include <sys/socket.h>
- 	/* Check bitfields */
- 	struct nbbuf {
- 	unsigned int  initDone:1;
- 	ushort signmaplen;
- 	};
- 	    ], [
- 		/* Check creating a socket. */
- 		struct sockaddr_in server;
- 		(void)socket(AF_INET, SOCK_STREAM, 0);
- 		(void)htons(100);
- 		(void)gethostbyname("microsoft.com");
- 		if (errno == ECONNREFUSED)
- 		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
- 	    ],
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); enable_netbeans="no"; enable_channel="no")
- fi
- if test "$enable_netbeans" = "yes"; then
-   AC_DEFINE(FEAT_NETBEANS_INTG)
-   NETBEANS_SRC="netbeans.c"
-   AC_SUBST(NETBEANS_SRC)
-   NETBEANS_OBJ="objects/netbeans.o"
-   AC_SUBST(NETBEANS_OBJ)
- fi
- if test "$enable_channel" = "yes"; then
-   AC_DEFINE(FEAT_JOB_CHANNEL)
-   CHANNEL_SRC="channel.c"
-   AC_SUBST(CHANNEL_SRC)
-   CHANNEL_OBJ="objects/channel.o"
-   AC_SUBST(CHANNEL_OBJ)
- fi
- 
- AC_MSG_CHECKING(--enable-multibyte argument)
- AC_ARG_ENABLE(multibyte,
- 	[  --enable-multibyte      Include multibyte editing support.], ,
- 	[enable_multibyte="no"])
- AC_MSG_RESULT($enable_multibyte)
- if test "$enable_multibyte" = "yes"; then
-   AC_DEFINE(FEAT_MBYTE)
- fi
- 
- AC_MSG_CHECKING(--enable-hangulinput argument)
- AC_ARG_ENABLE(hangulinput,
- 	[  --enable-hangulinput    Include Hangul input support.], ,
- 	[enable_hangulinput="no"])
- AC_MSG_RESULT($enable_hangulinput)
- 
- AC_MSG_CHECKING(--enable-xim argument)
- AC_ARG_ENABLE(xim,
- 	[  --enable-xim            Include XIM input support.],
- 	AC_MSG_RESULT($enable_xim),
- 	[enable_xim="auto"; AC_MSG_RESULT(defaulting to auto)])
- 
- AC_MSG_CHECKING(--enable-fontset argument)
- AC_ARG_ENABLE(fontset,
- 	[  --enable-fontset        Include X fontset output support.], ,
- 	[enable_fontset="no"])
- AC_MSG_RESULT($enable_fontset)
- dnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI
- 
- test -z "$with_x" && with_x=yes
- test "${enable_gui-yes}" != no -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
- if test "$with_x" = no; then
-   AC_MSG_RESULT(defaulting to: don't HAVE_X11)
- else
-   dnl Do this check early, so that its failure can override user requests.
- 
-   AC_PATH_PROG(xmkmfpath, xmkmf)
- 
-   AC_PATH_XTRA
- 
-   dnl On z/OS Unix the X libraries are DLLs. To use them the code must
-   dnl be compiled with a special option.
-   dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.
-   if test "$zOSUnix" = "yes"; then
-     CFLAGS="$CFLAGS -W c,dll"
-     LDFLAGS="$LDFLAGS -W l,dll"
-     X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
-   fi
- 
-   dnl On my HPUX system the X include dir is found, but the lib dir not.
-   dnl This is a desparate try to fix this.
- 
-   if test -d "$x_includes" && test ! -d "$x_libraries"; then
-     x_libraries=`echo "$x_includes" | sed s/include/lib/`
-     AC_MSG_RESULT(Corrected X libraries to $x_libraries)
-     X_LIBS="$X_LIBS -L$x_libraries"
-     if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
-       X_LIBS="$X_LIBS -R $x_libraries"
-     fi
-   fi
- 
-   if test -d "$x_libraries" && test ! -d "$x_includes"; then
-     x_includes=`echo "$x_libraries" | sed s/lib/include/`
-     AC_MSG_RESULT(Corrected X includes to $x_includes)
-     X_CFLAGS="$X_CFLAGS -I$x_includes"
-   fi
- 
-   dnl Remove "-I/usr/include " from X_CFLAGS, should not be needed.
-   X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
-   dnl Remove "-L/usr/lib " from X_LIBS, should not be needed.
-   X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
-   dnl Same for "-R/usr/lib ".
-   X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
- 
- 
-   dnl Check if the X11 header files are correctly installed. On some systems
-   dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h
-   dnl is missing.
-   AC_MSG_CHECKING(if X11 header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([#include <X11/Xlib.h>
- #include <X11/Intrinsic.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); no_x=yes)
-   CFLAGS=$cflags_save
- 
-   if test "${no_x-no}" = yes; then
-     with_x=no
-   else
-     AC_DEFINE(HAVE_X11)
-     X_LIB="-lXt -lX11";
-     AC_SUBST(X_LIB)
- 
-     ac_save_LDFLAGS="$LDFLAGS"
-     LDFLAGS="-L$x_libraries $LDFLAGS"
- 
-     dnl Check for -lXdmcp (needed on SunOS 4.1.4)
-     dnl For HP-UX 10.20 it must be before -lSM -lICE
-     AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"],,
- 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])
- 
-     dnl Some systems need -lnsl -lsocket when testing for ICE.
-     dnl The check above doesn't do this, try here (again).  Also needed to get
-     dnl them after Xdmcp.  link.sh will remove them when not needed.
-     dnl Check for other function than above to avoid the cached value
-     AC_CHECK_LIB(ICE, IceOpenConnection,
- 		  [X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"],, [$X_EXTRA_LIBS])
- 
-     dnl Check for -lXpm (needed for some versions of Motif)
-     LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
-     AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS="$X_PRE_LIBS -lXpm"],,
- 		[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])
- 
-     dnl Check that the X11 header files don't use implicit declarations
-     AC_MSG_CHECKING(if X11 header files implicitly declare return values)
-     cflags_save=$CFLAGS
-     dnl -Werror is GCC only, others like Solaris Studio might not like it
-     if test "$GCC" = yes; then
-       CFLAGS="$CFLAGS $X_CFLAGS -Werror"
-     else
-       CFLAGS="$CFLAGS $X_CFLAGS"
-     fi
-     AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
- 	AC_MSG_RESULT(no),
- 	CFLAGS="$CFLAGS -Wno-implicit-int"
- 	AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
- 	    AC_MSG_RESULT(yes); cflags_save="$cflags_save -Wno-implicit-int",
- 	    AC_MSG_RESULT(test failed)
- 	)
-     )
-     CFLAGS=$cflags_save
- 
-     LDFLAGS="$ac_save_LDFLAGS"
- 
-     AC_MSG_CHECKING(size of wchar_t is 2 bytes)
-     AC_CACHE_VAL(ac_cv_small_wchar_t,
- 	[AC_TRY_RUN([
- #include <X11/Xlib.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- 		main()
- 		{
- 		  if (sizeof(wchar_t) <= 2)
- 		    exit(1);
- 		  exit(0);
- 		}],
- 		ac_cv_small_wchar_t="no",
- 		ac_cv_small_wchar_t="yes",
- 		AC_MSG_ERROR(failed to compile test program))])
-     AC_MSG_RESULT($ac_cv_small_wchar_t)
-     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
-       AC_DEFINE(SMALL_WCHAR_T)
-     fi
- 
-   fi
- fi
- 
- test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
- 
- AC_MSG_CHECKING(--enable-gui argument)
- AC_ARG_ENABLE(gui,
-  [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
- 
- dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
- dnl Do not use character classes for portability with old tools.
- enable_gui_canon=`echo "_$enable_gui" | \
- 	sed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
- 
- dnl Skip everything by default.
- SKIP_GTK2=YES
- SKIP_GTK3=YES
- SKIP_GNOME=YES
- SKIP_MOTIF=YES
- SKIP_ATHENA=YES
- SKIP_NEXTAW=YES
- SKIP_PHOTON=YES
- SKIP_CARBON=YES
- GUITYPE=NONE
- 
- if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
-   SKIP_PHOTON=
-   case "$enable_gui_canon" in
-     no)		AC_MSG_RESULT(no GUI support)
- 		SKIP_PHOTON=YES ;;
-     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
-     auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
-     photon)	AC_MSG_RESULT(Photon GUI support) ;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
- 		SKIP_PHOTON=YES ;;
-   esac
- 
- elif test "x$MACOSX" = "xyes" -a "x$with_x" = "xno" ; then
-   SKIP_CARBON=
-   case "$enable_gui_canon" in
-     no)		AC_MSG_RESULT(no GUI support)
- 		SKIP_CARBON=YES ;;
-     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
-     auto)	AC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)
- 		SKIP_CARBON=YES ;;
-     carbon)	AC_MSG_RESULT(Carbon GUI support) ;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
- 		SKIP_CARBON=YES ;;
-   esac
- 
- else
- 
-   case "$enable_gui_canon" in
-     no|none)	AC_MSG_RESULT(no GUI support) ;;
-     yes|""|auto)	AC_MSG_RESULT(yes/auto - automatic GUI support)
- 		SKIP_GTK2=
- 		SKIP_GNOME=
- 		SKIP_MOTIF=
- 		SKIP_ATHENA=
- 		SKIP_NEXTAW=
- 		SKIP_CARBON=;;
-     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
- 		SKIP_GTK2=;;
-     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
- 		SKIP_GNOME=
- 		SKIP_GTK2=;;
-     gtk3)	AC_MSG_RESULT(GTK+ 3.x GUI support)
- 		SKIP_GTK3=;;
-     motif)	AC_MSG_RESULT(Motif GUI support)
- 		SKIP_MOTIF=;;
-     athena)	AC_MSG_RESULT(Athena GUI support)
- 		SKIP_ATHENA=;;
-     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
- 		SKIP_NEXTAW=;;
-     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
-   esac
- 
- fi
- 
- if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
- 				-a "$enable_gui_canon" != "gnome2"; then
-   AC_MSG_CHECKING(whether or not to look for GTK+ 2)
-   AC_ARG_ENABLE(gtk2-check,
- 	[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],
- 	, enable_gtk2_check="yes")
-   AC_MSG_RESULT($enable_gtk2_check)
-   if test "x$enable_gtk2_check" = "xno"; then
-     SKIP_GTK2=YES
-     SKIP_GNOME=YES
-   fi
- fi
- 
- if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
-   AC_MSG_CHECKING(whether or not to look for GNOME)
-   AC_ARG_ENABLE(gnome-check,
- 	[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],
- 	, enable_gnome_check="no")
-   AC_MSG_RESULT($enable_gnome_check)
-   if test "x$enable_gnome_check" = "xno"; then
-     SKIP_GNOME=YES
-   fi
- fi
- 
- if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
-   AC_MSG_CHECKING(whether or not to look for GTK+ 3)
-   AC_ARG_ENABLE(gtk3-check,
- 	[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],
- 	, enable_gtk3_check="yes")
-   AC_MSG_RESULT($enable_gtk3_check)
-   if test "x$enable_gtk3_check" = "xno"; then
-     SKIP_GTK3=YES
-   fi
- fi
- 
- if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
-   AC_MSG_CHECKING(whether or not to look for Motif)
-   AC_ARG_ENABLE(motif-check,
- 	[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],
- 	, enable_motif_check="yes")
-   AC_MSG_RESULT($enable_motif_check)
-   if test "x$enable_motif_check" = "xno"; then
-     SKIP_MOTIF=YES
-   fi
- fi
- 
- if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
-   AC_MSG_CHECKING(whether or not to look for Athena)
-   AC_ARG_ENABLE(athena-check,
- 	[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],
- 	, enable_athena_check="yes")
-   AC_MSG_RESULT($enable_athena_check)
-   if test "x$enable_athena_check" = "xno"; then
-     SKIP_ATHENA=YES
-   fi
- fi
- 
- if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
-   AC_MSG_CHECKING(whether or not to look for neXtaw)
-   AC_ARG_ENABLE(nextaw-check,
- 	[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],
- 	, enable_nextaw_check="yes")
-   AC_MSG_RESULT($enable_nextaw_check);
-   if test "x$enable_nextaw_check" = "xno"; then
-     SKIP_NEXTAW=YES
-   fi
- fi
- 
- if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
-   AC_MSG_CHECKING(whether or not to look for Carbon)
-   AC_ARG_ENABLE(carbon-check,
- 	[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],
- 	, enable_carbon_check="yes")
-   AC_MSG_RESULT($enable_carbon_check);
-   if test "x$enable_carbon_check" = "xno"; then
-     SKIP_CARBON=YES
-   fi
- fi
- 
- 
- if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
-   AC_MSG_CHECKING(for Carbon GUI)
-   dnl already did the check, just give the message
-   AC_MSG_RESULT(yes);
-   GUITYPE=CARBONGUI
-   if test "$VIMNAME" = "vim"; then
-     VIMNAME=Vim
-   fi
- 
-   if test "x$MACARCH" = "xboth"; then
-     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
-   else
-     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
-   fi
- 
-   dnl Default install directory is not /usr/local
-   if test x$prefix = xNONE; then
-     prefix=/Applications
-   fi
- 
-   dnl Sorry for the hard coded default
-   datadir='${prefix}/Vim.app/Contents/Resources'
- 
-   dnl skip everything else
-   SKIP_GTK2=YES;
-   SKIP_GNOME=YES;
-   SKIP_MOTIF=YES;
-   SKIP_ATHENA=YES;
-   SKIP_NEXTAW=YES;
-   SKIP_PHOTON=YES;
-   SKIP_CARBON=YES
- fi
- 
- dnl define an autoconf function to check for a specified version of GTK, and
- dnl try to compile/link a GTK program.
- dnl
- dnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
- dnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS
- dnl
- AC_DEFUN(AM_PATH_GTK,
- [
-   if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
-   {
-     no_gtk=""
-     if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
- 	  && $PKG_CONFIG --exists gtk+-2.0; then
-     {
-       min_gtk_version=ifelse([$1], ,2.2.0,$1)
-       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
-       dnl We should be using PKG_CHECK_MODULES() instead of this hack.
-       dnl But I guess the dependency on pkgconfig.m4 is not wanted or
-       dnl something like that.
-       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
-       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
-       GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
-       gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
-       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
-       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
-     }
-     elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
- 	  && $PKG_CONFIG --exists gtk+-3.0; then
-     {
-       min_gtk_version=ifelse([$1], ,3.0.0,$1)
-       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
- 
-       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
-       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
-       GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
-       gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
-       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
-       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
- 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
-     }
-     else
-       no_gtk=yes
-     fi
- 
-     if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
-     {
-       ac_save_CFLAGS="$CFLAGS"
-       ac_save_LIBS="$LIBS"
-       CFLAGS="$CFLAGS $GTK_CFLAGS"
-       LIBS="$LIBS $GTK_LIBS"
- 
-       dnl
-       dnl Now check if the installed GTK is sufficiently new.
-       dnl
-       rm -f conf.gtktest
-       AC_TRY_RUN([
- #include <gtk/gtk.h>
- #include <stdio.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- 
- int
- main ()
- {
- int major, minor, micro;
- char *tmp_version;
- 
- system ("touch conf.gtktest");
- 
- /* HP/UX 9 (%@#!) writes to sscanf strings */
- tmp_version = g_strdup("$min_gtk_version");
- if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
-    printf("%s, bad version string\n", "$min_gtk_version");
-    exit(1);
-  }
- 
- if ((gtk_major_version > major) ||
-     ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
-     ((gtk_major_version == major) && (gtk_minor_version == minor) &&
- 				     (gtk_micro_version >= micro)))
- {
-     return 0;
- }
- return 1;
- }
- ],, no_gtk=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
-       CFLAGS="$ac_save_CFLAGS"
-       LIBS="$ac_save_LIBS"
-     }
-     fi
-     if test "x$no_gtk" = x ; then
-       if test "x$enable_gtktest" = "xyes"; then
- 	AC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
-       else
- 	AC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
-       fi
-       ifelse([$2], , :, [$2])
-     else
-     {
-       AC_MSG_RESULT(no)
-       GTK_CFLAGS=""
-       GTK_LIBS=""
-       ifelse([$3], , :, [$3])
-     }
-     fi
-   }
-   else
-     GTK_CFLAGS=""
-     GTK_LIBS=""
-     ifelse([$3], , :, [$3])
-   fi
-   AC_SUBST(GTK_CFLAGS)
-   AC_SUBST(GTK_LIBS)
-   rm -f conf.gtktest
- ])
- 
- dnl ---------------------------------------------------------------------------
- dnl gnome
- dnl ---------------------------------------------------------------------------
- AC_DEFUN([GNOME_INIT_HOOK],
- [
-   AC_SUBST(GNOME_LIBS)
-   AC_SUBST(GNOME_LIBDIR)
-   AC_SUBST(GNOME_INCLUDEDIR)
- 
-   AC_ARG_WITH(gnome-includes,
-     [  --with-gnome-includes=DIR Specify location of GNOME headers],
-     [CFLAGS="$CFLAGS -I$withval"]
-   )
- 
-   AC_ARG_WITH(gnome-libs,
-     [  --with-gnome-libs=DIR   Specify location of GNOME libs],
-     [LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval]
-   )
- 
-   AC_ARG_WITH(gnome,
-     [  --with-gnome            Specify prefix for GNOME files],
-     if test x$withval = xyes; then
-       want_gnome=yes
-       ifelse([$1], [], :, [$1])
-     else
-       if test "x$withval" = xno; then
- 	want_gnome=no
-       else
- 	want_gnome=yes
- 	LDFLAGS="$LDFLAGS -L$withval/lib"
- 	CFLAGS="$CFLAGS -I$withval/include"
- 	gnome_prefix=$withval/lib
-       fi
-     fi,
-     want_gnome=yes)
- 
-   if test "x$want_gnome" = xyes; then
-   {
-     AC_MSG_CHECKING(for libgnomeui-2.0)
-     if $PKG_CONFIG --exists libgnomeui-2.0; then
-       AC_MSG_RESULT(yes)
-       GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
-       GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
-       GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
- 
-       dnl On FreeBSD we need -pthread but pkg-config doesn't include it.
-       dnl This might not be the right way but it works for me...
-       AC_MSG_CHECKING(for FreeBSD)
-       if test "`(uname) 2>/dev/null`" = FreeBSD; then
- 	AC_MSG_RESULT(yes, adding -pthread)
- 	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
- 	GNOME_LIBS="$GNOME_LIBS -pthread"
-       else
- 	AC_MSG_RESULT(no)
-       fi
-       $1
-     else
-       AC_MSG_RESULT(not found)
-       if test "x$2" = xfail; then
- 	AC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)
-       fi
-     fi
-   }
-   fi
- ])
- 
- AC_DEFUN([GNOME_INIT],[
- 	GNOME_INIT_HOOK([],fail)
- ])
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl Check for GTK2.  If it fails, then continue on for Motif as before...
- dnl ---------------------------------------------------------------------------
- if test -z "$SKIP_GTK2"; then
- 
-   AC_MSG_CHECKING(--disable-gtktest argument)
-   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
- 	, enable_gtktest=yes)
-   if test "x$enable_gtktest" = "xyes" ; then
-     AC_MSG_RESULT(gtk test enabled)
-   else
-     AC_MSG_RESULT(gtk test disabled)
-   fi
- 
-   if test "X$PKG_CONFIG" = "X"; then
-     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
-   fi
- 
-   if test "x$PKG_CONFIG" != "xno"; then
-     dnl First try finding version 2.2.0 or later.  The 2.0.x series has
-     dnl problems (bold fonts, --remote doesn't work).
-     AM_PATH_GTK(2.2.0,
- 		[GUI_LIB_LOC="$GTK_LIBDIR"
- 		 GTK_LIBNAME="$GTK_LIBS"
- 		GUI_INC_LOC="$GTK_CFLAGS"], )
-     if test "x$GTK_CFLAGS" != "x"; then
-       SKIP_GTK3=YES
-       SKIP_ATHENA=YES
-       SKIP_NEXTAW=YES
-       SKIP_MOTIF=YES
-       GUITYPE=GTK
-       AC_SUBST(GTK_LIBNAME)
-     fi
-   fi
-   if test "x$GUITYPE" = "xGTK"; then
-     if test "$gtk_minor_version" = 1 -a "0$gtk_micro_version" -ge 1 \
- 	|| test "0$gtk_minor_version" -ge 2; then
-       AC_DEFINE(HAVE_GTK_MULTIHEAD)
-     fi
-     dnl
-     dnl if GTK exists, then check for GNOME.
-     dnl
-     if test -z "$SKIP_GNOME"; then
-     {
-       GNOME_INIT_HOOK([have_gnome=yes])
-       if test "x$have_gnome" = xyes ; then
- 	AC_DEFINE(FEAT_GUI_GNOME)
- 	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
- 	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
-       fi
-     }
-     fi
-   fi
- fi
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl Check for GTK3.
- dnl ---------------------------------------------------------------------------
- if test -z "$SKIP_GTK3"; then
- 
-   AC_MSG_CHECKING(--disable-gtktest argument)
-   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
- 	, enable_gtktest=yes)
-   if test "x$enable_gtktest" = "xyes" ; then
-     AC_MSG_RESULT(gtk test enabled)
-   else
-     AC_MSG_RESULT(gtk test disabled)
-   fi
- 
-   if test "X$PKG_CONFIG" = "X"; then
-     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
-   fi
- 
-   if test "x$PKG_CONFIG" != "xno"; then
-     AM_PATH_GTK(3.0.0,
- 		[GUI_LIB_LOC="$GTK_LIBDIR"
- 		 GTK_LIBNAME="$GTK_LIBS"
- 		GUI_INC_LOC="$GTK_CFLAGS"], )
-     if test "x$GTK_CFLAGS" != "x"; then
-       SKIP_GTK2=YES
-       SKIP_GNOME=YES
-       SKIP_ATHENA=YES
-       SKIP_NEXTAW=YES
-       SKIP_MOTIF=YES
-       GUITYPE=GTK
-       AC_SUBST(GTK_LIBNAME)
-       AC_DEFINE(HAVE_GTK_MULTIHEAD)
-       AC_DEFINE(USE_GTK3)
-     fi
-   fi
- fi
- 
- dnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and
- dnl glib-compile-resources is found in PATH, use GResource.
- if test "x$GUITYPE" = "xGTK"; then
-   AC_MSG_CHECKING([version of Gdk-Pixbuf])
-   gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
-   if test "x$gdk_pixbuf_version" != x ; then
-     gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
-       sed -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/'`
-     if test "x$gdk_pixbuf_version_minor" != x -a \
- 	$gdk_pixbuf_version_minor -ge 31 ; then
-       AC_MSG_RESULT([OK.])
-       AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)
-       AC_MSG_CHECKING([glib-compile-resources])
-       if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
- 	GLIB_COMPILE_RESOURCES=""
- 	AC_MSG_RESULT([cannot be found in PATH.])
-       else
- 	AC_MSG_RESULT([usable.])
- 	AC_DEFINE(USE_GRESOURCE)
- 	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
- 	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
-       fi
-     else
-       AC_MSG_RESULT([not usable.])
-     fi
-   else
-     AC_MSG_RESULT([cannot obtain from pkg_config.])
-   fi
- 
-   AC_MSG_CHECKING([--disable-icon-cache-update argument])
-   AC_ARG_ENABLE(icon_cache_update,
-           [  --disable-icon-cache-update        update disabled],
-           [],
-           [enable_icon_cache_update="yes"])
-   if test "$enable_icon_cache_update" = "yes"; then
-     AC_MSG_RESULT([not set])
-     AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)
-     if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
-       AC_MSG_RESULT([not found in PATH.])
-     fi
-   else
-     AC_MSG_RESULT([update disabled])
-   fi
- 
-   AC_MSG_CHECKING([--disable-desktop-database-update argument])
-   AC_ARG_ENABLE(desktop_database_update,
-           [  --disable-desktop-database-update  update disabled],
-           [],
-           [enable_desktop_database_update="yes"])
-   if test "$enable_desktop_database_update" = "yes"; then
-     AC_MSG_RESULT([not set])
-     AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)
-     if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
-       AC_MSG_RESULT([not found in PATH.])
-     fi
-   else
-     AC_MSG_RESULT([update disabled])
-   fi
- fi
- AC_SUBST(GLIB_COMPILE_RESOURCES)
- AC_SUBST(GRESOURCE_SRC)
- AC_SUBST(GRESOURCE_OBJ)
- AC_SUBST(GTK_UPDATE_ICON_CACHE)
- AC_SUBST(UPDATE_DESKTOP_DATABASE)
- 
- dnl Check for Motif include files location.
- dnl The LAST one found is used, this makes the highest version to be used,
- dnl e.g. when Motif1.2 and Motif2.0 are both present.
- 
- if test -z "$SKIP_MOTIF"; then
-   gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
-   dnl Remove "-I" from before $GUI_INC_LOC if it's there
-   GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
- 
-   AC_MSG_CHECKING(for location of Motif GUI includes)
-   gui_includes="`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
-   GUI_INC_LOC=
-   for try in $gui_includes; do
-     if test -f "$try/Xm/Xm.h"; then
-       GUI_INC_LOC=$try
-     fi
-   done
-   if test -n "$GUI_INC_LOC"; then
-     if test "$GUI_INC_LOC" = /usr/include; then
-       GUI_INC_LOC=
-       AC_MSG_RESULT(in default path)
-     else
-       AC_MSG_RESULT($GUI_INC_LOC)
-     fi
-   else
-     AC_MSG_RESULT(<not found>)
-     SKIP_MOTIF=YES
-   fi
- fi
- 
- dnl Check for Motif library files location.  In the same order as the include
- dnl files, to avoid a mixup if several versions are present
- 
- if test -z "$SKIP_MOTIF"; then
-   AC_MSG_CHECKING(--with-motif-lib argument)
-   AC_ARG_WITH(motif-lib,
-   [  --with-motif-lib=STRING   Library for Motif ],
-   [ MOTIF_LIBNAME="${withval}" ] )
- 
-   if test -n "$MOTIF_LIBNAME"; then
-     AC_MSG_RESULT($MOTIF_LIBNAME)
-     GUI_LIB_LOC=
-   else
-     AC_MSG_RESULT(no)
- 
-     dnl Remove "-L" from before $GUI_LIB_LOC if it's there
-     GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
- 
-     dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The
-     dnl linker will figure out which one to use, we only check if one exists.
-     AC_MSG_CHECKING(for location of Motif GUI libs)
-     gui_libs="`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
-     GUI_LIB_LOC=
-     for try in $gui_libs; do
-       for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
- 	if test -f "$libtry"; then
- 	  GUI_LIB_LOC=$try
- 	fi
-       done
-     done
-     if test -n "$GUI_LIB_LOC"; then
-       dnl Remove /usr/lib, it causes trouble on some systems
-       if test "$GUI_LIB_LOC" = /usr/lib \
- 	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
- 	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
- 	GUI_LIB_LOC=
- 	AC_MSG_RESULT(in default path)
-       else
- 	if test -n "$GUI_LIB_LOC"; then
- 	  AC_MSG_RESULT($GUI_LIB_LOC)
- 	  if test "`(uname) 2>/dev/null`" = SunOS &&
- 					 uname -r | grep '^5' >/dev/null; then
- 	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
- 	  fi
- 	fi
-       fi
-       MOTIF_LIBNAME=-lXm
-     else
-       AC_MSG_RESULT(<not found>)
-       SKIP_MOTIF=YES
-     fi
-   fi
- fi
- 
- if test -z "$SKIP_MOTIF"; then
-   SKIP_ATHENA=YES
-   SKIP_NEXTAW=YES
-   GUITYPE=MOTIF
-   AC_SUBST(MOTIF_LIBNAME)
- fi
- 
- dnl Check if the Athena files can be found
- 
- GUI_X_LIBS=
- 
- if test -z "$SKIP_ATHENA"; then
-   AC_MSG_CHECKING(if Athena header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/Xaw/Paned.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); SKIP_ATHENA=YES )
-   CFLAGS=$cflags_save
- fi
- 
- if test -z "$SKIP_ATHENA"; then
-   GUITYPE=ATHENA
- fi
- 
- if test -z "$SKIP_NEXTAW"; then
-   AC_MSG_CHECKING(if neXtaw header files can be found)
-   cflags_save=$CFLAGS
-   CFLAGS="$CFLAGS $X_CFLAGS"
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/neXtaw/Paned.h>], ,
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_RESULT(no); SKIP_NEXTAW=YES )
-   CFLAGS=$cflags_save
- fi
- 
- if test -z "$SKIP_NEXTAW"; then
-   GUITYPE=NEXTAW
- fi
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
-   dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty
-   dnl Avoid adding it when it twice
-   if test -n "$GUI_INC_LOC"; then
-     GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
-   fi
-   if test -n "$GUI_LIB_LOC"; then
-     GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
-   fi
- 
-   dnl Check for -lXext and then for -lXmu
-   ldflags_save=$LDFLAGS
-   LDFLAGS="$X_LIBS $LDFLAGS"
-   AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS="-lXext"],,
- 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   dnl For Solaris we need -lw and -ldl before linking with -lXmu works.
-   AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS="-lXmu $GUI_X_LIBS"],,
- 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   if test -z "$SKIP_MOTIF"; then
-     AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS="-lXp $GUI_X_LIBS"],,
- 		[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
-   fi
-   LDFLAGS=$ldflags_save
- 
-   dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.
-   AC_MSG_CHECKING(for extra X11 defines)
-   NARROW_PROTO=
-   rm -fr conftestdir
-   if mkdir conftestdir; then
-     cd conftestdir
-     cat > Imakefile <<'EOF'
- acfindx:
- 	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
- EOF
-     if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
-       eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
-     fi
-     cd ..
-     rm -fr conftestdir
-   fi
-   if test -z "$NARROW_PROTO"; then
-     AC_MSG_RESULT(no)
-   else
-     AC_MSG_RESULT($NARROW_PROTO)
-   fi
-   AC_SUBST(NARROW_PROTO)
- fi
- 
- dnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs
- dnl use the X11 include path
- if test "$enable_xsmp" = "yes"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   AC_CHECK_HEADERS(X11/SM/SMlib.h)
-   CPPFLAGS=$cppflags_save
- fi
- 
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
-   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)
- 
-   dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h
-   if test ! "$enable_xim" = "no"; then
-     AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
-     AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
- 		  AC_MSG_RESULT(yes),
- 		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
-   fi
-   CPPFLAGS=$cppflags_save
- 
-   dnl automatically enable XIM when hangul input isn't enabled
-   if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
- 		-a "x$GUITYPE" != "xNONE" ; then
-     AC_MSG_RESULT(X GUI selected; xim has been enabled)
-     enable_xim="yes"
-   fi
- fi
- 
- if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
- dnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h
-   AC_MSG_CHECKING([for X11/Xmu/Editres.h])
-   AC_TRY_COMPILE([
- #include <X11/Intrinsic.h>
- #include <X11/Xmu/Editres.h>],
- 		      [int i; i = 0;],
- 	      AC_MSG_RESULT(yes)
- 		      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),
- 	      AC_MSG_RESULT(no))
-   CPPFLAGS=$cppflags_save
- fi
- 
- dnl Only use the Xm directory when compiling Motif, don't use it for Athena
- if test -z "$SKIP_MOTIF"; then
-   cppflags_save=$CPPFLAGS
-   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
-   if test "$zOSUnix" = "yes"; then
- 	xmheader="Xm/Xm.h"
-   else
- 	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
- 	   Xm/UnhighlightT.h Xm/Notebook.h"  
-   fi    
-   AC_CHECK_HEADERS($xmheader)
- 
-   if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
-     dnl Solaris uses XpmAttributes_21, very annoying.
-     AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])
-     AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),
- 	AC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
- 	)
-   else
-     AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
-   fi
-   CPPFLAGS=$cppflags_save
- fi
- 
- if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
-   AC_MSG_RESULT(no GUI selected; xim has been disabled)
-   enable_xim="no"
- fi
- if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
-   AC_MSG_RESULT(no GUI selected; fontset has been disabled)
-   enable_fontset="no"
- fi
- if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
-   AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)
-   enable_fontset="no"
- fi
- 
- if test -z "$SKIP_PHOTON"; then
-   GUITYPE=PHOTONGUI
- fi
- 
- AC_SUBST(GUI_INC_LOC)
- AC_SUBST(GUI_LIB_LOC)
- AC_SUBST(GUITYPE)
- AC_SUBST(GUI_X_LIBS)
- 
- if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
-   AC_MSG_ERROR([cannot use workshop without Motif])
- fi
- 
- dnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled
- if test "$enable_xim" = "yes"; then
-   AC_DEFINE(FEAT_XIM)
- fi
- if test "$enable_fontset" = "yes"; then
-   AC_DEFINE(FEAT_XFONTSET)
- fi
- 
- 
- dnl ---------------------------------------------------------------------------
- dnl end of GUI-checking
- dnl ---------------------------------------------------------------------------
- 
- dnl Check for Cygwin, which needs an extra source file if not using X11
- AC_MSG_CHECKING(for CYGWIN or MSYS environment)
- case `uname` in
-     CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)
-                 AC_MSG_CHECKING(for CYGWIN clipboard support)
-                 if test "x$with_x" = "xno" ; then
-                   OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
-                   AC_MSG_RESULT(yes)
-                   AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)
-                 else
-                   AC_MSG_RESULT(no - using X11)
-                 fi ;;
- 
-     *)          CYGWIN=no; AC_MSG_RESULT(no);;
- esac
- 
- dnl Only really enable hangul input when GUI and XFONTSET are available
- if test "$enable_hangulinput" = "yes"; then
-   if test "x$GUITYPE" = "xNONE"; then
-     AC_MSG_RESULT(no GUI selected; hangul input has been disabled)
-     enable_hangulinput=no
-   else
-     AC_DEFINE(FEAT_HANGULIN)
-     HANGULIN_SRC=hangulin.c
-     AC_SUBST(HANGULIN_SRC)
-     HANGULIN_OBJ=objects/hangulin.o
-     AC_SUBST(HANGULIN_OBJ)
-   fi
- fi
- 
- dnl Checks for libraries and include files.
- 
- AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #include <ctype.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
-   ]])],[
-     vim_cv_toupper_broken=yes
-   ],[
-     vim_cv_toupper_broken=no
-   ],[
-     AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')
-   ])])
- 
- if test "x$vim_cv_toupper_broken" = "xyes" ; then
-   AC_DEFINE(BROKEN_TOUPPER)
- fi
- 
- AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
- AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
- AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
- 	AC_MSG_RESULT(no))
- 
- dnl Checks for header files.
- AC_CHECK_HEADER(elf.h, HAS_ELF=1)
- dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
- if test "$HAS_ELF" = 1; then
-   AC_CHECK_LIB(elf, main)
- fi
- 
- AC_HEADER_DIRENT
- 
- dnl If sys/wait.h is not found it might still exist but not be POSIX
- dnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)
- if test $ac_cv_header_sys_wait_h = no; then
-   AC_MSG_CHECKING([for sys/wait.h that defines union wait])
-   AC_TRY_COMPILE([#include <sys/wait.h>],
- 			[union wait xx, yy; xx = yy],
- 		AC_MSG_RESULT(yes)
- 			AC_DEFINE(HAVE_SYS_WAIT_H)
- 			AC_DEFINE(HAVE_UNION_WAIT),
- 		AC_MSG_RESULT(no))
- fi
- 
- AC_CHECK_HEADERS(stdint.h stdlib.h string.h \
- 	sys/select.h sys/utsname.h termcap.h fcntl.h \
- 	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
- 	termio.h iconv.h inttypes.h langinfo.h math.h \
- 	unistd.h stropts.h errno.h sys/resource.h \
- 	sys/systeminfo.h locale.h sys/stream.h termios.h \
- 	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
- 	utime.h sys/param.h libintl.h libgen.h \
- 	util/debug.h util/msg18n.h frame.h sys/acl.h \
- 	sys/access.h sys/sysinfo.h wchar.h wctype.h)
- 
- dnl sys/ptem.h depends on sys/stream.h on Solaris
- AC_CHECK_HEADERS(sys/ptem.h, [], [],
- [#if defined HAVE_SYS_STREAM_H
- #  include <sys/stream.h>
- #endif])
- 
- dnl sys/sysctl.h depends on sys/param.h on OpenBSD
- AC_CHECK_HEADERS(sys/sysctl.h, [], [],
- [#if defined HAVE_SYS_PARAM_H
- #  include <sys/param.h>
- #endif])
- 
- 
- dnl pthread_np.h may exist but can only be used after including pthread.h
- AC_MSG_CHECKING([for pthread_np.h])
- AC_TRY_COMPILE([
- #include <pthread.h>
- #include <pthread_np.h>],
- 		      [int i; i = 0;],
- 	      AC_MSG_RESULT(yes)
- 		      AC_DEFINE(HAVE_PTHREAD_NP_H),
- 	      AC_MSG_RESULT(no))
- 
- AC_CHECK_HEADERS(strings.h)
- if test "x$MACOSX" = "xyes"; then
-   dnl The strings.h file on OS/X contains a warning and nothing useful.
-   AC_DEFINE(NO_STRINGS_WITH_STRING_H)
- else
- 
- dnl Check if strings.h and string.h can both be included when defined.
- AC_MSG_CHECKING([if strings.h can be included after string.h])
- cppflags_save=$CPPFLAGS
- CPPFLAGS="$CPPFLAGS $X_CFLAGS"
- AC_TRY_COMPILE([
- #if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
- # define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
- 			/* but don't do it on AIX 5.1 (Uribarri) */
- #endif
- #ifdef HAVE_XM_XM_H
- # include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
- #endif
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if defined(HAVE_STRINGS_H)
- # include <strings.h>
- #endif
- 		], [int i; i = 0;],
- 		AC_MSG_RESULT(yes),
- 		AC_DEFINE(NO_STRINGS_WITH_STRING_H)
- 		AC_MSG_RESULT(no))
- CPPFLAGS=$cppflags_save
- fi
- 
- dnl Checks for typedefs, structures, and compiler characteristics.
- AC_PROG_GCC_TRADITIONAL
- AC_C_CONST
- AC_C_VOLATILE
- AC_TYPE_MODE_T
- AC_TYPE_OFF_T
- AC_TYPE_PID_T
- AC_TYPE_SIZE_T
- AC_TYPE_UID_T
- AC_TYPE_UINT32_T
- 
- AC_HEADER_TIME
- AC_CHECK_TYPE(ino_t, long)
- AC_CHECK_TYPE(dev_t, unsigned)
- AC_C_BIGENDIAN(,,,)
- AC_C_INLINE
- 
- AC_MSG_CHECKING(for rlim_t)
- if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
-   AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])
- else
-   AC_EGREP_CPP(dnl
- changequote(<<,>>)dnl
- <<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl
- changequote([,]),
-   [
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_SYS_RESOURCE_H
- # include <sys/resource.h>
- #endif
- 	  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)
- 	  AC_MSG_RESULT($ac_cv_type_rlim_t)
- fi
- if test $ac_cv_type_rlim_t = no; then
-   cat >> confdefs.h <<\EOF
- #define rlim_t unsigned long
- EOF
- fi
- 
- AC_MSG_CHECKING(for stack_t)
- if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
-   AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])
- else
-   AC_EGREP_CPP(stack_t,
-   [
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <signal.h>
- 	  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)
- 	  AC_MSG_RESULT($ac_cv_type_stack_t)
- fi
- if test $ac_cv_type_stack_t = no; then
-   cat >> confdefs.h <<\EOF
- #define stack_t struct sigaltstack
- EOF
- fi
- 
- dnl BSDI uses ss_base while others use ss_sp for the stack pointer.
- AC_MSG_CHECKING(whether stack_t has an ss_base field)
- AC_TRY_COMPILE([
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <signal.h>
- #include "confdefs.h"
- 			], [stack_t sigstk; sigstk.ss_base = 0; ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),
- 	AC_MSG_RESULT(no))
- 
- olibs="$LIBS"
- AC_MSG_CHECKING(--with-tlib argument)
- AC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)
- if test -n "$with_tlib"; then
-   AC_MSG_RESULT($with_tlib)
-   LIBS="$LIBS -l$with_tlib"
-   AC_MSG_CHECKING(for linking with $with_tlib library)
-   AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))
-   dnl Need to check for tgetent() below.
-   olibs="$LIBS"
- else
-   AC_MSG_RESULT([empty: automatic terminal library selection])
-   dnl  On HP-UX 10.10 termcap or termlib should be used instead of
-   dnl  curses, because curses is much slower.
-   dnl  Newer versions of ncurses are preferred over anything, except
-   dnl  when tinfo has been split off, it contains all we need.
-   dnl  Older versions of ncurses have bugs, get a new one!
-   dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
-   dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
-   case "`uname -s 2>/dev/null`" in
- 	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
- 	*)	tlibs="tinfo ncurses termlib termcap curses";;
-   esac
-   for libname in $tlibs; do
-     AC_CHECK_LIB(${libname}, tgetent,,)
-     if test "x$olibs" != "x$LIBS"; then
-       dnl It's possible that a library is found but it doesn't work
-       dnl e.g., shared library that cannot be found
-       dnl compile and run a test program to be sure
-       AC_TRY_RUN([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }],
- 			  res="OK", res="FAIL", res="FAIL")
-       if test "$res" = "OK"; then
- 	break
-       fi
-       AC_MSG_RESULT($libname library is not usable)
-       LIBS="$olibs"
-     fi
-   done
-   if test "x$olibs" = "x$LIBS"; then
-     AC_MSG_RESULT(no terminal library found)
-   fi
- fi
- 
- if test "x$olibs" = "x$LIBS"; then
-   AC_MSG_CHECKING([for tgetent()])
-   AC_TRY_LINK([],
-       [char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");],
- 	AC_MSG_RESULT(yes),
- 	AC_MSG_ERROR([NOT FOUND!
-       You need to install a terminal library; for example ncurses.
-       Or specify the name of the library with --with-tlib.]))
- fi
- 
- AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main()
- {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
-     ]])],[
-       vim_cv_terminfo=no
-     ],[
-       vim_cv_terminfo=yes
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')
-     ])
-   ])
- 
- if test "x$vim_cv_terminfo" = "xyes" ; then
-   AC_DEFINE(TERMINFO)
- fi
- 
- if test "x$olibs" != "x$LIBS"; then
-   AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],
-     [
-       AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main()
- {char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
-       ]])],[
- 	vim_cv_tgent=zero
-       ],[
- 	vim_cv_tgent=non-zero
-       ],[
- 	AC_MSG_ERROR(failed to compile test program.)
-       ])
-     ])
-   
-   if test "x$vim_cv_tgent" = "xzero" ; then
-     AC_DEFINE(TGETENT_ZERO_ERR, 0)
-   fi
- fi
- 
- AC_MSG_CHECKING(whether termcap.h contains ospeed)
- AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [ospeed = 20000],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),
- 	[AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING(whether ospeed can be extern)
- 	AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- extern short ospeed;
- 			], [ospeed = 20000],
- 		AC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),
- 		AC_MSG_RESULT(no))]
- 	)
- 
- AC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])
- AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [if (UP == 0 && BC == 0) PC = 1],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),
- 	[AC_MSG_RESULT(no)
- 	AC_MSG_CHECKING([whether UP, BC and PC can be extern])
- 	AC_TRY_LINK([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- extern char *UP, *BC, PC;
- 			], [if (UP == 0 && BC == 0) PC = 1],
- 		AC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),
- 		AC_MSG_RESULT(no))]
- 	)
- 
- AC_MSG_CHECKING(whether tputs() uses outfuntype)
- AC_TRY_COMPILE([
- #ifdef HAVE_TERMCAP_H
- # include <termcap.h>
- #endif
- 			], [extern int xx(); tputs("test", 1, (outfuntype)xx)],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),
- 	AC_MSG_RESULT(no))
- 
- dnl On some SCO machines sys/select redefines struct timeval
- AC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])
- AC_TRY_COMPILE([
- #include <sys/types.h>
- #include <sys/time.h>
- #include <sys/select.h>], ,
- 	  AC_MSG_RESULT(yes)
- 			AC_DEFINE(SYS_SELECT_WITH_SYS_TIME),
- 	  AC_MSG_RESULT(no))
- 
- dnl AC_DECL_SYS_SIGLIST
- 
- dnl Checks for pty.c (copied from screen) ==========================
- AC_MSG_CHECKING(for /dev/ptc)
- if test -r /dev/ptc; then
-   AC_DEFINE(HAVE_DEV_PTC)
-   AC_MSG_RESULT(yes)
- else
-   AC_MSG_RESULT(no)
- fi
- 
- AC_MSG_CHECKING(for SVR4 ptys)
- if test -c /dev/ptmx ; then
-   AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),
- 	AC_MSG_RESULT(no))
- else
-   AC_MSG_RESULT(no)
- fi
- 
- AC_MSG_CHECKING(for ptyranges)
- if test -d /dev/ptym ; then
-   pdir='/dev/ptym'
- else
-   pdir='/dev'
- fi
- dnl SCO uses ptyp%d
- AC_EGREP_CPP(yes,
- [#ifdef M_UNIX
-    yes;
- #endif
- 	], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)
- dnl if test -c /dev/ptyp19; then
- dnl ptys=`echo /dev/ptyp??`
- dnl else
- dnl ptys=`echo $pdir/pty??`
- dnl fi
- if test "$ptys" != "$pdir/pty??" ; then
-   p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
-   p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
-   AC_DEFINE_UNQUOTED(PTYRANGE0,"$p0")
-   AC_DEFINE_UNQUOTED(PTYRANGE1,"$p1")
-   AC_MSG_RESULT([$p0 / $p1])
- else
-   AC_MSG_RESULT([don't know])
- fi
- 
- dnl    ****  pty mode/group handling ****
- dnl
- dnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222
- rm -f conftest_grp
- AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #include <sys/types.h>
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_UNISTD_H
- #include <unistd.h>
- #endif
- #include <sys/stat.h>
- #include <stdio.h>
- main()
- {
-   struct stat sb;
-   char *x,*ttyname();
-   int om, m;
-   FILE *fp;
- 
-   if (!(x = ttyname(0))) exit(1);
-   if (stat(x, &sb)) exit(1);
-   om = sb.st_mode;
-   if (om & 002) exit(0);
-   m = system("mesg y");
-   if (m == -1 || m == 127) exit(1);
-   if (stat(x, &sb)) exit(1);
-   m = sb.st_mode;
-   if (chmod(x, om)) exit(1);
-   if (m & 002) exit(0);
-   if (sb.st_gid == getgid()) exit(1);
-   if (!(fp=fopen("conftest_grp", "w")))
-     exit(1);
-   fprintf(fp, "%d\n", sb.st_gid);
-   fclose(fp);
-   exit(0);
- }
-     ]])],[
-       if test -f conftest_grp; then
- 	vim_cv_tty_group=`cat conftest_grp`
- 	if test "x$vim_cv_tty_mode" = "x" ; then
- 	  vim_cv_tty_mode=0620
- 	fi
- 	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
-       else
- 	vim_cv_tty_group=world
- 	AC_MSG_RESULT([ptys are world accessible])
-       fi
-     ],[
-       vim_cv_tty_group=world
-       AC_MSG_RESULT([can't determine - assume ptys are world accessible])
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
-     ])
-   ])
- rm -f conftest_grp
- 
- if test "x$vim_cv_tty_group" != "xworld" ; then
-   AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)
-   if test "x$vim_cv_tty_mode" = "x" ; then
-     AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])
-   else
-     AC_DEFINE(PTYMODE, 0620)
-   fi
- fi
- 
- dnl Checks for library functions. ===================================
- 
- AC_TYPE_SIGNAL
- 
- dnl find out what to use at the end of a signal function
- if test $ac_cv_type_signal = void; then
-   AC_DEFINE(SIGRETURN, [return])
- else
-   AC_DEFINE(SIGRETURN, [return 0])
- fi
- 
- dnl check if struct sigcontext is defined (used for SGI only)
- AC_MSG_CHECKING(for struct sigcontext)
- AC_TRY_COMPILE([
- #include <signal.h>
- test_sig()
- {
-     struct sigcontext *scont;
-     scont = (struct sigcontext *)0;
-     return 1;
- } ], ,
- 	  AC_MSG_RESULT(yes)
- 		AC_DEFINE(HAVE_SIGCONTEXT),
- 	  AC_MSG_RESULT(no))
- 
- dnl tricky stuff: try to find out if getcwd() is implemented with
- dnl system("sh -c pwd")
- AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #ifdef HAVE_UNISTD_H
- #include <unistd.h>
- #endif
- char *dagger[] = { "IFS=pwd", 0 };
- main()
- {
-   char buffer[500];
-   extern char **environ;
-   environ = dagger;
-   return getcwd(buffer, 500) ? 0 : 1;
- }
-     ]])],[
-       vim_cv_getcwd_broken=no
-     ],[
-       vim_cv_getcwd_broken=yes
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')
-     ])
-   ])
- 
- if test "x$vim_cv_getcwd_broken" = "xyes" ; then
-   AC_DEFINE(BAD_GETCWD)
- fi
- 
- dnl Check for functions in one big call, to reduce the size of configure.
- dnl Can only be used for functions that do not require any include.
- AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
- 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
- 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
- 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
- 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
- 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
- 	usleep utime utimes)
- AC_FUNC_FSEEKO
- 
- dnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when
- dnl appropriate, so that off_t is 64 bits when needed.
- AC_SYS_LARGEFILE
- 
- dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
- AC_MSG_CHECKING(for st_blksize)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/stat.h>],
- [	struct stat st;
- 	int n;
- 
- 	stat("/", &st);
- 	n = (int)st.st_blksize;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),
- 	AC_MSG_RESULT(no))
- 
- AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[
- #include "confdefs.h"
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #include <sys/types.h>
- #include <sys/stat.h>
- main() {struct stat st;  exit(stat("configure/", &st) != 0); }
-     ]])],[
-       vim_cv_stat_ignores_slash=yes
-     ],[
-       vim_cv_stat_ignores_slash=no
-     ],[
-       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')
-     ])
-   ])
- 
- if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
-   AC_DEFINE(STAT_IGNORES_SLASH)
- fi
-   
- dnl Link with iconv for charset translation, if not found without library.
- dnl check for iconv() requires including iconv.h
- dnl Add "-liconv" when possible; Solaris has iconv but use GNU iconv when it
- dnl has been installed.
- AC_MSG_CHECKING(for iconv_open())
- save_LIBS="$LIBS"
- LIBS="$LIBS -liconv"
- AC_TRY_LINK([
- #ifdef HAVE_ICONV_H
- # include <iconv.h>
- #endif
-     ], [iconv_open("fr", "to");],
-     AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),
-     LIBS="$save_LIBS"
-     AC_TRY_LINK([
- #ifdef HAVE_ICONV_H
- # include <iconv.h>
- #endif
- 	], [iconv_open("fr", "to");],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),
- 	AC_MSG_RESULT(no)))
- 
- 
- AC_MSG_CHECKING(for nl_langinfo(CODESET))
- AC_TRY_LINK([
- #ifdef HAVE_LANGINFO_H
- # include <langinfo.h>
- #endif
- ], [char *cs = nl_langinfo(CODESET);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),
- 	AC_MSG_RESULT(no))
- 
- dnl Need various functions for floating point support.  Only enable
- dnl floating point when they are all present.
- AC_CHECK_LIB(m, strtod)
- AC_MSG_CHECKING([for strtod() and other floating point functions])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [char *s; double d;
-     d = strtod("1.1", &s);
-     d = fabs(1.11);
-     d = ceil(1.11);
-     d = floor(1.11);
-     d = log10(1.11);
-     d = pow(1.11, 2.22);
-     d = sqrt(1.11);
-     d = sin(1.11);
-     d = cos(1.11);
-     d = atan(1.11);
-     ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),
- 	AC_MSG_RESULT(no))
- 
- dnl isinf() and isnan() need to include header files and may need -lm.
- AC_MSG_CHECKING([for isinf()])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [int r = isinf(1.11); ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),
- 	AC_MSG_RESULT(no))
- 
- AC_MSG_CHECKING([for isnan()])
- AC_TRY_LINK([
- #ifdef HAVE_MATH_H
- # include <math.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- ], [int r = isnan(1.11); ],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),
- 	AC_MSG_RESULT(no))
- 
- dnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI
- dnl when -lacl works, also try to use -lattr (required for Debian).
- dnl On Solaris, use the acl_get/set functions in libsec, if present.
- AC_MSG_CHECKING(--disable-acl argument)
- AC_ARG_ENABLE(acl,
- 	[  --disable-acl           Don't check for ACL support.],
- 	, [enable_acl="yes"])
- if test "$enable_acl" = "yes"; then
- AC_MSG_RESULT(no)
- AC_CHECK_LIB(posix1e, acl_get_file, [LIBS="$LIBS -lposix1e"],
- 	AC_CHECK_LIB(acl, acl_get_file, [LIBS="$LIBS -lacl"
- 		  AC_CHECK_LIB(attr, fgetxattr, LIBS="$LIBS -lattr",,)],,),)
- 
- AC_MSG_CHECKING(for POSIX ACL support)
- AC_TRY_LINK([
- #include <sys/types.h>
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif
- acl_t acl;], [acl = acl_get_file("foo", ACL_TYPE_ACCESS);
- 	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
- 	acl_free(acl);],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),
- 	AC_MSG_RESULT(no))
- 
- AC_CHECK_LIB(sec, acl_get, [LIBS="$LIBS -lsec"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],
- AC_MSG_CHECKING(for Solaris ACL support)
- AC_TRY_LINK([
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif], [acl("foo", GETACLCNT, 0, NULL);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),
- 	AC_MSG_RESULT(no)))
- 
- AC_MSG_CHECKING(for AIX ACL support)
- AC_TRY_LINK([
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- #ifdef HAVE_SYS_ACL_H
- # include <sys/acl.h>
- #endif
- #ifdef HAVE_SYS_ACCESS_H
- # include <sys/access.h>
- #endif
- #define _ALL_SOURCE
- 
- #include <sys/stat.h>
- 
- int aclsize;
- struct acl *aclent;], [aclsize = sizeof(struct acl);
- 	aclent = (void *)malloc(aclsize);
- 	statacl("foo", STX_NORMAL, aclent, aclsize);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),
- 	AC_MSG_RESULT(no))
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- if test "x$GTK_CFLAGS" != "x"; then
-   dnl pango_shape_full() is new, fall back to pango_shape().
-   AC_MSG_CHECKING(for pango_shape_full)
-   ac_save_CFLAGS="$CFLAGS"
-   ac_save_LIBS="$LIBS"
-   CFLAGS="$CFLAGS $GTK_CFLAGS"
-   LIBS="$LIBS $GTK_LIBS"
-   AC_TRY_LINK(
-   [#include <gtk/gtk.h>],
-   [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],
- 	  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),
- 	  AC_MSG_RESULT(no))
-   CFLAGS="$ac_save_CFLAGS"
-   LIBS="$ac_save_LIBS"
- fi
- 
- AC_MSG_CHECKING(--disable-gpm argument)
- AC_ARG_ENABLE(gpm,
- 	[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,
- 	[enable_gpm="yes"])
- 
- if test "$enable_gpm" = "yes"; then
-   AC_MSG_RESULT(no)
-   dnl Checking if gpm support can be compiled
-   AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,
- 	[olibs="$LIBS" ; LIBS="-lgpm"]
- 	AC_TRY_LINK(
- 	    [#include <gpm.h>
- 	    #include <linux/keyboard.h>],
- 	    [Gpm_GetLibVersion(NULL);],
- 	    dnl Configure defines HAVE_GPM, if it is defined feature.h defines
- 	    dnl FEAT_MOUSE_GPM if mouse support is included
- 	    [vi_cv_have_gpm=yes],
- 	    [vi_cv_have_gpm=no])
- 	[LIBS="$olibs"]
-     )
-   if test $vi_cv_have_gpm = yes; then
-     LIBS="$LIBS -lgpm"
-     AC_DEFINE(HAVE_GPM)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- AC_MSG_CHECKING(--disable-sysmouse argument)
- AC_ARG_ENABLE(sysmouse,
- 	[  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).], ,
- 	[enable_sysmouse="yes"])
- 
- if test "$enable_sysmouse" = "yes"; then
-   AC_MSG_RESULT(no)
-   dnl Checking if sysmouse support can be compiled
-   dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h
-   dnl defines FEAT_SYSMOUSE if mouse support is included
-   AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,
- 	AC_TRY_LINK(
- 	    [#include <sys/consio.h>
- 	     #include <signal.h>
- 	     #include <sys/fbio.h>],
- 	    [struct mouse_info   mouse;
- 	     mouse.operation = MOUSE_MODE;
- 	     mouse.operation = MOUSE_SHOW;
- 	     mouse.u.mode.mode = 0;
- 	     mouse.u.mode.signal = SIGUSR2;],
- 	    [vi_cv_have_sysmouse=yes],
- 	    [vi_cv_have_sysmouse=no])
-     )
-   if test $vi_cv_have_sysmouse = yes; then
-     AC_DEFINE(HAVE_SYSMOUSE)
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
- AC_MSG_CHECKING(for FD_CLOEXEC)
- AC_TRY_COMPILE(
- [#if HAVE_FCNTL_H
- # include <fcntl.h>
- #endif],
- [	int flag = FD_CLOEXEC;],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
- 	AC_MSG_RESULT(not usable))
- 
- dnl rename needs to be checked separately to work on Nextstep with cc
- AC_MSG_CHECKING(for rename)
- AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
- 	AC_MSG_RESULT(no))
- 
- dnl sysctl() may exist but not the arguments we use
- AC_MSG_CHECKING(for sysctl)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysctl.h>],
- [	int mib[2], r;
- 	size_t len;
- 
- 	mib[0] = CTL_HW;
- 	mib[1] = HW_USERMEM;
- 	len = sizeof(r);
- 	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),
- 	AC_MSG_RESULT(not usable))
- 
- dnl sysinfo() may exist but not be Linux compatible
- AC_MSG_CHECKING(for sysinfo)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysinfo.h>],
- [	struct sysinfo sinfo;
- 	int t;
- 
- 	(void)sysinfo(&sinfo);
- 	t = sinfo.totalram;
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),
- 	AC_MSG_RESULT(not usable))
- 
- dnl struct sysinfo may have the mem_unit field or not
- AC_MSG_CHECKING(for sysinfo.mem_unit)
- AC_TRY_COMPILE(
- [#include <sys/types.h>
- #include <sys/sysinfo.h>],
- [	struct sysinfo sinfo;
- 	sinfo.mem_unit = 1;
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),
- 	AC_MSG_RESULT(no))
- 
- dnl sysconf() may exist but not support what we want to use
- AC_MSG_CHECKING(for sysconf)
- AC_TRY_COMPILE(
- [#include <unistd.h>],
- [	(void)sysconf(_SC_PAGESIZE);
- 	(void)sysconf(_SC_PHYS_PAGES);
- 	],
- 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),
- 	AC_MSG_RESULT(not usable))
- 
- AC_CHECK_SIZEOF([int])
- AC_CHECK_SIZEOF([long])
- AC_CHECK_SIZEOF([time_t])
- AC_CHECK_SIZEOF([off_t])
- 
- dnl Use different names to avoid clashing with other header files.
- AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
- AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
- 
- dnl Make sure that uint32_t is really 32 bits unsigned.
- AC_MSG_CHECKING([uint32_t is 32 bits])
- AC_TRY_RUN([
- #ifdef HAVE_STDINT_H
- # include <stdint.h>
- #endif
- #ifdef HAVE_INTTYPES_H
- # include <inttypes.h>
- #endif
- main() {
-   uint32_t nr1 = (uint32_t)-1;
-   uint32_t nr2 = (uint32_t)0xffffffffUL;
-   if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
-   exit(0);
- }],
- AC_MSG_RESULT(ok),
- AC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),
- AC_MSG_WARN([cannot check uint32_t when cross-compiling.]))
- 
- dnl Check for memmove() before bcopy(), makes memmove() be used when both are
- dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
- 
- [bcopy_test_prog='
- #include "confdefs.h"
- #ifdef HAVE_STRING_H
- # include <string.h>
- #endif
- #if STDC_HEADERS
- # include <stdlib.h>
- # include <stddef.h>
- #endif
- main() {
-   char buf[10];
-   strcpy(buf, "abcdefghi");
-   mch_memmove(buf, buf + 2, 3);
-   if (strncmp(buf, "ababcf", 6))
-     exit(1);
-   strcpy(buf, "abcdefghi");
-   mch_memmove(buf + 2, buf, 3);
-   if (strncmp(buf, "cdedef", 6))
-     exit(1);
-   exit(0); /* libc version works properly.  */
- }']
- 
- AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
-   [
-     AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
-       [
- 	vim_cv_memmove_handles_overlap=yes
-       ],[
- 	vim_cv_memmove_handles_overlap=no
-       ],[
- 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')
-       ])
-   ])
- 
- if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
-   AC_DEFINE(USEMEMMOVE)
- else
-   AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
-     [
-       AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
-       [
- 	vim_cv_bcopy_handles_overlap=yes
-       ],[
- 	vim_cv_bcopy_handles_overlap=no
-       ],[
- 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')
-       ])
-     ])
- 
-   if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
-     AC_DEFINE(USEBCOPY)
-   else
-     AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
-       [
- 	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
- 	  [
- 	    vim_cv_memcpy_handles_overlap=yes
- 	  ],[
- 	    vim_cv_memcpy_handles_overlap=no
- 	  ],[
- 	    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')
- 	  ])
-       ])
- 
-     if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
-       AC_DEFINE(USEMEMCPY)
-     fi
-   fi
- fi
- 
- 
- dnl Check for multibyte locale functions
- dnl Find out if _Xsetlocale() is supported by libX11.
- dnl Check if X_LOCALE should be defined.
- if test "x$with_x" = "xyes"; then
-   cflags_save=$CFLAGS
-   libs_save=$LIBS
-   LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
-   CFLAGS="$CFLAGS $X_CFLAGS"
- 
-   AC_MSG_CHECKING(whether X_LOCALE needed)
-   AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
-       AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
- 	      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),
-       AC_MSG_RESULT(no))
- 
-   AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)
-   AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)
- 	      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))
- 
-   CFLAGS=$cflags_save
-   LIBS=$libs_save
- fi
- 
- dnl Link with xpg4, it is said to make Korean locale working
- AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
- 
- dnl Check how we can run ctags.  Default to "ctags" when nothing works.
- dnl Use --version to detect Exuberant ctags (preferred)
- dnl       Add --fields=+S to get function signatures for omni completion.
- dnl -t for typedefs (many ctags have this)
- dnl -s for static functions (Elvis ctags only?)
- dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
- dnl -i+m to test for older Exuberant ctags
- AC_MSG_CHECKING(how to create tags)
- test -f tags && mv tags tags.save
- if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="ctags -I INIT+ --fields=+S"
- elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="exctags -I INIT+ --fields=+S"
- elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
-   TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
- else
-   TAGPRG="ctags"
-   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
-   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
-   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
-   (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
-   (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
-   (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -tvs"
-   (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -i+m"
- fi
- test -f tags.save && mv tags.save tags
- AC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)
- 
- dnl Check how we can run man with a section number
- AC_MSG_CHECKING(how to run man with a section nr)
- MANDEF="man"
- (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
- AC_MSG_RESULT($MANDEF)
- if test "$MANDEF" = "man -s"; then
-   AC_DEFINE(USEMAN_S)
- fi
- 
- dnl Check if gettext() is working and if it needs -lintl
- dnl We take care to base this on an empty LIBS: on some systems libelf would be
- dnl in LIBS and implicitly take along libintl. The final LIBS would then not
- dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
- AC_MSG_CHECKING(--disable-nls argument)
- AC_ARG_ENABLE(nls,
- 	[  --disable-nls           Don't support NLS (gettext()).], ,
- 	[enable_nls="yes"])
- 
- if test "$enable_nls" = "yes"; then
-   AC_MSG_RESULT(no)
- 
-   INSTALL_LANGS=install-languages
-   AC_SUBST(INSTALL_LANGS)
-   INSTALL_TOOL_LANGS=install-tool-languages
-   AC_SUBST(INSTALL_TOOL_LANGS)
- 
-   AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )
-   AC_MSG_CHECKING([for NLS])
-   if test -f po/Makefile; then
-     have_gettext="no"
-     if test -n "$MSGFMT"; then
-       olibs=$LIBS
-       LIBS=""
-       AC_TRY_LINK(
- 	[#include <libintl.h>],
- 	[gettext("Test");],
- 	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
- 	  LIBS="-lintl"
- 	  AC_TRY_LINK(
- 	      [#include <libintl.h>],
- 	      [gettext("Test");],
- 	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
- 	      LIBS="$olibs -lintl",
- 	      AC_MSG_RESULT([gettext() doesn't work]);
- 	      LIBS=$olibs))
-     else
-       AC_MSG_RESULT([msgfmt not found - disabled]);
-     fi
-     if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
-       AC_DEFINE(HAVE_GETTEXT)
-       MAKEMO=yes
-       AC_SUBST(MAKEMO)
-       dnl this was added in GNU gettext 0.10.36
-       AC_CHECK_FUNCS(bind_textdomain_codeset)
-       dnl _nl_msg_cat_cntr is required for GNU gettext
-       AC_MSG_CHECKING([for _nl_msg_cat_cntr])
-       AC_TRY_LINK(
- 		[#include <libintl.h>
- 		extern int _nl_msg_cat_cntr;],
- 		[++_nl_msg_cat_cntr;],
- 		AC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),
- 		AC_MSG_RESULT([no]))
-     fi
-   else
-     AC_MSG_RESULT([no "po/Makefile" - disabled]);
-   fi
- else
-   AC_MSG_RESULT(yes)
- fi
- 
- dnl Check for dynamic linking loader
- AC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])
- if test x${DLL} = xdlfcn.h; then
-   AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])
-   AC_MSG_CHECKING([for dlopen()])
-   AC_TRY_LINK(,[
- 		extern void* dlopen();
- 		dlopen();
-       ],
-       AC_MSG_RESULT(yes);
- 	      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
-       AC_MSG_RESULT(no);
- 	      AC_MSG_CHECKING([for dlopen() in -ldl])
- 	      olibs=$LIBS
- 	      LIBS="$LIBS -ldl"
- 	      AC_TRY_LINK(,[
- 				extern void* dlopen();
- 				dlopen();
- 		 ],
- 		 AC_MSG_RESULT(yes);
- 			  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
- 		 AC_MSG_RESULT(no);
- 			  LIBS=$olibs))
-   dnl ReliantUNIX has dlopen() in libc but everything else in libdl
-   dnl ick :-)
-   AC_MSG_CHECKING([for dlsym()])
-   AC_TRY_LINK(,[
- 		extern void* dlsym();
- 		dlsym();
-       ],
-       AC_MSG_RESULT(yes);
- 	      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
-       AC_MSG_RESULT(no);
- 	      AC_MSG_CHECKING([for dlsym() in -ldl])
- 	      olibs=$LIBS
- 	      LIBS="$LIBS -ldl"
- 	      AC_TRY_LINK(,[
- 				extern void* dlsym();
- 				dlsym();
- 		 ],
- 		 AC_MSG_RESULT(yes);
- 			  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
- 		 AC_MSG_RESULT(no);
- 			  LIBS=$olibs))
- elif test x${DLL} = xdl.h; then
-   AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])
-   AC_MSG_CHECKING([for shl_load()])
-   AC_TRY_LINK(,[
- 		extern void* shl_load();
- 		shl_load();
-      ],
-      AC_MSG_RESULT(yes);
- 	  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
-      AC_MSG_RESULT(no);
- 	  AC_MSG_CHECKING([for shl_load() in -ldld])
- 	  olibs=$LIBS
- 	  LIBS="$LIBS -ldld"
- 	  AC_TRY_LINK(,[
- 			extern void* shl_load();
- 			shl_load();
- 	     ],
- 	     AC_MSG_RESULT(yes);
- 		  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
- 	     AC_MSG_RESULT(no);
- 		  LIBS=$olibs))
- fi
- AC_CHECK_HEADERS(setjmp.h)
- 
- if test "x$MACOSX" = "xyes" -a -n "$PERL"; then
-   dnl -ldl must come after DynaLoader.a
-   if echo $LIBS | grep -e '-ldl' >/dev/null; then
-     LIBS=`echo $LIBS | sed s/-ldl//`
-     PERL_LIBS="$PERL_LIBS -ldl"
-   fi
- fi
- 
- if test "x$MACOSX" = "xyes"; then
-   AC_MSG_CHECKING(whether we need -framework Cocoa)
-   dnl Cocoa is needed with FEAT_CLIPBOARD or FEAT_MBYTE (the former is
-   dnl disabled during tiny build)
-   if test "x$features" != "xtiny" || test "x$enable_multibyte" = "xyes"; then
-     LIBS=$"$LIBS -framework Cocoa"
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
-   dnl As mentioned above, tiny build implies os_macosx.m isn't needed.  
-   dnl Exclude it from OS_EXTRA_SRC so that linker won't complain about
-   dnl missing Objective-C symbols.
-   if test "x$features" = "xtiny"; then
-     OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
-     OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
-   fi
- fi
- if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
-   LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
- fi
- 
- dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
- dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
- dnl But only when making dependencies, cproto and lint don't take "-isystem".
- dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
- dnl the number before the version number.
- DEPEND_CFLAGS_FILTER=
- if test "$GCC" = yes; then
-   AC_MSG_CHECKING(for GCC 3 or later)
-   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
-   if test "$gccmajor" -gt "2"; then
-     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
-   dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
-   dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
-   dnl Also remove duplicate _FORTIFY_SOURCE arguments.
-   dnl And undefine it first to avoid a warning.
-   AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
-   if test "$gccmajor" -gt "3"; then
-     CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
-     AC_MSG_RESULT(yes)
-   else
-     AC_MSG_RESULT(no)
-   fi
- fi
- AC_SUBST(DEPEND_CFLAGS_FILTER)
- 
- dnl link.sh tries to avoid overlinking in a hackish way.
- dnl At least GNU ld supports --as-needed which provides the same functionality
- dnl at linker level. Let's use it.
- AC_MSG_CHECKING(linker --as-needed support)
- LINK_AS_NEEDED=
- # Check if linker supports --as-needed and --no-as-needed options
- if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
-   LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
-   LINK_AS_NEEDED=yes
- fi
- if test "$LINK_AS_NEEDED" = yes; then
-   AC_MSG_RESULT(yes)
- else
-   AC_MSG_RESULT(no)
- fi
- AC_SUBST(LINK_AS_NEEDED)
- 
- # IBM z/OS reset CFLAGS for config.mk
- if test "$zOSUnix" = "yes"; then
- 	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
- fi
- 
- dnl write output files
- AC_OUTPUT(auto/config.mk:config.mk.in)
- 
- dnl vim: set sw=2 tw=78 fo+=l:
--- 0 ----
*** ../vim-8.0.0081/src/configure.ac	2016-11-12 21:11:48.758573129 +0100
--- src/configure.ac	2016-11-12 20:10:17.939642034 +0100
***************
*** 0 ****
--- 1,4314 ----
+ dnl configure.ac: autoconf script for Vim
+ 
+ dnl Process this file with autoconf 2.12 or 2.13 to produce "configure".
+ dnl Should also work with autoconf 2.54 and later.
+ 
+ AC_INIT(vim.h)
+ AC_CONFIG_HEADER(auto/config.h:config.h.in)
+ 
+ dnl Being able to run configure means the system is Unix (compatible).
+ AC_DEFINE(UNIX)
+ AC_PROG_MAKE_SET
+ 
+ dnl Checks for programs.
+ AC_PROG_CC	dnl required by almost everything
+ AC_PROG_CPP	dnl required by header file checks
+ AC_PROGRAM_EGREP dnl required by AC_EGREP_CPP
+ AC_PROG_FGREP	dnl finds working grep -F
+ AC_ISC_POSIX	dnl required by AC_C_CROSS
+ AC_PROG_AWK	dnl required for "make html" in ../doc
+ 
+ dnl Don't strip if we don't have it
+ AC_CHECK_PROG(STRIP, strip, strip, :)
+ 
+ dnl Check for extension of executables
+ AC_EXEEXT
+ 
+ dnl Check for standard headers.  We don't use this in Vim but other stuff
+ dnl in autoconf needs it, where it uses STDC_HEADERS.
+ AC_HEADER_STDC
+ AC_HEADER_SYS_WAIT
+ 
+ dnl Check for the flag that fails if stuff are missing.
+ 
+ AC_MSG_CHECKING(--enable-fail-if-missing argument)
+ AC_ARG_ENABLE(fail_if_missing,
+ 	[  --enable-fail-if-missing    Fail if dependencies on additional features
+      specified on the command line are missing.], 
+ 	[fail_if_missing="yes"],
+ 	[fail_if_missing="no"])
+ AC_MSG_RESULT($fail_if_missing)
+ 
+ dnl Set default value for CFLAGS if none is defined or it's empty
+ if test -z "$CFLAGS"; then
+   CFLAGS="-O"
+   test "$GCC" = yes && CFLAGS="-O2 -fno-strength-reduce -Wall"
+ fi
+ if test "$GCC" = yes; then
+   dnl method that should work for nearly all versions
+   gccversion=`$CC -dumpversion`
+   if test "x$gccversion" = "x"; then
+     dnl old method; fall-back for when -dumpversion doesn't work
+     gccversion=`$CC --version | sed -e '2,$d' -e 's/darwin.//' -e 's/^[[^0-9]]*\([[0-9]]\.[[0-9.]]*\).*$/\1/g'`
+   fi
+   dnl version 4.0.1 was reported to cause trouble on Macintosh by Marcin Dalecki
+   if test "$gccversion" = "3.0.1" -o "$gccversion" = "3.0.2" -o "$gccversion" = "4.0.1"; then
+     echo 'GCC [[34]].0.[[12]] has a bug in the optimizer, disabling "-O#"'
+     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-O/'`
+   else
+     if test "$gccversion" = "3.1" -o "$gccversion" = "3.2" -o "$gccversion" = "3.2.1" && `echo "$CFLAGS" | grep -v fno-strength-reduce >/dev/null`; then
+       echo 'GCC 3.1 and 3.2 have a bug in the optimizer, adding "-fno-strength-reduce"'
+       CFLAGS="$CFLAGS -fno-strength-reduce"
+     fi
+   fi
+ fi
+ 
+ dnl clang-500.2.75 or around has abandoned -f[no-]strength-reduce and issues a
+ dnl warning when that flag is passed to.  Accordingly, adjust CFLAGS based on
+ dnl the version number of the clang in use.
+ dnl Note that this does not work to get the version of clang 3.1 or 3.2.
+ AC_MSG_CHECKING(for recent clang version)
+ CLANG_VERSION_STRING=`$CC --version 2>/dev/null | sed  -n -e 's/^.*clang.*\([[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\).*$/\1/p'`
+ if test x"$CLANG_VERSION_STRING" != x"" ; then
+   CLANG_MAJOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*/\1/p'`
+   CLANG_MINOR=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/p'`
+   CLANG_REVISION=`echo "$CLANG_VERSION_STRING" | sed -n -e 's/[[0-9]][[0-9]]*\.[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)/\1/p'`
+   CLANG_VERSION=`expr $CLANG_MAJOR '*' 1000000 '+' $CLANG_MINOR '*' 1000 '+' $CLANG_REVISION`
+   AC_MSG_RESULT($CLANG_VERSION)
+   dnl If you find the same issue with versions earlier than 500.2.75,
+   dnl change the constant 500002075 below appropriately.  To get the
+   dnl integer corresponding to a version number, refer to the
+   dnl definition of CLANG_VERSION above.
+   if test "$CLANG_VERSION" -ge 500002075 ; then
+     CFLAGS=`echo "$CFLAGS" | sed -n -e 's/-fno-strength-reduce/ /p'`
+   fi
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ dnl If configure thinks we are cross compiling, there might be something
+ dnl wrong with the CC or CFLAGS settings, give a useful warning message
+ CROSS_COMPILING=
+ if test "$cross_compiling" = yes; then
+   AC_MSG_RESULT([cannot compile a simple program; if not cross compiling check CC and CFLAGS])
+   CROSS_COMPILING=1
+ fi
+ AC_SUBST(CROSS_COMPILING)
+ 
+ dnl gcc-cpp has the wonderful -MM option to produce nicer dependencies.
+ dnl But gcc 3.1 changed the meaning!  See near the end.
+ test "$GCC" = yes && CPP_MM=M; AC_SUBST(CPP_MM)
+ 
+ if test -f ./toolcheck; then
+   AC_CHECKING(for buggy tools)
+   sh ./toolcheck 1>&AC_FD_MSG
+ fi
+ 
+ OS_EXTRA_SRC=""; OS_EXTRA_OBJ=""
+ 
+ dnl Check for BeOS, which needs an extra source file
+ AC_MSG_CHECKING(for BeOS)
+ case `uname` in
+     BeOS)	OS_EXTRA_SRC=os_beos.c; OS_EXTRA_OBJ=objects/os_beos.o
+ 		BEOS=yes; AC_MSG_RESULT(yes);;
+     *)		BEOS=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl If QNX is found, assume we don't want to use Xphoton
+ dnl unless it was specifically asked for (--with-x)
+ AC_MSG_CHECKING(for QNX)
+ case `uname` in
+     QNX)	OS_EXTRA_SRC=os_qnx.c; OS_EXTRA_OBJ=objects/os_qnx.o
+ 		test -z "$with_x" && with_x=no
+ 		QNX=yes; AC_MSG_RESULT(yes);;
+     *)		QNX=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl Check for Darwin and MacOS X
+ dnl We do a check for MacOS X in the very beginning because there
+ dnl are a lot of other things we need to change besides GUI stuff
+ AC_MSG_CHECKING([for Darwin (Mac OS X)])
+ if test "`(uname) 2>/dev/null`" = Darwin; then
+   AC_MSG_RESULT(yes)
+ 
+   AC_MSG_CHECKING(--disable-darwin argument)
+   AC_ARG_ENABLE(darwin,
+ 	  [  --disable-darwin        Disable Darwin (Mac OS X) support.],
+ 	  , [enable_darwin="yes"])
+   if test "$enable_darwin" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_MSG_CHECKING(if Darwin files are there)
+     if test -f os_macosx.m; then
+       AC_MSG_RESULT(yes)
+     else
+       AC_MSG_RESULT([no, Darwin support disabled])
+       enable_darwin=no
+     fi
+   else
+     AC_MSG_RESULT([yes, Darwin support excluded])
+   fi
+ 
+   AC_MSG_CHECKING(--with-mac-arch argument)
+   AC_ARG_WITH(mac-arch, [  --with-mac-arch=ARCH    current, intel, ppc or both],
+ 	MACARCH="$withval"; AC_MSG_RESULT($MACARCH),
+ 	MACARCH="current"; AC_MSG_RESULT(defaulting to $MACARCH))
+ 
+   AC_MSG_CHECKING(--with-developer-dir argument)
+   AC_ARG_WITH(developer-dir, [  --with-developer-dir=PATH    use PATH as location for Xcode developer tools],
+ 	DEVELOPER_DIR="$withval"; AC_MSG_RESULT($DEVELOPER_DIR),
+         AC_MSG_RESULT(not present))
+   
+   if test "x$DEVELOPER_DIR" = "x"; then
+     AC_PATH_PROG(XCODE_SELECT, xcode-select)
+     if test "x$XCODE_SELECT" != "x"; then
+       AC_MSG_CHECKING(for developer dir using xcode-select)
+       DEVELOPER_DIR=`$XCODE_SELECT -print-path`
+       AC_MSG_RESULT([$DEVELOPER_DIR])
+     else
+       DEVELOPER_DIR=/Developer
+     fi
+   fi
+ 
+   if test "x$MACARCH" = "xboth"; then
+     AC_MSG_CHECKING(for 10.4 universal SDK)
+     dnl There is a terrible inconsistency (but we appear to get away with it):
+     dnl $CFLAGS uses the 10.4u SDK library for the headers, while $CPPFLAGS
+     dnl doesn't, because "gcc -E" doesn't grok it.  That means the configure
+     dnl tests using the preprocessor are actually done with the wrong header
+     dnl files. $LDFLAGS is set at the end, because configure uses it together
+     dnl with $CFLAGS and we can only have one -sysroot argument.
+     save_cppflags="$CPPFLAGS"
+     save_cflags="$CFLAGS"
+     save_ldflags="$LDFLAGS"
+     CFLAGS="$CFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+     AC_TRY_LINK([ ], [ ],
+ 	AC_MSG_RESULT(found, will make universal binary),
+ 
+ 	AC_MSG_RESULT(not found)
+ 	CFLAGS="$save_cflags"
+ 	AC_MSG_CHECKING(if Intel architecture is supported)
+ 	CPPFLAGS="$CPPFLAGS -arch i386"
+ 	LDFLAGS="$save_ldflags -arch i386"
+ 	AC_TRY_LINK([ ], [ ],
+ 	    AC_MSG_RESULT(yes); MACARCH="intel",
+ 	    AC_MSG_RESULT(no, using PowerPC)
+ 		MACARCH="ppc"
+ 		CPPFLAGS="$save_cppflags -arch ppc"
+ 		LDFLAGS="$save_ldflags -arch ppc"))
+   elif test "x$MACARCH" = "xintel"; then
+     CPPFLAGS="$CPPFLAGS -arch intel"
+     LDFLAGS="$LDFLAGS -arch intel"
+   elif test "x$MACARCH" = "xppc"; then
+     CPPFLAGS="$CPPFLAGS -arch ppc"
+     LDFLAGS="$LDFLAGS -arch ppc"
+   fi
+ 
+   if test "$enable_darwin" = "yes"; then
+     MACOSX=yes
+     OS_EXTRA_SRC="os_macosx.m os_mac_conv.c";
+     OS_EXTRA_OBJ="objects/os_macosx.o objects/os_mac_conv.o"
+     dnl TODO: use -arch i386 on Intel machines
+     dnl Removed -no-cpp-precomp, only for very old compilers.
+     CPPFLAGS="$CPPFLAGS -DMACOS_X_UNIX"
+ 
+     dnl If Carbon is found, assume we don't want X11
+     dnl unless it was specifically asked for (--with-x)
+     dnl or Motif, Athena or GTK GUI is used.
+     AC_CHECK_HEADER(Carbon/Carbon.h, CARBON=yes)
+     if test "x$CARBON" = "xyes"; then
+       if test -z "$with_x" -a "X$enable_gui" != Xmotif -a "X$enable_gui" != Xathena -a "X$enable_gui" != Xgtk2 -a "X$enable_gui" != Xgtk3; then
+ 	with_x=no
+       fi
+     fi
+   fi
+ 
+   dnl Avoid a bug with -O2 with gcc 4.0.1.  Symptom: malloc() reports double
+   dnl free.  This happens in expand_filename(), because the optimizer swaps
+   dnl two blocks of code, both using "repl", that can't be swapped.
+   if test "$MACARCH" = "intel" -o "$MACARCH" = "both"; then
+     CFLAGS=`echo "$CFLAGS" | sed 's/-O[[23456789]]/-Oz/'`
+   fi
+ 
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ dnl Mac OS X 10.9+ no longer include AvailabilityMacros.h in Carbon
+ dnl so we need to include it to have access to version macros.
+ AC_CHECK_HEADERS(AvailabilityMacros.h)
+ 
+ AC_SUBST(OS_EXTRA_SRC)
+ AC_SUBST(OS_EXTRA_OBJ)
+ 
+ dnl Add /usr/local/lib to $LDFLAGS and /usr/local/include to CFLAGS.
+ dnl Only when the directory exists and it wasn't there yet.
+ dnl For gcc don't do this when it is already in the default search path.
+ dnl Skip all of this when cross-compiling.
+ if test "$cross_compiling" = no; then
+   AC_MSG_CHECKING(--with-local-dir argument)
+   have_local_include=''
+   have_local_lib=''
+   AC_ARG_WITH([local-dir], [  --with-local-dir=PATH   search PATH instead of /usr/local for local libraries.
+   --without-local-dir     do not search /usr/local for local libraries.], [
+     local_dir="$withval"
+     case "$withval" in
+     */*) ;;
+     no)
+       # avoid adding local dir to LDFLAGS and CPPFLAGS
+       have_local_include=yes
+       have_local_lib=yes
+       ;;
+     *) AC_MSG_ERROR(must pass path argument to --with-local-dir) ;;
+     esac
+ 	AC_MSG_RESULT($local_dir)
+   ], [
+     local_dir=/usr/local
+     AC_MSG_RESULT(Defaulting to $local_dir)
+   ])
+   if test "$GCC" = yes -a "$local_dir" != no; then
+     echo 'void f(){}' > conftest.c
+     dnl Removed -no-cpp-precomp, only needed for OS X 10.2 (Ben Fowler)
+     have_local_include=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/include"`
+     have_local_lib=`${CC-cc} -c -v conftest.c 2>&1 | grep "${local_dir}/lib"`
+     rm -f conftest.c conftest.o
+   fi
+   if test -z "$have_local_lib" -a -d "${local_dir}/lib"; then
+     tt=`echo "$LDFLAGS" | sed -e "s+-L${local_dir}/lib ++g" -e "s+-L${local_dir}/lib$++g"`
+     if test "$tt" = "$LDFLAGS"; then
+       LDFLAGS="$LDFLAGS -L${local_dir}/lib"
+     fi
+   fi
+   if test -z "$have_local_include" -a -d "${local_dir}/include"; then
+     tt=`echo "$CPPFLAGS" | sed -e "s+-I${local_dir}/include ++g" -e "s+-I${local_dir}/include$++g"`
+     if test "$tt" = "$CPPFLAGS"; then
+       CPPFLAGS="$CPPFLAGS -I${local_dir}/include"
+     fi
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--with-vim-name argument)
+ AC_ARG_WITH(vim-name, [  --with-vim-name=NAME    what to call the Vim executable],
+ 	VIMNAME="$withval"; AC_MSG_RESULT($VIMNAME),
+ 	VIMNAME="vim"; AC_MSG_RESULT(Defaulting to $VIMNAME))
+ AC_SUBST(VIMNAME)
+ AC_MSG_CHECKING(--with-ex-name argument)
+ AC_ARG_WITH(ex-name, [  --with-ex-name=NAME     what to call the Ex executable],
+ 	EXNAME="$withval"; AC_MSG_RESULT($EXNAME),
+ 	EXNAME="ex"; AC_MSG_RESULT(Defaulting to ex))
+ AC_SUBST(EXNAME)
+ AC_MSG_CHECKING(--with-view-name argument)
+ AC_ARG_WITH(view-name, [  --with-view-name=NAME   what to call the View executable],
+ 	VIEWNAME="$withval"; AC_MSG_RESULT($VIEWNAME),
+ 	VIEWNAME="view"; AC_MSG_RESULT(Defaulting to view))
+ AC_SUBST(VIEWNAME)
+ 
+ AC_MSG_CHECKING(--with-global-runtime argument)
+ AC_ARG_WITH(global-runtime, [  --with-global-runtime=DIR    global runtime directory in 'runtimepath'],
+ 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(RUNTIME_GLOBAL, "$withval"),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING(--with-modified-by argument)
+ AC_ARG_WITH(modified-by, [  --with-modified-by=NAME       name of who modified a release version],
+ 	AC_MSG_RESULT($withval); AC_DEFINE_UNQUOTED(MODIFIED_BY, "$withval"),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Check for EBCDIC stolen from the LYNX port to z/OS Unix
+ AC_MSG_CHECKING(if character set is EBCDIC)
+ AC_TRY_COMPILE([ ],
+ [ /* TryCompile function for CharSet.
+    Treat any failure as ASCII for compatibility with existing art.
+    Use compile-time rather than run-time tests for cross-compiler
+    tolerance.  */
+ #if '0'!=240
+ make an error "Character set is not EBCDIC"
+ #endif ],
+ [ # TryCompile action if true
+ cf_cv_ebcdic=yes ],
+ [ # TryCompile action if false
+ cf_cv_ebcdic=no])
+ # end of TryCompile ])
+ # end of CacheVal CvEbcdic
+ AC_MSG_RESULT($cf_cv_ebcdic)
+ case "$cf_cv_ebcdic" in  #(vi
+     yes)	AC_DEFINE(EBCDIC)
+ 		line_break='"\\n"'
+ 		;;
+     *)		line_break='"\\012"';;
+ esac
+ AC_SUBST(line_break)
+ 
+ if test "$cf_cv_ebcdic" = "yes"; then
+ dnl If we have EBCDIC we most likely have z/OS Unix, let's test it!
+ AC_MSG_CHECKING(for z/OS Unix)
+ case `uname` in
+     OS/390)	zOSUnix="yes";
+ 		dnl If using cc the environment variable _CC_CCMODE must be
+ 		dnl set to "1", so that some compiler extensions are enabled.
+ 		dnl If using c89 the environment variable is named _CC_C89MODE.
+ 		dnl Note: compile with c89 never tested.
+ 		if test "$CC" = "cc"; then
+ 		  ccm="$_CC_CCMODE"
+ 		  ccn="CC"
+ 		else
+ 		  if test "$CC" = "c89"; then
+ 		    ccm="$_CC_C89MODE"
+ 		    ccn="C89"
+ 		  else
+ 		    ccm=1
+ 		  fi
+ 		fi
+ 		if test "$ccm" != "1"; then
+ 		  echo ""
+ 		  echo "------------------------------------------"
+ 		  echo " On z/OS Unix, the environment variable"
+ 		  echo " _CC_${ccn}MODE must be set to \"1\"!"
+ 		  echo " Do:"
+ 		  echo "    export _CC_${ccn}MODE=1"
+ 		  echo " and then call configure again."
+ 		  echo "------------------------------------------"
+ 		  exit 1
+ 		fi
+ 		# Set CFLAGS for configure process.
+ 		# This will be reset later for config.mk.
+ 		# Use haltonmsg to force error for missing H files.
+ 		CFLAGS="$CFLAGS -D_ALL_SOURCE -Wc,float(ieee),haltonmsg(3296)";
+ 		LDFLAGS="$LDFLAGS -Wl,EDIT=NO"
+ 		AC_MSG_RESULT(yes)
+ 		;;
+     *)		zOSUnix="no";
+ 		AC_MSG_RESULT(no)
+ 		;;
+ esac
+ fi
+ 
+ dnl Set QUOTESED. Needs additional backslashes on zOS
+ if test "$zOSUnix" = "yes"; then
+     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\\\\\&/g' -e 's/\\\\\\\\\"/\"/' -e 's/\\\\\\\\\";\$\$/\";/'"
+ else
+     QUOTESED="sed -e 's/[[\\\\\"]]/\\\\&/g' -e 's/\\\\\"/\"/' -e 's/\\\\\";\$\$/\";/'"
+ fi
+ AC_SUBST(QUOTESED)
+ 
+ 
+ dnl Link with -lsmack for Smack stuff; if not found
+ AC_MSG_CHECKING(--disable-smack argument)
+ AC_ARG_ENABLE(smack,
+ 	[  --disable-smack	  Do not check for Smack support.],
+ 	, enable_smack="yes")
+ if test "$enable_smack" = "yes"; then
+   AC_MSG_RESULT(no)
+   AC_CHECK_HEADER([linux/xattr.h], true, enable_smack="no")
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_CHECK_HEADER([attr/xattr.h], true, enable_smack="no")
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_MSG_CHECKING(for XATTR_NAME_SMACKEXEC in linux/xattr.h)
+   AC_EGREP_CPP(XATTR_NAME_SMACKEXEC, [#include <linux/xattr.h>],
+ 	       AC_MSG_RESULT(yes),
+ 	       AC_MSG_RESULT(no); enable_smack="no")
+ fi
+ if test "$enable_smack" = "yes"; then
+   AC_CHECK_LIB(attr, setxattr,
+ 	  [LIBS="$LIBS -lattr"
+ 	   found_smack="yes"
+ 	   AC_DEFINE(HAVE_SMACK)])
+ fi
+ 
+ dnl When smack was found don't search for SELinux
+ if test "x$found_smack" = "x"; then
+   dnl Link with -lselinux for SELinux stuff; if not found
+   AC_MSG_CHECKING(--disable-selinux argument)
+   AC_ARG_ENABLE(selinux,
+ 	  [  --disable-selinux	  Do not check for SELinux support.],
+ 	  , enable_selinux="yes")
+   if test "$enable_selinux" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_CHECK_LIB(selinux, is_selinux_enabled,
+ 	    [LIBS="$LIBS -lselinux"
+ 	     AC_DEFINE(HAVE_SELINUX)])
+   else
+      AC_MSG_RESULT(yes)
+   fi
+ fi
+ 
+ dnl Check user requested features.
+ 
+ AC_MSG_CHECKING(--with-features argument)
+ AC_ARG_WITH(features, [  --with-features=TYPE    tiny, small, normal, big or huge (default: huge)],
+ 	features="$withval"; AC_MSG_RESULT($features),
+ 	features="huge"; AC_MSG_RESULT(Defaulting to huge))
+ 
+ dovimdiff=""
+ dogvimdiff=""
+ case "$features" in
+   tiny)		AC_DEFINE(FEAT_TINY) ;;
+   small)	AC_DEFINE(FEAT_SMALL) ;;
+   normal)	AC_DEFINE(FEAT_NORMAL) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   big)		AC_DEFINE(FEAT_BIG) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   huge)		AC_DEFINE(FEAT_HUGE) dovimdiff="installvimdiff";
+ 			dogvimdiff="installgvimdiff" ;;
+   *)		AC_MSG_RESULT([Sorry, $features is not supported]) ;;
+ esac
+ 
+ AC_SUBST(dovimdiff)
+ AC_SUBST(dogvimdiff)
+ 
+ AC_MSG_CHECKING(--with-compiledby argument)
+ AC_ARG_WITH(compiledby, [  --with-compiledby=NAME  name to show in :version message],
+ 	compiledby="$withval"; AC_MSG_RESULT($withval),
+ 	compiledby=""; AC_MSG_RESULT(no))
+ AC_SUBST(compiledby)
+ 
+ AC_MSG_CHECKING(--disable-xsmp argument)
+ AC_ARG_ENABLE(xsmp,
+ 	[  --disable-xsmp          Disable XSMP session management],
+ 	, enable_xsmp="yes")
+ 
+ if test "$enable_xsmp" = "yes"; then
+   AC_MSG_RESULT(no)
+   AC_MSG_CHECKING(--disable-xsmp-interact argument)
+   AC_ARG_ENABLE(xsmp-interact,
+ 	  [  --disable-xsmp-interact Disable XSMP interaction],
+ 	  , enable_xsmp_interact="yes")
+   if test "$enable_xsmp_interact" = "yes"; then
+     AC_MSG_RESULT(no)
+     AC_DEFINE(USE_XSMP_INTERACT)
+   else
+     AC_MSG_RESULT(yes)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl Check for Lua feature.
+ AC_MSG_CHECKING(--enable-luainterp argument)
+ AC_ARG_ENABLE(luainterp,
+ 	[  --enable-luainterp[=OPTS]     Include Lua interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_luainterp="no"])
+ AC_MSG_RESULT($enable_luainterp)
+ 
+ if test "$enable_luainterp" = "yes" -o "$enable_luainterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Lua with tiny or small features])
+   fi
+ 
+   dnl -- find the lua executable
+   AC_SUBST(vi_cv_path_lua)
+ 
+   AC_MSG_CHECKING(--with-lua-prefix argument)
+   AC_ARG_WITH(lua_prefix,
+ 	[  --with-lua-prefix=PFX   Prefix where Lua is installed.],
+ 	with_lua_prefix="$withval"; AC_MSG_RESULT($with_lua_prefix),
+ 	with_lua_prefix="";AC_MSG_RESULT(no))
+ 
+   if test "X$with_lua_prefix" != "X"; then
+        vi_cv_path_lua_pfx="$with_lua_prefix"
+   else
+     AC_MSG_CHECKING(LUA_PREFIX environment var)
+     if test "X$LUA_PREFIX" != "X"; then
+ 	AC_MSG_RESULT("$LUA_PREFIX")
+ 	vi_cv_path_lua_pfx="$LUA_PREFIX"
+     else
+ 	AC_MSG_RESULT([not set, default to /usr])
+ 	vi_cv_path_lua_pfx="/usr"
+     fi
+   fi
+ 
+   AC_MSG_CHECKING(--with-luajit)
+   AC_ARG_WITH(luajit,
+ 	[  --with-luajit           Link with LuaJIT instead of Lua.],
+ 	[vi_cv_with_luajit="$withval"],
+ 	[vi_cv_with_luajit="no"])
+   AC_MSG_RESULT($vi_cv_with_luajit)
+ 
+   LUA_INC=
+   if test "X$vi_cv_path_lua_pfx" != "X"; then
+     if test "x$vi_cv_with_luajit" != "xno"; then
+       dnl -- try to find LuaJIT executable
+       AC_PATH_PROG(vi_cv_path_luajit, luajit)
+       if test "X$vi_cv_path_luajit" != "X"; then
+ 	dnl -- find LuaJIT version
+ 	AC_CACHE_CHECK(LuaJIT version, vi_cv_version_luajit,
+ 	[ vi_cv_version_luajit=`${vi_cv_path_luajit} -v 2>&1 | sed 's/LuaJIT \([[0-9.]]*\)\.[[0-9]]\(-[[a-z0-9]]*\)* .*/\1/'` ])
+ 	AC_CACHE_CHECK(Lua version of LuaJIT, vi_cv_version_lua_luajit,
+ 	[ vi_cv_version_lua_luajit=`${vi_cv_path_luajit} -e "print(_VERSION)" | sed 's/.* //'` ])
+ 	vi_cv_path_lua="$vi_cv_path_luajit"
+ 	vi_cv_version_lua="$vi_cv_version_lua_luajit"
+       fi
+     else
+       dnl -- try to find Lua executable
+       AC_PATH_PROG(vi_cv_path_plain_lua, lua)
+       if test "X$vi_cv_path_plain_lua" != "X"; then
+ 	dnl -- find Lua version
+ 	AC_CACHE_CHECK(Lua version, vi_cv_version_plain_lua,
+ 	[ vi_cv_version_plain_lua=`${vi_cv_path_plain_lua} -e "print(_VERSION)" | sed 's/.* //'` ])
+       fi
+       vi_cv_path_lua="$vi_cv_path_plain_lua"
+       vi_cv_version_lua="$vi_cv_version_plain_lua"
+     fi
+     if test "x$vi_cv_with_luajit" != "xno" && test "X$vi_cv_version_luajit" != "X"; then
+       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit)
+       if test -f "$vi_cv_path_lua_pfx/include/luajit-$vi_cv_version_luajit/lua.h"; then
+ 	AC_MSG_RESULT(yes)
+ 	LUA_INC=/luajit-$vi_cv_version_luajit
+       fi
+     fi
+     if test "X$LUA_INC" = "X"; then
+       AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include)
+       if test -f "$vi_cv_path_lua_pfx/include/lua.h"; then
+ 	AC_MSG_RESULT(yes)
+       else
+ 	AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(if lua.h can be found in $vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua)
+ 	if test -f "$vi_cv_path_lua_pfx/include/lua$vi_cv_version_lua/lua.h"; then
+ 	  AC_MSG_RESULT(yes)
+ 	  LUA_INC=/lua$vi_cv_version_lua
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	  vi_cv_path_lua_pfx=
+ 	fi
+       fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_lua_pfx" != "X"; then
+     if test "x$vi_cv_with_luajit" != "xno"; then
+       multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+       if test "X$multiarch" != "X"; then
+ 	lib_multiarch="lib/${multiarch}"
+       else
+ 	lib_multiarch="lib"
+       fi
+       if test "X$vi_cv_version_lua" = "X"; then
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit"
+       else
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/${lib_multiarch} -lluajit-$vi_cv_version_lua"
+       fi
+     else
+       if test "X$LUA_INC" != "X"; then
+ 	dnl Test alternate location using version
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua$vi_cv_version_lua"
+       else
+ 	LUA_LIBS="-L${vi_cv_path_lua_pfx}/lib -llua"
+       fi
+     fi
+     if test "$enable_luainterp" = "dynamic"; then
+       lua_ok="yes"
+     else
+       AC_MSG_CHECKING([if link with ${LUA_LIBS} is sane])
+       libs_save=$LIBS
+       LIBS="$LIBS $LUA_LIBS"
+       AC_TRY_LINK(,[ ],
+ 	AC_MSG_RESULT(yes); lua_ok="yes",
+ 	AC_MSG_RESULT(no); lua_ok="no"; LUA_LIBS="")
+       LIBS=$libs_save
+     fi
+     if test "x$lua_ok" = "xyes"; then
+       LUA_CFLAGS="-I${vi_cv_path_lua_pfx}/include${LUA_INC}"
+       LUA_SRC="if_lua.c"
+       LUA_OBJ="objects/if_lua.o"
+       LUA_PRO="if_lua.pro"
+       AC_DEFINE(FEAT_LUA)
+     fi
+     if test "$enable_luainterp" = "dynamic"; then
+       if test "x$vi_cv_with_luajit" != "xno"; then
+ 	luajit="jit"
+       fi
+       if test -f "${vi_cv_path_lua_pfx}/bin/cyglua-${vi_cv_version_lua}.dll"; then
+ 	vi_cv_dll_name_lua="cyglua-${vi_cv_version_lua}.dll"
+       else
+ 	if test "x$MACOSX" = "xyes"; then
+ 	  ext="dylib"
+ 	  indexes=""
+ 	else
+ 	  ext="so"
+ 	  indexes=".0 .1 .2 .3 .4 .5 .6 .7 .8 .9"
+ 	  multiarch=`dpkg-architecture -qDEB_HOST_MULTIARCH 2> /dev/null`
+ 	  if test "X$multiarch" != "X"; then
+ 	    lib_multiarch="lib/${multiarch}"
+ 	  fi
+ 	fi
+ 	dnl Determine the sover for the current version, but fallback to
+ 	dnl liblua${vi_cv_version_lua}.so if no sover-versioned file is found.
+ 	AC_MSG_CHECKING(if liblua${luajit}*.${ext}* can be found in $vi_cv_path_lua_pfx)
+ 	for subdir in "${lib_multiarch}" lib64 lib; do
+ 	  if test -z "$subdir"; then
+ 	    continue
+ 	  fi
+ 	  for sover in "${vi_cv_version_lua}.${ext}" "-${vi_cv_version_lua}.${ext}" \
+ 	    ".${vi_cv_version_lua}.${ext}" ".${ext}.${vi_cv_version_lua}"; do
+ 	    for i in $indexes ""; do
+ 	      if test -f "${vi_cv_path_lua_pfx}/${subdir}/liblua${luajit}${sover}$i"; then
+ 		sover2="$i"
+ 		break 3
+ 	      fi
+ 	    done
+ 	  done
+ 	  sover=""
+ 	done
+ 	if test "X$sover" = "X"; then
+ 	  AC_MSG_RESULT(no)
+ 	  lua_ok="no"
+ 	  vi_cv_dll_name_lua="liblua${luajit}.${ext}"
+ 	else
+ 	  AC_MSG_RESULT(yes)
+ 	  lua_ok="yes"
+ 	  vi_cv_dll_name_lua="liblua${luajit}${sover}$sover2"
+ 	fi
+       fi
+       AC_DEFINE(DYNAMIC_LUA)
+       LUA_LIBS=""
+       LUA_CFLAGS="-DDYNAMIC_LUA_DLL=\\\"${vi_cv_dll_name_lua}\\\" $LUA_CFLAGS"
+     fi
+     if test "X$LUA_CFLAGS$LUA_LIBS" != "X" && \
+        test "x$MACOSX" = "xyes" && test "x$vi_cv_with_luajit" != "xno" && \
+        test "`(uname -m) 2>/dev/null`" = "x86_64"; then
+       dnl OSX/x64 requires these flags. See http://luajit.org/install.html
+       LUA_LIBS="-pagezero_size 10000 -image_base 100000000 $LUA_LIBS"
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a "$lua_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure lua])
+   fi
+   AC_SUBST(LUA_SRC)
+   AC_SUBST(LUA_OBJ)
+   AC_SUBST(LUA_PRO)
+   AC_SUBST(LUA_LIBS)
+   AC_SUBST(LUA_CFLAGS)
+ fi
+ 
+ 
+ dnl Check for MzScheme feature.
+ AC_MSG_CHECKING(--enable-mzschemeinterp argument)
+ AC_ARG_ENABLE(mzschemeinterp,
+ 	[  --enable-mzschemeinterp   Include MzScheme interpreter.], ,
+ 	[enable_mzschemeinterp="no"])
+ AC_MSG_RESULT($enable_mzschemeinterp)
+ 
+ if test "$enable_mzschemeinterp" = "yes"; then
+   dnl -- find the mzscheme executable
+   AC_SUBST(vi_cv_path_mzscheme)
+ 
+   AC_MSG_CHECKING(--with-plthome argument)
+   AC_ARG_WITH(plthome,
+ 	[  --with-plthome=PLTHOME   Use PLTHOME.],
+ 	with_plthome="$withval"; AC_MSG_RESULT($with_plthome),
+ 	with_plthome="";AC_MSG_RESULT("no"))
+ 
+   if test "X$with_plthome" != "X"; then
+        vi_cv_path_mzscheme_pfx="$with_plthome"
+        vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+   else
+     AC_MSG_CHECKING(PLTHOME environment var)
+     if test "X$PLTHOME" != "X"; then
+ 	AC_MSG_RESULT("$PLTHOME")
+ 	vi_cv_path_mzscheme_pfx="$PLTHOME"
+ 	vi_cv_path_mzscheme="${vi_cv_path_mzscheme_pfx}/bin/mzscheme"
+     else
+ 	AC_MSG_RESULT(not set)
+ 	dnl -- try to find MzScheme executable
+ 	AC_PATH_PROG(vi_cv_path_mzscheme, mzscheme)
+ 
+ 	dnl resolve symbolic link, the executable is often elsewhere and there
+ 	dnl are no links for the include files.
+ 	if test "X$vi_cv_path_mzscheme" != "X"; then
+ 	  lsout=`ls -l $vi_cv_path_mzscheme`
+ 	  if echo "$lsout" | grep -e '->' >/dev/null 2>/dev/null; then
+ 	    vi_cv_path_mzscheme=`echo "$lsout" | sed 's/.*-> \(.*\)/\1/'`
+ 	  fi
+ 	fi
+ 
+ 	if test "X$vi_cv_path_mzscheme" != "X"; then
+ 	    dnl -- find where MzScheme thinks it was installed
+ 	    AC_CACHE_CHECK(MzScheme install prefix,vi_cv_path_mzscheme_pfx,
+ 	    dnl different versions of MzScheme differ in command line processing
+ 	    dnl use universal approach
+ 	    echo "(display (simplify-path		\
+ 	       (build-path (call-with-values	\
+ 		(lambda () (split-path (find-system-path (quote exec-file)))) \
+ 		(lambda (base name must-be-dir?) base)) (quote up))))" > mzdirs.scm
+ 	    dnl Remove a trailing slash
+ 	    [ vi_cv_path_mzscheme_pfx=`${vi_cv_path_mzscheme} -r mzdirs.scm | \
+ 		sed -e 's+/$++'` ])
+ 	    rm -f mzdirs.scm
+ 	fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+     AC_MSG_CHECKING(for racket include directory)
+     SCHEME_INC=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-include-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_INC" != "X"; then
+       AC_MSG_RESULT(${SCHEME_INC})
+     else
+       AC_MSG_RESULT(not found)
+       AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include)
+       if test -f "$vi_cv_path_mzscheme_pfx/include/scheme.h"; then
+ 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include
+ 	AC_MSG_RESULT(yes)
+       else
+ 	AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/plt)
+ 	if test -f "$vi_cv_path_mzscheme_pfx/include/plt/scheme.h"; then
+ 	  AC_MSG_RESULT(yes)
+ 	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	  AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
+ 	  if test -f "$vi_cv_path_mzscheme_pfx/include/racket/scheme.h"; then
+ 	    AC_MSG_RESULT(yes)
+ 	    SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
+ 	  else
+ 	    AC_MSG_RESULT(no)
+ 	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+ 	    if test -f /usr/include/plt/scheme.h; then
+ 	      AC_MSG_RESULT(yes)
+ 	      SCHEME_INC=/usr/include/plt
+ 	    else
+ 	      AC_MSG_RESULT(no)
+ 	      AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
+ 	      if test -f /usr/include/racket/scheme.h; then
+ 		AC_MSG_RESULT(yes)
+ 		SCHEME_INC=/usr/include/racket
+ 	      else
+ 		AC_MSG_RESULT(no)
+ 		vi_cv_path_mzscheme_pfx=
+ 	      fi
+ 	    fi
+ 	  fi
+ 	fi
+       fi
+     fi
+   fi
+ 
+   if test "X$vi_cv_path_mzscheme_pfx" != "X"; then
+ 
+     AC_MSG_CHECKING(for racket lib directory)
+     SCHEME_LIB=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-lib-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_LIB" != "X"; then
+       AC_MSG_RESULT(${SCHEME_LIB})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     for path in "${vi_cv_path_mzscheme_pfx}/lib" "${SCHEME_LIB}"; do
+       if test "X$path" != "X"; then
+ 	if test "x$MACOSX" = "xyes"; then
+ 	  MZSCHEME_LIBS="-framework Racket"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libmzscheme3m.a"; then
+ 	  MZSCHEME_LIBS="${path}/libmzscheme3m.a"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libracket3m.a"; then
+ 	  MZSCHEME_LIBS="${path}/libracket3m.a"
+ 	  MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	elif test -f "${path}/libracket.a"; then
+ 	  MZSCHEME_LIBS="${path}/libracket.a ${path}/libmzgc.a"
+ 	elif test -f "${path}/libmzscheme.a"; then
+ 	  MZSCHEME_LIBS="${path}/libmzscheme.a ${path}/libmzgc.a"
+ 	else
+ 	  dnl Using shared objects
+ 	  if test -f "${path}/libmzscheme3m.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lmzscheme3m"
+ 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	  elif test -f "${path}/libracket3m.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lracket3m"
+ 	    MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+ 	  elif test -f "${path}/libracket.so"; then
+ 	    MZSCHEME_LIBS="-L${path} -lracket -lmzgc"
+ 	  else
+ 	    dnl try next until last
+ 	    if test "$path" != "$SCHEME_LIB"; then
+ 	      continue
+ 	    fi
+ 	    MZSCHEME_LIBS="-L${path} -lmzscheme -lmzgc"
+ 	  fi
+ 	  if test "$GCC" = yes; then
+ 	    dnl Make Vim remember the path to the library.  For when it's not in
+ 	    dnl $LD_LIBRARY_PATH.
+ 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -Wl,-rpath -Wl,${path}"
+ 	  elif test "`(uname) 2>/dev/null`" = SunOS &&
+ 				   uname -r | grep '^5' >/dev/null; then
+ 	    MZSCHEME_LIBS="${MZSCHEME_LIBS} -R ${path}"
+ 	  fi
+ 	fi
+       fi
+       if test "X$MZSCHEME_LIBS" != "X"; then
+ 	break
+       fi
+     done
+ 
+     AC_MSG_CHECKING([if racket requires -pthread])
+     if test "X$SCHEME_LIB" != "X" && $FGREP -e -pthread "$SCHEME_LIB/buildinfo" >/dev/null ; then
+       AC_MSG_RESULT(yes)
+       MZSCHEME_LIBS="${MZSCHEME_LIBS} -pthread"
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -pthread"
+     else
+       AC_MSG_RESULT(no)
+     fi
+ 
+     AC_MSG_CHECKING(for racket config directory)
+     SCHEME_CONFIGDIR=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-config-dir))) (when (path? p) (display p)))'`
+     if test "X$SCHEME_CONFIGDIR" != "X"; then
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DMZSCHEME_CONFIGDIR='\"${SCHEME_CONFIGDIR}\"'"
+       AC_MSG_RESULT(${SCHEME_CONFIGDIR})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     AC_MSG_CHECKING(for racket collects directory)
+     SCHEME_COLLECTS=`${vi_cv_path_mzscheme} -e '(require setup/dirs)(let ((p (find-collects-dir))) (when (path? p) (let-values (((base _1 _2) (split-path p))) (display base))))'`
+     if test "X$SCHEME_COLLECTS" = "X"; then
+       if test -d "$vi_cv_path_mzscheme_pfx/lib/plt/collects"; then
+ 	SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/plt/
+       else
+ 	if test -d "$vi_cv_path_mzscheme_pfx/lib/racket/collects"; then
+ 	  SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/lib/racket/
+ 	else
+ 	  if test -d "$vi_cv_path_mzscheme_pfx/share/racket/collects"; then
+ 	    SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/share/racket/
+ 	  else
+ 	    if test -d "$vi_cv_path_mzscheme_pfx/collects"; then
+ 	      SCHEME_COLLECTS=$vi_cv_path_mzscheme_pfx/
+ 	    fi
+ 	  fi
+ 	fi
+       fi
+     fi
+     if test "X$SCHEME_COLLECTS" != "X" ; then
+       AC_MSG_RESULT(${SCHEME_COLLECTS})
+     else
+       AC_MSG_RESULT(not found)
+     fi
+ 
+     AC_MSG_CHECKING(for mzscheme_base.c)
+     if test -f "${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
+       MZSCHEME_EXTRA="mzscheme_base.c"
+       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+       MZSCHEME_MOD="++lib scheme/base"
+     else
+       if test -f "${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+ 	MZSCHEME_EXTRA="mzscheme_base.c"
+ 	MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
+ 	MZSCHEME_MOD="++lib scheme/base"
+       else
+ 	if test -f "${SCHEME_COLLECTS}collects/racket/base.rkt" ; then
+ 	  MZSCHEME_EXTRA="mzscheme_base.c"
+ 	  MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/raco ctool"
+ 	  MZSCHEME_MOD=""
+ 	fi
+       fi
+     fi
+     if test "X$MZSCHEME_EXTRA" != "X" ; then
+       dnl need to generate bytecode for MzScheme base
+       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+       AC_MSG_RESULT(needed)
+     else
+       AC_MSG_RESULT(not needed)
+     fi
+ 
+     dnl On Ubuntu this fixes "undefined reference to symbol 'ffi_type_void'".
+     AC_CHECK_LIB(ffi, ffi_type_void, [MZSCHEME_LIBS="$MZSCHEME_LIBS -lffi"])
+ 
+     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
+       -DMZSCHEME_COLLECTS='\"${SCHEME_COLLECTS}collects\"'"
+ 
+     dnl Test that we can compile a simple program with these CFLAGS and LIBS.
+     AC_MSG_CHECKING([if compile and link flags for MzScheme are sane])
+     cflags_save=$CFLAGS
+     libs_save=$LIBS
+     CFLAGS="$CFLAGS $MZSCHEME_CFLAGS"
+     LIBS="$LIBS $MZSCHEME_LIBS"
+     AC_TRY_LINK(,[ ],
+ 	   AC_MSG_RESULT(yes); mzs_ok=yes,
+ 	   AC_MSG_RESULT(no: MZSCHEME DISABLED); mzs_ok=no)
+     CFLAGS=$cflags_save
+     LIBS=$libs_save
+     if test $mzs_ok = yes; then
+       MZSCHEME_SRC="if_mzsch.c"
+       MZSCHEME_OBJ="objects/if_mzsch.o"
+       MZSCHEME_PRO="if_mzsch.pro"
+       AC_DEFINE(FEAT_MZSCHEME)
+     else
+       MZSCHEME_CFLAGS=
+       MZSCHEME_LIBS=
+       MZSCHEME_EXTRA=
+       MZSCHEME_MZC=
+     fi
+   fi
+   AC_SUBST(MZSCHEME_SRC)
+   AC_SUBST(MZSCHEME_OBJ)
+   AC_SUBST(MZSCHEME_PRO)
+   AC_SUBST(MZSCHEME_LIBS)
+   AC_SUBST(MZSCHEME_CFLAGS)
+   AC_SUBST(MZSCHEME_EXTRA)
+   AC_SUBST(MZSCHEME_MZC)
+ fi
+ 
+ 
+ AC_MSG_CHECKING(--enable-perlinterp argument)
+ AC_ARG_ENABLE(perlinterp,
+ 	[  --enable-perlinterp[=OPTS]     Include Perl interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_perlinterp="no"])
+ AC_MSG_RESULT($enable_perlinterp)
+ if test "$enable_perlinterp" = "yes" -o "$enable_perlinterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Perl with tiny or small features])
+   fi
+   AC_SUBST(vi_cv_path_perl)
+   AC_PATH_PROG(vi_cv_path_perl, perl)
+   if test "X$vi_cv_path_perl" != "X"; then
+     AC_MSG_CHECKING(Perl version)
+     if $vi_cv_path_perl -e 'require 5.003_01' >/dev/null 2>/dev/null; then
+      eval `$vi_cv_path_perl -V:usethreads`
+      eval `$vi_cv_path_perl -V:libperl`
+      if test "X$usethreads" = "XUNKNOWN" -o "X$usethreads" = "Xundef"; then
+        badthreads=no
+      else
+        if $vi_cv_path_perl -e 'require 5.6.0' >/dev/null 2>/dev/null; then
+ 	 eval `$vi_cv_path_perl -V:use5005threads`
+ 	 if test "X$use5005threads" = "XUNKNOWN" -o "X$use5005threads" = "Xundef"; then
+ 	   badthreads=no
+ 	 else
+ 	   badthreads=yes
+ 	   AC_MSG_RESULT(>>> Perl > 5.6 with 5.5 threads cannot be used <<<)
+ 	 fi
+        else
+ 	 badthreads=yes
+ 	 AC_MSG_RESULT(>>> Perl 5.5 with threads cannot be used <<<)
+        fi
+      fi
+      if test $badthreads = no; then
+       AC_MSG_RESULT(OK)
+       eval `$vi_cv_path_perl -V:shrpenv`
+       if test "X$shrpenv" = "XUNKNOWN"; then # pre 5.003_04
+ 	shrpenv=""
+       fi
+       vi_cv_perllib=`$vi_cv_path_perl -MConfig -e 'print $Config{privlibexp}'`
+       AC_SUBST(vi_cv_perllib)
+       vi_cv_perl_extutils=unknown_perl_extutils_path
+       for extutils_rel_path in ExtUtils vendor_perl/ExtUtils; do
+ 	xsubpp_path="$vi_cv_perllib/$extutils_rel_path/xsubpp"
+ 	if test -f "$xsubpp_path"; then
+ 	  vi_cv_perl_xsubpp="$xsubpp_path"
+ 	fi
+       done
+       AC_SUBST(vi_cv_perl_xsubpp)
+       dnl Remove "-fno-something", it breaks using cproto.
+       dnl Remove "-fdebug-prefix-map", it isn't supported by clang.
+       perlcppflags=`$vi_cv_path_perl -Mlib=$srcdir -MExtUtils::Embed \
+ 	      -e 'ccflags;perl_inc;print"\n"' | sed -e 's/-fno[[^ ]]*//' \
+ 			-e 's/-fdebug-prefix-map[[^ ]]*//g'`
+       dnl Remove "-lc", it breaks on FreeBSD when using "-pthread".
+       perllibs=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed -e 'ldopts' | \
+ 		sed -e '/Warning/d' -e '/Note (probably harmless)/d' \
+ 			-e 's/-bE:perl.exp//' -e 's/-lc //'`
+       dnl Don't add perl lib to $LIBS: if it's not in LD_LIBRARY_PATH
+       dnl a test in configure may fail because of that.
+       perlldflags=`cd $srcdir; $vi_cv_path_perl -MExtUtils::Embed \
+ 		-e 'ccdlflags' | sed -e 's/-bE:perl.exp//'`
+ 
+       dnl check that compiling a simple program still works with the flags
+       dnl added for Perl.
+       AC_MSG_CHECKING([if compile and link flags for Perl are sane])
+       cflags_save=$CFLAGS
+       libs_save=$LIBS
+       ldflags_save=$LDFLAGS
+       CFLAGS="$CFLAGS $perlcppflags"
+       LIBS="$LIBS $perllibs"
+       perlldflags=`echo "$perlldflags" | sed -e 's/^ *//g'`
+       LDFLAGS="$perlldflags $LDFLAGS"
+       AC_TRY_LINK(,[ ],
+ 	     AC_MSG_RESULT(yes); perl_ok=yes,
+ 	     AC_MSG_RESULT(no: PERL DISABLED); perl_ok=no)
+       CFLAGS=$cflags_save
+       LIBS=$libs_save
+       LDFLAGS=$ldflags_save
+       if test $perl_ok = yes; then
+ 	if test "X$perlcppflags" != "X"; then
+ 	  dnl remove -pipe and -Wxxx, it confuses cproto
+ 	  PERL_CFLAGS=`echo "$perlcppflags" | sed -e 's/-pipe //' -e 's/-W[[^ ]]*//'`
+ 	fi
+ 	if test "X$perlldflags" != "X"; then
+ 	  if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$perlldflags\"`" = "X"; then
+ 	    LDFLAGS="$perlldflags $LDFLAGS"
+ 	  fi
+ 	fi
+ 	PERL_LIBS=$perllibs
+ 	PERL_SRC="auto/if_perl.c if_perlsfio.c"
+ 	PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o"
+ 	PERL_PRO="if_perl.pro if_perlsfio.pro"
+ 	AC_DEFINE(FEAT_PERL)
+       fi
+      fi
+     else
+       AC_MSG_RESULT(>>> too old; need Perl version 5.003_01 or later <<<)
+     fi
+   fi
+ 
+   if test "x$MACOSX" = "xyes"; then
+     dnl Mac OS X 10.2 or later
+     dir=/System/Library/Perl
+     darwindir=$dir/darwin
+     if test -d $darwindir; then
+       PERL=/usr/bin/perl
+     else
+       dnl Mac OS X 10.3
+       dir=/System/Library/Perl/5.8.1
+       darwindir=$dir/darwin-thread-multi-2level
+       if test -d $darwindir; then
+ 	PERL=/usr/bin/perl
+       fi
+     fi
+     if test -n "$PERL"; then
+       PERL_DIR="$dir"
+       PERL_CFLAGS="-DFEAT_PERL -I$darwindir/CORE"
+       PERL_OBJ="objects/if_perl.o objects/if_perlsfio.o $darwindir/auto/DynaLoader/DynaLoader.a"
+       PERL_LIBS="-L$darwindir/CORE -lperl"
+     fi
+     dnl Perl on Mac OS X 10.5 adds "-arch" flags but these should only
+     dnl be included if requested by passing --with-mac-arch to
+     dnl configure, so strip these flags first (if present)
+     PERL_LIBS=`echo "$PERL_LIBS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+     PERL_CFLAGS=`echo "$PERL_CFLAGS" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+   fi
+   if test "$enable_perlinterp" = "dynamic"; then
+     if test "$perl_ok" = "yes" -a "X$libperl" != "X"; then
+       AC_DEFINE(DYNAMIC_PERL)
+       PERL_CFLAGS="-DDYNAMIC_PERL_DLL=\\\"$libperl\\\" $PERL_CFLAGS"
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a "$perl_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure perl])
+   fi
+ fi
+ AC_SUBST(shrpenv)
+ AC_SUBST(PERL_SRC)
+ AC_SUBST(PERL_OBJ)
+ AC_SUBST(PERL_PRO)
+ AC_SUBST(PERL_CFLAGS)
+ AC_SUBST(PERL_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-pythoninterp argument)
+ AC_ARG_ENABLE(pythoninterp,
+ 	[  --enable-pythoninterp[=OPTS]   Include Python interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_pythoninterp="no"])
+ AC_MSG_RESULT($enable_pythoninterp)
+ if test "$enable_pythoninterp" = "yes" -o "$enable_pythoninterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Python with tiny or small features])
+   fi
+ 
+   dnl -- find the python executable
+   AC_PATH_PROGS(vi_cv_path_python, python2 python)
+   if test "X$vi_cv_path_python" != "X"; then
+ 
+     dnl -- get its version number
+     AC_CACHE_CHECK(Python version,vi_cv_var_python_version,
+     [[vi_cv_var_python_version=`
+ 	    ${vi_cv_path_python} -c 'import sys; print sys.version[:3]'`
+     ]])
+ 
+     dnl -- it must be at least version 2.3
+     AC_MSG_CHECKING(Python is 2.3 or better)
+     if ${vi_cv_path_python} -c \
+ 	"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"
+     then
+       AC_MSG_RESULT(yep)
+ 
+       dnl -- find where python thinks it was installed
+       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python_pfx,
+       [ vi_cv_path_python_pfx=`
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys; print sys.prefix"` ])
+ 
+       dnl -- and where it thinks it runs
+       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python_epfx,
+       [ vi_cv_path_python_epfx=`
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys; print sys.exec_prefix"` ])
+ 
+       dnl -- python's internal library path
+ 
+       AC_CACHE_VAL(vi_cv_path_pythonpath,
+       [ vi_cv_path_pythonpath=`
+ 	    unset PYTHONPATH;
+ 	    ${vi_cv_path_python} -c \
+ 		"import sys, string; print string.join(sys.path,':')"` ])
+ 
+       dnl -- where the Python implementation library archives are
+ 
+       AC_ARG_WITH(python-config-dir,
+ 	[  --with-python-config-dir=PATH  Python's config directory],
+ 	[ vi_cv_path_python_conf="${withval}" ] )
+ 
+       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python_conf,
+       [
+ 	vi_cv_path_python_conf=
+ 	d=`${vi_cv_path_python} -c "import distutils.sysconfig; print distutils.sysconfig.get_config_var('LIBPL')"`
+ 	if test -d "$d" && test -f "$d/config.c"; then
+ 	  vi_cv_path_python_conf="$d"
+ 	else
+ 	  for path in "${vi_cv_path_python_pfx}" "${vi_cv_path_python_epfx}"; do
+ 	    for subdir in lib64 lib share; do
+ 	      d="${path}/${subdir}/python${vi_cv_var_python_version}/config"
+ 	      if test -d "$d" && test -f "$d/config.c"; then
+ 		vi_cv_path_python_conf="$d"
+ 	      fi
+ 	    done
+ 	  done
+ 	fi
+       ])
+ 
+       PYTHON_CONFDIR="${vi_cv_path_python_conf}"
+ 
+       if test "X$PYTHON_CONFDIR" = "X"; then
+ 	AC_MSG_RESULT([can't find it!])
+       else
+ 
+ 	dnl -- we need to examine Python's config/Makefile too
+ 	dnl    see what the interpreter is built from
+ 	AC_CACHE_VAL(vi_cv_path_python_plibs,
+ 	[
+ 	    pwd=`pwd`
+ 	    tmp_mkf="$pwd/config-PyMake$$"
+ 	    cat -- "${PYTHON_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+ __:
+ 	@echo "python_BASEMODLIBS='$(BASEMODLIBS)'"
+ 	@echo "python_LIBS='$(LIBS)'"
+ 	@echo "python_SYSLIBS='$(SYSLIBS)'"
+ 	@echo "python_LINKFORSHARED='$(LINKFORSHARED)'"
+ 	@echo "python_DLLLIBRARY='$(DLLLIBRARY)'"
+ 	@echo "python_INSTSONAME='$(INSTSONAME)'"
+ 	@echo "python_PYTHONFRAMEWORK='$(PYTHONFRAMEWORK)'"
+ 	@echo "python_PYTHONFRAMEWORKPREFIX='$(PYTHONFRAMEWORKPREFIX)'"
+ 	@echo "python_PYTHONFRAMEWORKINSTALLDIR='$(PYTHONFRAMEWORKINSTALLDIR)'"
+ eof
+ 	    dnl -- delete the lines from make about Entering/Leaving directory
+ 	    eval "`cd ${PYTHON_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+ 	    rm -f -- "${tmp_mkf}"
+ 	    if test "x$MACOSX" = "xyes" && test -n "${python_PYTHONFRAMEWORK}" && ${vi_cv_path_python} -c \
+ 		"import sys; sys.exit(${vi_cv_var_python_version} < 2.3)"; then
+ 	      vi_cv_path_python_plibs="-framework Python"
+ 	      if test "x${vi_cv_path_python}" != "x/usr/bin/python" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+ 		  vi_cv_path_python_plibs="-F${python_PYTHONFRAMEWORKPREFIX} -framework Python"
+ 	      fi
+ 	    else
+ 	      if test "${vi_cv_var_python_version}" = "1.4"; then
+ 		  vi_cv_path_python_plibs="${PYTHON_CONFDIR}/libModules.a ${PYTHON_CONFDIR}/libPython.a ${PYTHON_CONFDIR}/libObjects.a ${PYTHON_CONFDIR}/libParser.a"
+ 	      else
+ 		  vi_cv_path_python_plibs="-L${PYTHON_CONFDIR} -lpython${vi_cv_var_python_version}"
+ 	      fi
+ 	      dnl -- Check if the path contained in python_LINKFORSHARED is
+ 	      dnl    usable for vim build. If not, make and try other
+ 	      dnl    candidates.
+ 	      if test -n "${python_LINKFORSHARED}" && test -n "${python_PYTHONFRAMEWORKPREFIX}"; then
+ 	        python_link_symbol=`echo ${python_LINKFORSHARED} | sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]].*/\1/'`
+ 		python_link_path=`echo ${python_LINKFORSHARED} |   sed 's/\([[^ \t]][[^ \t]]*[[ \t]][[ \t]]*[[^ \t]][[^ \t]]*\)[[ \t]][[ \t]]*\(.*\)/\2/'`
+ 	        if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+ 	          dnl -- The path looks relative. Guess the absolute one using
+ 		  dnl    the prefix and try that.
+ 	          python_link_path="${python_PYTHONFRAMEWORKPREFIX}/${python_link_path}"
+ 		  if test -n "${python_link_path}" && ! test -x "${python_link_path}"; then
+ 		    dnl -- A last resort.
+ 		    python_link_path="${python_PYTHONFRAMEWORKINSTALLDIR}/Versions/${vi_cv_var_python_version}/${python_PYTHONFRAMEWORK}"
+ 	            dnl -- No check is done. The last word is left to the
+ 	            dnl    "sanity" test on link flags that follows shortly.
+ 		  fi
+ 	          python_LINKFORSHARED="${python_link_symbol} ${python_link_path}"
+ 	        fi
+ 	      fi
+ 	      vi_cv_path_python_plibs="${vi_cv_path_python_plibs} ${python_BASEMODLIBS} ${python_LIBS} ${python_SYSLIBS} ${python_LINKFORSHARED}"
+ 	      dnl remove -ltermcap, it can conflict with an earlier -lncurses
+ 	      vi_cv_path_python_plibs=`echo $vi_cv_path_python_plibs | sed s/-ltermcap//`
+ 	    fi
+ 	])
+ 	AC_CACHE_CHECK(Python's dll name,vi_cv_dll_name_python,
+ 	[
+ 	  if test "X$python_DLLLIBRARY" != "X"; then
+ 	    vi_cv_dll_name_python="$python_DLLLIBRARY"
+ 	  else
+ 	    vi_cv_dll_name_python="$python_INSTSONAME"
+ 	  fi
+ 	])
+ 
+ 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
+ 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
+ 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+ 	else
+ 	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME='\"${vi_cv_path_python_pfx}\"'"
+ 	fi
+ 	PYTHON_SRC="if_python.c"
+ 	PYTHON_OBJ="objects/if_python.o"
+ 	if test "${vi_cv_var_python_version}" = "1.4"; then
+ 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
+ 	fi
+     PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+ 
+ 	dnl On FreeBSD linking with "-pthread" is required to use threads.
+ 	dnl _THREAD_SAFE must be used for compiling then.
+ 	dnl The "-pthread" is added to $LIBS, so that the following check for
+ 	dnl sigaltstack() will look in libc_r (it's there in libc!).
+ 	dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+ 	dnl will then define target-specific defines, e.g., -D_REENTRANT.
+ 	dnl Don't do this for Mac OSX, -pthread will generate a warning.
+ 	AC_MSG_CHECKING([if -pthread should be used])
+ 	threadsafe_flag=
+ 	thread_lib=
+ 	dnl if test "x$MACOSX" != "xyes"; then
+         if test "`(uname) 2>/dev/null`" != Darwin; then
+ 	  test "$GCC" = yes && threadsafe_flag="-pthread"
+ 	  if test "`(uname) 2>/dev/null`" = FreeBSD; then
+ 	    threadsafe_flag="-D_THREAD_SAFE"
+ 	    thread_lib="-pthread"
+ 	  fi
+ 	  if test "`(uname) 2>/dev/null`" = SunOS; then
+ 	    threadsafe_flag="-pthreads"
+ 	  fi
+ 	fi
+ 	libs_save_old=$LIBS
+ 	if test -n "$threadsafe_flag"; then
+ 	  cflags_save=$CFLAGS
+ 	  CFLAGS="$CFLAGS $threadsafe_flag"
+ 	  LIBS="$LIBS $thread_lib"
+ 	  AC_TRY_LINK(,[ ],
+ 	     AC_MSG_RESULT(yes); PYTHON_CFLAGS="$PYTHON_CFLAGS $threadsafe_flag",
+ 	     AC_MSG_RESULT(no); LIBS=$libs_save_old
+ 	     )
+ 	  CFLAGS=$cflags_save
+ 	else
+ 	  AC_MSG_RESULT(no)
+ 	fi
+ 
+ 	dnl Check that compiling a simple program still works with the flags
+ 	dnl added for Python.
+ 	AC_MSG_CHECKING([if compile and link flags for Python are sane])
+ 	cflags_save=$CFLAGS
+ 	libs_save=$LIBS
+ 	CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+ 	LIBS="$LIBS $PYTHON_LIBS"
+ 	AC_TRY_LINK(,[ ],
+ 	       AC_MSG_RESULT(yes); python_ok=yes,
+ 	       AC_MSG_RESULT(no: PYTHON DISABLED); python_ok=no)
+ 	CFLAGS=$cflags_save
+ 	LIBS=$libs_save
+ 	if test $python_ok = yes; then
+ 	  AC_DEFINE(FEAT_PYTHON)
+ 	else
+ 	  LIBS=$libs_save_old
+ 	  PYTHON_SRC=
+ 	  PYTHON_OBJ=
+ 	  PYTHON_LIBS=
+ 	  PYTHON_CFLAGS=
+ 	fi
+       fi
+     else
+       AC_MSG_RESULT(too old)
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a "$python_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure python])
+   fi
+ fi
+ 
+ AC_SUBST(PYTHON_CONFDIR)
+ AC_SUBST(PYTHON_LIBS)
+ AC_SUBST(PYTHON_GETPATH_CFLAGS)
+ AC_SUBST(PYTHON_CFLAGS)
+ AC_SUBST(PYTHON_SRC)
+ AC_SUBST(PYTHON_OBJ)
+ 
+ 
+ AC_MSG_CHECKING(--enable-python3interp argument)
+ AC_ARG_ENABLE(python3interp,
+ 	[  --enable-python3interp[=OPTS]   Include Python3 interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_python3interp="no"])
+ AC_MSG_RESULT($enable_python3interp)
+ if test "$enable_python3interp" = "yes" -o "$enable_python3interp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Python with tiny or small features])
+   fi
+ 
+   dnl -- find the python3 executable
+   AC_PATH_PROGS(vi_cv_path_python3, python3 python)
+   if test "X$vi_cv_path_python3" != "X"; then
+ 
+     dnl -- get its version number
+     AC_CACHE_CHECK(Python version,vi_cv_var_python3_version,
+     [[vi_cv_var_python3_version=`
+           ${vi_cv_path_python3} -c 'import sys; print(sys.version[:3])'`
+     ]])
+ 
+     dnl -- it must be at least version 3
+     AC_MSG_CHECKING(Python is 3.0 or better)
+     if ${vi_cv_path_python3} -c \
+       "import sys; sys.exit(${vi_cv_var_python3_version} < 3.0)"
+     then
+       AC_MSG_RESULT(yep)
+ 
+       dnl -- get abiflags for python 3.2 or higher (PEP 3149)
+       AC_CACHE_CHECK(Python's abiflags,vi_cv_var_python3_abiflags,
+       [
+        vi_cv_var_python3_abiflags=
+        if ${vi_cv_path_python3} -c \
+            "import sys; sys.exit(${vi_cv_var_python3_version} < 3.2)"
+        then
+          vi_cv_var_python3_abiflags=`${vi_cv_path_python3} -c \    
+            "import sys; print(sys.abiflags)"`
+        fi ])
+   
+       dnl -- find where python3 thinks it was installed
+       AC_CACHE_CHECK(Python's install prefix,vi_cv_path_python3_pfx,
+       [ vi_cv_path_python3_pfx=`
+        ${vi_cv_path_python3} -c \
+        "import sys; print(sys.prefix)"` ])
+   
+       dnl -- and where it thinks it runs
+       AC_CACHE_CHECK(Python's execution prefix,vi_cv_path_python3_epfx,
+       [ vi_cv_path_python3_epfx=`
+        ${vi_cv_path_python3} -c \
+        "import sys; print(sys.exec_prefix)"` ])
+   
+       dnl -- python3's internal library path
+   
+       AC_CACHE_VAL(vi_cv_path_python3path,
+       [ vi_cv_path_python3path=`
+        unset PYTHONPATH;
+        ${vi_cv_path_python3} -c \
+        "import sys, string; print(':'.join(sys.path))"` ])
+   
+       dnl -- where the Python implementation library archives are
+   
+       AC_ARG_WITH(python3-config-dir,
+        [  --with-python3-config-dir=PATH  Python's config directory],
+        [ vi_cv_path_python3_conf="${withval}" ] )
+   
+       AC_CACHE_CHECK(Python's configuration directory,vi_cv_path_python3_conf,
+       [
+        vi_cv_path_python3_conf=
+        config_dir="config-${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+        d=`${vi_cv_path_python3} -c "import distutils.sysconfig; print(distutils.sysconfig.get_config_var('LIBPL'))"`
+        if test -d "$d" && test -f "$d/config.c"; then
+          vi_cv_path_python3_conf="$d"
+        else
+          for path in "${vi_cv_path_python3_pfx}" "${vi_cv_path_python3_epfx}"; do
+ 	   for subdir in lib64 lib share; do
+ 	     d="${path}/${subdir}/python${vi_cv_var_python3_version}/${config_dir}"
+ 	     if test -d "$d" && test -f "$d/config.c"; then
+ 	       vi_cv_path_python3_conf="$d"
+ 	     fi
+ 	   done
+          done
+        fi
+       ])
+   
+       PYTHON3_CONFDIR="${vi_cv_path_python3_conf}"
+   
+       if test "X$PYTHON3_CONFDIR" = "X"; then
+         AC_MSG_RESULT([can't find it!])
+       else
+   
+         dnl -- we need to examine Python's config/Makefile too
+         dnl    see what the interpreter is built from
+         AC_CACHE_VAL(vi_cv_path_python3_plibs,
+         [
+             pwd=`pwd`
+             tmp_mkf="$pwd/config-PyMake$$"
+             cat -- "${PYTHON3_CONFDIR}/Makefile" - <<'eof' >"${tmp_mkf}"
+ __:
+ 	@echo "python3_BASEMODLIBS='$(BASEMODLIBS)'"
+ 	@echo "python3_LIBS='$(LIBS)'"
+ 	@echo "python3_SYSLIBS='$(SYSLIBS)'"
+ 	@echo "python3_DLLLIBRARY='$(DLLLIBRARY)'"
+ 	@echo "python3_INSTSONAME='$(INSTSONAME)'"
+ eof
+ 	    dnl -- delete the lines from make about Entering/Leaving directory
+ 	    eval "`cd ${PYTHON3_CONFDIR} && make -f "${tmp_mkf}" __ | sed '/ directory /d'`"
+ 	    rm -f -- "${tmp_mkf}"
+ 	    vi_cv_path_python3_plibs="-L${PYTHON3_CONFDIR} -lpython${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags}"
+ 	    vi_cv_path_python3_plibs="${vi_cv_path_python3_plibs} ${python3_BASEMODLIBS} ${python3_LIBS} ${python3_SYSLIBS}"
+ 	    dnl remove -ltermcap, it can conflict with an earlier -lncurses
+ 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-ltermcap//`
+ 	    vi_cv_path_python3_plibs=`echo $vi_cv_path_python3_plibs | sed s/-lffi//`
+ 	])
+ 	AC_CACHE_CHECK(Python3's dll name,vi_cv_dll_name_python3,
+ 	[
+ 	  if test "X$python3_DLLLIBRARY" != "X"; then
+ 	    vi_cv_dll_name_python3="$python3_DLLLIBRARY"
+ 	  else
+ 	    vi_cv_dll_name_python3="$python3_INSTSONAME"
+ 	  fi
+ 	])
+ 
+         PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
+         if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
+           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+         else
+           PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}${vi_cv_var_python3_abiflags} -DPYTHON3_HOME='L\"${vi_cv_path_python3_pfx}\"'"
+         fi
+         PYTHON3_SRC="if_python3.c"
+         PYTHON3_OBJ="objects/if_python3.o"
+   
+         dnl On FreeBSD linking with "-pthread" is required to use threads.
+         dnl _THREAD_SAFE must be used for compiling then.
+         dnl The "-pthread" is added to $LIBS, so that the following check for
+         dnl sigaltstack() will look in libc_r (it's there in libc!).
+         dnl Otherwise, when using GCC, try adding -pthread to $CFLAGS.  GCC
+         dnl will then define target-specific defines, e.g., -D_REENTRANT.
+         dnl Don't do this for Mac OSX, -pthread will generate a warning.
+         AC_MSG_CHECKING([if -pthread should be used])
+         threadsafe_flag=
+         thread_lib=
+         dnl if test "x$MACOSX" != "xyes"; then
+         if test "`(uname) 2>/dev/null`" != Darwin; then
+           test "$GCC" = yes && threadsafe_flag="-pthread"
+           if test "`(uname) 2>/dev/null`" = FreeBSD; then
+             threadsafe_flag="-D_THREAD_SAFE"
+             thread_lib="-pthread"
+           fi
+           if test "`(uname) 2>/dev/null`" = SunOS; then
+             threadsafe_flag="-pthreads"
+           fi
+         fi
+         libs_save_old=$LIBS
+         if test -n "$threadsafe_flag"; then
+           cflags_save=$CFLAGS
+           CFLAGS="$CFLAGS $threadsafe_flag"
+           LIBS="$LIBS $thread_lib"
+           AC_TRY_LINK(,[ ],
+              AC_MSG_RESULT(yes); PYTHON3_CFLAGS="$PYTHON3_CFLAGS $threadsafe_flag",
+              AC_MSG_RESULT(no); LIBS=$libs_save_old
+              )
+           CFLAGS=$cflags_save
+         else
+           AC_MSG_RESULT(no)
+         fi
+   
+         dnl check that compiling a simple program still works with the flags
+         dnl added for Python.
+         AC_MSG_CHECKING([if compile and link flags for Python 3 are sane])
+         cflags_save=$CFLAGS
+         libs_save=$LIBS
+         CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+         LIBS="$LIBS $PYTHON3_LIBS"
+         AC_TRY_LINK(,[ ],
+                AC_MSG_RESULT(yes); python3_ok=yes,
+                AC_MSG_RESULT(no: PYTHON3 DISABLED); python3_ok=no)
+         CFLAGS=$cflags_save
+         LIBS=$libs_save
+         if test "$python3_ok" = yes; then
+           AC_DEFINE(FEAT_PYTHON3)
+         else
+           LIBS=$libs_save_old
+           PYTHON3_SRC=
+           PYTHON3_OBJ=
+           PYTHON3_LIBS=
+           PYTHON3_CFLAGS=
+         fi
+       fi
+     else
+       AC_MSG_RESULT(too old)
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a "$python3_ok" != "yes"; then
+     AC_MSG_ERROR([could not configure python3])
+   fi
+ fi
+ 
+ AC_SUBST(PYTHON3_CONFDIR)
+ AC_SUBST(PYTHON3_LIBS)
+ AC_SUBST(PYTHON3_CFLAGS)
+ AC_SUBST(PYTHON3_SRC)
+ AC_SUBST(PYTHON3_OBJ)
+ 
+ dnl if python2.x and python3.x are enabled one can only link in code
+ dnl with dlopen(), dlsym(), dlclose() 
+ if test "$python_ok" = yes && test "$python3_ok" = yes; then
+   AC_DEFINE(DYNAMIC_PYTHON)
+   AC_DEFINE(DYNAMIC_PYTHON3)
+   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $PYTHON_CFLAGS"
+   libs_save=$LIBS
+   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+   LIBS="-ldl $LIBS"
+   AC_RUN_IFELSE([AC_LANG_SOURCE([
+     #include <dlfcn.h>
+     /* If this program fails, then RTLD_GLOBAL is needed.
+      * RTLD_GLOBAL will be used and then it is not possible to
+      * have both python versions enabled in the same vim instance.
+      * Only the first python version used will be switched on.
+      */
+ 
+     int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
+     {
+       int needed = 0;
+       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+       if (pylib != 0)
+       {
+           void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
+           void (*init)(void) = dlsym(pylib, "Py_Initialize");
+           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+           (*pfx)(prefix);
+           (*init)();
+           needed = (*simple)("import termios") == -1;
+           (*final)();
+           dlclose(pylib);
+       }
+       return !needed;
+     }
+ 
+     int main(int argc, char** argv)
+     {
+       int not_needed = 0;
+       if (no_rtl_global_needed_for("${vi_cv_dll_name_python}", "${vi_cv_path_python_pfx}"))
+             not_needed = 1;
+       return !not_needed;
+     }])],
+     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ 
+   AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+   libs_save=$LIBS
+   dnl -ldl must go first to make this work on Archlinux (Roland Puntaier)
+   LIBS="-ldl $LIBS"
+   AC_RUN_IFELSE([AC_LANG_SOURCE([
+     #include <dlfcn.h>
+     #include <wchar.h>
+     /* If this program fails, then RTLD_GLOBAL is needed.
+      * RTLD_GLOBAL will be used and then it is not possible to
+      * have both python versions enabled in the same vim instance.
+      * Only the first python version used will be switched on.
+      */
+ 
+     int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+     {
+       int needed = 0;
+       void* pylib = dlopen(python_instsoname, RTLD_LAZY|RTLD_LOCAL);
+       if (pylib != 0)
+       {
+           void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+           void (*init)(void) = dlsym(pylib, "Py_Initialize");
+           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+           (*pfx)(prefix);
+           (*init)();
+           needed = (*simple)("import termios") == -1;
+           (*final)();
+           dlclose(pylib);
+       }
+       return !needed;
+     }
+ 
+     int main(int argc, char** argv)
+     {
+       int not_needed = 0;
+       if (no_rtl_global_needed_for("${vi_cv_dll_name_python3}", L"${vi_cv_path_python3_pfx}"))
+             not_needed = 1;
+       return !not_needed;
+     }])],
+     [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ 
+   PYTHON_SRC="if_python.c"
+   PYTHON_OBJ="objects/if_python.o"
+   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+   PYTHON_LIBS=
+   PYTHON3_SRC="if_python3.c"
+   PYTHON3_OBJ="objects/if_python3.o"
+   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+   PYTHON3_LIBS=
+ elif test "$python_ok" = yes && test "$enable_pythoninterp" = "dynamic"; then
+   AC_DEFINE(DYNAMIC_PYTHON)
+   PYTHON_SRC="if_python.c"
+   PYTHON_OBJ="objects/if_python.o"
+   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${vi_cv_dll_name_python}\\\""
+   PYTHON_LIBS=
+ elif test "$python_ok" = yes; then
+   dnl Check that adding -fPIE works.  It may be needed when using a static
+   dnl Python library.
+   AC_MSG_CHECKING([if -fPIE can be added for Python])
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   CFLAGS="$CFLAGS $PYTHON_CFLAGS -fPIE"
+   LIBS="$LIBS $PYTHON_LIBS"
+   AC_TRY_LINK(,[ ],
+ 	 AC_MSG_RESULT(yes); fpie_ok=yes,
+ 	 AC_MSG_RESULT(no); fpie_ok=no)
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+   if test $fpie_ok = yes; then
+     PYTHON_CFLAGS="$PYTHON_CFLAGS -fPIE"
+   fi
+ elif test "$python3_ok" = yes && test "$enable_python3interp" = "dynamic"; then
+   AC_DEFINE(DYNAMIC_PYTHON3)
+   PYTHON3_SRC="if_python3.c"
+   PYTHON3_OBJ="objects/if_python3.o"
+   PYTHON3_CFLAGS="$PYTHON3_CFLAGS -DDYNAMIC_PYTHON3_DLL=\\\"${vi_cv_dll_name_python3}\\\""
+   PYTHON3_LIBS=
+ elif test "$python3_ok" = yes; then
+   dnl Check that adding -fPIE works.  It may be needed when using a static
+   dnl Python library.
+   AC_MSG_CHECKING([if -fPIE can be added for Python3])
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   CFLAGS="$CFLAGS $PYTHON3_CFLAGS -fPIE"
+   LIBS="$LIBS $PYTHON3_LIBS"
+   AC_TRY_LINK(,[ ],
+ 	 AC_MSG_RESULT(yes); fpie_ok=yes,
+ 	 AC_MSG_RESULT(no); fpie_ok=no)
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+   if test $fpie_ok = yes; then
+     PYTHON3_CFLAGS="$PYTHON3_CFLAGS -fPIE"
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--enable-tclinterp argument)
+ AC_ARG_ENABLE(tclinterp,
+ 	[  --enable-tclinterp[=OPTS]      Include Tcl interpreter. [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_tclinterp="no"])
+ AC_MSG_RESULT($enable_tclinterp)
+ 
+ if test "$enable_tclinterp" = "yes" -o "$enable_tclinterp" = "dynamic"; then
+ 
+   dnl on FreeBSD tclsh is a silly script, look for tclsh8.[5420]
+   AC_MSG_CHECKING(--with-tclsh argument)
+   AC_ARG_WITH(tclsh, [  --with-tclsh=PATH       which tclsh to use (default: tclsh8.0)],
+ 	tclsh_name="$withval"; AC_MSG_RESULT($tclsh_name),
+ 	tclsh_name="tclsh8.5"; AC_MSG_RESULT(no))
+   AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   AC_SUBST(vi_cv_path_tcl)
+ 
+   dnl when no specific version specified, also try 8.4, 8.2 and 8.0
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.5"; then
+     tclsh_name="tclsh8.4"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.4"; then
+     tclsh_name="tclsh8.2"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" = "X" -a $tclsh_name = "tclsh8.2"; then
+     tclsh_name="tclsh8.0"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   dnl still didn't find it, try without version number
+   if test "X$vi_cv_path_tcl" = "X"; then
+     tclsh_name="tclsh"
+     AC_PATH_PROG(vi_cv_path_tcl, $tclsh_name)
+   fi
+   if test "X$vi_cv_path_tcl" != "X"; then
+     AC_MSG_CHECKING(Tcl version)
+     if echo 'exit [[expr [info tclversion] < 8.0]]' | "$vi_cv_path_tcl" - ; then
+       tclver=`echo 'puts [[info tclversion]]' | $vi_cv_path_tcl -`
+       AC_MSG_RESULT($tclver - OK);
+       tclloc=`echo 'set l [[info library]];set i [[string last lib $l]];incr i -2;puts [[string range $l 0 $i]]' | $vi_cv_path_tcl -`
+       tcldll=`echo 'puts libtcl[[info tclversion]][[info sharedlibextension]]' | $vi_cv_path_tcl -`
+ 
+       AC_MSG_CHECKING(for location of Tcl include)
+       if test "x$MACOSX" != "xyes"; then
+ 	tclinc="$tclloc/include $tclloc/include/tcl $tclloc/include/tcl$tclver /usr/local/include /usr/local/include/tcl$tclver /usr/include /usr/include/tcl$tclver"
+       else
+ 	dnl For Mac OS X 10.3, use the OS-provided framework location
+ 	tclinc="/System/Library/Frameworks/Tcl.framework/Headers"
+       fi
+       TCL_INC=
+       for try in $tclinc; do
+ 	if test -f "$try/tcl.h"; then
+ 	  AC_MSG_RESULT($try/tcl.h)
+ 	  TCL_INC=$try
+ 	  break
+ 	fi
+       done
+       if test -z "$TCL_INC"; then
+ 	AC_MSG_RESULT(<not found>)
+ 	SKIP_TCL=YES
+       fi
+       if test -z "$SKIP_TCL"; then
+ 	AC_MSG_CHECKING(for location of tclConfig.sh script)
+ 	if test "x$MACOSX" != "xyes"; then
+ 	  tclcnf=`echo $tclinc | sed s/include/lib/g`
+ 	  tclcnf="$tclcnf `echo $tclinc | sed s/include/lib64/g`"
+ 	else
+ 	  dnl For Mac OS X 10.3, use the OS-provided framework location
+ 	  tclcnf="/System/Library/Frameworks/Tcl.framework"
+ 	fi
+ 	for try in $tclcnf; do
+ 	  if test -f "$try/tclConfig.sh"; then
+ 	    AC_MSG_RESULT($try/tclConfig.sh)
+ 	    . "$try/tclConfig.sh"
+ 	    dnl use eval, because tcl 8.2 includes ${TCL_DBGX}
+ 	    if test "$enable_tclinterp" = "dynamic"; then
+ 	      TCL_LIBS=`eval echo "$TCL_STUB_LIB_SPEC $TCL_LIBS"`
+ 	    else
+ 	      TCL_LIBS=`eval echo "$TCL_LIB_SPEC $TCL_LIBS"`
+ 	    fi
+ 	    dnl Use $TCL_DEFS for -D_THREAD_SAFE et al.  But only use the
+ 	    dnl "-D_ABC" items.  Watch out for -DFOO=long\ long.
+ 	    TCL_DEFS=`echo $TCL_DEFS | sed -e 's/\\\\ /\\\\X/g' | tr ' ' '\012' | sed -e '/^[[^-]]/d' -e '/^-[[^D]]/d' -e '/-D[[^_]]/d' -e 's/-D_/ -D_/' | tr '\012' ' ' | sed -e 's/\\\\X/\\\\ /g'`
+ 	    break
+ 	  fi
+ 	done
+ 	if test -z "$TCL_LIBS"; then
+ 	  AC_MSG_RESULT(<not found>)
+ 	  AC_MSG_CHECKING(for Tcl library by myself)
+ 	  tcllib=`echo $tclinc | sed s/include/lib/g`
+ 	  tcllib="$tcllib `echo $tclinc | sed s/include/lib64/g`"
+ 	  for ext in .so .a ; do
+ 	    for ver in "" $tclver ; do
+ 	      for try in $tcllib ; do
+ 		trylib=tcl$ver$ext
+ 		if test -f "$try/lib$trylib" ; then
+ 		  AC_MSG_RESULT($try/lib$trylib)
+ 		  TCL_LIBS="-L\"$try\" -ltcl$ver -ldl -lm"
+ 		  if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+ 		    TCL_LIBS="$TCL_LIBS -R $try"
+ 		  fi
+ 		  break 3
+ 		fi
+ 	      done
+ 	    done
+ 	  done
+ 	  if test -z "$TCL_LIBS"; then
+ 	    AC_MSG_RESULT(<not found>)
+ 	    SKIP_TCL=YES
+ 	  fi
+ 	fi
+ 	if test -z "$SKIP_TCL"; then
+ 	  AC_DEFINE(FEAT_TCL)
+ 	  TCL_SRC=if_tcl.c
+ 	  TCL_OBJ=objects/if_tcl.o
+ 	  TCL_PRO=if_tcl.pro
+ 	  TCL_CFLAGS="-I$TCL_INC $TCL_DEFS"
+ 	fi
+       fi
+     else
+       AC_MSG_RESULT(too old; need Tcl version 8.0 or later)
+     fi
+   fi
+   if test "$enable_tclinterp" = "dynamic"; then
+     if test "X$TCL_SRC" != "X" -a "X$tcldll" != "X"; then
+       AC_DEFINE(DYNAMIC_TCL)
+       TCL_CFLAGS="-DDYNAMIC_TCL_DLL=\\\"$tcldll\\\" -DDYNAMIC_TCL_VER=\\\"$tclver\\\" $TCL_CFLAGS"
+     fi
+   fi
+   if test "$fail_if_missing" = "yes" -a -z "$TCL_SRC"; then
+     AC_MSG_ERROR([could not configure Tcl])
+   fi
+ fi
+ AC_SUBST(TCL_SRC)
+ AC_SUBST(TCL_OBJ)
+ AC_SUBST(TCL_PRO)
+ AC_SUBST(TCL_CFLAGS)
+ AC_SUBST(TCL_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-rubyinterp argument)
+ AC_ARG_ENABLE(rubyinterp,
+ 	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
+ 	[enable_rubyinterp="no"])
+ AC_MSG_RESULT($enable_rubyinterp)
+ if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_ERROR([cannot use Ruby with tiny or small features])
+   fi
+ 
+   AC_MSG_CHECKING(--with-ruby-command argument)
+   AC_SUBST(vi_cv_path_ruby)
+   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
+ 	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
+ 	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
+   AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
+   if test "X$vi_cv_path_ruby" != "X"; then
+     AC_MSG_CHECKING(Ruby version)
+     if $vi_cv_path_ruby -e '(VERSION rescue RUBY_VERSION) >= "1.6.0" or exit 1' >/dev/null 2>/dev/null; then
+       AC_MSG_RESULT(OK)
+       AC_MSG_CHECKING(Ruby rbconfig)
+       ruby_rbconfig="RbConfig"
+       if ! $vi_cv_path_ruby -r rbconfig -e 'RbConfig' >/dev/null 2>/dev/null; then
+ 	ruby_rbconfig="Config"
+       fi
+       AC_MSG_RESULT($ruby_rbconfig)
+       AC_MSG_CHECKING(Ruby header files)
+       rubyhdrdir=`$vi_cv_path_ruby -r mkmf -e "print $ruby_rbconfig::CONFIG[['rubyhdrdir']] || $ruby_rbconfig::CONFIG[['archdir']] || \\$hdrdir" 2>/dev/null`
+       if test "X$rubyhdrdir" != "X"; then
+ 	AC_MSG_RESULT($rubyhdrdir)
+ 	RUBY_CFLAGS="-I$rubyhdrdir"
+         rubyarchdir=`$vi_cv_path_ruby -r rbconfig -e "print ($ruby_rbconfig::CONFIG.has_key? 'rubyarchhdrdir') ? $ruby_rbconfig::CONFIG[['rubyarchhdrdir']] : '$rubyhdrdir/'+$ruby_rbconfig::CONFIG[['arch']]"`
+         if test -d "$rubyarchdir"; then
+           RUBY_CFLAGS="$RUBY_CFLAGS -I$rubyarchdir"
+         fi
+         rubyversion=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['ruby_version']].gsub(/\./, '')[[0,2]]"`
+ 	if test "X$rubyversion" = "X"; then
+ 	  rubyversion=`$vi_cv_path_ruby -e "print ((VERSION rescue RUBY_VERSION)).gsub(/\./, '')[[0,2]]"`
+ 	fi
+         RUBY_CFLAGS="$RUBY_CFLAGS -DRUBY_VERSION=$rubyversion"
+ 	rubylibs=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LIBS']]"`
+ 	if test "X$rubylibs" != "X"; then
+ 	  RUBY_LIBS="$rubylibs"
+ 	fi
+ 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBYARG']])"`
+ 	librubya=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['LIBRUBY_A']])"`
+ 	rubylibdir=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig.expand($ruby_rbconfig::CONFIG[['libdir']])"`
+ 	if test -f "$rubylibdir/$librubya"; then
+ 	  librubyarg="$librubyarg"
+ 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+ 	elif test "$librubyarg" = "libruby.a"; then
+ 	  dnl required on Mac OS 10.3 where libruby.a doesn't exist
+ 	  librubyarg="-lruby"
+ 	  RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+ 	fi
+ 
+ 	if test "X$librubyarg" != "X"; then
+ 	  RUBY_LIBS="$librubyarg $RUBY_LIBS"
+ 	fi
+ 	rubyldflags=`$vi_cv_path_ruby -r rbconfig -e "print $ruby_rbconfig::CONFIG[['LDFLAGS']]"`
+ 	if test "X$rubyldflags" != "X"; then
+ 	  dnl Ruby on Mac OS X 10.5 adds "-arch" flags but these should only
+ 	  dnl be included if requested by passing --with-mac-arch to
+ 	  dnl configure, so strip these flags first (if present)
+ 	  rubyldflags=`echo "$rubyldflags" | sed -e 's/-arch\ ppc//' -e 's/-arch\ i386//' -e 's/-arch\ x86_64//'`
+ 	  if test "X$rubyldflags" != "X"; then
+ 	    if test "X`echo \"$LDFLAGS\" | $FGREP -e \"$rubyldflags\"`" = "X"; then
+ 	      LDFLAGS="$rubyldflags $LDFLAGS"
+ 	    fi
+ 	  fi
+ 	fi
+ 	RUBY_SRC="if_ruby.c"
+ 	RUBY_OBJ="objects/if_ruby.o"
+ 	RUBY_PRO="if_ruby.pro"
+ 	AC_DEFINE(FEAT_RUBY)
+ 	if test "$enable_rubyinterp" = "dynamic"; then
+ 	  libruby=`$vi_cv_path_ruby -r rbconfig -e "puts $ruby_rbconfig::CONFIG[['LIBRUBY_SO']]"`
+ 	  AC_DEFINE(DYNAMIC_RUBY)
+ 	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+ 	  RUBY_LIBS=
+ 	fi
+       else
+ 	AC_MSG_RESULT(not found; disabling Ruby)
+       fi
+     else
+       AC_MSG_RESULT(too old; need Ruby version 1.6.0 or later)
+     fi
+   fi
+ 
+   if test "$fail_if_missing" = "yes" -a -z "$RUBY_OBJ"; then
+     AC_MSG_ERROR([could not configure Ruby])
+   fi
+ fi
+ AC_SUBST(RUBY_SRC)
+ AC_SUBST(RUBY_OBJ)
+ AC_SUBST(RUBY_PRO)
+ AC_SUBST(RUBY_CFLAGS)
+ AC_SUBST(RUBY_LIBS)
+ 
+ AC_MSG_CHECKING(--enable-cscope argument)
+ AC_ARG_ENABLE(cscope,
+ 	[  --enable-cscope         Include cscope interface.], ,
+ 	[enable_cscope="no"])
+ AC_MSG_RESULT($enable_cscope)
+ if test "$enable_cscope" = "yes"; then
+   AC_DEFINE(FEAT_CSCOPE)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-workshop argument)
+ AC_ARG_ENABLE(workshop,
+ 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
+ 	[enable_workshop="no"])
+ AC_MSG_RESULT($enable_workshop)
+ if test "$enable_workshop" = "yes"; then
+   AC_DEFINE(FEAT_SUN_WORKSHOP)
+   WORKSHOP_SRC="workshop.c integration.c"
+   AC_SUBST(WORKSHOP_SRC)
+   WORKSHOP_OBJ="objects/workshop.o objects/integration.o"
+   AC_SUBST(WORKSHOP_OBJ)
+   if test "${enable_gui-xxx}" = xxx; then
+     enable_gui=motif
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(--disable-netbeans argument)
+ AC_ARG_ENABLE(netbeans,
+ 	[  --disable-netbeans      Disable NetBeans integration support.],
+ 	, [enable_netbeans="yes"])
+ if test "$enable_netbeans" = "yes"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_RESULT([cannot use NetBeans with tiny or small features])
+     enable_netbeans="no"
+   else
+     AC_MSG_RESULT(no)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ AC_MSG_CHECKING(--disable-channel argument)
+ AC_ARG_ENABLE(channel,
+ 	[  --disable-channel      Disable process communication support.],
+ 	, [enable_channel="yes"])
+ if test "$enable_channel" = "yes"; then
+   if test "x$features" = "xtiny" -o "x$features" = "xsmall"; then
+     AC_MSG_RESULT([cannot use channels with tiny or small features])
+     enable_channel="no"
+   else
+     AC_MSG_RESULT(no)
+   fi
+ else
+   if test "$enable_netbeans" = "yes"; then
+     AC_MSG_RESULT([yes, netbeans also disabled])
+     enable_netbeans="no"
+   else
+     AC_MSG_RESULT(yes)
+   fi
+ fi
+ 
+ if test "$enable_channel" = "yes"; then
+   dnl On Solaris we need the socket and nsl library.
+   AC_CHECK_LIB(socket, socket)
+   AC_CHECK_LIB(nsl, gethostbyname)
+   AC_MSG_CHECKING(whether compiling with process communication is possible)
+   AC_TRY_LINK([
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <stdarg.h>
+ #include <fcntl.h>
+ #include <netdb.h>
+ #include <netinet/in.h>
+ #include <errno.h>
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ 	/* Check bitfields */
+ 	struct nbbuf {
+ 	unsigned int  initDone:1;
+ 	ushort signmaplen;
+ 	};
+ 	    ], [
+ 		/* Check creating a socket. */
+ 		struct sockaddr_in server;
+ 		(void)socket(AF_INET, SOCK_STREAM, 0);
+ 		(void)htons(100);
+ 		(void)gethostbyname("microsoft.com");
+ 		if (errno == ECONNREFUSED)
+ 		  (void)connect(1, (struct sockaddr *)&server, sizeof(server));
+ 	    ],
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); enable_netbeans="no"; enable_channel="no")
+ fi
+ if test "$enable_netbeans" = "yes"; then
+   AC_DEFINE(FEAT_NETBEANS_INTG)
+   NETBEANS_SRC="netbeans.c"
+   AC_SUBST(NETBEANS_SRC)
+   NETBEANS_OBJ="objects/netbeans.o"
+   AC_SUBST(NETBEANS_OBJ)
+ fi
+ if test "$enable_channel" = "yes"; then
+   AC_DEFINE(FEAT_JOB_CHANNEL)
+   CHANNEL_SRC="channel.c"
+   AC_SUBST(CHANNEL_SRC)
+   CHANNEL_OBJ="objects/channel.o"
+   AC_SUBST(CHANNEL_OBJ)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-multibyte argument)
+ AC_ARG_ENABLE(multibyte,
+ 	[  --enable-multibyte      Include multibyte editing support.], ,
+ 	[enable_multibyte="no"])
+ AC_MSG_RESULT($enable_multibyte)
+ if test "$enable_multibyte" = "yes"; then
+   AC_DEFINE(FEAT_MBYTE)
+ fi
+ 
+ AC_MSG_CHECKING(--enable-hangulinput argument)
+ AC_ARG_ENABLE(hangulinput,
+ 	[  --enable-hangulinput    Include Hangul input support.], ,
+ 	[enable_hangulinput="no"])
+ AC_MSG_RESULT($enable_hangulinput)
+ 
+ AC_MSG_CHECKING(--enable-xim argument)
+ AC_ARG_ENABLE(xim,
+ 	[  --enable-xim            Include XIM input support.],
+ 	AC_MSG_RESULT($enable_xim),
+ 	[enable_xim="auto"; AC_MSG_RESULT(defaulting to auto)])
+ 
+ AC_MSG_CHECKING(--enable-fontset argument)
+ AC_ARG_ENABLE(fontset,
+ 	[  --enable-fontset        Include X fontset output support.], ,
+ 	[enable_fontset="no"])
+ AC_MSG_RESULT($enable_fontset)
+ dnl defining FEAT_XFONTSET is delayed, so that it can be disabled for no GUI
+ 
+ test -z "$with_x" && with_x=yes
+ test "${enable_gui-yes}" != no -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && with_x=yes
+ if test "$with_x" = no; then
+   AC_MSG_RESULT(defaulting to: don't HAVE_X11)
+ else
+   dnl Do this check early, so that its failure can override user requests.
+ 
+   AC_PATH_PROG(xmkmfpath, xmkmf)
+ 
+   AC_PATH_XTRA
+ 
+   dnl On z/OS Unix the X libraries are DLLs. To use them the code must
+   dnl be compiled with a special option.
+   dnl Also add SM, ICE and Xmu to X_EXTRA_LIBS.
+   if test "$zOSUnix" = "yes"; then
+     CFLAGS="$CFLAGS -W c,dll"
+     LDFLAGS="$LDFLAGS -W l,dll"
+     X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE -lXmu"
+   fi
+ 
+   dnl On my HPUX system the X include dir is found, but the lib dir not.
+   dnl This is a desparate try to fix this.
+ 
+   if test -d "$x_includes" && test ! -d "$x_libraries"; then
+     x_libraries=`echo "$x_includes" | sed s/include/lib/`
+     AC_MSG_RESULT(Corrected X libraries to $x_libraries)
+     X_LIBS="$X_LIBS -L$x_libraries"
+     if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+       X_LIBS="$X_LIBS -R $x_libraries"
+     fi
+   fi
+ 
+   if test -d "$x_libraries" && test ! -d "$x_includes"; then
+     x_includes=`echo "$x_libraries" | sed s/lib/include/`
+     AC_MSG_RESULT(Corrected X includes to $x_includes)
+     X_CFLAGS="$X_CFLAGS -I$x_includes"
+   fi
+ 
+   dnl Remove "-I/usr/include " from X_CFLAGS, should not be needed.
+   X_CFLAGS="`echo $X_CFLAGS\  | sed 's%-I/usr/include %%'`"
+   dnl Remove "-L/usr/lib " from X_LIBS, should not be needed.
+   X_LIBS="`echo $X_LIBS\  | sed 's%-L/usr/lib %%'`"
+   dnl Same for "-R/usr/lib ".
+   X_LIBS="`echo $X_LIBS\  | sed -e 's%-R/usr/lib %%' -e 's%-R /usr/lib %%'`"
+ 
+ 
+   dnl Check if the X11 header files are correctly installed. On some systems
+   dnl Xlib.h includes files that don't exist.  On some systems X11/Intrinsic.h
+   dnl is missing.
+   AC_MSG_CHECKING(if X11 header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([#include <X11/Xlib.h>
+ #include <X11/Intrinsic.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); no_x=yes)
+   CFLAGS=$cflags_save
+ 
+   if test "${no_x-no}" = yes; then
+     with_x=no
+   else
+     AC_DEFINE(HAVE_X11)
+     X_LIB="-lXt -lX11";
+     AC_SUBST(X_LIB)
+ 
+     ac_save_LDFLAGS="$LDFLAGS"
+     LDFLAGS="-L$x_libraries $LDFLAGS"
+ 
+     dnl Check for -lXdmcp (needed on SunOS 4.1.4)
+     dnl For HP-UX 10.20 it must be before -lSM -lICE
+     AC_CHECK_LIB(Xdmcp, _XdmcpAuthDoIt, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lXdmcp"],,
+ 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS -lXdmcp])
+ 
+     dnl Some systems need -lnsl -lsocket when testing for ICE.
+     dnl The check above doesn't do this, try here (again).  Also needed to get
+     dnl them after Xdmcp.  link.sh will remove them when not needed.
+     dnl Check for other function than above to avoid the cached value
+     AC_CHECK_LIB(ICE, IceOpenConnection,
+ 		  [X_EXTRA_LIBS="$X_EXTRA_LIBS -lSM -lICE"],, [$X_EXTRA_LIBS])
+ 
+     dnl Check for -lXpm (needed for some versions of Motif)
+     LDFLAGS="$X_LIBS $ac_save_LDFLAGS"
+     AC_CHECK_LIB(Xpm, XpmCreatePixmapFromData, [X_PRE_LIBS="$X_PRE_LIBS -lXpm"],,
+ 		[-lXt $X_PRE_LIBS -lXpm -lX11 $X_EXTRA_LIBS])
+ 
+     dnl Check that the X11 header files don't use implicit declarations
+     AC_MSG_CHECKING(if X11 header files implicitly declare return values)
+     cflags_save=$CFLAGS
+     dnl -Werror is GCC only, others like Solaris Studio might not like it
+     if test "$GCC" = yes; then
+       CFLAGS="$CFLAGS $X_CFLAGS -Werror"
+     else
+       CFLAGS="$CFLAGS $X_CFLAGS"
+     fi
+     AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+ 	AC_MSG_RESULT(no),
+ 	CFLAGS="$CFLAGS -Wno-implicit-int"
+ 	AC_TRY_COMPILE([#include <X11/Xlib.h>], ,
+ 	    AC_MSG_RESULT(yes); cflags_save="$cflags_save -Wno-implicit-int",
+ 	    AC_MSG_RESULT(test failed)
+ 	)
+     )
+     CFLAGS=$cflags_save
+ 
+     LDFLAGS="$ac_save_LDFLAGS"
+ 
+     AC_MSG_CHECKING(size of wchar_t is 2 bytes)
+     AC_CACHE_VAL(ac_cv_small_wchar_t,
+ 	[AC_TRY_RUN([
+ #include <X11/Xlib.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 		main()
+ 		{
+ 		  if (sizeof(wchar_t) <= 2)
+ 		    exit(1);
+ 		  exit(0);
+ 		}],
+ 		ac_cv_small_wchar_t="no",
+ 		ac_cv_small_wchar_t="yes",
+ 		AC_MSG_ERROR(failed to compile test program))])
+     AC_MSG_RESULT($ac_cv_small_wchar_t)
+     if test "x$ac_cv_small_wchar_t" = "xyes" ; then
+       AC_DEFINE(SMALL_WCHAR_T)
+     fi
+ 
+   fi
+ fi
+ 
+ test "x$with_x" = xno -a "x$MACOSX" != "xyes" -a "x$QNX" != "xyes" && enable_gui=no
+ 
+ AC_MSG_CHECKING(--enable-gui argument)
+ AC_ARG_ENABLE(gui,
+  [  --enable-gui[=OPTS]     X11 GUI [default=auto] [OPTS=auto/no/gtk2/gnome2/gtk3/motif/athena/neXtaw/photon/carbon]], , enable_gui="auto")
+ 
+ dnl Canonicalize the --enable-gui= argument so that it can be easily compared.
+ dnl Do not use character classes for portability with old tools.
+ enable_gui_canon=`echo "_$enable_gui" | \
+ 	sed 's/[[ _+-]]//g;y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/'`
+ 
+ dnl Skip everything by default.
+ SKIP_GTK2=YES
+ SKIP_GTK3=YES
+ SKIP_GNOME=YES
+ SKIP_MOTIF=YES
+ SKIP_ATHENA=YES
+ SKIP_NEXTAW=YES
+ SKIP_PHOTON=YES
+ SKIP_CARBON=YES
+ GUITYPE=NONE
+ 
+ if test "x$QNX" = "xyes" -a "x$with_x" = "xno" ; then
+   SKIP_PHOTON=
+   case "$enable_gui_canon" in
+     no)		AC_MSG_RESULT(no GUI support)
+ 		SKIP_PHOTON=YES ;;
+     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+     auto)	AC_MSG_RESULT(auto - automatic GUI support) ;;
+     photon)	AC_MSG_RESULT(Photon GUI support) ;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+ 		SKIP_PHOTON=YES ;;
+   esac
+ 
+ elif test "x$MACOSX" = "xyes" -a "x$with_x" = "xno" ; then
+   SKIP_CARBON=
+   case "$enable_gui_canon" in
+     no)		AC_MSG_RESULT(no GUI support)
+ 		SKIP_CARBON=YES ;;
+     yes|"")	AC_MSG_RESULT(yes - automatic GUI support) ;;
+     auto)	AC_MSG_RESULT(auto - Carbon GUI is outdated - disable GUI support)
+ 		SKIP_CARBON=YES ;;
+     carbon)	AC_MSG_RESULT(Carbon GUI support) ;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported])
+ 		SKIP_CARBON=YES ;;
+   esac
+ 
+ else
+ 
+   case "$enable_gui_canon" in
+     no|none)	AC_MSG_RESULT(no GUI support) ;;
+     yes|""|auto)	AC_MSG_RESULT(yes/auto - automatic GUI support)
+ 		SKIP_GTK2=
+ 		SKIP_GNOME=
+ 		SKIP_MOTIF=
+ 		SKIP_ATHENA=
+ 		SKIP_NEXTAW=
+ 		SKIP_CARBON=;;
+     gtk2)	AC_MSG_RESULT(GTK+ 2.x GUI support)
+ 		SKIP_GTK2=;;
+     gnome2)	AC_MSG_RESULT(GNOME 2.x GUI support)
+ 		SKIP_GNOME=
+ 		SKIP_GTK2=;;
+     gtk3)	AC_MSG_RESULT(GTK+ 3.x GUI support)
+ 		SKIP_GTK3=;;
+     motif)	AC_MSG_RESULT(Motif GUI support)
+ 		SKIP_MOTIF=;;
+     athena)	AC_MSG_RESULT(Athena GUI support)
+ 		SKIP_ATHENA=;;
+     nextaw)	AC_MSG_RESULT(neXtaw GUI support)
+ 		SKIP_NEXTAW=;;
+     *)		AC_MSG_RESULT([Sorry, $enable_gui GUI is not supported]) ;;
+   esac
+ 
+ fi
+ 
+ if test "x$SKIP_GTK2" != "xYES" -a "$enable_gui_canon" != "gtk2" \
+ 				-a "$enable_gui_canon" != "gnome2"; then
+   AC_MSG_CHECKING(whether or not to look for GTK+ 2)
+   AC_ARG_ENABLE(gtk2-check,
+ 	[  --enable-gtk2-check     If auto-select GUI, check for GTK+ 2 [default=yes]],
+ 	, enable_gtk2_check="yes")
+   AC_MSG_RESULT($enable_gtk2_check)
+   if test "x$enable_gtk2_check" = "xno"; then
+     SKIP_GTK2=YES
+     SKIP_GNOME=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_GNOME" != "xYES" -a "$enable_gui_canon" != "gnome2"; then
+   AC_MSG_CHECKING(whether or not to look for GNOME)
+   AC_ARG_ENABLE(gnome-check,
+ 	[  --enable-gnome-check    If GTK GUI, check for GNOME [default=no]],
+ 	, enable_gnome_check="no")
+   AC_MSG_RESULT($enable_gnome_check)
+   if test "x$enable_gnome_check" = "xno"; then
+     SKIP_GNOME=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_GTK3" != "xYES" -a "$enable_gui_canon" != "gtk3"; then
+   AC_MSG_CHECKING(whether or not to look for GTK+ 3)
+   AC_ARG_ENABLE(gtk3-check,
+ 	[  --enable-gtk3-check     If auto-select GUI, check for GTK+ 3 [default=yes]],
+ 	, enable_gtk3_check="yes")
+   AC_MSG_RESULT($enable_gtk3_check)
+   if test "x$enable_gtk3_check" = "xno"; then
+     SKIP_GTK3=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_MOTIF" != "xYES" -a "$enable_gui_canon" != "motif"; then
+   AC_MSG_CHECKING(whether or not to look for Motif)
+   AC_ARG_ENABLE(motif-check,
+ 	[  --enable-motif-check    If auto-select GUI, check for Motif [default=yes]],
+ 	, enable_motif_check="yes")
+   AC_MSG_RESULT($enable_motif_check)
+   if test "x$enable_motif_check" = "xno"; then
+     SKIP_MOTIF=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_ATHENA" != "xYES" -a "$enable_gui_canon" != "athena"; then
+   AC_MSG_CHECKING(whether or not to look for Athena)
+   AC_ARG_ENABLE(athena-check,
+ 	[  --enable-athena-check   If auto-select GUI, check for Athena [default=yes]],
+ 	, enable_athena_check="yes")
+   AC_MSG_RESULT($enable_athena_check)
+   if test "x$enable_athena_check" = "xno"; then
+     SKIP_ATHENA=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_NEXTAW" != "xYES" -a "$enable_gui_canon" != "nextaw"; then
+   AC_MSG_CHECKING(whether or not to look for neXtaw)
+   AC_ARG_ENABLE(nextaw-check,
+ 	[  --enable-nextaw-check   If auto-select GUI, check for neXtaw [default=yes]],
+ 	, enable_nextaw_check="yes")
+   AC_MSG_RESULT($enable_nextaw_check);
+   if test "x$enable_nextaw_check" = "xno"; then
+     SKIP_NEXTAW=YES
+   fi
+ fi
+ 
+ if test "x$SKIP_CARBON" != "xYES" -a "$enable_gui_canon" != "carbon"; then
+   AC_MSG_CHECKING(whether or not to look for Carbon)
+   AC_ARG_ENABLE(carbon-check,
+ 	[  --enable-carbon-check   If auto-select GUI, check for Carbon [default=yes]],
+ 	, enable_carbon_check="yes")
+   AC_MSG_RESULT($enable_carbon_check);
+   if test "x$enable_carbon_check" = "xno"; then
+     SKIP_CARBON=YES
+   fi
+ fi
+ 
+ 
+ if test "x$MACOSX" = "xyes" -a -z "$SKIP_CARBON" -a "x$CARBON" = "xyes"; then
+   AC_MSG_CHECKING(for Carbon GUI)
+   dnl already did the check, just give the message
+   AC_MSG_RESULT(yes);
+   GUITYPE=CARBONGUI
+   if test "$VIMNAME" = "vim"; then
+     VIMNAME=Vim
+   fi
+ 
+   if test "x$MACARCH" = "xboth"; then
+     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk/Developer/Headers/FlatCarbon"
+   else
+     CPPFLAGS="$CPPFLAGS -I$DEVELOPER_DIR/Headers/FlatCarbon"
+   fi
+ 
+   dnl Default install directory is not /usr/local
+   if test x$prefix = xNONE; then
+     prefix=/Applications
+   fi
+ 
+   dnl Sorry for the hard coded default
+   datadir='${prefix}/Vim.app/Contents/Resources'
+ 
+   dnl skip everything else
+   SKIP_GTK2=YES;
+   SKIP_GNOME=YES;
+   SKIP_MOTIF=YES;
+   SKIP_ATHENA=YES;
+   SKIP_NEXTAW=YES;
+   SKIP_PHOTON=YES;
+   SKIP_CARBON=YES
+ fi
+ 
+ dnl define an autoconf function to check for a specified version of GTK, and
+ dnl try to compile/link a GTK program.
+ dnl
+ dnl AM_PATH_GTK([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
+ dnl Test for GTK, and define GTK_CFLAGS, GTK_LIBDIR and GTK_LIBS
+ dnl
+ AC_DEFUN(AM_PATH_GTK,
+ [
+   if test "X$GTK_CONFIG" != "Xno" -o "X$PKG_CONFIG" != "Xno"; then
+   {
+     no_gtk=""
+     if (test "X$SKIP_GTK2" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+ 	  && $PKG_CONFIG --exists gtk+-2.0; then
+     {
+       min_gtk_version=ifelse([$1], ,2.2.0,$1)
+       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+       dnl We should be using PKG_CHECK_MODULES() instead of this hack.
+       dnl But I guess the dependency on pkgconfig.m4 is not wanted or
+       dnl something like that.
+       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-2.0`
+       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-2.0`
+       GTK_LIBS=`$PKG_CONFIG --libs gtk+-2.0`
+       gtk_major_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-2.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+     }
+     elif (test "X$SKIP_GTK3" != "XYES" -a "X$PKG_CONFIG" != "Xno") \
+ 	  && $PKG_CONFIG --exists gtk+-3.0; then
+     {
+       min_gtk_version=ifelse([$1], ,3.0.0,$1)
+       AC_MSG_CHECKING(for GTK - version >= $min_gtk_version)
+ 
+       GTK_CFLAGS=`$PKG_CONFIG --cflags gtk+-3.0`
+       GTK_LIBDIR=`$PKG_CONFIG --libs-only-L gtk+-3.0`
+       GTK_LIBS=`$PKG_CONFIG --libs gtk+-3.0`
+       gtk_major_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\1/'`
+       gtk_minor_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\2/'`
+       gtk_micro_version=`$PKG_CONFIG --modversion gtk+-3.0 | \
+ 	     sed 's/\([[0-9]]*\)\.\([[0-9]]*\)\.\([[0-9]]*\)/\3/'`
+     }
+     else
+       no_gtk=yes
+     fi
+ 
+     if test "x$enable_gtktest" = "xyes" -a "x$no_gtk" = "x"; then
+     {
+       ac_save_CFLAGS="$CFLAGS"
+       ac_save_LIBS="$LIBS"
+       CFLAGS="$CFLAGS $GTK_CFLAGS"
+       LIBS="$LIBS $GTK_LIBS"
+ 
+       dnl
+       dnl Now check if the installed GTK is sufficiently new.
+       dnl
+       rm -f conf.gtktest
+       AC_TRY_RUN([
+ #include <gtk/gtk.h>
+ #include <stdio.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ 
+ int
+ main ()
+ {
+ int major, minor, micro;
+ char *tmp_version;
+ 
+ system ("touch conf.gtktest");
+ 
+ /* HP/UX 9 (%@#!) writes to sscanf strings */
+ tmp_version = g_strdup("$min_gtk_version");
+ if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
+    printf("%s, bad version string\n", "$min_gtk_version");
+    exit(1);
+  }
+ 
+ if ((gtk_major_version > major) ||
+     ((gtk_major_version == major) && (gtk_minor_version > minor)) ||
+     ((gtk_major_version == major) && (gtk_minor_version == minor) &&
+ 				     (gtk_micro_version >= micro)))
+ {
+     return 0;
+ }
+ return 1;
+ }
+ ],, no_gtk=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
+       CFLAGS="$ac_save_CFLAGS"
+       LIBS="$ac_save_LIBS"
+     }
+     fi
+     if test "x$no_gtk" = x ; then
+       if test "x$enable_gtktest" = "xyes"; then
+ 	AC_MSG_RESULT(yes; found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+       else
+ 	AC_MSG_RESULT(found version $gtk_major_version.$gtk_minor_version.$gtk_micro_version)
+       fi
+       ifelse([$2], , :, [$2])
+     else
+     {
+       AC_MSG_RESULT(no)
+       GTK_CFLAGS=""
+       GTK_LIBS=""
+       ifelse([$3], , :, [$3])
+     }
+     fi
+   }
+   else
+     GTK_CFLAGS=""
+     GTK_LIBS=""
+     ifelse([$3], , :, [$3])
+   fi
+   AC_SUBST(GTK_CFLAGS)
+   AC_SUBST(GTK_LIBS)
+   rm -f conf.gtktest
+ ])
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl gnome
+ dnl ---------------------------------------------------------------------------
+ AC_DEFUN([GNOME_INIT_HOOK],
+ [
+   AC_SUBST(GNOME_LIBS)
+   AC_SUBST(GNOME_LIBDIR)
+   AC_SUBST(GNOME_INCLUDEDIR)
+ 
+   AC_ARG_WITH(gnome-includes,
+     [  --with-gnome-includes=DIR Specify location of GNOME headers],
+     [CFLAGS="$CFLAGS -I$withval"]
+   )
+ 
+   AC_ARG_WITH(gnome-libs,
+     [  --with-gnome-libs=DIR   Specify location of GNOME libs],
+     [LDFLAGS="$LDFLAGS -L$withval" gnome_prefix=$withval]
+   )
+ 
+   AC_ARG_WITH(gnome,
+     [  --with-gnome            Specify prefix for GNOME files],
+     if test x$withval = xyes; then
+       want_gnome=yes
+       ifelse([$1], [], :, [$1])
+     else
+       if test "x$withval" = xno; then
+ 	want_gnome=no
+       else
+ 	want_gnome=yes
+ 	LDFLAGS="$LDFLAGS -L$withval/lib"
+ 	CFLAGS="$CFLAGS -I$withval/include"
+ 	gnome_prefix=$withval/lib
+       fi
+     fi,
+     want_gnome=yes)
+ 
+   if test "x$want_gnome" = xyes; then
+   {
+     AC_MSG_CHECKING(for libgnomeui-2.0)
+     if $PKG_CONFIG --exists libgnomeui-2.0; then
+       AC_MSG_RESULT(yes)
+       GNOME_LIBS=`$PKG_CONFIG --libs-only-l libgnomeui-2.0`
+       GNOME_LIBDIR=`$PKG_CONFIG --libs-only-L libgnomeui-2.0`
+       GNOME_INCLUDEDIR=`$PKG_CONFIG --cflags libgnomeui-2.0`
+ 
+       dnl On FreeBSD we need -pthread but pkg-config doesn't include it.
+       dnl This might not be the right way but it works for me...
+       AC_MSG_CHECKING(for FreeBSD)
+       if test "`(uname) 2>/dev/null`" = FreeBSD; then
+ 	AC_MSG_RESULT(yes, adding -pthread)
+ 	GNOME_INCLUDEDIR="$GNOME_INCLUDEDIR -D_THREAD_SAFE"
+ 	GNOME_LIBS="$GNOME_LIBS -pthread"
+       else
+ 	AC_MSG_RESULT(no)
+       fi
+       $1
+     else
+       AC_MSG_RESULT(not found)
+       if test "x$2" = xfail; then
+ 	AC_MSG_ERROR(Could not find libgnomeui-2.0 via pkg-config)
+       fi
+     fi
+   }
+   fi
+ ])
+ 
+ AC_DEFUN([GNOME_INIT],[
+ 	GNOME_INIT_HOOK([],fail)
+ ])
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl Check for GTK2.  If it fails, then continue on for Motif as before...
+ dnl ---------------------------------------------------------------------------
+ if test -z "$SKIP_GTK2"; then
+ 
+   AC_MSG_CHECKING(--disable-gtktest argument)
+   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+ 	, enable_gtktest=yes)
+   if test "x$enable_gtktest" = "xyes" ; then
+     AC_MSG_RESULT(gtk test enabled)
+   else
+     AC_MSG_RESULT(gtk test disabled)
+   fi
+ 
+   if test "X$PKG_CONFIG" = "X"; then
+     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+   fi
+ 
+   if test "x$PKG_CONFIG" != "xno"; then
+     dnl First try finding version 2.2.0 or later.  The 2.0.x series has
+     dnl problems (bold fonts, --remote doesn't work).
+     AM_PATH_GTK(2.2.0,
+ 		[GUI_LIB_LOC="$GTK_LIBDIR"
+ 		 GTK_LIBNAME="$GTK_LIBS"
+ 		GUI_INC_LOC="$GTK_CFLAGS"], )
+     if test "x$GTK_CFLAGS" != "x"; then
+       SKIP_GTK3=YES
+       SKIP_ATHENA=YES
+       SKIP_NEXTAW=YES
+       SKIP_MOTIF=YES
+       GUITYPE=GTK
+       AC_SUBST(GTK_LIBNAME)
+     fi
+   fi
+   if test "x$GUITYPE" = "xGTK"; then
+     if test "$gtk_minor_version" = 1 -a "0$gtk_micro_version" -ge 1 \
+ 	|| test "0$gtk_minor_version" -ge 2; then
+       AC_DEFINE(HAVE_GTK_MULTIHEAD)
+     fi
+     dnl
+     dnl if GTK exists, then check for GNOME.
+     dnl
+     if test -z "$SKIP_GNOME"; then
+     {
+       GNOME_INIT_HOOK([have_gnome=yes])
+       if test "x$have_gnome" = xyes ; then
+ 	AC_DEFINE(FEAT_GUI_GNOME)
+ 	GUI_INC_LOC="$GUI_INC_LOC $GNOME_INCLUDEDIR"
+ 	GTK_LIBNAME="$GTK_LIBNAME $GNOME_LIBDIR $GNOME_LIBS"
+       fi
+     }
+     fi
+   fi
+ fi
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl Check for GTK3.
+ dnl ---------------------------------------------------------------------------
+ if test -z "$SKIP_GTK3"; then
+ 
+   AC_MSG_CHECKING(--disable-gtktest argument)
+   AC_ARG_ENABLE(gtktest, [  --disable-gtktest       Do not try to compile and run a test GTK program],
+ 	, enable_gtktest=yes)
+   if test "x$enable_gtktest" = "xyes" ; then
+     AC_MSG_RESULT(gtk test enabled)
+   else
+     AC_MSG_RESULT(gtk test disabled)
+   fi
+ 
+   if test "X$PKG_CONFIG" = "X"; then
+     AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
+   fi
+ 
+   if test "x$PKG_CONFIG" != "xno"; then
+     AM_PATH_GTK(3.0.0,
+ 		[GUI_LIB_LOC="$GTK_LIBDIR"
+ 		 GTK_LIBNAME="$GTK_LIBS"
+ 		GUI_INC_LOC="$GTK_CFLAGS"], )
+     if test "x$GTK_CFLAGS" != "x"; then
+       SKIP_GTK2=YES
+       SKIP_GNOME=YES
+       SKIP_ATHENA=YES
+       SKIP_NEXTAW=YES
+       SKIP_MOTIF=YES
+       GUITYPE=GTK
+       AC_SUBST(GTK_LIBNAME)
+       AC_DEFINE(HAVE_GTK_MULTIHEAD)
+       AC_DEFINE(USE_GTK3)
+     fi
+   fi
+ fi
+ 
+ dnl Check the version of Gdk-Pixbuf.  If the version is 2.31 or later and
+ dnl glib-compile-resources is found in PATH, use GResource.
+ if test "x$GUITYPE" = "xGTK"; then
+   AC_MSG_CHECKING([version of Gdk-Pixbuf])
+   gdk_pixbuf_version=`$PKG_CONFIG --modversion gdk-pixbuf-2.0`
+   if test "x$gdk_pixbuf_version" != x ; then
+     gdk_pixbuf_version_minor=`echo $gdk_pixbuf_version | \
+       sed -e 's/[[0-9]][[0-9]]*\.\([[0-9]][[0-9]]*\)\.[[0-9]][[0-9]]*/\1/'`
+     if test "x$gdk_pixbuf_version_minor" != x -a \
+ 	$gdk_pixbuf_version_minor -ge 31 ; then
+       AC_MSG_RESULT([OK.])
+       AC_PATH_PROG(GLIB_COMPILE_RESOURCES,[glib-compile-resources],no)
+       AC_MSG_CHECKING([glib-compile-resources])
+       if test "x$GLIB_COMPILE_RESOURCES" = xno ; then
+ 	GLIB_COMPILE_RESOURCES=""
+ 	AC_MSG_RESULT([cannot be found in PATH.])
+       else
+ 	AC_MSG_RESULT([usable.])
+ 	AC_DEFINE(USE_GRESOURCE)
+ 	GRESOURCE_SRC="auto/gui_gtk_gresources.c"
+ 	GRESOURCE_OBJ="objects/gui_gtk_gresources.o"
+       fi
+     else
+       AC_MSG_RESULT([not usable.])
+     fi
+   else
+     AC_MSG_RESULT([cannot obtain from pkg_config.])
+   fi
+ 
+   AC_MSG_CHECKING([--disable-icon-cache-update argument])
+   AC_ARG_ENABLE(icon_cache_update,
+           [  --disable-icon-cache-update        update disabled],
+           [],
+           [enable_icon_cache_update="yes"])
+   if test "$enable_icon_cache_update" = "yes"; then
+     AC_MSG_RESULT([not set])
+     AC_PATH_PROG(GTK_UPDATE_ICON_CACHE,[gtk-update-icon-cache],no)
+     if test "x$GTK_UPDATE_ICON_CACHE" = "xno" ; then
+       AC_MSG_RESULT([not found in PATH.])
+     fi
+   else
+     AC_MSG_RESULT([update disabled])
+   fi
+ 
+   AC_MSG_CHECKING([--disable-desktop-database-update argument])
+   AC_ARG_ENABLE(desktop_database_update,
+           [  --disable-desktop-database-update  update disabled],
+           [],
+           [enable_desktop_database_update="yes"])
+   if test "$enable_desktop_database_update" = "yes"; then
+     AC_MSG_RESULT([not set])
+     AC_PATH_PROG(UPDATE_DESKTOP_DATABASE,[update-desktop-database],no)
+     if test "x$UPDATE_DESKTOP_DATABASE" = "xno" ; then
+       AC_MSG_RESULT([not found in PATH.])
+     fi
+   else
+     AC_MSG_RESULT([update disabled])
+   fi
+ fi
+ AC_SUBST(GLIB_COMPILE_RESOURCES)
+ AC_SUBST(GRESOURCE_SRC)
+ AC_SUBST(GRESOURCE_OBJ)
+ AC_SUBST(GTK_UPDATE_ICON_CACHE)
+ AC_SUBST(UPDATE_DESKTOP_DATABASE)
+ 
+ dnl Check for Motif include files location.
+ dnl The LAST one found is used, this makes the highest version to be used,
+ dnl e.g. when Motif1.2 and Motif2.0 are both present.
+ 
+ if test -z "$SKIP_MOTIF"; then
+   gui_XXX="/usr/XXX/Motif* /usr/Motif*/XXX /usr/XXX /usr/shlib /usr/X11*/XXX /usr/XXX/X11* /usr/dt/XXX /local/Motif*/XXX /local/XXX/Motif* /usr/local/Motif*/XXX /usr/local/XXX/Motif* /usr/local/XXX /usr/local/X11*/XXX /usr/local/LessTif/Motif*/XXX $MOTIFHOME/XXX"
+   dnl Remove "-I" from before $GUI_INC_LOC if it's there
+   GUI_INC_LOC="`echo $GUI_INC_LOC|sed 's%-I%%g'`"
+ 
+   AC_MSG_CHECKING(for location of Motif GUI includes)
+   gui_includes="`echo $x_includes|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/include/g` $GUI_INC_LOC"
+   GUI_INC_LOC=
+   for try in $gui_includes; do
+     if test -f "$try/Xm/Xm.h"; then
+       GUI_INC_LOC=$try
+     fi
+   done
+   if test -n "$GUI_INC_LOC"; then
+     if test "$GUI_INC_LOC" = /usr/include; then
+       GUI_INC_LOC=
+       AC_MSG_RESULT(in default path)
+     else
+       AC_MSG_RESULT($GUI_INC_LOC)
+     fi
+   else
+     AC_MSG_RESULT(<not found>)
+     SKIP_MOTIF=YES
+   fi
+ fi
+ 
+ dnl Check for Motif library files location.  In the same order as the include
+ dnl files, to avoid a mixup if several versions are present
+ 
+ if test -z "$SKIP_MOTIF"; then
+   AC_MSG_CHECKING(--with-motif-lib argument)
+   AC_ARG_WITH(motif-lib,
+   [  --with-motif-lib=STRING   Library for Motif ],
+   [ MOTIF_LIBNAME="${withval}" ] )
+ 
+   if test -n "$MOTIF_LIBNAME"; then
+     AC_MSG_RESULT($MOTIF_LIBNAME)
+     GUI_LIB_LOC=
+   else
+     AC_MSG_RESULT(no)
+ 
+     dnl Remove "-L" from before $GUI_LIB_LOC if it's there
+     GUI_LIB_LOC="`echo $GUI_LIB_LOC|sed 's%-L%%g'`"
+ 
+     dnl Ubuntu has libXm.so in /usr/lib/i386-linux-gnu and elsewhere.  The
+     dnl linker will figure out which one to use, we only check if one exists.
+     AC_MSG_CHECKING(for location of Motif GUI libs)
+     gui_libs="`echo $x_libraries|sed 's%/[^/][^/]*$%%'` `echo "$gui_XXX" | sed s/XXX/lib/g` /usr/lib/i386-linux-gnu /usr/lib/x86_64-linux-gnu `echo "$GUI_INC_LOC" | sed s/include/lib/` $GUI_LIB_LOC"
+     GUI_LIB_LOC=
+     for try in $gui_libs; do
+       for libtry in "$try"/libXm.a "$try"/libXm.so* "$try"/libXm.sl "$try"/libXm.dylib; do
+ 	if test -f "$libtry"; then
+ 	  GUI_LIB_LOC=$try
+ 	fi
+       done
+     done
+     if test -n "$GUI_LIB_LOC"; then
+       dnl Remove /usr/lib, it causes trouble on some systems
+       if test "$GUI_LIB_LOC" = /usr/lib \
+ 	   -o "$GUI_LIB_LOC" = /usr/lib/i386-linux-gnu \
+ 	   -o "$GUI_LIB_LOC" = /usr/lib/x86_64-linux-gnu; then
+ 	GUI_LIB_LOC=
+ 	AC_MSG_RESULT(in default path)
+       else
+ 	if test -n "$GUI_LIB_LOC"; then
+ 	  AC_MSG_RESULT($GUI_LIB_LOC)
+ 	  if test "`(uname) 2>/dev/null`" = SunOS &&
+ 					 uname -r | grep '^5' >/dev/null; then
+ 	    GUI_LIB_LOC="$GUI_LIB_LOC -R $GUI_LIB_LOC"
+ 	  fi
+ 	fi
+       fi
+       MOTIF_LIBNAME=-lXm
+     else
+       AC_MSG_RESULT(<not found>)
+       SKIP_MOTIF=YES
+     fi
+   fi
+ fi
+ 
+ if test -z "$SKIP_MOTIF"; then
+   SKIP_ATHENA=YES
+   SKIP_NEXTAW=YES
+   GUITYPE=MOTIF
+   AC_SUBST(MOTIF_LIBNAME)
+ fi
+ 
+ dnl Check if the Athena files can be found
+ 
+ GUI_X_LIBS=
+ 
+ if test -z "$SKIP_ATHENA"; then
+   AC_MSG_CHECKING(if Athena header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/Xaw/Paned.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); SKIP_ATHENA=YES )
+   CFLAGS=$cflags_save
+ fi
+ 
+ if test -z "$SKIP_ATHENA"; then
+   GUITYPE=ATHENA
+ fi
+ 
+ if test -z "$SKIP_NEXTAW"; then
+   AC_MSG_CHECKING(if neXtaw header files can be found)
+   cflags_save=$CFLAGS
+   CFLAGS="$CFLAGS $X_CFLAGS"
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/neXtaw/Paned.h>], ,
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_RESULT(no); SKIP_NEXTAW=YES )
+   CFLAGS=$cflags_save
+ fi
+ 
+ if test -z "$SKIP_NEXTAW"; then
+   GUITYPE=NEXTAW
+ fi
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+   dnl Prepend -I and -L to $GUI_INC_LOC and $GUI_LIB_LOC if not empty
+   dnl Avoid adding it when it twice
+   if test -n "$GUI_INC_LOC"; then
+     GUI_INC_LOC=-I"`echo $GUI_INC_LOC|sed 's%-I%%'`"
+   fi
+   if test -n "$GUI_LIB_LOC"; then
+     GUI_LIB_LOC=-L"`echo $GUI_LIB_LOC|sed 's%-L%%'`"
+   fi
+ 
+   dnl Check for -lXext and then for -lXmu
+   ldflags_save=$LDFLAGS
+   LDFLAGS="$X_LIBS $LDFLAGS"
+   AC_CHECK_LIB(Xext, XShapeQueryExtension, [GUI_X_LIBS="-lXext"],,
+ 		[-lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   dnl For Solaris we need -lw and -ldl before linking with -lXmu works.
+   AC_CHECK_LIB(w, wslen, [X_EXTRA_LIBS="$X_EXTRA_LIBS -lw"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   AC_CHECK_LIB(dl, dlsym, [X_EXTRA_LIBS="$X_EXTRA_LIBS -ldl"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   AC_CHECK_LIB(Xmu, XmuCreateStippledPixmap, [GUI_X_LIBS="-lXmu $GUI_X_LIBS"],,
+ 		[$GUI_X_LIBS -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   if test -z "$SKIP_MOTIF"; then
+     AC_CHECK_LIB(Xp, XpEndJob, [GUI_X_LIBS="-lXp $GUI_X_LIBS"],,
+ 		[$GUI_X_LIBS -lXm -lXt $X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+   fi
+   LDFLAGS=$ldflags_save
+ 
+   dnl Execute xmkmf to figure out if -DNARROWPROTO is needed.
+   AC_MSG_CHECKING(for extra X11 defines)
+   NARROW_PROTO=
+   rm -fr conftestdir
+   if mkdir conftestdir; then
+     cd conftestdir
+     cat > Imakefile <<'EOF'
+ acfindx:
+ 	@echo 'NARROW_PROTO="${PROTO_DEFINES}"'
+ EOF
+     if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
+       eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
+     fi
+     cd ..
+     rm -fr conftestdir
+   fi
+   if test -z "$NARROW_PROTO"; then
+     AC_MSG_RESULT(no)
+   else
+     AC_MSG_RESULT($NARROW_PROTO)
+   fi
+   AC_SUBST(NARROW_PROTO)
+ fi
+ 
+ dnl Look for XSMP support - but don't necessarily restrict it to X11 GUIs
+ dnl use the X11 include path
+ if test "$enable_xsmp" = "yes"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   AC_CHECK_HEADERS(X11/SM/SMlib.h)
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF" -o -z "$SKIP_GTK2" -o -z "$SKIP_GTK3"; then
+   dnl Check for X11/xpm.h and X11/Sunkeysym.h with the GUI include path
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   AC_CHECK_HEADERS(X11/xpm.h X11/Sunkeysym.h)
+ 
+   dnl automatically disable XIM when XIMtext isn't in X11/Xlib.h
+   if test ! "$enable_xim" = "no"; then
+     AC_MSG_CHECKING(for XIMText in X11/Xlib.h)
+     AC_EGREP_CPP(XIMText, [#include <X11/Xlib.h>],
+ 		  AC_MSG_RESULT(yes),
+ 		  AC_MSG_RESULT(no; xim has been disabled); enable_xim="no")
+   fi
+   CPPFLAGS=$cppflags_save
+ 
+   dnl automatically enable XIM when hangul input isn't enabled
+   if test "$enable_xim" = "auto" -a "$enable_hangulinput" != "yes" \
+ 		-a "x$GUITYPE" != "xNONE" ; then
+     AC_MSG_RESULT(X GUI selected; xim has been enabled)
+     enable_xim="yes"
+   fi
+ fi
+ 
+ if test -z "$SKIP_ATHENA" -o -z "$SKIP_NEXTAW" -o -z "$SKIP_MOTIF"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+ dnl Xmu/Editres.h may exist but can only be used after including Intrinsic.h
+   AC_MSG_CHECKING([for X11/Xmu/Editres.h])
+   AC_TRY_COMPILE([
+ #include <X11/Intrinsic.h>
+ #include <X11/Xmu/Editres.h>],
+ 		      [int i; i = 0;],
+ 	      AC_MSG_RESULT(yes)
+ 		      AC_DEFINE(HAVE_X11_XMU_EDITRES_H),
+ 	      AC_MSG_RESULT(no))
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ dnl Only use the Xm directory when compiling Motif, don't use it for Athena
+ if test -z "$SKIP_MOTIF"; then
+   cppflags_save=$CPPFLAGS
+   CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+   if test "$zOSUnix" = "yes"; then
+ 	xmheader="Xm/Xm.h"
+   else
+ 	xmheader="Xm/Xm.h Xm/XpmP.h Xm/JoinSideT.h Xm/TraitP.h Xm/Manager.h
+ 	   Xm/UnhighlightT.h Xm/Notebook.h"  
+   fi    
+   AC_CHECK_HEADERS($xmheader)
+ 
+   if test "x$ac_cv_header_Xm_XpmP_h" = "xyes"; then
+     dnl Solaris uses XpmAttributes_21, very annoying.
+     AC_MSG_CHECKING([for XpmAttributes_21 in Xm/XpmP.h])
+     AC_TRY_COMPILE([#include <Xm/XpmP.h>], [XpmAttributes_21 attr;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes_21),
+ 	AC_MSG_RESULT(no); AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+ 	)
+   else
+     AC_DEFINE(XPMATTRIBUTES_TYPE, XpmAttributes)
+   fi
+   CPPFLAGS=$cppflags_save
+ fi
+ 
+ if test "x$GUITYPE" = "xNONE" -a "$enable_xim" = "yes"; then
+   AC_MSG_RESULT(no GUI selected; xim has been disabled)
+   enable_xim="no"
+ fi
+ if test "x$GUITYPE" = "xNONE" -a "$enable_fontset" = "yes"; then
+   AC_MSG_RESULT(no GUI selected; fontset has been disabled)
+   enable_fontset="no"
+ fi
+ if test "x$GUITYPE:$enable_fontset" = "xGTK:yes"; then
+   AC_MSG_RESULT(GTK+ 2 GUI selected; fontset has been disabled)
+   enable_fontset="no"
+ fi
+ 
+ if test -z "$SKIP_PHOTON"; then
+   GUITYPE=PHOTONGUI
+ fi
+ 
+ AC_SUBST(GUI_INC_LOC)
+ AC_SUBST(GUI_LIB_LOC)
+ AC_SUBST(GUITYPE)
+ AC_SUBST(GUI_X_LIBS)
+ 
+ if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
+   AC_MSG_ERROR([cannot use workshop without Motif])
+ fi
+ 
+ dnl defining FEAT_XIM and FEAT_XFONTSET is delayed, so that they can be disabled
+ if test "$enable_xim" = "yes"; then
+   AC_DEFINE(FEAT_XIM)
+ fi
+ if test "$enable_fontset" = "yes"; then
+   AC_DEFINE(FEAT_XFONTSET)
+ fi
+ 
+ 
+ dnl ---------------------------------------------------------------------------
+ dnl end of GUI-checking
+ dnl ---------------------------------------------------------------------------
+ 
+ dnl Check for Cygwin, which needs an extra source file if not using X11
+ AC_MSG_CHECKING(for CYGWIN or MSYS environment)
+ case `uname` in
+     CYGWIN*|MSYS*)    CYGWIN=yes; AC_MSG_RESULT(yes)
+                 AC_MSG_CHECKING(for CYGWIN clipboard support)
+                 if test "x$with_x" = "xno" ; then
+                   OS_EXTRA_SRC=winclip.c; OS_EXTRA_OBJ=objects/winclip.o
+                   AC_MSG_RESULT(yes)
+                   AC_DEFINE(FEAT_CYGWIN_WIN32_CLIPBOARD)
+                 else
+                   AC_MSG_RESULT(no - using X11)
+                 fi ;;
+ 
+     *)          CYGWIN=no; AC_MSG_RESULT(no);;
+ esac
+ 
+ dnl Only really enable hangul input when GUI and XFONTSET are available
+ if test "$enable_hangulinput" = "yes"; then
+   if test "x$GUITYPE" = "xNONE"; then
+     AC_MSG_RESULT(no GUI selected; hangul input has been disabled)
+     enable_hangulinput=no
+   else
+     AC_DEFINE(FEAT_HANGULIN)
+     HANGULIN_SRC=hangulin.c
+     AC_SUBST(HANGULIN_SRC)
+     HANGULIN_OBJ=objects/hangulin.o
+     AC_SUBST(HANGULIN_OBJ)
+   fi
+ fi
+ 
+ dnl Checks for libraries and include files.
+ 
+ AC_CACHE_CHECK([whether toupper is broken], [vim_cv_toupper_broken],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #include <ctype.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() { exit(toupper('A') == 'A' && tolower('z') == 'z'); }
+   ]])],[
+     vim_cv_toupper_broken=yes
+   ],[
+     vim_cv_toupper_broken=no
+   ],[
+     AC_MSG_ERROR(cross-compiling: please set 'vim_cv_toupper_broken')
+   ])])
+ 
+ if test "x$vim_cv_toupper_broken" = "xyes" ; then
+   AC_DEFINE(BROKEN_TOUPPER)
+ fi
+ 
+ AC_MSG_CHECKING(whether __DATE__ and __TIME__ work)
+ AC_TRY_COMPILE([#include <stdio.h>], [printf("(" __DATE__ " " __TIME__ ")");],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_DATE_TIME),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING(whether __attribute__((unused)) is allowed)
+ AC_TRY_COMPILE([#include <stdio.h>], [int x __attribute__((unused));],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ATTRIBUTE_UNUSED),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Checks for header files.
+ AC_CHECK_HEADER(elf.h, HAS_ELF=1)
+ dnl AC_CHECK_HEADER(dwarf.h, SVR4=1)
+ if test "$HAS_ELF" = 1; then
+   AC_CHECK_LIB(elf, main)
+ fi
+ 
+ AC_HEADER_DIRENT
+ 
+ dnl If sys/wait.h is not found it might still exist but not be POSIX
+ dnl compliant. In that case we define HAVE_UNION_WAIT (for NeXT)
+ if test $ac_cv_header_sys_wait_h = no; then
+   AC_MSG_CHECKING([for sys/wait.h that defines union wait])
+   AC_TRY_COMPILE([#include <sys/wait.h>],
+ 			[union wait xx, yy; xx = yy],
+ 		AC_MSG_RESULT(yes)
+ 			AC_DEFINE(HAVE_SYS_WAIT_H)
+ 			AC_DEFINE(HAVE_UNION_WAIT),
+ 		AC_MSG_RESULT(no))
+ fi
+ 
+ AC_CHECK_HEADERS(stdint.h stdlib.h string.h \
+ 	sys/select.h sys/utsname.h termcap.h fcntl.h \
+ 	sgtty.h sys/ioctl.h sys/time.h sys/types.h \
+ 	termio.h iconv.h inttypes.h langinfo.h math.h \
+ 	unistd.h stropts.h errno.h sys/resource.h \
+ 	sys/systeminfo.h locale.h sys/stream.h termios.h \
+ 	libc.h sys/statfs.h poll.h sys/poll.h pwd.h \
+ 	utime.h sys/param.h libintl.h libgen.h \
+ 	util/debug.h util/msg18n.h frame.h sys/acl.h \
+ 	sys/access.h sys/sysinfo.h wchar.h wctype.h)
+ 
+ dnl sys/ptem.h depends on sys/stream.h on Solaris
+ AC_CHECK_HEADERS(sys/ptem.h, [], [],
+ [#if defined HAVE_SYS_STREAM_H
+ #  include <sys/stream.h>
+ #endif])
+ 
+ dnl sys/sysctl.h depends on sys/param.h on OpenBSD
+ AC_CHECK_HEADERS(sys/sysctl.h, [], [],
+ [#if defined HAVE_SYS_PARAM_H
+ #  include <sys/param.h>
+ #endif])
+ 
+ 
+ dnl pthread_np.h may exist but can only be used after including pthread.h
+ AC_MSG_CHECKING([for pthread_np.h])
+ AC_TRY_COMPILE([
+ #include <pthread.h>
+ #include <pthread_np.h>],
+ 		      [int i; i = 0;],
+ 	      AC_MSG_RESULT(yes)
+ 		      AC_DEFINE(HAVE_PTHREAD_NP_H),
+ 	      AC_MSG_RESULT(no))
+ 
+ AC_CHECK_HEADERS(strings.h)
+ if test "x$MACOSX" = "xyes"; then
+   dnl The strings.h file on OS/X contains a warning and nothing useful.
+   AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+ else
+ 
+ dnl Check if strings.h and string.h can both be included when defined.
+ AC_MSG_CHECKING([if strings.h can be included after string.h])
+ cppflags_save=$CPPFLAGS
+ CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+ AC_TRY_COMPILE([
+ #if defined(_AIX) && !defined(_AIX51) && !defined(_NO_PROTO)
+ # define _NO_PROTO	/* like in os_unix.h, causes conflict for AIX (Winn) */
+ 			/* but don't do it on AIX 5.1 (Uribarri) */
+ #endif
+ #ifdef HAVE_XM_XM_H
+ # include <Xm/Xm.h>	/* This breaks it for HP-UX 11 (Squassabia) */
+ #endif
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if defined(HAVE_STRINGS_H)
+ # include <strings.h>
+ #endif
+ 		], [int i; i = 0;],
+ 		AC_MSG_RESULT(yes),
+ 		AC_DEFINE(NO_STRINGS_WITH_STRING_H)
+ 		AC_MSG_RESULT(no))
+ CPPFLAGS=$cppflags_save
+ fi
+ 
+ dnl Checks for typedefs, structures, and compiler characteristics.
+ AC_PROG_GCC_TRADITIONAL
+ AC_C_CONST
+ AC_C_VOLATILE
+ AC_TYPE_MODE_T
+ AC_TYPE_OFF_T
+ AC_TYPE_PID_T
+ AC_TYPE_SIZE_T
+ AC_TYPE_UID_T
+ AC_TYPE_UINT32_T
+ 
+ AC_HEADER_TIME
+ AC_CHECK_TYPE(ino_t, long)
+ AC_CHECK_TYPE(dev_t, unsigned)
+ AC_C_BIGENDIAN(,,,)
+ AC_C_INLINE
+ 
+ AC_MSG_CHECKING(for rlim_t)
+ if eval "test \"`echo '$''{'ac_cv_type_rlim_t'+set}'`\" = set"; then
+   AC_MSG_RESULT([(cached) $ac_cv_type_rlim_t])
+ else
+   AC_EGREP_CPP(dnl
+ changequote(<<,>>)dnl
+ <<(^|[^a-zA-Z_0-9])rlim_t[^a-zA-Z_0-9]>>dnl
+ changequote([,]),
+   [
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_SYS_RESOURCE_H
+ # include <sys/resource.h>
+ #endif
+ 	  ], ac_cv_type_rlim_t=yes, ac_cv_type_rlim_t=no)
+ 	  AC_MSG_RESULT($ac_cv_type_rlim_t)
+ fi
+ if test $ac_cv_type_rlim_t = no; then
+   cat >> confdefs.h <<\EOF
+ #define rlim_t unsigned long
+ EOF
+ fi
+ 
+ AC_MSG_CHECKING(for stack_t)
+ if eval "test \"`echo '$''{'ac_cv_type_stack_t'+set}'`\" = set"; then
+   AC_MSG_RESULT([(cached) $ac_cv_type_stack_t])
+ else
+   AC_EGREP_CPP(stack_t,
+   [
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <signal.h>
+ 	  ], ac_cv_type_stack_t=yes, ac_cv_type_stack_t=no)
+ 	  AC_MSG_RESULT($ac_cv_type_stack_t)
+ fi
+ if test $ac_cv_type_stack_t = no; then
+   cat >> confdefs.h <<\EOF
+ #define stack_t struct sigaltstack
+ EOF
+ fi
+ 
+ dnl BSDI uses ss_base while others use ss_sp for the stack pointer.
+ AC_MSG_CHECKING(whether stack_t has an ss_base field)
+ AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <signal.h>
+ #include "confdefs.h"
+ 			], [stack_t sigstk; sigstk.ss_base = 0; ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SS_BASE),
+ 	AC_MSG_RESULT(no))
+ 
+ olibs="$LIBS"
+ AC_MSG_CHECKING(--with-tlib argument)
+ AC_ARG_WITH(tlib, [  --with-tlib=library     terminal library to be used ],)
+ if test -n "$with_tlib"; then
+   AC_MSG_RESULT($with_tlib)
+   LIBS="$LIBS -l$with_tlib"
+   AC_MSG_CHECKING(for linking with $with_tlib library)
+   AC_TRY_LINK([], [], AC_MSG_RESULT(OK), AC_MSG_ERROR(FAILED))
+   dnl Need to check for tgetent() below.
+   olibs="$LIBS"
+ else
+   AC_MSG_RESULT([empty: automatic terminal library selection])
+   dnl  On HP-UX 10.10 termcap or termlib should be used instead of
+   dnl  curses, because curses is much slower.
+   dnl  Newer versions of ncurses are preferred over anything, except
+   dnl  when tinfo has been split off, it contains all we need.
+   dnl  Older versions of ncurses have bugs, get a new one!
+   dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
+   dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
+   case "`uname -s 2>/dev/null`" in
+ 	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+ 	*)	tlibs="tinfo ncurses termlib termcap curses";;
+   esac
+   for libname in $tlibs; do
+     AC_CHECK_LIB(${libname}, tgetent,,)
+     if test "x$olibs" != "x$LIBS"; then
+       dnl It's possible that a library is found but it doesn't work
+       dnl e.g., shared library that cannot be found
+       dnl compile and run a test program to be sure
+       AC_TRY_RUN([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(0); }],
+ 			  res="OK", res="FAIL", res="FAIL")
+       if test "$res" = "OK"; then
+ 	break
+       fi
+       AC_MSG_RESULT($libname library is not usable)
+       LIBS="$olibs"
+     fi
+   done
+   if test "x$olibs" = "x$LIBS"; then
+     AC_MSG_RESULT(no terminal library found)
+   fi
+ fi
+ 
+ if test "x$olibs" = "x$LIBS"; then
+   AC_MSG_CHECKING([for tgetent()])
+   AC_TRY_LINK([],
+       [char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist");],
+ 	AC_MSG_RESULT(yes),
+ 	AC_MSG_ERROR([NOT FOUND!
+       You need to install a terminal library; for example ncurses.
+       Or specify the name of the library with --with-tlib.]))
+ fi
+ 
+ AC_CACHE_CHECK([whether we talk terminfo], [vim_cv_terminfo],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main()
+ {char *s; s=(char *)tgoto("%p1%d", 0, 1); exit(!strcmp(s==0 ? "" : s, "1")); }
+     ]])],[
+       vim_cv_terminfo=no
+     ],[
+       vim_cv_terminfo=yes
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_terminfo')
+     ])
+   ])
+ 
+ if test "x$vim_cv_terminfo" = "xyes" ; then
+   AC_DEFINE(TERMINFO)
+ fi
+ 
+ if test "x$olibs" != "x$LIBS"; then
+   AC_CACHE_CHECK([what tgetent() returns for an unknown terminal], [vim_cv_tgent],
+     [
+       AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main()
+ {char s[10000]; int res = tgetent(s, "thisterminaldoesnotexist"); exit(res != 0); }
+       ]])],[
+ 	vim_cv_tgent=zero
+       ],[
+ 	vim_cv_tgent=non-zero
+       ],[
+ 	AC_MSG_ERROR(failed to compile test program.)
+       ])
+     ])
+   
+   if test "x$vim_cv_tgent" = "xzero" ; then
+     AC_DEFINE(TGETENT_ZERO_ERR, 0)
+   fi
+ fi
+ 
+ AC_MSG_CHECKING(whether termcap.h contains ospeed)
+ AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [ospeed = 20000],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OSPEED),
+ 	[AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING(whether ospeed can be extern)
+ 	AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ extern short ospeed;
+ 			], [ospeed = 20000],
+ 		AC_MSG_RESULT(yes); AC_DEFINE(OSPEED_EXTERN),
+ 		AC_MSG_RESULT(no))]
+ 	)
+ 
+ AC_MSG_CHECKING([whether termcap.h contains UP, BC and PC])
+ AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [if (UP == 0 && BC == 0) PC = 1],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_UP_BC_PC),
+ 	[AC_MSG_RESULT(no)
+ 	AC_MSG_CHECKING([whether UP, BC and PC can be extern])
+ 	AC_TRY_LINK([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ extern char *UP, *BC, PC;
+ 			], [if (UP == 0 && BC == 0) PC = 1],
+ 		AC_MSG_RESULT(yes); AC_DEFINE(UP_BC_PC_EXTERN),
+ 		AC_MSG_RESULT(no))]
+ 	)
+ 
+ AC_MSG_CHECKING(whether tputs() uses outfuntype)
+ AC_TRY_COMPILE([
+ #ifdef HAVE_TERMCAP_H
+ # include <termcap.h>
+ #endif
+ 			], [extern int xx(); tputs("test", 1, (outfuntype)xx)],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_OUTFUNTYPE),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl On some SCO machines sys/select redefines struct timeval
+ AC_MSG_CHECKING([whether sys/select.h and sys/time.h may both be included])
+ AC_TRY_COMPILE([
+ #include <sys/types.h>
+ #include <sys/time.h>
+ #include <sys/select.h>], ,
+ 	  AC_MSG_RESULT(yes)
+ 			AC_DEFINE(SYS_SELECT_WITH_SYS_TIME),
+ 	  AC_MSG_RESULT(no))
+ 
+ dnl AC_DECL_SYS_SIGLIST
+ 
+ dnl Checks for pty.c (copied from screen) ==========================
+ AC_MSG_CHECKING(for /dev/ptc)
+ if test -r /dev/ptc; then
+   AC_DEFINE(HAVE_DEV_PTC)
+   AC_MSG_RESULT(yes)
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ AC_MSG_CHECKING(for SVR4 ptys)
+ if test -c /dev/ptmx ; then
+   AC_TRY_LINK([], [ptsname(0);grantpt(0);unlockpt(0);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SVR4_PTYS),
+ 	AC_MSG_RESULT(no))
+ else
+   AC_MSG_RESULT(no)
+ fi
+ 
+ AC_MSG_CHECKING(for ptyranges)
+ if test -d /dev/ptym ; then
+   pdir='/dev/ptym'
+ else
+   pdir='/dev'
+ fi
+ dnl SCO uses ptyp%d
+ AC_EGREP_CPP(yes,
+ [#ifdef M_UNIX
+    yes;
+ #endif
+ 	], ptys=`echo /dev/ptyp??`, ptys=`echo $pdir/pty??`)
+ dnl if test -c /dev/ptyp19; then
+ dnl ptys=`echo /dev/ptyp??`
+ dnl else
+ dnl ptys=`echo $pdir/pty??`
+ dnl fi
+ if test "$ptys" != "$pdir/pty??" ; then
+   p0=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\).$/\1/g' | sort -u | tr -d '\012'`
+   p1=`echo $ptys | tr ' ' '\012' | sed -e 's/^.*\(.\)$/\1/g'  | sort -u | tr -d '\012'`
+   AC_DEFINE_UNQUOTED(PTYRANGE0,"$p0")
+   AC_DEFINE_UNQUOTED(PTYRANGE1,"$p1")
+   AC_MSG_RESULT([$p0 / $p1])
+ else
+   AC_MSG_RESULT([don't know])
+ fi
+ 
+ dnl    ****  pty mode/group handling ****
+ dnl
+ dnl support provided by Luke Mewburn <lm@rmit.edu.au>, 931222
+ rm -f conftest_grp
+ AC_CACHE_CHECK([default tty permissions/group], [vim_cv_tty_group],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #include <sys/types.h>
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ #include <sys/stat.h>
+ #include <stdio.h>
+ main()
+ {
+   struct stat sb;
+   char *x,*ttyname();
+   int om, m;
+   FILE *fp;
+ 
+   if (!(x = ttyname(0))) exit(1);
+   if (stat(x, &sb)) exit(1);
+   om = sb.st_mode;
+   if (om & 002) exit(0);
+   m = system("mesg y");
+   if (m == -1 || m == 127) exit(1);
+   if (stat(x, &sb)) exit(1);
+   m = sb.st_mode;
+   if (chmod(x, om)) exit(1);
+   if (m & 002) exit(0);
+   if (sb.st_gid == getgid()) exit(1);
+   if (!(fp=fopen("conftest_grp", "w")))
+     exit(1);
+   fprintf(fp, "%d\n", sb.st_gid);
+   fclose(fp);
+   exit(0);
+ }
+     ]])],[
+       if test -f conftest_grp; then
+ 	vim_cv_tty_group=`cat conftest_grp`
+ 	if test "x$vim_cv_tty_mode" = "x" ; then
+ 	  vim_cv_tty_mode=0620
+ 	fi
+ 	AC_MSG_RESULT([pty mode: $vim_cv_tty_mode, group: $vim_cv_tty_group])
+       else
+ 	vim_cv_tty_group=world
+ 	AC_MSG_RESULT([ptys are world accessible])
+       fi
+     ],[
+       vim_cv_tty_group=world
+       AC_MSG_RESULT([can't determine - assume ptys are world accessible])
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_tty_group' and 'vim_cv_tty_mode')
+     ])
+   ])
+ rm -f conftest_grp
+ 
+ if test "x$vim_cv_tty_group" != "xworld" ; then
+   AC_DEFINE_UNQUOTED(PTYGROUP,$vim_cv_tty_group)
+   if test "x$vim_cv_tty_mode" = "x" ; then
+     AC_MSG_ERROR([It seems you're cross compiling and have 'vim_cv_tty_group' set, please also set the environment variable 'vim_cv_tty_mode' to the correct mode (probably 0620)])
+   else
+     AC_DEFINE(PTYMODE, 0620)
+   fi
+ fi
+ 
+ dnl Checks for library functions. ===================================
+ 
+ AC_TYPE_SIGNAL
+ 
+ dnl find out what to use at the end of a signal function
+ if test $ac_cv_type_signal = void; then
+   AC_DEFINE(SIGRETURN, [return])
+ else
+   AC_DEFINE(SIGRETURN, [return 0])
+ fi
+ 
+ dnl check if struct sigcontext is defined (used for SGI only)
+ AC_MSG_CHECKING(for struct sigcontext)
+ AC_TRY_COMPILE([
+ #include <signal.h>
+ test_sig()
+ {
+     struct sigcontext *scont;
+     scont = (struct sigcontext *)0;
+     return 1;
+ } ], ,
+ 	  AC_MSG_RESULT(yes)
+ 		AC_DEFINE(HAVE_SIGCONTEXT),
+ 	  AC_MSG_RESULT(no))
+ 
+ dnl tricky stuff: try to find out if getcwd() is implemented with
+ dnl system("sh -c pwd")
+ AC_CACHE_CHECK([getcwd implementation is broken], [vim_cv_getcwd_broken],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #ifdef HAVE_UNISTD_H
+ #include <unistd.h>
+ #endif
+ char *dagger[] = { "IFS=pwd", 0 };
+ main()
+ {
+   char buffer[500];
+   extern char **environ;
+   environ = dagger;
+   return getcwd(buffer, 500) ? 0 : 1;
+ }
+     ]])],[
+       vim_cv_getcwd_broken=no
+     ],[
+       vim_cv_getcwd_broken=yes
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_getcwd_broken')
+     ])
+   ])
+ 
+ if test "x$vim_cv_getcwd_broken" = "xyes" ; then
+   AC_DEFINE(BAD_GETCWD)
+ fi
+ 
+ dnl Check for functions in one big call, to reduce the size of configure.
+ dnl Can only be used for functions that do not require any include.
+ AC_CHECK_FUNCS(bcmp fchdir fchown fsync getcwd getpseudotty \
+ 	getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat memcmp \
+ 	memset mkdtemp nanosleep opendir putenv qsort readlink select setenv \
+ 	setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction \
+ 	sigprocmask sigvec strcasecmp strerror strftime stricmp strncasecmp \
+ 	strnicmp strpbrk strtol tgetent towlower towupper iswupper \
+ 	usleep utime utimes)
+ AC_FUNC_FSEEKO
+ 
+ dnl define _LARGE_FILES, _FILE_OFFSET_BITS and _LARGEFILE_SOURCE when
+ dnl appropriate, so that off_t is 64 bits when needed.
+ AC_SYS_LARGEFILE
+ 
+ dnl fstatfs() can take 2 to 4 arguments, try to use st_blksize if possible
+ AC_MSG_CHECKING(for st_blksize)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/stat.h>],
+ [	struct stat st;
+ 	int n;
+ 
+ 	stat("/", &st);
+ 	n = (int)st.st_blksize;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ST_BLKSIZE),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_CACHE_CHECK([whether stat() ignores a trailing slash], [vim_cv_stat_ignores_slash],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[
+ #include "confdefs.h"
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ main() {struct stat st;  exit(stat("configure/", &st) != 0); }
+     ]])],[
+       vim_cv_stat_ignores_slash=yes
+     ],[
+       vim_cv_stat_ignores_slash=no
+     ],[
+       AC_MSG_ERROR(cross-compiling: please set 'vim_cv_stat_ignores_slash')
+     ])
+   ])
+ 
+ if test "x$vim_cv_stat_ignores_slash" = "xyes" ; then
+   AC_DEFINE(STAT_IGNORES_SLASH)
+ fi
+   
+ dnl Link with iconv for charset translation, if not found without library.
+ dnl check for iconv() requires including iconv.h
+ dnl Add "-liconv" when possible; Solaris has iconv but use GNU iconv when it
+ dnl has been installed.
+ AC_MSG_CHECKING(for iconv_open())
+ save_LIBS="$LIBS"
+ LIBS="$LIBS -liconv"
+ AC_TRY_LINK([
+ #ifdef HAVE_ICONV_H
+ # include <iconv.h>
+ #endif
+     ], [iconv_open("fr", "to");],
+     AC_MSG_RESULT(yes; with -liconv); AC_DEFINE(HAVE_ICONV),
+     LIBS="$save_LIBS"
+     AC_TRY_LINK([
+ #ifdef HAVE_ICONV_H
+ # include <iconv.h>
+ #endif
+ 	], [iconv_open("fr", "to");],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ICONV),
+ 	AC_MSG_RESULT(no)))
+ 
+ 
+ AC_MSG_CHECKING(for nl_langinfo(CODESET))
+ AC_TRY_LINK([
+ #ifdef HAVE_LANGINFO_H
+ # include <langinfo.h>
+ #endif
+ ], [char *cs = nl_langinfo(CODESET);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_NL_LANGINFO_CODESET),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Need various functions for floating point support.  Only enable
+ dnl floating point when they are all present.
+ AC_CHECK_LIB(m, strtod)
+ AC_MSG_CHECKING([for strtod() and other floating point functions])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [char *s; double d;
+     d = strtod("1.1", &s);
+     d = fabs(1.11);
+     d = ceil(1.11);
+     d = floor(1.11);
+     d = log10(1.11);
+     d = pow(1.11, 2.22);
+     d = sqrt(1.11);
+     d = sin(1.11);
+     d = cos(1.11);
+     d = atan(1.11);
+     ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FLOAT_FUNCS),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl isinf() and isnan() need to include header files and may need -lm.
+ AC_MSG_CHECKING([for isinf()])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [int r = isinf(1.11); ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISINF),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_MSG_CHECKING([for isnan()])
+ AC_TRY_LINK([
+ #ifdef HAVE_MATH_H
+ # include <math.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ ], [int r = isnan(1.11); ],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_ISNAN),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl Link with -lposix1e for ACL stuff; if not found, try -lacl for SGI
+ dnl when -lacl works, also try to use -lattr (required for Debian).
+ dnl On Solaris, use the acl_get/set functions in libsec, if present.
+ AC_MSG_CHECKING(--disable-acl argument)
+ AC_ARG_ENABLE(acl,
+ 	[  --disable-acl           Don't check for ACL support.],
+ 	, [enable_acl="yes"])
+ if test "$enable_acl" = "yes"; then
+ AC_MSG_RESULT(no)
+ AC_CHECK_LIB(posix1e, acl_get_file, [LIBS="$LIBS -lposix1e"],
+ 	AC_CHECK_LIB(acl, acl_get_file, [LIBS="$LIBS -lacl"
+ 		  AC_CHECK_LIB(attr, fgetxattr, LIBS="$LIBS -lattr",,)],,),)
+ 
+ AC_MSG_CHECKING(for POSIX ACL support)
+ AC_TRY_LINK([
+ #include <sys/types.h>
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif
+ acl_t acl;], [acl = acl_get_file("foo", ACL_TYPE_ACCESS);
+ 	acl_set_file("foo", ACL_TYPE_ACCESS, acl);
+ 	acl_free(acl);],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_POSIX_ACL),
+ 	AC_MSG_RESULT(no))
+ 
+ AC_CHECK_LIB(sec, acl_get, [LIBS="$LIBS -lsec"; AC_DEFINE(HAVE_SOLARIS_ZFS_ACL)],
+ AC_MSG_CHECKING(for Solaris ACL support)
+ AC_TRY_LINK([
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif], [acl("foo", GETACLCNT, 0, NULL);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SOLARIS_ACL),
+ 	AC_MSG_RESULT(no)))
+ 
+ AC_MSG_CHECKING(for AIX ACL support)
+ AC_TRY_LINK([
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ #ifdef HAVE_SYS_ACL_H
+ # include <sys/acl.h>
+ #endif
+ #ifdef HAVE_SYS_ACCESS_H
+ # include <sys/access.h>
+ #endif
+ #define _ALL_SOURCE
+ 
+ #include <sys/stat.h>
+ 
+ int aclsize;
+ struct acl *aclent;], [aclsize = sizeof(struct acl);
+ 	aclent = (void *)malloc(aclsize);
+ 	statacl("foo", STX_NORMAL, aclent, aclsize);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_AIX_ACL),
+ 	AC_MSG_RESULT(no))
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ if test "x$GTK_CFLAGS" != "x"; then
+   dnl pango_shape_full() is new, fall back to pango_shape().
+   AC_MSG_CHECKING(for pango_shape_full)
+   ac_save_CFLAGS="$CFLAGS"
+   ac_save_LIBS="$LIBS"
+   CFLAGS="$CFLAGS $GTK_CFLAGS"
+   LIBS="$LIBS $GTK_LIBS"
+   AC_TRY_LINK(
+   [#include <gtk/gtk.h>],
+   [ pango_shape_full(NULL, 0, NULL, 0, NULL, NULL); ],
+ 	  AC_MSG_RESULT(yes); AC_DEFINE(HAVE_PANGO_SHAPE_FULL),
+ 	  AC_MSG_RESULT(no))
+   CFLAGS="$ac_save_CFLAGS"
+   LIBS="$ac_save_LIBS"
+ fi
+ 
+ AC_MSG_CHECKING(--disable-gpm argument)
+ AC_ARG_ENABLE(gpm,
+ 	[  --disable-gpm           Don't use gpm (Linux mouse daemon).], ,
+ 	[enable_gpm="yes"])
+ 
+ if test "$enable_gpm" = "yes"; then
+   AC_MSG_RESULT(no)
+   dnl Checking if gpm support can be compiled
+   AC_CACHE_CHECK([for gpm], vi_cv_have_gpm,
+ 	[olibs="$LIBS" ; LIBS="-lgpm"]
+ 	AC_TRY_LINK(
+ 	    [#include <gpm.h>
+ 	    #include <linux/keyboard.h>],
+ 	    [Gpm_GetLibVersion(NULL);],
+ 	    dnl Configure defines HAVE_GPM, if it is defined feature.h defines
+ 	    dnl FEAT_MOUSE_GPM if mouse support is included
+ 	    [vi_cv_have_gpm=yes],
+ 	    [vi_cv_have_gpm=no])
+ 	[LIBS="$olibs"]
+     )
+   if test $vi_cv_have_gpm = yes; then
+     LIBS="$LIBS -lgpm"
+     AC_DEFINE(HAVE_GPM)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ AC_MSG_CHECKING(--disable-sysmouse argument)
+ AC_ARG_ENABLE(sysmouse,
+ 	[  --disable-sysmouse    Don't use sysmouse (mouse in *BSD console).], ,
+ 	[enable_sysmouse="yes"])
+ 
+ if test "$enable_sysmouse" = "yes"; then
+   AC_MSG_RESULT(no)
+   dnl Checking if sysmouse support can be compiled
+   dnl Configure defines HAVE_SYSMOUSE, if it is defined feature.h
+   dnl defines FEAT_SYSMOUSE if mouse support is included
+   AC_CACHE_CHECK([for sysmouse], vi_cv_have_sysmouse,
+ 	AC_TRY_LINK(
+ 	    [#include <sys/consio.h>
+ 	     #include <signal.h>
+ 	     #include <sys/fbio.h>],
+ 	    [struct mouse_info   mouse;
+ 	     mouse.operation = MOUSE_MODE;
+ 	     mouse.operation = MOUSE_SHOW;
+ 	     mouse.u.mode.mode = 0;
+ 	     mouse.u.mode.signal = SIGUSR2;],
+ 	    [vi_cv_have_sysmouse=yes],
+ 	    [vi_cv_have_sysmouse=no])
+     )
+   if test $vi_cv_have_sysmouse = yes; then
+     AC_DEFINE(HAVE_SYSMOUSE)
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl make sure the FD_CLOEXEC flag for fcntl()'s F_SETFD command is known
+ AC_MSG_CHECKING(for FD_CLOEXEC)
+ AC_TRY_COMPILE(
+ [#if HAVE_FCNTL_H
+ # include <fcntl.h>
+ #endif],
+ [	int flag = FD_CLOEXEC;],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_FD_CLOEXEC),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl rename needs to be checked separately to work on Nextstep with cc
+ AC_MSG_CHECKING(for rename)
+ AC_TRY_LINK([#include <stdio.h>], [rename("this", "that")],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_RENAME),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl sysctl() may exist but not the arguments we use
+ AC_MSG_CHECKING(for sysctl)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysctl.h>],
+ [	int mib[2], r;
+ 	size_t len;
+ 
+ 	mib[0] = CTL_HW;
+ 	mib[1] = HW_USERMEM;
+ 	len = sizeof(r);
+ 	(void)sysctl(mib, 2, &r, &len, (void *)0, (size_t)0);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCTL),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl sysinfo() may exist but not be Linux compatible
+ AC_MSG_CHECKING(for sysinfo)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysinfo.h>],
+ [	struct sysinfo sinfo;
+ 	int t;
+ 
+ 	(void)sysinfo(&sinfo);
+ 	t = sinfo.totalram;
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO),
+ 	AC_MSG_RESULT(not usable))
+ 
+ dnl struct sysinfo may have the mem_unit field or not
+ AC_MSG_CHECKING(for sysinfo.mem_unit)
+ AC_TRY_COMPILE(
+ [#include <sys/types.h>
+ #include <sys/sysinfo.h>],
+ [	struct sysinfo sinfo;
+ 	sinfo.mem_unit = 1;
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSINFO_MEM_UNIT),
+ 	AC_MSG_RESULT(no))
+ 
+ dnl sysconf() may exist but not support what we want to use
+ AC_MSG_CHECKING(for sysconf)
+ AC_TRY_COMPILE(
+ [#include <unistd.h>],
+ [	(void)sysconf(_SC_PAGESIZE);
+ 	(void)sysconf(_SC_PHYS_PAGES);
+ 	],
+ 	AC_MSG_RESULT(yes); AC_DEFINE(HAVE_SYSCONF),
+ 	AC_MSG_RESULT(not usable))
+ 
+ AC_CHECK_SIZEOF([int])
+ AC_CHECK_SIZEOF([long])
+ AC_CHECK_SIZEOF([time_t])
+ AC_CHECK_SIZEOF([off_t])
+ 
+ dnl Use different names to avoid clashing with other header files.
+ AC_DEFINE_UNQUOTED(VIM_SIZEOF_INT, [$ac_cv_sizeof_int])
+ AC_DEFINE_UNQUOTED(VIM_SIZEOF_LONG, [$ac_cv_sizeof_long])
+ 
+ dnl Make sure that uint32_t is really 32 bits unsigned.
+ AC_MSG_CHECKING([uint32_t is 32 bits])
+ AC_TRY_RUN([
+ #ifdef HAVE_STDINT_H
+ # include <stdint.h>
+ #endif
+ #ifdef HAVE_INTTYPES_H
+ # include <inttypes.h>
+ #endif
+ main() {
+   uint32_t nr1 = (uint32_t)-1;
+   uint32_t nr2 = (uint32_t)0xffffffffUL;
+   if (sizeof(uint32_t) != 4 || nr1 != 0xffffffffUL || nr2 + 1 != 0) exit(1);
+   exit(0);
+ }],
+ AC_MSG_RESULT(ok),
+ AC_MSG_ERROR([WRONG!  uint32_t not defined correctly.]),
+ AC_MSG_WARN([cannot check uint32_t when cross-compiling.]))
+ 
+ dnl Check for memmove() before bcopy(), makes memmove() be used when both are
+ dnl present, fixes problem with incompatibility between Solaris 2.4 and 2.5.
+ 
+ [bcopy_test_prog='
+ #include "confdefs.h"
+ #ifdef HAVE_STRING_H
+ # include <string.h>
+ #endif
+ #if STDC_HEADERS
+ # include <stdlib.h>
+ # include <stddef.h>
+ #endif
+ main() {
+   char buf[10];
+   strcpy(buf, "abcdefghi");
+   mch_memmove(buf, buf + 2, 3);
+   if (strncmp(buf, "ababcf", 6))
+     exit(1);
+   strcpy(buf, "abcdefghi");
+   mch_memmove(buf + 2, buf, 3);
+   if (strncmp(buf, "cdedef", 6))
+     exit(1);
+   exit(0); /* libc version works properly.  */
+ }']
+ 
+ AC_CACHE_CHECK([whether memmove handles overlaps],[vim_cv_memmove_handles_overlap],
+   [
+     AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memmove(s,d,l) memmove(d,s,l) $bcopy_test_prog]])],
+       [
+ 	vim_cv_memmove_handles_overlap=yes
+       ],[
+ 	vim_cv_memmove_handles_overlap=no
+       ],[
+ 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memmove_handles_overlap')
+       ])
+   ])
+ 
+ if test "x$vim_cv_memmove_handles_overlap" = "xyes" ; then
+   AC_DEFINE(USEMEMMOVE)
+ else
+   AC_CACHE_CHECK([whether bcopy handles overlaps],[vim_cv_bcopy_handles_overlap],
+     [
+       AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_bcopy(s,d,l) bcopy(d,s,l) $bcopy_test_prog]])],
+       [
+ 	vim_cv_bcopy_handles_overlap=yes
+       ],[
+ 	vim_cv_bcopy_handles_overlap=no
+       ],[
+ 	AC_MSG_ERROR(cross-compiling: please set 'vim_cv_bcopy_handles_overlap')
+       ])
+     ])
+ 
+   if test "x$vim_cv_bcopy_handles_overlap" = "xyes" ; then
+     AC_DEFINE(USEBCOPY)
+   else
+     AC_CACHE_CHECK([whether memcpy handles overlaps],[vim_cv_memcpy_handles_overlap],
+       [
+ 	AC_RUN_IFELSE([AC_LANG_SOURCE([[#define mch_memcpy(s,d,l) memcpy(d,s,l) $bcopy_test_prog]])],
+ 	  [
+ 	    vim_cv_memcpy_handles_overlap=yes
+ 	  ],[
+ 	    vim_cv_memcpy_handles_overlap=no
+ 	  ],[
+ 	    AC_MSG_ERROR(cross-compiling: please set 'vim_cv_memcpy_handles_overlap')
+ 	  ])
+       ])
+ 
+     if test "x$vim_cv_memcpy_handles_overlap" = "xyes" ; then
+       AC_DEFINE(USEMEMCPY)
+     fi
+   fi
+ fi
+ 
+ 
+ dnl Check for multibyte locale functions
+ dnl Find out if _Xsetlocale() is supported by libX11.
+ dnl Check if X_LOCALE should be defined.
+ if test "x$with_x" = "xyes"; then
+   cflags_save=$CFLAGS
+   libs_save=$LIBS
+   LIBS="$LIBS $X_LIBS $GUI_LIB_LOC $GUI_X_LIBS $X_PRE_LIBS $X_LIB $X_EXTRA_LIBS"
+   CFLAGS="$CFLAGS $X_CFLAGS"
+ 
+   AC_MSG_CHECKING(whether X_LOCALE needed)
+   AC_TRY_COMPILE([#include <X11/Xlocale.h>],,
+       AC_TRY_LINK_FUNC([_Xsetlocale], [AC_MSG_RESULT(yes)
+ 	      AC_DEFINE(X_LOCALE)], AC_MSG_RESULT(no)),
+       AC_MSG_RESULT(no))
+ 
+   AC_MSG_CHECKING(whether Xutf8SetWMProperties() can be used)
+   AC_TRY_LINK_FUNC([Xutf8SetWMProperties], [AC_MSG_RESULT(yes)
+ 	      AC_DEFINE(HAVE_XUTF8SETWMPROPERTIES)], AC_MSG_RESULT(no))
+ 
+   CFLAGS=$cflags_save
+   LIBS=$libs_save
+ fi
+ 
+ dnl Link with xpg4, it is said to make Korean locale working
+ AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
+ 
+ dnl Check how we can run ctags.  Default to "ctags" when nothing works.
+ dnl Use --version to detect Exuberant ctags (preferred)
+ dnl       Add --fields=+S to get function signatures for omni completion.
+ dnl -t for typedefs (many ctags have this)
+ dnl -s for static functions (Elvis ctags only?)
+ dnl -v for variables. Dangerous, most ctags take this for 'vgrind style'.
+ dnl -i+m to test for older Exuberant ctags
+ AC_MSG_CHECKING(how to create tags)
+ test -f tags && mv tags tags.save
+ if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="ctags -I INIT+ --fields=+S"
+ elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="exctags -I INIT+ --fields=+S"
+ elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+   TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
+ else
+   TAGPRG="ctags"
+   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
+   (eval etags -c   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags -c"
+   (eval ctags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags"
+   (eval ctags -t   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -t"
+   (eval ctags -ts  /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -ts"
+   (eval ctags -tvs /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -tvs"
+   (eval ctags -i+m /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="ctags -i+m"
+ fi
+ test -f tags.save && mv tags.save tags
+ AC_MSG_RESULT($TAGPRG) AC_SUBST(TAGPRG)
+ 
+ dnl Check how we can run man with a section number
+ AC_MSG_CHECKING(how to run man with a section nr)
+ MANDEF="man"
+ (eval MANPAGER=cat PAGER=cat man -s 2 read) < /dev/null > /dev/null 2>&AC_FD_CC && MANDEF="man -s"
+ AC_MSG_RESULT($MANDEF)
+ if test "$MANDEF" = "man -s"; then
+   AC_DEFINE(USEMAN_S)
+ fi
+ 
+ dnl Check if gettext() is working and if it needs -lintl
+ dnl We take care to base this on an empty LIBS: on some systems libelf would be
+ dnl in LIBS and implicitly take along libintl. The final LIBS would then not
+ dnl contain libintl, and the link step would fail due to -Wl,--as-needed.
+ AC_MSG_CHECKING(--disable-nls argument)
+ AC_ARG_ENABLE(nls,
+ 	[  --disable-nls           Don't support NLS (gettext()).], ,
+ 	[enable_nls="yes"])
+ 
+ if test "$enable_nls" = "yes"; then
+   AC_MSG_RESULT(no)
+ 
+   INSTALL_LANGS=install-languages
+   AC_SUBST(INSTALL_LANGS)
+   INSTALL_TOOL_LANGS=install-tool-languages
+   AC_SUBST(INSTALL_TOOL_LANGS)
+ 
+   AC_CHECK_PROG(MSGFMT, msgfmt, msgfmt, )
+   AC_MSG_CHECKING([for NLS])
+   if test -f po/Makefile; then
+     have_gettext="no"
+     if test -n "$MSGFMT"; then
+       olibs=$LIBS
+       LIBS=""
+       AC_TRY_LINK(
+ 	[#include <libintl.h>],
+ 	[gettext("Test");],
+ 	AC_MSG_RESULT([gettext() works]); have_gettext="yes"; LIBS=$olibs,
+ 	  LIBS="-lintl"
+ 	  AC_TRY_LINK(
+ 	      [#include <libintl.h>],
+ 	      [gettext("Test");],
+ 	      AC_MSG_RESULT([gettext() works with -lintl]); have_gettext="yes";
+ 	      LIBS="$olibs -lintl",
+ 	      AC_MSG_RESULT([gettext() doesn't work]);
+ 	      LIBS=$olibs))
+     else
+       AC_MSG_RESULT([msgfmt not found - disabled]);
+     fi
+     if test $have_gettext = "yes" -a "x$features" != "xtiny" -a "x$features" != "xsmall"; then
+       AC_DEFINE(HAVE_GETTEXT)
+       MAKEMO=yes
+       AC_SUBST(MAKEMO)
+       dnl this was added in GNU gettext 0.10.36
+       AC_CHECK_FUNCS(bind_textdomain_codeset)
+       dnl _nl_msg_cat_cntr is required for GNU gettext
+       AC_MSG_CHECKING([for _nl_msg_cat_cntr])
+       AC_TRY_LINK(
+ 		[#include <libintl.h>
+ 		extern int _nl_msg_cat_cntr;],
+ 		[++_nl_msg_cat_cntr;],
+ 		AC_MSG_RESULT([yes]); AC_DEFINE(HAVE_NL_MSG_CAT_CNTR),
+ 		AC_MSG_RESULT([no]))
+     fi
+   else
+     AC_MSG_RESULT([no "po/Makefile" - disabled]);
+   fi
+ else
+   AC_MSG_RESULT(yes)
+ fi
+ 
+ dnl Check for dynamic linking loader
+ AC_CHECK_HEADER(dlfcn.h, DLL=dlfcn.h, [AC_CHECK_HEADER(dl.h, DLL=dl.h)])
+ if test x${DLL} = xdlfcn.h; then
+   AC_DEFINE(HAVE_DLFCN_H, 1, [ Define if we have dlfcn.h. ])
+   AC_MSG_CHECKING([for dlopen()])
+   AC_TRY_LINK(,[
+ 		extern void* dlopen();
+ 		dlopen();
+       ],
+       AC_MSG_RESULT(yes);
+ 	      AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+       AC_MSG_RESULT(no);
+ 	      AC_MSG_CHECKING([for dlopen() in -ldl])
+ 	      olibs=$LIBS
+ 	      LIBS="$LIBS -ldl"
+ 	      AC_TRY_LINK(,[
+ 				extern void* dlopen();
+ 				dlopen();
+ 		 ],
+ 		 AC_MSG_RESULT(yes);
+ 			  AC_DEFINE(HAVE_DLOPEN, 1, [ Define if we have dlopen() ]),
+ 		 AC_MSG_RESULT(no);
+ 			  LIBS=$olibs))
+   dnl ReliantUNIX has dlopen() in libc but everything else in libdl
+   dnl ick :-)
+   AC_MSG_CHECKING([for dlsym()])
+   AC_TRY_LINK(,[
+ 		extern void* dlsym();
+ 		dlsym();
+       ],
+       AC_MSG_RESULT(yes);
+ 	      AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+       AC_MSG_RESULT(no);
+ 	      AC_MSG_CHECKING([for dlsym() in -ldl])
+ 	      olibs=$LIBS
+ 	      LIBS="$LIBS -ldl"
+ 	      AC_TRY_LINK(,[
+ 				extern void* dlsym();
+ 				dlsym();
+ 		 ],
+ 		 AC_MSG_RESULT(yes);
+ 			  AC_DEFINE(HAVE_DLSYM, 1, [ Define if we have dlsym() ]),
+ 		 AC_MSG_RESULT(no);
+ 			  LIBS=$olibs))
+ elif test x${DLL} = xdl.h; then
+   AC_DEFINE(HAVE_DL_H, 1, [ Define if we have dl.h. ])
+   AC_MSG_CHECKING([for shl_load()])
+   AC_TRY_LINK(,[
+ 		extern void* shl_load();
+ 		shl_load();
+      ],
+      AC_MSG_RESULT(yes);
+ 	  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+      AC_MSG_RESULT(no);
+ 	  AC_MSG_CHECKING([for shl_load() in -ldld])
+ 	  olibs=$LIBS
+ 	  LIBS="$LIBS -ldld"
+ 	  AC_TRY_LINK(,[
+ 			extern void* shl_load();
+ 			shl_load();
+ 	     ],
+ 	     AC_MSG_RESULT(yes);
+ 		  AC_DEFINE(HAVE_SHL_LOAD, 1, [ Define if we have shl_load() ]),
+ 	     AC_MSG_RESULT(no);
+ 		  LIBS=$olibs))
+ fi
+ AC_CHECK_HEADERS(setjmp.h)
+ 
+ if test "x$MACOSX" = "xyes" -a -n "$PERL"; then
+   dnl -ldl must come after DynaLoader.a
+   if echo $LIBS | grep -e '-ldl' >/dev/null; then
+     LIBS=`echo $LIBS | sed s/-ldl//`
+     PERL_LIBS="$PERL_LIBS -ldl"
+   fi
+ fi
+ 
+ if test "x$MACOSX" = "xyes"; then
+   AC_MSG_CHECKING(whether we need -framework Cocoa)
+   dnl Cocoa is needed with FEAT_CLIPBOARD or FEAT_MBYTE (the former is
+   dnl disabled during tiny build)
+   if test "x$features" != "xtiny" || test "x$enable_multibyte" = "xyes"; then
+     LIBS=$"$LIBS -framework Cocoa"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+   dnl As mentioned above, tiny build implies os_macosx.m isn't needed.  
+   dnl Exclude it from OS_EXTRA_SRC so that linker won't complain about
+   dnl missing Objective-C symbols.
+   if test "x$features" = "xtiny"; then
+     OS_EXTRA_SRC=`echo "$OS_EXTRA_SRC" | sed -e 's+os_macosx.m++'`
+     OS_EXTRA_OBJ=`echo "$OS_EXTRA_OBJ" | sed -e 's+objects/os_macosx.o++'`
+   fi
+ fi
+ if test "x$MACARCH" = "xboth" && test "x$GUITYPE" = "xCARBONGUI"; then
+   LDFLAGS="$LDFLAGS -isysroot $DEVELOPER_DIR/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc"
+ fi
+ 
+ dnl gcc 3.1 changed the meaning of -MM.  The only solution appears to be to
+ dnl use "-isystem" instead of "-I" for all non-Vim include dirs.
+ dnl But only when making dependencies, cproto and lint don't take "-isystem".
+ dnl Mac gcc returns "powerpc-apple-darwin8-gcc-4.0.1 (GCC)...", need to allow
+ dnl the number before the version number.
+ DEPEND_CFLAGS_FILTER=
+ if test "$GCC" = yes; then
+   AC_MSG_CHECKING(for GCC 3 or later)
+   gccmajor=`echo "$gccversion" | sed -e 's/^\([[1-9]]\)\..*$/\1/g'`
+   if test "$gccmajor" -gt "2"; then
+     DEPEND_CFLAGS_FILTER="| sed 's+-I */+-isystem /+g'"
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+   dnl -D_FORTIFY_SOURCE=2 crashes Vim on strcpy(buf, "000") when buf is
+   dnl declared as char x[1] but actually longer.  Introduced in gcc 4.0.
+   dnl Also remove duplicate _FORTIFY_SOURCE arguments.
+   dnl And undefine it first to avoid a warning.
+   AC_MSG_CHECKING(whether we need -D_FORTIFY_SOURCE=1)
+   if test "$gccmajor" -gt "3"; then
+     CFLAGS=`echo "$CFLAGS" | sed -e 's/ *-Wp,-D_FORTIFY_SOURCE=.//g' -e 's/ *-D_FORTIFY_SOURCE=.//g' -e 's/ *-U_FORTIFY_SOURCE//g' -e 's/$/ -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1/'`
+     AC_MSG_RESULT(yes)
+   else
+     AC_MSG_RESULT(no)
+   fi
+ fi
+ AC_SUBST(DEPEND_CFLAGS_FILTER)
+ 
+ dnl link.sh tries to avoid overlinking in a hackish way.
+ dnl At least GNU ld supports --as-needed which provides the same functionality
+ dnl at linker level. Let's use it.
+ AC_MSG_CHECKING(linker --as-needed support)
+ LINK_AS_NEEDED=
+ # Check if linker supports --as-needed and --no-as-needed options
+ if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+   LDFLAGS=`echo "$LDFLAGS" | sed -e 's/ *-Wl,--as-needed//g' | sed -e 's/$/ -Wl,--as-needed/'`
+   LINK_AS_NEEDED=yes
+ fi
+ if test "$LINK_AS_NEEDED" = yes; then
+   AC_MSG_RESULT(yes)
+ else
+   AC_MSG_RESULT(no)
+ fi
+ AC_SUBST(LINK_AS_NEEDED)
+ 
+ # IBM z/OS reset CFLAGS for config.mk
+ if test "$zOSUnix" = "yes"; then
+ 	CFLAGS="-D_ALL_SOURCE -Wc,float\(ieee\),dll"
+ fi
+ 
+ dnl write output files
+ AC_OUTPUT(auto/config.mk:config.mk.in)
+ 
+ dnl vim: set sw=2 tw=78 fo+=l:
*** ../vim-8.0.0081/Filelist	2016-08-28 20:13:39.000000000 +0200
--- Filelist	2016-11-12 20:12:35.618728568 +0100
***************
*** 207,213 ****
  		src/config.mk.dist \
  		src/config.mk.in \
  		src/configure \
! 		src/configure.in \
  		src/gui_at_fs.c \
  		src/gui_at_sb.c \
  		src/gui_at_sb.h \
--- 207,213 ----
  		src/config.mk.dist \
  		src/config.mk.in \
  		src/configure \
! 		src/configure.ac \
  		src/gui_at_fs.c \
  		src/gui_at_sb.c \
  		src/gui_at_sb.h \
*** ../vim-8.0.0081/src/Makefile	2016-11-10 20:01:41.201582868 +0100
--- src/Makefile	2016-11-12 20:11:51.591020603 +0100
***************
*** 690,697 ****
  #####################################################
  
  ### Uncomment things here only if the values chosen by configure are wrong.
! ### It's better to adjust configure.in and "make autoconf", if you can!
! ### Then send the required changes to configure.in to the bugs list.
  
  ### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries
  ###
--- 690,697 ----
  #####################################################
  
  ### Uncomment things here only if the values chosen by configure are wrong.
! ### It's better to adjust configure.ac and "make autoconf", if you can!
! ### Then send the required changes to configure.ac to the bugs list.
  
  ### (1) BSD/OS 2.0.1, 2.1 or 3.0 using shared libraries
  ###
***************
*** 1832,1838 ****
  # - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of
  #   producing auto/configure.
  # - autoconf is not run automatically, because a patch usually changes both
! #   configure.in and auto/configure but can't update the timestamps.  People
  #   who do not have (the correct version of) autoconf would run into trouble.
  #
  # Two tricks are required to make autoconf put its output in the "auto" dir:
--- 1832,1838 ----
  # - DO NOT RUN autoconf MANUALLY!  It will overwrite ./configure instead of
  #   producing auto/configure.
  # - autoconf is not run automatically, because a patch usually changes both
! #   configure.ac and auto/configure but can't update the timestamps.  People
  #   who do not have (the correct version of) autoconf would run into trouble.
  #
  # Two tricks are required to make autoconf put its output in the "auto" dir:
*** ../vim-8.0.0081/src/blowfish.c	2016-11-10 20:01:41.181582995 +0100
--- src/blowfish.c	2016-11-12 20:08:09.272496358 +0100
***************
*** 38,44 ****
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
!    /* in configure.in AC_C_BIGENDIAN() defines WORDS_BIGENDIAN when needed */
  # else
     error!
     Please change this code to define WORDS_BIGENDIAN for big-endian machines.
--- 38,44 ----
    /* MS-Windows is always little endian */
  #else
  # ifdef HAVE_CONFIG_H
!    /* in configure.ac AC_C_BIGENDIAN() defines WORDS_BIGENDIAN when needed */
  # else
     error!
     Please change this code to define WORDS_BIGENDIAN for big-endian machines.
*** ../vim-8.0.0081/src/channel.c	2016-11-11 21:13:56.836753930 +0100
--- src/channel.c	2016-11-12 20:08:27.040378345 +0100
***************
*** 19,25 ****
  # define CH_HAS_GUI (gui.in_use || gui.starting)
  #endif
  
! /* Note: when making changes here also adjust configure.in. */
  #ifdef WIN32
  /* WinSock API is separated from C API, thus we can't use read(), write(),
   * errno... */
--- 19,25 ----
  # define CH_HAS_GUI (gui.in_use || gui.starting)
  #endif
  
! /* Note: when making changes here also adjust configure.ac. */
  #ifdef WIN32
  /* WinSock API is separated from C API, thus we can't use read(), write(),
   * errno... */
*** ../vim-8.0.0081/src/config.h.in	2016-10-18 16:27:20.540756047 +0200
--- src/config.h.in	2016-11-12 20:09:15.712055133 +0100
***************
*** 1,6 ****
  /*
!  * config.h.in.  Generated automatically from configure.in by autoheader, and
!  * manually changed after that.
   */
  
  /* Define if we have EBCDIC code */
--- 1,6 ----
  /*
!  * config.h.in.  Originally generated automatically from configure.ac by
!  * autoheader and manually changed after that.
   */
  
  /* Define if we have EBCDIC code */
*** ../vim-8.0.0081/src/main.aap	2016-09-25 21:44:59.441600148 +0200
--- src/main.aap	2016-11-12 20:10:45.471459311 +0100
***************
*** 22,32 ****
      # A U T O C O N F
      #
  
!     # Run autoconf when configure.in has been changed since it was last run.
      # This is skipped when the signatures in "mysign" are up-to-date.  When
      # there is no autoconf program skip this (the signature is often the only
      # thing that's outdated)
!     auto/configure {signfile = mysign} : configure.in
          @if not program_path("autoconf"):
              :print Can't find autoconf, using existing configure script.
          @else:
--- 22,32 ----
      # A U T O C O N F
      #
  
!     # Run autoconf when configure.ac has been changed since it was last run.
      # This is skipped when the signatures in "mysign" are up-to-date.  When
      # there is no autoconf program skip this (the signature is often the only
      # thing that's outdated)
!     auto/configure {signfile = mysign} : configure.ac
          @if not program_path("autoconf"):
              :print Can't find autoconf, using existing configure script.
          @else:
*** ../vim-8.0.0081/src/os_unix.c	2016-11-07 22:42:48.828350757 +0100
--- src/os_unix.c	2016-11-12 20:11:05.415326964 +0100
***************
*** 265,271 ****
   * that describe the signals. That is nearly what we want here.  But
   * autoconf does only check for sys_siglist (without the underscore), I
   * do not want to change everything today.... jw.
!  * This is why AC_DECL_SYS_SIGLIST is commented out in configure.in
   */
  #endif
  
--- 265,271 ----
   * that describe the signals. That is nearly what we want here.  But
   * autoconf does only check for sys_siglist (without the underscore), I
   * do not want to change everything today.... jw.
!  * This is why AC_DECL_SYS_SIGLIST is commented out in configure.ac.
   */
  #endif
  
*** ../vim-8.0.0081/src/INSTALL	2016-04-12 22:44:00.000000000 +0200
--- src/INSTALL	2016-11-12 20:11:25.459193970 +0100
***************
*** 221,228 ****
  be considered for the next release.  If at some point `config.cache'
  contains results you don't want to keep, you may remove or edit it.
  
!    The file `configure.in' is used to create `configure' by a program
! called `autoconf'.  You only need `configure.in' if you want to change
  it or regenerate `configure' using a newer version of `autoconf'.
  
  The simplest way to compile this package is:
--- 221,228 ----
  be considered for the next release.  If at some point `config.cache'
  contains results you don't want to keep, you may remove or edit it.
  
!    The file `configure.ac' is used to create `configure' by a program
! called `autoconf'.  You only need `configure.ac' if you want to change
  it or regenerate `configure' using a newer version of `autoconf'.
  
  The simplest way to compile this package is:
*** ../vim-8.0.0081/src/mysign	2010-05-15 13:04:12.000000000 +0200
--- src/mysign	2016-11-12 21:01:30.478617518 +0100
***************
*** 1 ****
! =auto/configure-lastupdate=1178970549.78-@buildcheck=dfc15c059b7ce88a951584995c49a201=configure.in@md5=e0d6e9a7d7b986d63ce4e8e7362fd0b9
--- 1 ----
! =auto/configure-lastupdate=1178970549.78-@buildcheck=dfc15c059b7ce88a951584995c49a201=configure.ac@md5=e0d6e9a7d7b986d63ce4e8e7362fd0b9
*** ../vim-8.0.0081/src/version.c	2016-11-12 19:16:42.216999886 +0100
--- src/version.c	2016-11-12 20:06:39.673091660 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     82,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
27. You refer to your age as 3.x.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0083
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0083
Problem:    Using freed memory with win_getid(). (Domenique Pelle)
Solution:   For the current tab use curwin.
Files:      src/window.c, src/testdir/test_window_id.vim


*** ../vim-8.0.0082/src/window.c	2016-11-10 20:01:41.201582868 +0100
--- src/window.c	2016-11-13 14:30:24.411958067 +0100
***************
*** 7133,7139 ****
  		    break;
  	    if (tp == NULL)
  		return -1;
! 	    wp = tp->tp_firstwin;
  	}
  	for ( ; wp != NULL; wp = wp->w_next)
  	    if (--winnr == 0)
--- 7133,7142 ----
  		    break;
  	    if (tp == NULL)
  		return -1;
! 	    if (tp == curtab)
! 		wp = firstwin;
! 	    else
! 		wp = tp->tp_firstwin;
  	}
  	for ( ; wp != NULL; wp = wp->w_next)
  	    if (--winnr == 0)
*** ../vim-8.0.0082/src/testdir/test_window_id.vim	2016-06-04 18:45:17.000000000 +0200
--- src/testdir/test_window_id.vim	2016-11-13 14:25:47.545713017 +0100
***************
*** 92,94 ****
--- 92,103 ----
  
    only!
  endfunc
+ 
+ func Test_win_getid_curtab()
+   tabedit X
+   tabfirst
+   copen
+   only
+   call assert_equal(win_getid(1), win_getid(1, 1))
+   tabclose!
+ endfunc
*** ../vim-8.0.0082/src/version.c	2016-11-12 21:12:48.538182233 +0100
--- src/version.c	2016-11-13 14:29:18.912373539 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     83,
  /**/

-- 
Bypasses are devices that allow some people to dash from point A to
point B very fast while other people dash from point B to point A very
fast.  People living at point C, being a point directly in between, are
often given to wonder what's so great about point A that so many people
from point B are so keen to get there and what's so great about point B
that so many people from point A are so keen to get there.  They often
wish that people would just once and for all work out where the hell
they wanted to be.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0084
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0084
Problem:    Using freed memory when adding to a quickfix list. (Domenique
            Pelle)
Solution:   Clear the directory name.
Files:      src/quicfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0083/src/quickfix.c	2016-11-12 18:14:39.605896756 +0100
--- src/quickfix.c	2016-11-13 15:02:08.327755407 +0100
***************
*** 1617,1623 ****
  static bufref_T  qf_last_bufref = {NULL, 0};
  
  /*
!  * Get buffer number for file "directory.fname".
   * Also sets the b_has_qf_entry flag.
   */
      static int
--- 1617,1623 ----
  static bufref_T  qf_last_bufref = {NULL, 0};
  
  /*
!  * Get buffer number for file "directory/fname".
   * Also sets the b_has_qf_entry flag.
   */
      static int
***************
*** 2711,2717 ****
--- 2711,2719 ----
      qi->qf_lists[idx].qf_index = 0;
  
      qf_clean_dir_stack(&qi->qf_dir_stack);
+     qi->qf_directory = NULL;
      qf_clean_dir_stack(&qi->qf_file_stack);
+     qi->qf_currfile = NULL;
  }
  
  /*
*** ../vim-8.0.0083/src/testdir/test_quickfix.vim	2016-11-12 18:14:39.609896729 +0100
--- src/testdir/test_quickfix.vim	2016-11-13 14:52:16.099512635 +0100
***************
*** 1669,1671 ****
--- 1669,1693 ----
    call assert_fails('caddexpr ""', 'E376:')
    let &efm = save_efm
  endfunc
+ 
+ func Test_dirstack_cleanup()
+   " This used to cause a memory access in freed memory.
+   let save_efm = &efm
+   lexpr '0'
+   lopen
+   fun X(c)
+     let save_efm=&efm
+     set efm=%D%f
+     if a:c == 'c'
+       caddexpr '::'
+     else
+       laddexpr ':0:0'
+     endif
+     let &efm=save_efm
+   endfun
+   call X('c')
+   call X('l')
+   call setqflist([], 'r')
+   caddbuffer
+   let &efm = save_efm
+ endfunc
*** ../vim-8.0.0083/src/version.c	2016-11-13 14:31:36.691499383 +0100
--- src/version.c	2016-11-13 15:08:25.177362299 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     84,
  /**/

-- 
Far back in the mists of ancient time, in the great and glorious days of the
former Galactic Empire, life was wild, rich and largely tax free.
Mighty starships plied their way between exotic suns, seeking adventure and
reward among the furthest reaches of Galactic space.  In those days, spirits
were brave, the stakes were high, men were real men, women were real women
and small furry creatures from Alpha Centauri were real small furry creatures
from Alpha Centauri.  And all dared to brave unknown terrors, to do mighty
deeds, to boldly split infinitives that no man had split before -- and thus
was the Empire forged.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0085
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0085
Problem:    Using freed memory with recursive function call. (Dominique Pelle)
Solution:   Make a copy of the function name.
Files:      src/eval.c, src/testdir/test_nested_function.vim


*** ../vim-8.0.0084/src/eval.c	2016-11-10 20:01:41.185582969 +0100
--- src/eval.c	2016-11-14 21:46:38.269423032 +0100
***************
*** 4339,4348 ****
  		 * use its contents. */
  		s = deref_func_name(s, &len, &partial, !evaluate);
  
! 		/* Invoke the function. */
! 		ret = get_func_tv(s, len, rettv, arg,
! 			  curwin->w_cursor.lnum, curwin->w_cursor.lnum,
! 			  &len, evaluate, partial, NULL);
  
  		/* If evaluate is FALSE rettv->v_type was not set in
  		 * get_func_tv, but it's needed in handle_subscript() to parse
--- 4339,4355 ----
  		 * use its contents. */
  		s = deref_func_name(s, &len, &partial, !evaluate);
  
! 		/* Need to make a copy, in case evaluating the arguments makes
! 		 * the name invalid. */
! 		s = vim_strsave(s);
! 		if (s == NULL)
! 		    ret = FAIL;
! 		else
! 		    /* Invoke the function. */
! 		    ret = get_func_tv(s, len, rettv, arg,
! 			      curwin->w_cursor.lnum, curwin->w_cursor.lnum,
! 			      &len, evaluate, partial, NULL);
! 		vim_free(s);
  
  		/* If evaluate is FALSE rettv->v_type was not set in
  		 * get_func_tv, but it's needed in handle_subscript() to parse
*** ../vim-8.0.0084/src/testdir/test_nested_function.vim	2016-09-01 22:07:07.000000000 +0200
--- src/testdir/test_nested_function.vim	2016-11-14 21:43:56.074512335 +0100
***************
*** 1,32 ****
  "Tests for nested functions
  "
! function! NestedFunc()
!   fu! Func1()
      let g:text .= 'Func1 '
!   endfunction
    call Func1()
!   fu! s:func2()
      let g:text .= 's:func2 '
!   endfunction
    call s:func2()
!   fu! s:_func3()
      let g:text .= 's:_func3 '
!   endfunction
    call s:_func3()
    let fn = 'Func4'
!   fu! {fn}()
      let g:text .= 'Func4 '
!   endfunction
    call {fn}()
    let fn = 'func5'
!   fu! s:{fn}()
      let g:text .= 's:func5'
!   endfunction
    call s:{fn}()
! endfunction
  
! function! Test_nested_functions()
    let g:text = ''
    call NestedFunc()
    call assert_equal('Func1 s:func2 s:_func3 Func4 s:func5', g:text)
  endfunction
--- 1,42 ----
  "Tests for nested functions
  "
! func NestedFunc()
!   func! Func1()
      let g:text .= 'Func1 '
!   endfunc
    call Func1()
!   func! s:func2()
      let g:text .= 's:func2 '
!   endfunc
    call s:func2()
!   func! s:_func3()
      let g:text .= 's:_func3 '
!   endfunc
    call s:_func3()
    let fn = 'Func4'
!   func! {fn}()
      let g:text .= 'Func4 '
!   endfunc
    call {fn}()
    let fn = 'func5'
!   func! s:{fn}()
      let g:text .= 's:func5'
!   endfunc
    call s:{fn}()
! endfunc
  
! func Test_nested_functions()
    let g:text = ''
    call NestedFunc()
    call assert_equal('Func1 s:func2 s:_func3 Func4 s:func5', g:text)
  endfunction
+ 
+ func Test_nested_argument()
+   func g:X()
+     let g:Y = function('sort')
+   endfunc
+   let g:Y = function('sort')
+   echo g:Y([], g:X())
+   delfunc g:X
+   unlet g:Y
+ endfunc
*** ../vim-8.0.0084/src/version.c	2016-11-13 15:09:21.301005386 +0100
--- src/version.c	2016-11-14 21:40:08.616043065 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     85,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
3. Every time someone asks you to do something, ask if they want fries
   with that.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0086
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0086
Problem:    Cannot add a comment after ":hide". (Norio Takagi)
Solution:   Make it work, add a test. (Hirohito Higashi)
Files:      src/Makefile, src/ex_cmds.h, src/ex_docmd.c,
            src/testdir/Make_all.mak, src/testdir/test_hide.vim


*** ../vim-8.0.0085/src/Makefile	2016-11-12 21:12:48.534182259 +0100
--- src/Makefile	2016-11-15 20:38:20.349739241 +0100
***************
*** 2097,2102 ****
--- 2097,2103 ----
  	test_gui \
  	test_hardcopy \
  	test_help_tagjump \
+ 	test_hide \
  	test_history \
  	test_hlsearch \
  	test_increment \
*** ../vim-8.0.0085/src/ex_cmds.h	2016-11-12 19:16:42.212999914 +0100
--- src/ex_cmds.h	2016-11-15 20:38:20.349739241 +0100
***************
*** 623,629 ****
  			BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN,
  			ADDR_LINES),
  EX(CMD_hide,		"hide",		ex_hide,
! 			BANG|RANGE|NOTADR|COUNT|EXTRA|NOTRLCOM,
  			ADDR_WINDOWS),
  EX(CMD_history,		"history",	ex_history,
  			EXTRA|TRLBAR|CMDWIN,
--- 623,629 ----
  			BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN,
  			ADDR_LINES),
  EX(CMD_hide,		"hide",		ex_hide,
! 			BANG|RANGE|NOTADR|COUNT|EXTRA|TRLBAR,
  			ADDR_WINDOWS),
  EX(CMD_history,		"history",	ex_history,
  			EXTRA|TRLBAR|CMDWIN,
*** ../vim-8.0.0085/src/ex_docmd.c	2016-11-12 19:16:42.216999886 +0100
--- src/ex_docmd.c	2016-11-15 20:38:20.353739214 +0100
***************
*** 5632,5646 ****
  #endif
  
  /*
!  * Check if *p is a separator between Ex commands.
!  * Return NULL if it isn't, (p + 1) if it is.
   */
      char_u *
  check_nextcmd(char_u *p)
  {
!     p = skipwhite(p);
!     if (*p == '|' || *p == '\n')
! 	return (p + 1);
      else
  	return NULL;
  }
--- 5632,5647 ----
  #endif
  
  /*
!  * Check if *p is a separator between Ex commands, skipping over white space.
!  * Return NULL if it isn't, the following character if it is.
   */
      char_u *
  check_nextcmd(char_u *p)
  {
!     char_u *s = skipwhite(p);
! 
!     if (*s == '|' || *s == '\n')
! 	return (s + 1);
      else
  	return NULL;
  }
***************
*** 7572,7609 ****
      static void
  ex_hide(exarg_T *eap)
  {
!     if (*eap->arg != NUL && check_nextcmd(eap->arg) == NULL)
! 	eap->errmsg = e_invarg;
!     else
!     {
! 	/* ":hide" or ":hide | cmd": hide current window */
! 	eap->nextcmd = check_nextcmd(eap->arg);
  #ifdef FEAT_WINDOWS
! 	if (!eap->skip)
! 	{
  # ifdef FEAT_GUI
! 	    need_mouse_correct = TRUE;
  # endif
! 	    if (eap->addr_count == 0)
! 		win_close(curwin, FALSE);	/* don't free buffer */
! 	    else
! 	    {
! 		int	winnr = 0;
! 		win_T	*win;
  
! 		FOR_ALL_WINDOWS(win)
! 		{
! 		    winnr++;
! 		    if (winnr == eap->line2)
! 			break;
! 		}
! 		if (win == NULL)
! 		    win = lastwin;
! 		win_close(win, FALSE);
  	    }
  	}
- #endif
      }
  }
  
  /*
--- 7573,7604 ----
      static void
  ex_hide(exarg_T *eap)
  {
!     /* ":hide" or ":hide | cmd": hide current window */
  #ifdef FEAT_WINDOWS
!     if (!eap->skip)
!     {
  # ifdef FEAT_GUI
! 	need_mouse_correct = TRUE;
  # endif
! 	if (eap->addr_count == 0)
! 	    win_close(curwin, FALSE);	/* don't free buffer */
! 	else
! 	{
! 	    int	winnr = 0;
! 	    win_T	*win;
  
! 	    FOR_ALL_WINDOWS(win)
! 	    {
! 		winnr++;
! 		if (winnr == eap->line2)
! 		    break;
  	    }
+ 	    if (win == NULL)
+ 		win = lastwin;
+ 	    win_close(win, FALSE);
  	}
      }
+ #endif
  }
  
  /*
*** ../vim-8.0.0085/src/testdir/Make_all.mak	2016-10-15 17:06:42.094912699 +0200
--- src/testdir/Make_all.mak	2016-11-15 20:38:20.357739188 +0100
***************
*** 156,161 ****
--- 156,162 ----
  	    test_gn.res \
  	    test_gui.res \
  	    test_hardcopy.res \
+ 	    test_hide.res \
  	    test_history.res \
  	    test_hlsearch.res \
  	    test_increment.res \
*** ../vim-8.0.0085/src/testdir/test_hide.vim	2016-11-15 21:16:01.358754552 +0100
--- src/testdir/test_hide.vim	2016-11-15 20:38:20.357739188 +0100
***************
*** 0 ****
--- 1,97 ----
+ " Tests for :hide command/modifier and 'hidden' option
+ 
+ function SetUp()
+   let s:save_hidden = &hidden
+   let s:save_bufhidden = &bufhidden
+   let s:save_autowrite = &autowrite
+   set nohidden
+   set bufhidden=
+   set noautowrite
+ endfunc
+ 
+ function TearDown()
+   let &hidden = s:save_hidden
+   let &bufhidden = s:save_bufhidden
+   let &autowrite = s:save_autowrite
+ endfunc
+ 
+ function Test_hide()
+   let orig_bname = bufname('')
+   let orig_winnr = winnr('$')
+ 
+   new Xf1
+   set modified
+   call assert_fails('edit Xf2')
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   edit! Xf2
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 0], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " :hide as a command
+   hide
+   call assert_equal([orig_bname, orig_winnr], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   " :hide as a command with trailing comment
+   hide " comment
+   call assert_equal([orig_bname, orig_winnr], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   new Xf1
+   set modified
+   " :hide as a command with bar
+   hide | new Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " :hide as a modifier with trailing comment
+   hide edit Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   new Xf1
+   set modified
+   " To check that the bar is not recognized to separate commands
+   hide echo "one|two"
+   call assert_equal(['Xf1', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+ 
+   " set hidden
+   new Xf1
+   set hidden
+   set modified
+   edit Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([1, 1], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf1
+   bwipeout! Xf2
+ 
+   " set hidden bufhidden=wipe
+   new Xf1
+   set bufhidden=wipe
+   set modified
+   hide edit! Xf2 " comment
+   call assert_equal(['Xf2', 2], [bufname(''), winnr('$')])
+   call assert_equal([0, 0], [buflisted('Xf1'), bufloaded('Xf1')])
+   bwipeout! Xf2
+ endfunc
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0085/src/version.c	2016-11-14 21:49:57.080090226 +0100
--- src/version.c	2016-11-15 20:39:04.805438063 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     86,
  /**/

-- 
How To Keep A Healthy Level Of Insanity:
10. Ask people what sex they are. Laugh hysterically after they answer.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0087
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0087
Problem:    When the channel callback gets job info the job may already have
            been deleted. (lifepillar)
Solution:   Do not delete the job when the channel is still useful. (ichizok,
            closes #1242, closes #1245)
Files:      src/channel.c, src/eval.c, src/os_unix.c, src/os_win32.c,
            src/structs.h, src/testdir/test_channel.vim


*** ../vim-8.0.0086/src/channel.c	2016-11-12 21:12:48.538182233 +0100
--- src/channel.c	2016-11-17 17:13:15.080933875 +0100
***************
*** 4433,4451 ****
      }
  }
  
      static void
  job_cleanup(job_T *job)
  {
      if (job->jv_status != JOB_ENDED)
  	return;
  
      if (job->jv_exit_cb != NULL)
      {
  	typval_T	argv[3];
  	typval_T	rettv;
  	int		dummy;
  
! 	/* invoke the exit callback; make sure the refcount is > 0 */
  	++job->jv_refcount;
  	argv[0].v_type = VAR_JOB;
  	argv[0].vval.v_job = job;
--- 4433,4498 ----
      }
  }
  
+ #if defined(EXITFREE) || defined(PROTO)
+     void
+ job_free_all(void)
+ {
+     while (first_job != NULL)
+ 	job_free(first_job);
+ }
+ #endif
+ 
+ /*
+  * Return TRUE if we need to check if the process of "job" has ended.
+  */
+     static int
+ job_need_end_check(job_T *job)
+ {
+     return job->jv_status == JOB_STARTED
+ 		   && (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL);
+ }
+ 
+ /*
+  * Return TRUE if the channel of "job" is still useful.
+  */
+     static int
+ job_channel_still_useful(job_T *job)
+ {
+     return job->jv_channel != NULL && channel_still_useful(job->jv_channel);
+ }
+ 
+ /*
+  * Return TRUE if the job should not be freed yet.  Do not free the job when
+  * it has not ended yet and there is a "stoponexit" flag, an exit callback
+  * or when the associated channel will do something with the job output.
+  */
+     static int
+ job_still_useful(job_T *job)
+ {
+     return job_need_end_check(job) || job_channel_still_useful(job);
+ }
+ 
+ /*
+  * NOTE: Must call job_cleanup() only once right after the status of "job"
+  * changed to JOB_ENDED (i.e. after job_status() returned "dead" first or
+  * mch_detect_ended_job() returned non-NULL).
+  */
      static void
  job_cleanup(job_T *job)
  {
      if (job->jv_status != JOB_ENDED)
  	return;
  
+     /* Ready to cleanup the job. */
+     job->jv_status = JOB_FINISHED;
+ 
      if (job->jv_exit_cb != NULL)
      {
  	typval_T	argv[3];
  	typval_T	rettv;
  	int		dummy;
  
! 	/* Invoke the exit callback. Make sure the refcount is > 0. */
  	++job->jv_refcount;
  	argv[0].v_type = VAR_JOB;
  	argv[0].vval.v_job = job;
***************
*** 4458,4499 ****
  	--job->jv_refcount;
  	channel_need_redraw = TRUE;
      }
!     if (job->jv_refcount == 0)
!     {
! 	/* The job was already unreferenced, now that it ended it can be
! 	 * freed. Careful: caller must not use "job" after this! */
  	job_free(job);
      }
  }
  
- #if defined(EXITFREE) || defined(PROTO)
-     void
- job_free_all(void)
- {
-     while (first_job != NULL)
- 	job_free(first_job);
- }
- #endif
- 
- /*
-  * Return TRUE if the job should not be freed yet.  Do not free the job when
-  * it has not ended yet and there is a "stoponexit" flag, an exit callback
-  * or when the associated channel will do something with the job output.
-  */
-     static int
- job_still_useful(job_T *job)
- {
-     return (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
- 	    || (job->jv_channel != NULL
- 		&& channel_still_useful(job->jv_channel)));
- }
- 
-     static int
- job_still_alive(job_T *job)
- {
-     return (job->jv_status == JOB_STARTED) && job_still_useful(job);
- }
- 
  /*
   * Mark references in jobs that are still useful.
   */
--- 4505,4522 ----
  	--job->jv_refcount;
  	channel_need_redraw = TRUE;
      }
! 
!     /* Do not free the job in case the close callback of the associated channel
!      * isn't invoked yet and may get information by job_info(). */
!     if (job->jv_refcount == 0 && !job_channel_still_useful(job))
!     {
! 	/* The job was already unreferenced and the associated channel was
! 	 * detached, now that it ended it can be freed. Careful: caller must
! 	 * not use "job" after this! */
  	job_free(job);
      }
  }
  
  /*
   * Mark references in jobs that are still useful.
   */
***************
*** 4505,4511 ****
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
--- 4528,4534 ----
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_useful(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
***************
*** 4514,4539 ****
      return abort;
  }
  
      void
  job_unref(job_T *job)
  {
      if (job != NULL && --job->jv_refcount <= 0)
      {
! 	/* Do not free the job when it has not ended yet and there is a
! 	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_alive(job))
! 	{
! 	    job_free(job);
! 	}
! 	else if (job->jv_channel != NULL
! 				    && !channel_still_useful(job->jv_channel))
! 	{
! 	    /* Do remove the link to the channel, otherwise it hangs
! 	     * around until Vim exits. See job_free() for refcount. */
! 	    ch_log(job->jv_channel, "detaching channel from job");
! 	    job->jv_channel->ch_job = NULL;
! 	    channel_unref(job->jv_channel);
! 	    job->jv_channel = NULL;
  	}
      }
  }
--- 4537,4569 ----
      return abort;
  }
  
+ /*
+  * Dereference "job".  Note that after this "job" may have been freed.
+  */
      void
  job_unref(job_T *job)
  {
      if (job != NULL && --job->jv_refcount <= 0)
      {
! 	/* Do not free the job if there is a channel where the close callback
! 	 * may get the job info. */
! 	if (!job_channel_still_useful(job))
! 	{
! 	    /* Do not free the job when it has not ended yet and there is a
! 	     * "stoponexit" flag or an exit callback. */
! 	    if (!job_need_end_check(job))
! 	    {
! 		job_free(job);
! 	    }
! 	    else if (job->jv_channel != NULL)
! 	    {
! 		/* Do remove the link to the channel, otherwise it hangs
! 		 * around until Vim exits. See job_free() for refcount. */
! 		ch_log(job->jv_channel, "detaching channel from job");
! 		job->jv_channel->ch_job = NULL;
! 		channel_unref(job->jv_channel);
! 		job->jv_channel = NULL;
! 	    }
  	}
      }
  }
***************
*** 4546,4552 ****
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
--- 4576,4582 ----
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
***************
*** 4566,4572 ****
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
--- 4596,4602 ----
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
***************
*** 4660,4667 ****
  	/* Only should check if the channel has been closed, if the channel is
  	 * open the job won't exit. */
  	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 		&& (job->jv_channel == NULL
! 		    || !channel_still_useful(job->jv_channel)))
  	    return TRUE;
      return FALSE;
  }
--- 4690,4696 ----
  	/* Only should check if the channel has been closed, if the channel is
  	 * open the job won't exit. */
  	if (job->jv_status == JOB_STARTED && job->jv_exit_cb != NULL
! 					    && !job_channel_still_useful(job))
  	    return TRUE;
      return FALSE;
  }
***************
*** 4676,4689 ****
  {
      int		i;
  
      for (i = 0; i < MAX_CHECK_ENDED; ++i)
      {
  	job_T	*job = mch_detect_ended_job(first_job);
  
  	if (job == NULL)
  	    break;
! 	if (job_still_useful(job))
! 	    job_cleanup(job); /* may free "job" */
      }
  
      if (channel_need_redraw)
--- 4705,4722 ----
  {
      int		i;
  
+     if (first_job == NULL)
+ 	return;
+ 
      for (i = 0; i < MAX_CHECK_ENDED; ++i)
      {
+ 	/* NOTE: mch_detect_ended_job() must only return a job of which the
+ 	 * status was just set to JOB_ENDED. */
  	job_T	*job = mch_detect_ended_job(first_job);
  
  	if (job == NULL)
  	    break;
! 	job_cleanup(job); /* may free "job" */
      }
  
      if (channel_need_redraw)
***************
*** 4897,4903 ****
  {
      char	*result;
  
!     if (job->jv_status == JOB_ENDED)
  	/* No need to check, dead is dead. */
  	result = "dead";
      else if (job->jv_status == JOB_FAILED)
--- 4930,4936 ----
  {
      char	*result;
  
!     if (job->jv_status >= JOB_ENDED)
  	/* No need to check, dead is dead. */
  	result = "dead";
      else if (job->jv_status == JOB_FAILED)
*** ../vim-8.0.0086/src/eval.c	2016-11-14 21:49:57.080090226 +0100
--- src/eval.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 7290,7296 ****
  		if (job == NULL)
  		    return (char_u *)"no process";
  		status = job->jv_status == JOB_FAILED ? "fail"
! 				: job->jv_status == JOB_ENDED ? "dead"
  				: "run";
  # ifdef UNIX
  		vim_snprintf((char *)buf, NUMBUFLEN,
--- 7290,7296 ----
  		if (job == NULL)
  		    return (char_u *)"no process";
  		status = job->jv_status == JOB_FAILED ? "fail"
! 				: job->jv_status >= JOB_ENDED ? "dead"
  				: "run";
  # ifdef UNIX
  		vim_snprintf((char *)buf, NUMBUFLEN,
*** ../vim-8.0.0086/src/os_unix.c	2016-11-12 21:12:48.538182233 +0100
--- src/os_unix.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 5354,5360 ****
      return "run";
  
  return_dead:
!     if (job->jv_status != JOB_ENDED)
      {
  	ch_log(job->jv_channel, "Job ended");
  	job->jv_status = JOB_ENDED;
--- 5354,5360 ----
      return "run";
  
  return_dead:
!     if (job->jv_status < JOB_ENDED)
      {
  	ch_log(job->jv_channel, "Job ended");
  	job->jv_status = JOB_ENDED;
***************
*** 5398,5404 ****
  		job->jv_exitval = WEXITSTATUS(status);
  	    else if (WIFSIGNALED(status))
  		job->jv_exitval = -1;
! 	    if (job->jv_status != JOB_ENDED)
  	    {
  		ch_log(job->jv_channel, "Job ended");
  		job->jv_status = JOB_ENDED;
--- 5398,5404 ----
  		job->jv_exitval = WEXITSTATUS(status);
  	    else if (WIFSIGNALED(status))
  		job->jv_exitval = -1;
! 	    if (job->jv_status < JOB_ENDED)
  	    {
  		ch_log(job->jv_channel, "Job ended");
  		job->jv_status = JOB_ENDED;
*** ../vim-8.0.0086/src/os_win32.c	2016-10-29 14:54:56.628135821 +0200
--- src/os_win32.c	2016-11-17 16:09:44.478455636 +0100
***************
*** 4978,4984 ****
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
! 	if (job->jv_status != JOB_ENDED)
  	{
  	    ch_log(job->jv_channel, "Job ended");
  	    job->jv_status = JOB_ENDED;
--- 4978,4984 ----
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
! 	if (job->jv_status < JOB_ENDED)
  	{
  	    ch_log(job->jv_channel, "Job ended");
  	    job->jv_status = JOB_ENDED;
*** ../vim-8.0.0086/src/structs.h	2016-11-10 20:20:01.870602701 +0100
--- src/structs.h	2016-11-17 16:17:49.727271673 +0100
***************
*** 1421,1431 ****
      dict_T	*pt_dict;	/* dict for "self" */
  };
  
  typedef enum
  {
      JOB_FAILED,
      JOB_STARTED,
!     JOB_ENDED
  } jobstatus_T;
  
  /*
--- 1421,1433 ----
      dict_T	*pt_dict;	/* dict for "self" */
  };
  
+ /* Status of a job.  Order matters! */
  typedef enum
  {
      JOB_FAILED,
      JOB_STARTED,
!     JOB_ENDED,	    /* detected job done */
!     JOB_FINISHED    /* job done and cleanup done */
  } jobstatus_T;
  
  /*
*** ../vim-8.0.0086/src/testdir/test_channel.vim	2016-10-27 20:00:03.665357405 +0200
--- src/testdir/test_channel.vim	2016-11-17 16:07:29.307354887 +0100
***************
*** 1232,1237 ****
--- 1232,1263 ----
    endtry
  endfunc
  
+ func Test_close_and_exit_cb()
+   if !has('job')
+     return
+   endif
+   call ch_log('Test_close_and_exit_cb')
+ 
+   let dict = {'ret': {}}
+   func dict.close_cb(ch) dict
+     let self.ret['close_cb'] = job_status(ch_getjob(a:ch))
+   endfunc
+   func dict.exit_cb(job, status) dict
+     let self.ret['exit_cb'] = job_status(a:job)
+   endfunc
+ 
+   let g:job = job_start('echo', {
+         \ 'close_cb': dict.close_cb,
+         \ 'exit_cb': dict.exit_cb,
+         \ })
+   call assert_equal('run', job_status(g:job))
+   unlet g:job
+   call WaitFor('len(dict.ret) >= 2')
+   call assert_equal(2, len(dict.ret))
+   call assert_match('^\%(dead\|run\)', dict.ret['close_cb'])
+   call assert_equal('dead', dict.ret['exit_cb'])
+ endfunc
+ 
  """"""""""
  
  let g:Ch_unletResponse = ''
*** ../vim-8.0.0086/src/version.c	2016-11-15 21:16:46.754453019 +0100
--- src/version.c	2016-11-17 16:10:21.326213761 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     87,
  /**/

-- 
The technology involved in making anything invisible is so infinitely
complex that nine hundred and ninety-nine billion, nine hundred and
ninety-nine million, nine hundred and ninety-nine thousand, nine hundred
and ninety-nine times out of a trillion it is much simpler and more
effective just to take the thing away and do without it.
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0088
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0088
Problem:    When a test fails in Setup or Teardown the problem is not reported.
Solution:   Add a try/catch. (Hirohito Higashi)
Files:      src/testdir/runtest.vim


*** ../vim-8.0.0087/src/testdir/runtest.vim	2016-09-25 22:27:33.709341985 +0200
--- src/testdir/runtest.vim	2016-11-17 17:33:55.192759713 +0100
***************
*** 89,95 ****
  function RunTheTest(test)
    echo 'Executing ' . a:test
    if exists("*SetUp")
!     call SetUp()
    endif
  
    call add(s:messages, 'Executing ' . a:test)
--- 89,99 ----
  function RunTheTest(test)
    echo 'Executing ' . a:test
    if exists("*SetUp")
!     try
!       call SetUp()
!     catch
!       call add(v:errors, 'Caught exception in SetUp() before ' . a:test . ': ' . v:exception . ' @ ' . v:throwpoint)
!     endtry
    endif
  
    call add(s:messages, 'Executing ' . a:test)
***************
*** 104,110 ****
    endtry
  
    if exists("*TearDown")
!     call TearDown()
    endif
  
    " Close any extra windows and make the current one not modified.
--- 108,118 ----
    endtry
  
    if exists("*TearDown")
!     try
!       call TearDown()
!     catch
!       call add(v:errors, 'Caught exception in TearDown() after ' . a:test . ': ' . v:exception . ' @ ' . v:throwpoint)
!     endtry
    endif
  
    " Close any extra windows and make the current one not modified.
***************
*** 221,223 ****
--- 229,233 ----
  write
  
  qall!
+ 
+ " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0087/src/version.c	2016-11-17 17:25:28.212093109 +0100
--- src/version.c	2016-11-17 17:34:43.256423233 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     88,
  /**/

-- 
Time is an illusion.  Lunchtime doubly so.
		-- Ford Prefect, in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0089
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0089
Problem:    Various problems with GTK 3.22.2.
Solution:   Fix the problems, add #ifdefs. (Kazunobu Kuriyama)
Files:      src/gui_beval.c, src/gui_gtk.c, src/gui_gtk_x11.c


*** ../vim-8.0.0088/src/gui_beval.c	2016-11-10 20:01:41.189582944 +0100
--- src/gui_beval.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 1178,1189 ****
--- 1178,1200 ----
  	int		y_offset = EVAL_OFFSET_Y;
  	PangoLayout	*layout;
  # ifdef HAVE_GTK_MULTIHEAD
+ #  if GTK_CHECK_VERSION(3,22,2)
+ 	GdkRectangle rect;
+ 	GdkMonitor * const mon = gdk_display_get_monitor_at_window(
+ 		gtk_widget_get_display(beval->balloonShell),
+ 		gtk_widget_get_window(beval->balloonShell));
+ 	gdk_monitor_get_geometry(mon, &rect);
+ 
+ 	screen_w = rect.width;
+ 	screen_h = rect.height;
+ #  else
  	GdkScreen	*screen;
  
  	screen = gtk_widget_get_screen(beval->target);
  	gtk_window_set_screen(GTK_WINDOW(beval->balloonShell), screen);
  	screen_w = gdk_screen_get_width(screen);
  	screen_h = gdk_screen_get_height(screen);
+ #  endif
  # else
  	screen_w = gdk_screen_width();
  	screen_h = gdk_screen_height();
*** ../vim-8.0.0088/src/gui_gtk.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_gtk.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 1881,1890 ****
--- 1881,1916 ----
  #  endif
  # endif /* FEAT_XIM */
  
+ # if GTK_CHECK_VERSION(3,22,2)
+     {
+ 	GdkEventButton trigger;
+ 
+ 	/* A pseudo event to have gtk_menu_popup_at_pointer() work. Since the
+ 	 * function calculates the popup menu position on the basis of the
+ 	 * actual pointer position when it is invoked, the fields x, y, x_root
+ 	 * and y_root are set to zero for convenience. */
+ 	trigger.type       = GDK_BUTTON_PRESS;
+ 	trigger.window     = gtk_widget_get_window(gui.drawarea);
+ 	trigger.send_event = FALSE;
+ 	trigger.time       = gui.event_time;
+ 	trigger.x          = 0.0;
+ 	trigger.y          = 0.0;
+ 	trigger.axes       = NULL;
+ 	trigger.state      = 0;
+ 	trigger.button     = 3;
+ 	trigger.device     = NULL;
+ 	trigger.x_root     = 0.0;
+ 	trigger.y_root     = 0.0;
+ 
+ 	gtk_menu_popup_at_pointer(GTK_MENU(menu->submenu_id),
+ 				  (GdkEvent *)&trigger);
+     }
+ #else
      gtk_menu_popup(GTK_MENU(menu->submenu_id),
  		   NULL, NULL,
  		   (GtkMenuPositionFunc)NULL, NULL,
  		   3U, gui.event_time);
+ #endif
  }
  
  /* Ugly global variable to pass "mouse_pos" flag from gui_make_popup() to
***************
*** 1942,1951 ****
--- 1968,2022 ----
  
      if (menu != NULL && menu->submenu_id != NULL)
      {
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	GdkWindow * const win = gtk_widget_get_window(gui.drawarea);
+ 	GdkEventButton trigger;
+ 
+ 	/* A pseudo event to have gtk_menu_popup_at_*() functions work. Since
+ 	 * the position where the menu pops up is automatically adjusted by
+ 	 * the functions, none of the fields x, y, x_root and y_root has to be
+ 	 * set to a specific value here; therefore, they are set to zero for
+ 	 * convenience.*/
+ 	trigger.type       = GDK_BUTTON_PRESS;
+ 	trigger.window     = win;
+ 	trigger.send_event = FALSE;
+ 	trigger.time       = GDK_CURRENT_TIME;
+ 	trigger.x          = 0.0;
+ 	trigger.y          = 0.0;
+ 	trigger.axes       = NULL;
+ 	trigger.state      = 0;
+ 	trigger.button     = 0;
+ 	trigger.device     = NULL;
+ 	trigger.x_root     = 0.0;
+ 	trigger.y_root     = 0.0;
+ 
+ 	if (mouse_pos)
+ 	    gtk_menu_popup_at_pointer(GTK_MENU(menu->submenu_id),
+ 				      (GdkEvent *)&trigger);
+ 	else
+ 	{
+ 	    gint origin_x, origin_y;
+ 	    GdkRectangle rect = { 0, 0, 0, 0 };
+ 
+ 	    gdk_window_get_origin(win, &origin_x, &origin_y);
+ 	    popup_menu_position_func(NULL, &rect.x, &rect.y, NULL, NULL);
+ 
+ 	    rect.x -= origin_x;
+ 	    rect.y -= origin_y;
+ 
+ 	    gtk_menu_popup_at_rect(GTK_MENU(menu->submenu_id),
+ 				   win,
+ 				   &rect,
+ 				   GDK_GRAVITY_SOUTH_EAST,
+ 				   GDK_GRAVITY_NORTH_WEST,
+ 				   (GdkEvent *)&trigger);
+ 	}
+ # else
  	gtk_menu_popup(GTK_MENU(menu->submenu_id),
  		       NULL, NULL,
  		       &popup_menu_position_func, NULL,
  		       0U, (guint32)GDK_CURRENT_TIME);
+ # endif
      }
  }
  
*** ../vim-8.0.0088/src/gui_gtk_x11.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_gtk_x11.c	2016-11-17 19:09:58.650122624 +0100
***************
*** 3076,3085 ****
--- 3076,3091 ----
      gui.blank_pointer = NULL;
  }
  
+ #if GTK_CHECK_VERSION(3,22,2)
+     static void
+ drawarea_style_updated_cb(GtkWidget *widget UNUSED,
+ 			 gpointer data UNUSED)
+ #else
      static void
  drawarea_style_set_cb(GtkWidget	*widget UNUSED,
  		      GtkStyle	*previous_style UNUSED,
  		      gpointer	data UNUSED)
+ #endif
  {
      gui_mch_new_colors();
  }
***************
*** 3096,3101 ****
--- 3102,3132 ----
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
+ # if GTK_CHECK_VERSION(3,22,2)
+     /* As of 3.22.2, GdkWindows have started distributing configure events to
+      * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
+      *
+      * As can be seen from the implementation of move_native_children() and
+      * configure_native_child() in gdkwindow.c, those functions actually
+      * propagate configure events to every child, failing to distinguish
+      * "native" one from non-native one.
+      *
+      * Naturally, configure events propagated to here like that are fallacious
+      * and, as a matter of fact, they trigger a geometric collapse of
+      * gui.drawarea in fullscreen and miximized modes.
+      *
+      * To filter out such nuisance events, we are making use of the fact that
+      * the field send_event of such GdkEventConfigures is set to FALSE in
+      * configure_native_child().
+      *
+      * Obviously, this is a terrible hack making GVim depend on GTK's
+      * implementation details.  Therefore, watch out any relevant internal
+      * changes happening in GTK in the feature (sigh).
+      */
+     if (event->send_event == FALSE)
+ 	return TRUE;
+ # endif
+ 
      if (event->width == cur_width && event->height == cur_height)
  	return TRUE;
  
***************
*** 3519,3526 ****
--- 3550,3561 ----
  	/* If the event was generated for 3rd button popup the menu. */
  	if (bevent->button == 3)
  	{
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	    gtk_menu_popup_at_pointer(GTK_MENU(widget), event);
+ # else
  	    gtk_menu_popup(GTK_MENU(widget), NULL, NULL, NULL, NULL,
  						bevent->button, bevent->time);
+ # endif
  	    /* We handled the event. */
  	    return TRUE;
  	}
***************
*** 4116,4121 ****
--- 4151,4159 ----
  #endif
  
      gui.drawarea = gtk_drawing_area_new();
+ #if GTK_CHECK_VERSION(3,22,2)
+     gtk_widget_set_name(gui.drawarea, "vim-gui-drawarea");
+ #endif
  #if GTK_CHECK_VERSION(3,0,0)
      gui.surface = NULL;
      gui.by_signal = FALSE;
***************
*** 4167,4174 ****
--- 4205,4217 ----
  		     G_CALLBACK(drawarea_unrealize_cb), NULL);
      g_signal_connect(G_OBJECT(gui.drawarea), "configure-event",
  	    G_CALLBACK(drawarea_configure_event_cb), NULL);
+ # if GTK_CHECK_VERSION(3,22,2)
+     g_signal_connect_after(G_OBJECT(gui.drawarea), "style-updated",
+ 			   G_CALLBACK(&drawarea_style_updated_cb), NULL);
+ # else
      g_signal_connect_after(G_OBJECT(gui.drawarea), "style-set",
  			   G_CALLBACK(&drawarea_style_set_cb), NULL);
+ # endif
  #else
      gtk_signal_connect(GTK_OBJECT(gui.drawarea), "realize",
  		       GTK_SIGNAL_FUNC(drawarea_realize_cb), NULL);
***************
*** 4384,4397 ****
  gui_mch_new_colors(void)
  {
  #if GTK_CHECK_VERSION(3,0,0)
      GdkWindow * const da_win = gtk_widget_get_window(gui.drawarea);
  
      if (gui.drawarea != NULL && gtk_widget_get_window(gui.drawarea) != NULL)
  #else
      if (gui.drawarea != NULL && gui.drawarea->window != NULL)
  #endif
      {
! #if GTK_CHECK_VERSION(3,4,0)
  	GdkRGBA rgba;
  
  	rgba = color_to_rgba(gui.back_pixel);
--- 4427,4460 ----
  gui_mch_new_colors(void)
  {
  #if GTK_CHECK_VERSION(3,0,0)
+ # if !GTK_CHECK_VERSION(3,22,2)
      GdkWindow * const da_win = gtk_widget_get_window(gui.drawarea);
+ # endif
  
      if (gui.drawarea != NULL && gtk_widget_get_window(gui.drawarea) != NULL)
  #else
      if (gui.drawarea != NULL && gui.drawarea->window != NULL)
  #endif
      {
! #if GTK_CHECK_VERSION(3,22,2)
! 	GtkStyleContext * const context
! 	    = gtk_widget_get_style_context(gui.drawarea);
! 	GtkCssProvider * const provider = gtk_css_provider_new();
! 	gchar * const css = g_strdup_printf(
! 		"widget#vim-gui-drawarea {\n"
! 		"  background-color: #%.2lx%.2lx%.2lx;\n"
! 		"}\n",
! 		 (gui.back_pixel >> 16) & 0xff,
! 		 (gui.back_pixel >> 8) & 0xff,
! 		 gui.back_pixel & 0xff);
! 
! 	gtk_css_provider_load_from_data(provider, css, -1, NULL);
! 	gtk_style_context_add_provider(context,
! 		GTK_STYLE_PROVIDER(provider), G_MAXUINT);
! 
! 	g_free(css);
! 	g_object_unref(provider);
! #elif GTK_CHECK_VERSION(3,4,0) /* !GTK_CHECK_VERSION(3,22,2) */
  	GdkRGBA rgba;
  
  	rgba = color_to_rgba(gui.back_pixel);
***************
*** 4415,4421 ****
  # else
  	gdk_window_set_background(gui.drawarea->window, &color);
  # endif
! #endif /* !GTK_CHECK_VERSION(3,4,0) */
      }
  }
  
--- 4478,4484 ----
  # else
  	gdk_window_set_background(gui.drawarea->window, &color);
  # endif
! #endif /* !GTK_CHECK_VERSION(3,22,2) */
      }
  }
  
***************
*** 4429,4434 ****
--- 4492,4517 ----
  {
      int usable_height = event->height;
  
+ #if GTK_CHECK_VERSION(3,22,2)
+     /* As of 3.22.2, GdkWindows have started distributing configure events to
+      * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
+      *
+      * As can be seen from the implementation of move_native_children() and
+      * configure_native_child() in gdkwindow.c, those functions actually
+      * propagate configure events to every child, failing to distinguish
+      * "native" one from non-native one.
+      *
+      * Naturally, configure events propagated to here like that are fallacious
+      * and, as a matter of fact, they trigger a geometric collapse of
+      * gui.formwin.
+      *
+      * To filter out such fallacious events, check if the given event is the
+      * one that was sent out to the right place. Ignore it if not.
+      */
+     if (event->window != gtk_widget_get_window(gui.formwin))
+ 	return TRUE;
+ #endif
+ 
      /* When in a GtkPlug, we can't guarantee valid heights (as a round
       * no. of char-heights), so we have to manually sanitise them.
       * Widths seem to sort themselves out, don't ask me why.
***************
*** 4890,4895 ****
--- 4973,4988 ----
  gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
  {
  #ifdef HAVE_GTK_MULTIHEAD
+ # if GTK_CHECK_VERSION(3,22,2)
+     GdkRectangle rect;
+     GdkMonitor * const mon = gdk_display_get_monitor_at_window(
+ 	    gtk_widget_get_display(gui.mainwin),
+ 	    gtk_widget_get_window(gui.mainwin));
+     gdk_monitor_get_geometry(mon, &rect);
+ 
+     *screen_w = rect.width;
+     *screen_h = rect.height - p_ghr;
+ # else
      GdkScreen* screen;
  
      if (gui.mainwin != NULL && gtk_widget_has_screen(gui.mainwin))
***************
*** 4899,4904 ****
--- 4992,4998 ----
  
      *screen_w = gdk_screen_get_width(screen);
      *screen_h = gdk_screen_get_height(screen) - p_ghr;
+ # endif
  #else
      *screen_w = gdk_screen_width();
      /* Subtract 'guiheadroom' from the height to allow some room for the
***************
*** 6626,6636 ****
--- 6720,6734 ----
  	};
  	GdkWindow * const win = gtk_widget_get_window(gui.drawarea);
  	cairo_t * const cr = cairo_create(gui.surface);
+ # if GTK_CHECK_VERSION(3,22,2)
+ 	set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # else
  	cairo_pattern_t * const pat = gdk_window_get_background_pattern(win);
  	if (pat != NULL)
  	    cairo_set_source(cr, pat);
  	else
  	    set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # endif
  	gdk_cairo_rectangle(cr, &rect);
  	cairo_fill(cr);
  	cairo_destroy(cr);
***************
*** 6659,6669 ****
--- 6757,6771 ----
  	0, 0, gdk_window_get_width(win), gdk_window_get_height(win)
      };
      cairo_t * const cr = cairo_create(gui.surface);
+ # if GTK_CHECK_VERSION(3,22,2)
+     set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # else
      cairo_pattern_t * const pat = gdk_window_get_background_pattern(win);
      if (pat != NULL)
  	cairo_set_source(cr, pat);
      else
  	set_cairo_source_rgba_from_color(cr, gui.back_pixel);
+ # endif
      gdk_cairo_rectangle(cr, &rect);
      cairo_fill(cr);
      cairo_destroy(cr);
*** ../vim-8.0.0088/src/version.c	2016-11-17 17:56:10.103449001 +0100
--- src/version.c	2016-11-17 19:10:50.549780930 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     89,
  /**/

-- 
What a wonderfully exciting cough!  Do you mind if I join you?
		-- Douglas Adams, "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0090
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0090
Problem:    Cursor moved after last character when using 'breakindent'.
Solution:   Fix the cursor positioning.  Turn the breakindent test into new
            style.  (Christian Brabandt)
Files:      src/screen.c, src/testdir/Make_all.mak,
            src/testdir/test_breakindent.in, src/testdir/test_breakindent.ok,
            src/testdir/test_breakindent.vim, src/Makefile


*** ../vim-8.0.0089/src/screen.c	2016-11-06 15:25:37.697627447 +0100
--- src/screen.c	2016-11-17 19:27:22.767064438 +0100
***************
*** 3010,3016 ****
  #endif
      colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
  #ifdef FEAT_LINEBREAK
!     int		need_showbreak = FALSE;
  #endif
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
--- 3010,3017 ----
  #endif
      colnr_T	trailcol = MAXCOL;	/* start of trailing spaces */
  #ifdef FEAT_LINEBREAK
!     int		need_showbreak = FALSE; /* overlong line, skipping first x
! 					   chars */
  #endif
  #if defined(FEAT_SIGNS) || (defined(FEAT_QUICKFIX) && defined(FEAT_WINDOWS)) \
  	|| defined(FEAT_SYN_HL) || defined(FEAT_DIFF)
***************
*** 3793,3805 ****
  	    if (draw_state == WL_BRI - 1 && n_extra == 0)
  	    {
  		draw_state = WL_BRI;
! 		if (wp->w_p_bri && n_extra == 0 && row != startrow
  # ifdef FEAT_DIFF
  			&& filler_lines == 0
  # endif
  		   )
  		{
! 		    char_attr = 0; /* was: hl_attr(HLF_AT); */
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
--- 3794,3808 ----
  	    if (draw_state == WL_BRI - 1 && n_extra == 0)
  	    {
  		draw_state = WL_BRI;
! 		/* if need_showbreak is set, breakindent also applies */
! 		if (wp->w_p_bri && n_extra == 0
! 					 && (row != startrow || need_showbreak)
  # ifdef FEAT_DIFF
  			&& filler_lines == 0
  # endif
  		   )
  		{
! 		    char_attr = 0;
  # ifdef FEAT_DIFF
  		    if (diff_hlf != (hlf_T)0)
  		    {
*** ../vim-8.0.0089/src/testdir/Make_all.mak	2016-11-15 21:16:46.754453019 +0100
--- src/testdir/Make_all.mak	2016-11-17 19:24:06.120428121 +0100
***************
*** 75,81 ****
  	test108.out \
  	test_autocmd_option.out \
  	test_autoformat_join.out \
- 	test_breakindent.out \
  	test_changelist.out \
  	test_close_count.out \
  	test_comparators.out \
--- 75,80 ----
***************
*** 141,146 ****
--- 140,146 ----
  	    test_assert.res \
  	    test_autochdir.res \
  	    test_backspace_opt.res \
+ 	    test_breakindent.res \
  	    test_bufwintabinfo.res \
  	    test_cdo.res \
  	    test_channel.res \
*** ../vim-8.0.0089/src/testdir/test_breakindent.in	2015-01-27 17:07:20.000000000 +0100
--- src/testdir/test_breakindent.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,122 ****
- Test for breakindent
- 
- STARTTEST
- :so small.vim
- :if !exists("+breakindent") | e! test.ok | w! test.out | qa! | endif
- :10new|:vsp|:vert resize 20
- :put =\"\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP\"
- :set ts=4 sw=4 sts=4 breakindent
- :fu! ScreenChar(line, width)
- :	let c=''
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line, i))
- :	endfor
- :       let c.="\n"
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line+1, i))
- :	endfor
- :       let c.="\n"
- :	for i in range(1,a:width)
- :		let c.=nr2char(screenchar(a:line+2, i))
- :	endfor
- :	return c
- :endfu
- :fu DoRecordScreen()
- :	wincmd l
- :	$put =printf(\"\n%s\", g:test)
- :	$put =g:line1
- :	wincmd p
- :endfu
- :set briopt=min:0
- :let g:test="Test 1: Simple breakindent"
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test="Test 2: Simple breakindent + sbr=>>"
- :set sbr=>>
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test ="Test 3: Simple breakindent + briopt:sbr"
- :set briopt=sbr,min:0 sbr=++
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test ="Test 4: Simple breakindent + min width: 18"
- :set sbr= briopt=min:18
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test =" Test 5: Simple breakindent + shift by 2"
- :set briopt=shift:2,min:0
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test=" Test 6: Simple breakindent + shift by -1"
- :set briopt=shift:-1,min:0
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :let g:test=" Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr"
- :set briopt=shift:1,sbr,min:0 nu sbr=? nuw=4
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr"
- :set briopt=shift:1,sbr,min:0 nu sbr=# list
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 9: breakindent + shift by +1 + 'nu' + sbr=# list"
- :set briopt-=sbr
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :let g:test=" Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n"
- :set cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0
- :let line1=ScreenChar(line('.'),10)
- :call DoRecordScreen()
- :wincmd p
- :let g:test="\n Test 11: strdisplaywidth when breakindent is on"
- :set cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4
- :let text=getline(2) "skip leading tab when calculating text width
- :let width = strlen(text[1:])+indent(2)*4+strlen(&sbr)*3 " text wraps 3 times
- :$put =g:test
- :$put =printf(\"strdisplaywidth: %d == calculated: %d\", strdisplaywidth(text), width)
- :let g:str="\t\t\t\t\t{"
- :let g:test=" Test 12: breakindent + long indent"
- :wincmd p
- :set all& breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4
- :$put =g:str
- zt:let line1=ScreenChar(1,10)
- :wincmd p
- :call DoRecordScreen()
- :"
- :" Test, that the string "    a\tb\tc\td\te" is correctly
- :" displayed in a 20 column wide window (see bug report
- :" https://groups.google.com/d/msg/vim_dev/ZOdg2mc9c9Y/TT8EhFjEy0IJ
- :only
- :vert 20new
- :set all& nocp breakindent briopt=min:10
- :call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
- :/^\s*a
- fbgjyl:let line1 = @0
- :?^\s*z
- fygjyl:let line2 = @0
- :quit!
- :$put ='Test 13: breakindent with wrapping Tab'
- :$put =line1
- :$put =line2
- :"
- :let g:test="Test 14: breakindent + visual blockwise delete #1"
- :set all& breakindent viminfo+=nviminfo
- :30vnew
- :normal! 3a1234567890
- :normal! a    abcde
- :exec "normal! 0\<C-V>tex"
- :let line1=ScreenChar(line('.'),8)
- :call DoRecordScreen()
- :"
- :let g:test="Test 15: breakindent + visual blockwise delete #2"
- :%d
- :normal! 4a1234567890
- :exec "normal! >>\<C-V>3f0x"
- :let line1=ScreenChar(line('.'),20)
- :call DoRecordScreen()
- :quit!
- :"
- :%w! test.out
- :qa!
- ENDTEST
- dummy text
--- 0 ----
*** ../vim-8.0.0089/src/testdir/test_breakindent.ok	2015-01-27 13:06:51.000000000 +0100
--- src/testdir/test_breakindent.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,74 ****
- 
- 	abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP
- 
- Test 1: Simple breakindent
-     abcd
-     qrst
-     GHIJ
- 
- Test 2: Simple breakindent + sbr=>>
-     abcd
-     >>qr
-     >>EF
- 
- Test 3: Simple breakindent + briopt:sbr
-     abcd
- ++  qrst
- ++  GHIJ
- 
- Test 4: Simple breakindent + min width: 18
-     abcd
-   qrstuv
-   IJKLMN
- 
-  Test 5: Simple breakindent + shift by 2
-     abcd
-       qr
-       EF
- 
-  Test 6: Simple breakindent + shift by -1
-     abcd
-    qrstu
-    HIJKL
- 
-  Test 7: breakindent + shift by +1 + nu + sbr=? briopt:sbr
-   2     ab
- ?        m
- ?        x
- 
-  Test 8: breakindent + shift:1 + nu + sbr=# list briopt:sbr
-   2 ^Iabcd
- #      opq
- #      BCD
- 
-  Test 9: breakindent + shift by +1 + 'nu' + sbr=# list
-   2 ^Iabcd
-        #op
-        #AB
- 
-  Test 10: breakindent + shift by +1 + 'nu' + sbr=~ cpo+=n
-   2     ab
- ~       mn
- ~       yz
- 
-  Test 11: strdisplaywidth when breakindent is on
- strdisplaywidth: 46 == calculated: 64
- 					{
- 
-  Test 12: breakindent + long indent
- 56        
-           
- ~         
- Test 13: breakindent with wrapping Tab
- d
- w
- 
- Test 14: breakindent + visual blockwise delete #1
- e       
- ~       
- ~       
- 
- Test 15: breakindent + visual blockwise delete #2
-         1234567890  
- ~                   
- ~                   
--- 0 ----
*** ../vim-8.0.0089/src/testdir/test_breakindent.vim	2016-11-17 19:31:49.285221709 +0100
--- src/testdir/test_breakindent.vim	2016-11-17 19:26:47.999305286 +0100
***************
*** 0 ****
--- 1,241 ----
+ " Test for breakindent
+ "
+ " Note: if you get strange failures when adding new tests, it might be that
+ " while the test is run, the breakindent cacheing gets in its way.
+ " It helps to change the tabastop setting and force a redraw (e.g. see
+ " Test_breakindent08())
+ if !exists('+breakindent')
+   finish
+ endif
+ 
+ let s:input ="\tabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOP"
+ 
+ function s:screenline(lnum, width) abort
+   " always get 4 screen lines
+   redraw!
+   let line = []
+   for j in range(3)
+     for c in range(1, a:width)
+   call add(line, nr2char(screenchar(a:lnum+j, c)))
+     endfor
+     call add(line, "\n")
+   endfor
+   return join(line, '')
+ endfunction
+ 
+ function s:testwindows(...)
+   10new
+   vsp
+   vert resize 20
+   setl ts=4 sw=4 sts=4 breakindent 
+   put =s:input
+   if a:0
+     exe a:1
+   endif
+ endfunction
+ 
+ function s:close_windows(...)
+   bw!
+   if a:0
+     exe a:1
+   endif
+   unlet! g:line g:expect
+ endfunction
+ 
+ function Test_breakindent01()
+   " simple breakindent test
+   call s:testwindows('setl briopt=min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n    qrst\n    GHIJ\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent02()
+   " simple breakindent test with showbreak set
+   call s:testwindows('setl briopt=min:0 sbr=>>')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n    >>qr\n    >>EF\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent03()
+   " simple breakindent test with showbreak set and briopt including sbr
+   call s:testwindows('setl briopt=sbr,min:0 sbr=++')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n++  qrst\n++  GHIJ\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent04()
+   " breakindent set with min width 18
+   call s:testwindows('setl sbr= briopt=min:18')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n  qrstuv\n  IJKLMN\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent05()
+   " breakindent set and shift by 2
+   call s:testwindows('setl briopt=shift:2,min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n      qr\n      EF\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent06()
+   " breakindent set and shift by -1
+   call s:testwindows('setl briopt=shift:-1,min:0')
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="    abcd\n   qrstu\n   HIJKL\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent07()
+   " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4 cpo+=n')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n?        m\n?        x\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent07a()
+   " breakindent set and shift by 1, Number  set sbr=? and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu sbr=? nuw=4')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n    ?    m\n    ?    x\n"
+   call assert_equal(g:expect, g:line)
+   " clean up
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent08()
+   " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list cpo+=n ts=4')
+   " make sure, cache is invalidated!
+   set ts=8
+   redraw!
+   set ts=4
+   redraw!
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n#      opq\n#      BCD\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent08a()
+   " breakindent set and shift by 1, Number and list set sbr=# and briopt:sbr
+   call s:testwindows('setl briopt=shift:1,sbr,min:0 nu nuw=4 sbr=# list')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n    #  opq\n    #  BCD\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent09()
+   " breakindent set and shift by 1, Number and list set sbr=#
+   call s:testwindows('setl briopt=shift:1,min:0 nu nuw=4 sbr=# list')
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2 ^Iabcd\n       #op\n       #AB\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent10()
+   " breakindent set, Number set sbr=~
+   call s:testwindows('setl cpo+=n sbr=~ nu nuw=4 nolist briopt=sbr,min:0')
+   " make sure, cache is invalidated!
+   set ts=8
+   redraw!
+   set ts=4
+   redraw!
+   let g:line=s:screenline(line('.'),10)
+   let g:expect="  2     ab\n~       mn\n~       yz\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set sbr= cpo-=n')
+ endfunction
+ 
+ function Test_breakindent11()
+   " test strdisplaywidth()
+   call s:testwindows('setl cpo-=n sbr=>> nu nuw=4 nolist briopt= ts=4')
+   let text=getline(2)
+   let width = strlen(text[1:])+indent(2)+strlen(&sbr)*3 " text wraps 3 times
+   call assert_equal(width, strdisplaywidth(text))
+   call s:close_windows('set sbr=')
+ endfunction
+ 
+ function Test_breakindent12()
+   " test breakindent with long indent
+   let s:input="\t\t\t\t\t{"
+   call s:testwindows('setl breakindent linebreak briopt=min:10 nu numberwidth=3 ts=4 list listchars=tab:>-')
+   let g:line=s:screenline(2,16)
+   let g:expect=" 2 >--->--->--->\n          ---{  \n~               \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows('set nuw=4 listchars=')
+ endfunction
+ 
+ function Test_breakindent13()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt=min:10 ts=8')
+   vert resize 20
+   call setline(1, ["    a\tb\tc\td\te", "    z   y       x       w       v"])
+   1
+   norm! fbgj"ayl
+   2
+   norm! fygj"byl
+   call assert_equal('d', @a)
+   call assert_equal('w', @b)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent14()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt= ts=8')
+   vert resize 30
+   norm! 3a1234567890
+   norm! a    abcde
+   exec "norm! 0\<C-V>tex"
+   let g:line=s:screenline(line('.'),8)
+   let g:expect="e       \n~       \n~       \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent15()
+   let s:input=""
+   call s:testwindows('setl breakindent briopt= ts=8 sw=8')
+   vert resize 30
+   norm! 4a1234567890
+   exe "normal! >>\<C-V>3f0x"
+   let g:line=s:screenline(line('.'),20)
+   let g:expect="        1234567890  \n~                   \n~                   \n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
+ 
+ function Test_breakindent16()
+   " Check that overlong lines are indented correctly.
+   " TODO: currently it does not fail even when the bug is not fixed.
+   let s:input=""
+   call s:testwindows('setl breakindent briopt=min:0 ts=4')
+   call setline(1, "\t".repeat("1234567890", 10))
+   resize 6
+   norm! 1gg$
+   redraw!
+   let g:line=s:screenline(1,10)
+   let g:expect="    123456\n    789012\n    345678\n"
+   call assert_equal(g:expect, g:line)
+   let g:line=s:screenline(4,10)
+   let g:expect="    901234\n    567890\n    123456\n"
+   call assert_equal(g:expect, g:line)
+   call s:close_windows()
+ endfunction
*** ../vim-8.0.0089/src/Makefile	2016-11-15 21:16:46.746453073 +0100
--- src/Makefile	2016-11-17 19:25:11.119976976 +0100
***************
*** 2029,2035 ****
  test1 \
  	test_autocmd_option \
  	test_autoformat_join \
- 	test_breakindent \
  	test_changelist \
  	test_close_count \
  	test_comparators \
--- 2029,2034 ----
***************
*** 2064,2069 ****
--- 2063,2069 ----
  	test_autochdir \
  	test_autocmd \
  	test_backspace_opt \
+ 	test_breakindent \
  	test_bufwintabinfo \
  	test_cdo \
  	test_channel \
*** ../vim-8.0.0089/src/version.c	2016-11-17 19:11:51.717378244 +0100
--- src/version.c	2016-11-17 19:24:36.424217741 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     90,
  /**/

-- 
"You know, it's at times like this when I'm trapped in a Vogon airlock with
a man from Betelgeuse and about to die of asphyxiation in deep space that I
really wish I'd listened to what my mother told me when I was young!"
"Why, what did she tell you?"
"I don't know, I didn't listen!"
		-- Arthur Dent and Ford Prefect in Douglas Adams'
		   "The Hitchhiker's Guide to the Galaxy"

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0091
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0091
Problem:    Test_help_complete sometimes fails in MS-Windows console.
Solution:   Use getcompletion() instead of feedkeys() and command line
            completion. (Hirohito Higashi)
Files:      src/testdir/test_help_tagjump.vim


*** ../vim-8.0.0090/src/testdir/test_help_tagjump.vim	2016-08-18 22:59:47.000000000 +0200
--- src/testdir/test_help_tagjump.vim	2016-11-17 19:38:16.806536964 +0100
***************
*** 77,93 ****
    endif
  endfunc
  
! func s:get_cmd_compl_list(cmd)
!   let list = []
!   let str = ''
!   for cnt in range(1, 999)
!     call feedkeys(a:cmd . repeat("\<Tab>", cnt) . "'\<C-B>let str='\<CR>", 'tx')
!     if str ==# a:cmd[1:]
!       break
!     endif
!     call add(list, str)
!   endfor
!   return list
  endfunc
  
  func Test_help_complete()
--- 77,84 ----
    endif
  endfunc
  
! func s:get_help_compl_list(cmd)
!   return getcompletion(a:cmd, 'help')
  endfunc
  
  func Test_help_complete()
***************
*** 99,147 ****
      if has('multi_lang')
        set helplang=
      endif
!     let list = s:get_cmd_compl_list(":h test")
!     call assert_equal(['h test-col', 'h test-char'], list)
  
      if has('multi_lang')
        " 'helplang=ab' and help file lang is 'en'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(['h test-col', 'h test-char'], list)
  
        " 'helplang=' and help file lang is 'en' and 'ab'
        set rtp+=Xdir1/doc-ab
        set helplang=
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col@en', 'h test-col@ab',
!             \             'h test-char@en', 'h test-char@ab']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en' and 'ab'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@en',
!             \             'h test-char', 'h test-char@en']), sort(list))
  
        " 'helplang=' and help file lang is 'en', 'ab' and 'ja'
        set rtp+=Xdir1/doc-ja
        set helplang=
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col@en', 'h test-col@ab',
!             \             'h test-col@ja', 'h test-char@en',
!             \             'h test-char@ab', 'h test-char@ja']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@en',
!             \             'h test-col@ja', 'h test-char',
!             \             'h test-char@en', 'h test-char@ja']), sort(list))
  
        " 'helplang=ab,ja' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab,ja
!       let list = s:get_cmd_compl_list(":h test")
!       call assert_equal(sort(['h test-col', 'h test-col@ja',
!             \             'h test-col@en', 'h test-char',
!             \             'h test-char@ja', 'h test-char@en']), sort(list))
      endif
    catch
      call assert_exception('X')
--- 90,138 ----
      if has('multi_lang')
        set helplang=
      endif
!     let list = s:get_help_compl_list("test")
!     call assert_equal(['test-col', 'test-char'], list)
  
      if has('multi_lang')
        " 'helplang=ab' and help file lang is 'en'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(['test-col', 'test-char'], list)
  
        " 'helplang=' and help file lang is 'en' and 'ab'
        set rtp+=Xdir1/doc-ab
        set helplang=
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col@en', 'test-col@ab',
!             \             'test-char@en', 'test-char@ab']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en' and 'ab'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@en',
!             \             'test-char', 'test-char@en']), sort(list))
  
        " 'helplang=' and help file lang is 'en', 'ab' and 'ja'
        set rtp+=Xdir1/doc-ja
        set helplang=
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col@en', 'test-col@ab',
!             \             'test-col@ja', 'test-char@en',
!             \             'test-char@ab', 'test-char@ja']), sort(list))
  
        " 'helplang=ab' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@en',
!             \             'test-col@ja', 'test-char',
!             \             'test-char@en', 'test-char@ja']), sort(list))
  
        " 'helplang=ab,ja' and help file lang is 'en', 'ab' and 'ja'
        set helplang=ab,ja
!       let list = s:get_help_compl_list("test")
!       call assert_equal(sort(['test-col', 'test-col@ja',
!             \             'test-col@en', 'test-char',
!             \             'test-char@ja', 'test-char@en']), sort(list))
      endif
    catch
      call assert_exception('X')
*** ../vim-8.0.0090/src/version.c	2016-11-17 19:32:17.901024218 +0100
--- src/version.c	2016-11-17 19:42:02.032924245 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     91,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
29. Your phone bill comes to your doorstep in a box.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0092
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0092
Problem:    C indenting does not support nested namespaces that C++ 17 has.
Solution:   Add check that passes double colon inside a name. (Pauli, closes
            #1214)
Files:      src/misc1.c, src/testdir/test3.in, src/testdir/test3.ok


*** ../vim-8.0.0091/src/misc1.c	2016-10-12 14:19:55.746357751 +0200
--- src/misc1.c	2016-11-17 21:21:03.040128865 +0100
***************
*** 5762,5767 ****
--- 5762,5768 ----
  {
      char_u	*p;
      int		has_name = FALSE;
+     int		has_name_start = FALSE;
  
      s = cin_skipcomment(s);
      if (STRNCMP(s, "namespace", 9) == 0 && (s[9] == NUL || !vim_iswordc(s[9])))
***************
*** 5780,5789 ****
--- 5781,5798 ----
  	    }
  	    else if (vim_iswordc(*p))
  	    {
+ 		has_name_start = TRUE;
  		if (has_name)
  		    return FALSE; /* word character after skipping past name */
  		++p;
  	    }
+ 	    else if (p[0] == ':' && p[1] == ':' && vim_iswordc(p[2]))
+ 	    {
+ 		if (!has_name_start || has_name)
+ 		    return FALSE;
+ 		/* C++ 17 nested namespace */
+ 		p += 3;
+ 	    }
  	    else
  	    {
  		return FALSE;
*** ../vim-8.0.0091/src/testdir/test3.in	2015-11-10 13:56:14.000000000 +0100
--- src/testdir/test3.in	2016-11-17 21:16:53.861790464 +0100
***************
*** 1932,1937 ****
--- 1932,1957 ----
  {
    111111111111111111;
  }
+ namespace test::cpp17
+ {
+   111111111111111111;
+ }
+ namespace ::incorrectcpp17
+ {
+   111111111111111111;
+ }
+ namespace test::incorrectcpp17::
+ {
+   111111111111111111;
+ }
+ namespace test:incorrectcpp17
+ {
+   111111111111111111;
+ }
+ namespace test:::incorrectcpp17
+ {
+   111111111111111111;
+ }
  namespace{
    111111111111111111;
  }
*** ../vim-8.0.0091/src/testdir/test3.ok	2015-11-10 13:56:40.000000000 +0100
--- src/testdir/test3.ok	2016-11-17 21:16:53.861790464 +0100
***************
*** 1730,1735 ****
--- 1730,1755 ----
  {
  111111111111111111;
  }
+ namespace test::cpp17
+ {
+ 111111111111111111;
+ }
+ namespace ::incorrectcpp17
+ {
+ 	111111111111111111;
+ }
+ namespace test::incorrectcpp17::
+ {
+ 	111111111111111111;
+ }
+ namespace test:incorrectcpp17
+ {
+ 	111111111111111111;
+ }
+ namespace test:::incorrectcpp17
+ {
+ 	111111111111111111;
+ }
  namespace{
  111111111111111111;
  }
*** ../vim-8.0.0091/src/version.c	2016-11-17 19:44:56.627678988 +0100
--- src/version.c	2016-11-17 21:18:59.916949760 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     92,
  /**/

-- 
Due knot trussed yore spell chequer two fined awl miss steaks.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0093
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0093
Problem:    Not using multiprocess build feature.
Solution:   Enable multiprocess build with MSVC 10. (Ken Takata)
Files:      src/Make_mvc.mak


*** ../vim-8.0.0092/src/Make_mvc.mak	2016-10-12 14:19:55.738357808 +0200
--- src/Make_mvc.mak	2016-11-19 17:14:13.715603450 +0100
***************
*** 297,302 ****
--- 297,305 ----
  # Flag to turn on Win64 compatibility warnings for VC7.x and VC8.
  WP64CHECK = /Wp64
  
+ # Use multiprocess build
+ USE_MP = yes
+ 
  #>>>>> path of the compiler and linker; name of include and lib directories
  # PATH = c:\msvc20\bin;$(PATH)
  # INCLUDE = c:\msvc20\include
***************
*** 473,478 ****
--- 476,489 ----
  NODEFAULTLIB = /nodefaultlib
  !endif
  
+ # Use multiprocess build on MSVC 10
+ !if "$(USE_MP)"=="yes"
+ !if $(MSVC_MAJOR) >= 10
+ CFLAGS = $(CFLAGS) /MP
+ !endif
+ !endif
+ 
+ 
  !ifdef NODEBUG
  VIM = vim
  !if "$(OPTIMIZE)" == "SPACE"
*** ../vim-8.0.0092/src/version.c	2016-11-17 21:30:17.144445729 +0100
--- src/version.c	2016-11-19 17:15:10.123226082 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     93,
  /**/

-- 
hundred-and-one symptoms of being an internet addict:
38. You wake up at 3 a.m. to go to the bathroom and stop and check your e-mail
    on the way back to bed.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0094
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0094
Problem:    When vimrun.exe is not found the error message is not properly
            encoded.
Solution:   Use utf-16 and MessageBoxW(). (Ken Takata)
Files:      src/os_win32.c
    

*** ../vim-8.0.0093/src/os_win32.c	2016-11-17 17:25:28.212093109 +0100
--- src/os_win32.c	2016-11-19 17:28:31.537877020 +0100
***************
*** 4705,4716 ****
  #if defined(FEAT_GUI_W32)
  		if (need_vimrun_warning)
  		{
! 		    MessageBox(NULL,
! 			    _("VIMRUN.EXE not found in your $PATH.\n"
! 				"External commands will not pause after completion.\n"
! 				"See  :help win32-vimrun  for more information."),
! 			    _("Vim Warning"),
! 			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
  		if (!s_dont_use_vimrun && p_stmp)
--- 4705,4728 ----
  #if defined(FEAT_GUI_W32)
  		if (need_vimrun_warning)
  		{
! 		    char *msg = _("VIMRUN.EXE not found in your $PATH.\n"
! 			"External commands will not pause after completion.\n"
! 			"See  :help win32-vimrun  for more information.");
! 		    char *title = _("Vim Warning");
! # ifdef FEAT_MBYTE
! 		    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 		    {
! 			WCHAR *wmsg = enc_to_utf16((char_u *)msg, NULL);
! 			WCHAR *wtitle = enc_to_utf16((char_u *)title, NULL);
! 
! 			if (wmsg != NULL && wtitle != NULL)
! 			    MessageBoxW(NULL, wmsg, wtitle, MB_ICONWARNING);
! 			vim_free(wmsg);
! 			vim_free(wtitle);
! 		    }
! 		    else
! # endif
! 			MessageBox(NULL, msg, title, MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
  		if (!s_dont_use_vimrun && p_stmp)
*** ../vim-8.0.0093/src/version.c	2016-11-19 17:17:09.442428237 +0100
--- src/version.c	2016-11-19 17:26:21.074746311 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     94,
  /**/

-- 
Everyone has a photographic memory. Some don't have film.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0095
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0095
Problem:    Problems with GTK 3.22.2 fixed in 3.22.4.
Solution:   Adjust the #ifdefs. (Kazunobu Kuriyama)
Files:      src/gui_gtk_x11.c


*** ../vim-8.0.0094/src/gui_gtk_x11.c	2016-11-17 19:11:51.713378271 +0100
--- src/gui_gtk_x11.c	2016-11-21 20:53:44.123726068 +0100
***************
*** 3102,3108 ****
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
! # if GTK_CHECK_VERSION(3,22,2)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
--- 3102,3108 ----
      g_return_val_if_fail(event
  	    && event->width >= 1 && event->height >= 1, TRUE);
  
! # if GTK_CHECK_VERSION(3,22,2) && !GTK_CHECK_VERSION(3,22,4)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
***************
*** 3123,3128 ****
--- 3123,3132 ----
       * implementation details.  Therefore, watch out any relevant internal
       * changes happening in GTK in the feature (sigh).
       */
+     /* Follow-up
+      * After a few weeks later, the GdkWindow change mentioned above was
+      * reverted (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=f70039cb9603a02d2369fec4038abf40a1711155).
+      * The corresponding official release is 3.22.4. */
      if (event->send_event == FALSE)
  	return TRUE;
  # endif
***************
*** 4492,4498 ****
  {
      int usable_height = event->height;
  
! #if GTK_CHECK_VERSION(3,22,2)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
--- 4496,4502 ----
  {
      int usable_height = event->height;
  
! #if GTK_CHECK_VERSION(3,22,2) && !GTK_CHECK_VERSION(3,22,4)
      /* As of 3.22.2, GdkWindows have started distributing configure events to
       * their "native" children (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=12579fe71b3b8f79eb9c1b80e429443bcc437dd0).
       *
***************
*** 4508,4513 ****
--- 4512,4521 ----
       * To filter out such fallacious events, check if the given event is the
       * one that was sent out to the right place. Ignore it if not.
       */
+     /* Follow-up
+      * After a few weeks later, the GdkWindow change mentioned above was
+      * reverted (https://git.gnome.org/browse/gtk+/commit/?h=gtk-3-22&id=f70039cb9603a02d2369fec4038abf40a1711155).
+      * The corresponding official release is 3.22.4. */
      if (event->window != gtk_widget_get_window(gui.formwin))
  	return TRUE;
  #endif
*** ../vim-8.0.0094/src/version.c	2016-11-19 17:28:41.577810144 +0100
--- src/version.c	2016-11-21 20:54:36.527350483 +0100
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     95,
  /**/

-- 
Those who live by the sword get shot by those who don't.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
