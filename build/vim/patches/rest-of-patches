To: vim_dev@googlegroups.com
Subject: Patch 8.0.0015
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0015
Problem:    Can't tell which part of a channel has "buffered" status.
Solution:   Add an optional argument to ch_status().  Let ch_info() also
            return "buffered" for out_status and err_status.
Files:      src/evalfunc.c, src/channel.c, src/proto/channel.pro,
            src/testdir/test_channel.vim, runtime/doc/eval.txt


*** ../vim-8.0.0014/src/evalfunc.c	2016-09-25 21:44:59.441600148 +0200
--- src/evalfunc.c	2016-09-26 22:03:14.961368676 +0200
***************
*** 514,520 ****
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 1, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
--- 514,520 ----
      {"ch_sendexpr",	2, 3, f_ch_sendexpr},
      {"ch_sendraw",	2, 3, f_ch_sendraw},
      {"ch_setoptions",	2, 2, f_ch_setoptions},
!     {"ch_status",	1, 2, f_ch_status},
  #endif
      {"changenr",	0, 0, f_changenr},
      {"char2nr",		1, 2, f_char2nr},
***************
*** 1985,1997 ****
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel));
  }
  #endif
  
--- 1985,2008 ----
  f_ch_status(typval_T *argvars, typval_T *rettv)
  {
      channel_T	*channel;
+     jobopt_T	opt;
+     int		part = -1;
  
      /* return an empty string by default */
      rettv->v_type = VAR_STRING;
      rettv->vval.v_string = NULL;
  
      channel = get_channel_arg(&argvars[0], FALSE, FALSE, 0);
! 
!     if (argvars[1].v_type != VAR_UNKNOWN)
!     {
! 	clear_job_options(&opt);
! 	if (get_job_options(&argvars[1], &opt, JO_PART) == OK
! 						     && (opt.jo_set & JO_PART))
! 	    part = opt.jo_part;
!     }
! 
!     rettv->vval.v_string = vim_strsave((char_u *)channel_status(channel, part));
  }
  #endif
  
*** ../vim-8.0.0014/src/channel.c	2016-09-07 23:15:55.000000000 +0200
--- src/channel.c	2016-09-26 22:19:18.270706785 +0200
***************
*** 2590,2612 ****
  
  /*
   * Return a string indicating the status of the channel.
   */
      char *
! channel_status(channel_T *channel)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (channel_is_open(channel))
! 	 return "open";
!     for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	if (channel_has_readahead(channel, part))
! 	{
  	    has_readahead = TRUE;
! 	    break;
! 	}
  
      if (has_readahead)
  	return "buffered";
--- 2590,2630 ----
  
  /*
   * Return a string indicating the status of the channel.
+  * If "req_part" is not negative check that part.
   */
      char *
! channel_status(channel_T *channel, int req_part)
  {
      int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
  	 return "fail";
!     if (req_part == PART_OUT)
!     {
! 	if (channel->CH_OUT_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_OUT))
  	    has_readahead = TRUE;
!     }
!     else if (req_part == PART_ERR)
!     {
! 	if (channel->CH_ERR_FD != INVALID_FD)
! 	    return "open";
! 	if (channel_has_readahead(channel, PART_ERR))
! 	    has_readahead = TRUE;
!     }
!     else
!     {
! 	if (channel_is_open(channel))
! 	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
! 	    if (channel_has_readahead(channel, part))
! 	    {
! 		has_readahead = TRUE;
! 		break;
! 	    }
!     }
  
      if (has_readahead)
  	return "buffered";
***************
*** 2619,2624 ****
--- 2637,2643 ----
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
      size_t	tail;
+     char	*status;
      char	*s = "";
  
      vim_strncpy((char_u *)namebuf, (char_u *)name, 4);
***************
*** 2626,2633 ****
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     dict_add_nr_str(dict, namebuf, 0,
! 		(char_u *)(chanpart->ch_fd == INVALID_FD ? "closed" : "open"));
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
--- 2645,2657 ----
      tail = STRLEN(namebuf);
  
      STRCPY(namebuf + tail, "status");
!     if (chanpart->ch_fd != INVALID_FD)
! 	status = "open";
!     else if (channel_has_readahead(channel, part))
! 	status = "buffered";
!     else
! 	status = "closed";
!     dict_add_nr_str(dict, namebuf, 0, (char_u *)status);
  
      STRCPY(namebuf + tail, "mode");
      switch (chanpart->ch_mode)
***************
*** 2660,2666 ****
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel));
  
      if (channel->ch_hostname != NULL)
      {
--- 2684,2690 ----
  channel_info(channel_T *channel, dict_T *dict)
  {
      dict_add_nr_str(dict, "id", channel->ch_id, NULL);
!     dict_add_nr_str(dict, "status", 0, (char_u *)channel_status(channel, -1));
  
      if (channel->ch_hostname != NULL)
      {
***************
*** 4244,4249 ****
--- 4268,4275 ----
  		val = get_tv_string(item);
  		if (STRCMP(val, "err") == 0)
  		    opt->jo_part = PART_ERR;
+ 		else if (STRCMP(val, "out") == 0)
+ 		    opt->jo_part = PART_OUT;
  		else
  		{
  		    EMSG2(_(e_invarg2), val);
*** ../vim-8.0.0014/src/proto/channel.pro	2016-09-12 13:04:24.000000000 +0200
--- src/proto/channel.pro	2016-09-26 22:14:54.376537165 +0200
***************
*** 24,30 ****
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
--- 24,30 ----
  int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
! char *channel_status(channel_T *channel, int req_part);
  void channel_info(channel_T *channel, dict_T *dict);
  void channel_close(channel_T *channel, int invoke_close_cb);
  void channel_close_in(channel_T *channel);
*** ../vim-8.0.0014/src/testdir/test_channel.vim	2016-09-07 23:23:56.000000000 +0200
--- src/testdir/test_channel.vim	2016-09-26 22:34:36.352321622 +0200
***************
*** 434,439 ****
--- 434,456 ----
    let job = job_start(s:python . " test_channel_pipe.py", {'mode': 'raw'})
    call assert_equal(v:t_job, type(job))
    call assert_equal("run", job_status(job))
+ 
+   call assert_equal("open", ch_status(job))
+   call assert_equal("open", ch_status(job), {"part": "out"})
+   call assert_equal("open", ch_status(job), {"part": "err"})
+   call assert_fails('call ch_status(job, {"in_mode": "raw"})', 'E475:')
+   call assert_fails('call ch_status(job, {"part": "in"})', 'E475:')
+ 
+   let dict = ch_info(job)
+   call assert_true(dict.id != 0)
+   call assert_equal('open', dict.status)
+   call assert_equal('open', dict.out_status)
+   call assert_equal('RAW', dict.out_mode)
+   call assert_equal('pipe', dict.out_io)
+   call assert_equal('open', dict.err_status)
+   call assert_equal('RAW', dict.err_mode)
+   call assert_equal('pipe', dict.err_io)
+ 
    try
      " For a change use the job where a channel is expected.
      call ch_sendraw(job, "echo something\n")
*** ../vim-8.0.0014/runtime/doc/eval.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/eval.txt	2016-09-26 22:24:12.284664360 +0200
***************
*** 2030,2036 ****
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle})		String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
--- 2031,2038 ----
  				any	send {string} over raw {handle}
  ch_setoptions({handle}, {options})
  				none	set options for {handle}
! ch_status({handle} [, {options}])
! 				String	status of channel {handle}
  changenr()			Number	current change number
  char2nr({expr}[, {utf8}])	Number	ASCII/UTF8 value of first char in {expr}
  cindent({lnum})			Number	C indent for line {lnum}
***************
*** 3041,3047 ****
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open" (any part is open) or "closed"
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
--- 3043,3050 ----
  		Returns a Dictionary with information about {handle}.  The
  		items are:
  		   "id"		  number of the channel
! 		   "status"	  "open", "buffered" or "closed", like
! 				  ch_status()
  		When opened with ch_open():
  		   "hostname"	  the hostname of the address
  		   "port"	  the port of the address
***************
*** 3050,3060 ****
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
--- 3053,3063 ----
  		   "sock_io"	  "socket"
  		   "sock_timeout" timeout in msec
  		When opened with job_start():
! 		   "out_status"	  "open", "buffered" or "closed"
  		   "out_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "out_io"	  "null", "pipe", "file" or "buffer"
  		   "out_timeout"  timeout in msec
! 		   "err_status"	  "open", "buffered" or "closed"
  		   "err_mode"	  "NL", "RAW", "JSON" or "JS"
  		   "err_io"	  "out", "null", "pipe", "file" or "buffer"
  		   "err_timeout"  timeout in msec
***************
*** 3139,3145 ****
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle})						*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
--- 3142,3148 ----
  		These options cannot be changed:
  			"waittime"	only applies to |ch_open()|
  
! ch_status({handle} [, {options}])				*ch_status()*
  		Return the status of {handle}:
  			"fail"		failed to open the channel
  			"open"		channel can be used
***************
*** 3149,3154 ****
--- 3152,3162 ----
  		"buffered" is used when the channel was closed but there is
  		still data that can be obtained with |ch_read()|.
  
+ 		If {options} is given it can contain a "part" entry to specify
+ 		the part of the channel to return the status for: "out" or
+ 		"err".  For example, to get the error status: >
+ 			ch_status(job, {"part": "err"})
+ <
  							*copy()*
  copy({expr})	Make a copy of {expr}.  For Numbers and Strings this isn't
  		different from using {expr} directly.
*** ../vim-8.0.0014/src/version.c	2016-09-26 20:14:49.925906743 +0200
--- src/version.c	2016-09-26 22:15:39.060227458 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     15,
  /**/

-- 
"A mouse can be just as dangerous as a bullet or a bomb."
             (US Representative Lamar Smith, R-Texas)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0016
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0016 (after 8.0.0015)
Problem:    Build fails.
Solution:   Include missing change.
Files:      src/eval.c


*** ../vim-8.0.0015/src/eval.c	2016-08-29 22:42:20.000000000 +0200
--- src/eval.c	2016-09-26 22:57:29.622842295 +0200
***************
*** 7305,7311 ****
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
--- 7305,7311 ----
  #ifdef FEAT_JOB_CHANNEL
  	    {
  		channel_T *channel = varp->vval.v_channel;
! 		char      *status = channel_status(channel, -1);
  
  		if (channel == NULL)
  		    vim_snprintf((char *)buf, NUMBUFLEN, "channel %s", status);
*** ../vim-8.0.0015/src/version.c	2016-09-26 22:36:50.619386344 +0200
--- src/version.c	2016-09-26 22:58:00.882626187 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     16,
  /**/

-- 
Nothing is impossible for the man who doesn't have to do it.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0017
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0017
Problem:    Cannot get the number of the current quickfix or location list.
Solution:   Use the current list if "nr" in "what" is zero. (Yegappan
            Lakshmanan)  Remove debug command from test.
Files:      src/quickfix.c, src/testdir/test_quickfix.vim,
            runtime/doc/eval.txt


*** ../vim-8.0.0016/src/quickfix.c	2016-09-25 21:44:59.445600117 +0200
--- src/quickfix.c	2016-09-27 21:27:48.729788268 +0200
***************
*** 4591,4599 ****
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    qf_idx = di->di_tv.vval.v_number - 1;
! 	    if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		return FAIL;
  	    flags |= QF_GETLIST_NR;
  	}
  	else
--- 4591,4603 ----
  	/* Use the specified quickfix/location list */
  	if (di->di_tv.v_type == VAR_NUMBER)
  	{
! 	    /* for zero use the current list */
! 	    if (di->di_tv.vval.v_number != 0)
! 	    {
! 		qf_idx = di->di_tv.vval.v_number - 1;
! 		if (qf_idx < 0 || qf_idx >= qi->qf_listcount)
! 		    return FAIL;
! 	    }
  	    flags |= QF_GETLIST_NR;
  	}
  	else
*** ../vim-8.0.0016/src/testdir/test_quickfix.vim	2016-09-01 15:39:30.000000000 +0200
--- src/testdir/test_quickfix.vim	2016-09-27 21:22:51.671854368 +0200
***************
*** 1429,1440 ****
    laddexpr 'one.txt:3:one one one'
  
    let loc_one = getloclist(one_id)
- echo string(loc_one)
    call assert_equal('Xone/a/one.txt', bufname(loc_one[1].bufnr))
    call assert_equal(3, loc_one[1].lnum)
  
    let loc_two = getloclist(two_id)
- echo string(loc_two)
    call assert_equal('Xtwo/a/two.txt', bufname(loc_two[1].bufnr))
    call assert_equal(5, loc_two[1].lnum)
  
--- 1429,1438 ----
***************
*** 1534,1539 ****
--- 1532,1542 ----
      call assert_equal('N1', g:Xgetlist({'all':1}).title)
      call g:Xsetlist([], ' ', {'title' : 'N2'})
      call assert_equal(qfnr + 1, g:Xgetlist({'all':1}).nr)
+ 
+     let res = g:Xgetlist({'nr': 0})
+     call assert_equal(qfnr + 1, res.nr)
+     call assert_equal(['nr'], keys(res))
+ 
      call g:Xsetlist([], ' ', {'title' : 'N3'})
      call assert_equal('N2', g:Xgetlist({'nr':2, 'title':1}).title)
  
***************
*** 1546,1552 ****
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, ['title']))
      endif
  endfunction
  
--- 1549,1555 ----
      call assert_equal({}, g:Xgetlist({'abc':1}))
  
      if a:cchar == 'l'
! 	call assert_equal({}, getloclist(99, {'title': 1}))
      endif
  endfunction
  
*** ../vim-8.0.0016/runtime/doc/eval.txt	2016-09-26 22:36:50.619386344 +0200
--- runtime/doc/eval.txt	2016-09-27 21:14:57.863151829 +0200
***************
*** 4510,4516 ****
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
--- 4516,4523 ----
  		If the optional {what} dictionary argument is supplied, then
  		returns only the items listed in {what} as a dictionary. The
  		following string items are supported in {what}:
! 			nr	get information for this quickfix list; zero
! 				means the current quickfix list
  			title	get the list title
  			winid	get the |window-ID| (if opened)
  			all	all of the above quickfix properties
*** ../vim-8.0.0016/src/version.c	2016-09-26 22:58:54.498255420 +0200
--- src/version.c	2016-09-27 21:17:23.714136503 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     17,
  /**/

-- 
This is the polymorph virus!  Follow these instructions carefully:
1. Send this message to everybody you know.
2. Format your harddisk.
Thank you for your cooperation in spreading the most powerful virus ever!

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0018
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0018
Problem:    When using ":sleep" channel input is not handled.
Solution:   When there is a channel check for input also when not in raw mode.
            Check every 100 msec.
Files:      src/channel.c, src/proto/channel.pro, src/ui.c, src/proto/ui.pro,
            src/ex_docmd.c, src/os_amiga.c, src/proto/os_amiga.pro,
            src/os_unix.c, src/proto/os_unix.pro, src/os_win32.c,
            src/proto/os_win32.pro


*** ../vim-8.0.0017/src/channel.c	2016-09-26 22:36:50.615386371 +0200
--- src/channel.c	2016-09-29 15:12:13.482556346 +0200
***************
*** 341,346 ****
--- 341,352 ----
      return channel;
  }
  
+     int
+ has_any_channel(void)
+ {
+     return first_channel != NULL;
+ }
+ 
  /*
   * Called when the refcount of a channel is zero.
   * Return TRUE if "channel" has a callback and the associated job wasn't
*** ../vim-8.0.0017/src/proto/channel.pro	2016-09-26 22:36:50.615386371 +0200
--- src/proto/channel.pro	2016-09-29 14:59:14.620048830 +0200
***************
*** 4,9 ****
--- 4,10 ----
  void ch_log(channel_T *ch, char *msg);
  void ch_logs(channel_T *ch, char *msg, char *name);
  channel_T *add_channel(void);
+ int has_any_channel(void);
  int channel_unref(channel_T *channel);
  int free_unused_channels_contents(int copyID, int mask);
  void free_unused_channels(int copyID, int mask);
*** ../vim-8.0.0017/src/ui.c	2016-08-29 22:42:20.000000000 +0200
--- src/ui.c	2016-09-29 15:06:26.753000044 +0200
***************
*** 353,364 ****
      void
  ui_breakcheck(void)
  {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck();
  }
  
  /*****************************************************************************
--- 353,374 ----
      void
  ui_breakcheck(void)
  {
+     ui_breakcheck_force(FALSE);
+ }
+ 
+ /*
+  * When "force" is true also check when the terminal is not in raw mode.
+  * This is useful to read input on channels.
+  */
+     void
+ ui_breakcheck_force(int force)
+ {
  #ifdef FEAT_GUI
      if (gui.in_use)
  	gui_mch_update();
      else
  #endif
! 	mch_breakcheck(force);
  }
  
  /*****************************************************************************
*** ../vim-8.0.0017/src/proto/ui.pro	2016-09-12 13:04:21.000000000 +0200
--- src/proto/ui.pro	2016-09-29 15:06:34.028948742 +0200
***************
*** 10,15 ****
--- 10,16 ----
  void ui_set_shellsize(int mustset);
  void ui_new_shellsize(void);
  void ui_breakcheck(void);
+ void ui_breakcheck_force(int force);
  void clip_init(int can_use);
  void clip_update_selection(VimClipboard *clip);
  void clip_own_selection(VimClipboard *cbd);
*** ../vim-8.0.0017/src/ex_docmd.c	2016-09-11 14:36:00.000000000 +0200
--- src/ex_docmd.c	2016-09-29 15:06:48.532846478 +0200
***************
*** 9065,9072 ****
  		wait_now = due_time;
  	}
  #endif
  	ui_delay(wait_now, TRUE);
! 	ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
--- 9065,9081 ----
  		wait_now = due_time;
  	}
  #endif
+ #ifdef FEAT_JOB_CHANNEL
+ 	if (has_any_channel() && wait_now > 100L)
+ 	    wait_now = 100L;
+ #endif
  	ui_delay(wait_now, TRUE);
! #ifdef FEAT_JOB_CHANNEL
! 	if (has_any_channel())
! 	    ui_breakcheck_force(TRUE);
! 	else
! #endif
! 	    ui_breakcheck();
  #ifdef MESSAGE_QUEUE
  	/* Process the netbeans and clientserver messages that may have been
  	 * received in the call to ui_breakcheck() when the GUI is in use. This
*** ../vim-8.0.0017/src/os_amiga.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_amiga.c	2016-09-29 15:07:57.060363361 +0200
***************
*** 1381,1387 ****
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(void)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
--- 1381,1387 ----
   * trouble with lattice-c programs.
   */
      void
! mch_breakcheck(int force)
  {
     if (SetSignal(0L, (long)(SIGBREAKF_CTRL_C|SIGBREAKF_CTRL_D|SIGBREAKF_CTRL_E|SIGBREAKF_CTRL_F)) & SIGBREAKF_CTRL_C)
  	got_int = TRUE;
*** ../vim-8.0.0017/src/proto/os_amiga.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_amiga.pro	2016-09-29 15:08:16.240228159 +0200
***************
*** 36,42 ****
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(void);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 36,42 ----
  void mch_set_shellsize(void);
  void mch_new_shellsize(void);
  int mch_call_shell(char_u *cmd, int options);
! void mch_breakcheck(int force);
  long Chk_Abort(void);
  int mch_expandpath(garray_T *gap, char_u *pat, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_unix.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_unix.c	2016-09-29 15:12:37.530386938 +0200
***************
*** 5364,5372 ****
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(void)
  {
!     if (curr_tmode == TMODE_RAW && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
--- 5364,5373 ----
   * In cooked mode we should get SIGINT, no need to check.
   */
      void
! mch_breakcheck(int force)
  {
!     if ((curr_tmode == TMODE_RAW || force)
! 			       && RealWaitForChar(read_cmd_fd, 0L, NULL, NULL))
  	fill_input_buf(FALSE);
  }
  
*** ../vim-8.0.0017/src/proto/os_unix.pro	2016-09-12 13:04:15.000000000 +0200
--- src/proto/os_unix.pro	2016-09-29 15:09:02.235903956 +0200
***************
*** 61,67 ****
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(void);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
--- 61,67 ----
  char *mch_job_status(job_T *job);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
! void mch_breakcheck(int force);
  int mch_expandpath(garray_T *gap, char_u *path, int flags);
  int mch_expand_wildcards(int num_pat, char_u **pat, int *num_file, char_u ***file, int flags);
  int mch_has_exp_wildcard(char_u *p);
*** ../vim-8.0.0017/src/os_win32.c	2016-09-01 18:31:42.000000000 +0200
--- src/os_win32.c	2016-09-29 15:09:50.431564286 +0200
***************
*** 6187,6196 ****
  
  
  /*
!  * check for an "interrupt signal": CTRL-break or CTRL-C
   */
      void
! mch_breakcheck(void)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
--- 6187,6196 ----
  
  
  /*
!  * Check for an "interrupt signal": CTRL-break or CTRL-C.
   */
      void
! mch_breakcheck(int force)
  {
  #ifndef FEAT_GUI_W32	    /* never used */
      if (g_fCtrlCPressed || g_fCBrkPressed)
*** ../vim-8.0.0017/src/proto/os_win32.pro	2016-09-12 13:04:29.000000000 +0200
--- src/proto/os_win32.pro	2016-09-29 15:10:04.219467120 +0200
***************
*** 48,54 ****
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(void);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
--- 48,54 ----
  void mch_write(char_u *s, int len);
  void mch_delay(long msec, int ignoreinput);
  int mch_remove(char_u *name);
! void mch_breakcheck(int force);
  long_u mch_total_mem(int special);
  int mch_wrename(WCHAR *wold, WCHAR *wnew);
  int mch_rename(const char *pszOldFile, const char *pszNewFile);
*** ../vim-8.0.0017/src/version.c	2016-09-27 21:28:52.905342034 +0200
--- src/version.c	2016-09-29 15:17:41.140258776 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     18,
  /**/

-- 
ARTHUR:  Well, I can't just call you `Man'.
DENNIS:  Well, you could say `Dennis'.
ARTHUR:  Well, I didn't know you were called `Dennis.'
DENNIS:  Well, you didn't bother to find out, did you?
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0019
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0019
Problem:    Test_command_count is old style.
Solution:   Turn it into a new style test. (Naruhiko Nishino)
            Use more assert functions.
Files:      src/Makefile, src/testdir/Make_all.mak, src/testdir/test_alot.vim,
            src/testdir/test_autocmd.vim, src/testdir/test_command_count.in,
            src/testdir/test_command_count.ok,
            src/testdir/test_command_count.vim


*** ../vim-8.0.0018/src/Makefile	2016-09-26 20:14:49.921906772 +0200
--- src/Makefile	2016-09-29 19:23:13.153274891 +0200
***************
*** 2028,2034 ****
  	test_breakindent \
  	test_changelist \
  	test_close_count \
- 	test_command_count \
  	test_comparators \
  	test_erasebackword \
  	test_eval \
--- 2028,2033 ----
***************
*** 2066,2071 ****
--- 2065,2071 ----
  	test_channel \
  	test_charsearch \
  	test_cmdline \
+ 	test_command_count \
  	test_crypt \
  	test_cscope \
  	test_cursor_func \
*** ../vim-8.0.0018/src/testdir/Make_all.mak	2016-09-26 20:14:49.921906772 +0200
--- src/testdir/Make_all.mak	2016-09-29 19:11:33.650159645 +0200
***************
*** 79,85 ****
  	test_breakindent.out \
  	test_changelist.out \
  	test_close_count.out \
- 	test_command_count.out \
  	test_comparators.out \
  	test_erasebackword.out \
  	test_eval.out \
--- 79,84 ----
*** ../vim-8.0.0018/src/testdir/test_alot.vim	2016-09-11 14:34:48.000000000 +0200
--- src/testdir/test_alot.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 3,8 ****
--- 3,9 ----
  
  source test_assign.vim
  source test_autocmd.vim
+ source test_command_count.vim
  source test_cursor_func.vim
  source test_delete.vim
  source test_execute_func.vim
*** ../vim-8.0.0018/src/testdir/test_autocmd.vim	2016-09-08 22:06:01.000000000 +0200
--- src/testdir/test_autocmd.vim	2016-09-29 19:11:33.650159645 +0200
***************
*** 1,5 ****
--- 1,13 ----
  " Tests for autocommands
  
+ function! s:cleanup_buffers() abort
+   for bnr in range(1, bufnr('$'))
+     if bufloaded(bnr) && bufnr('%') != bnr
+       execute 'bd! ' . bnr
+     endif
+   endfor
+ endfunction
+ 
  func Test_vim_did_enter()
    call assert_false(v:vim_did_enter)
  
***************
*** 254,259 ****
--- 262,270 ----
  " Tests for autocommands on :close command.
  " This used to be in test13.
  func Test_three_windows()
+   " Clean up buffers, because in some cases this function fails.
+   call s:cleanup_buffers()
+ 
    " Write three files and open them, each in a window.
    " Then go to next window, with autocommand that deletes the previous one.
    " Do this twice, writing the file.
*** ../vim-8.0.0018/src/testdir/test_command_count.in	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,158 ****
- Test for user command counts	    vim: set ft=vim :
- 
- STARTTEST
- :so small.vim
- :lang C
- :let g:lines = []
- :com -range=% RangeLines :call add(g:lines, 'RangeLines '.<line1>.' '.<line2>)
- :com -range -addr=arguments RangeArguments :call add(g:lines, 'RangeArguments '.<line1>.' '.<line2>)
- :com -range=% -addr=arguments RangeArgumentsAll :call add(g:lines, 'RangeArgumentsAll '.<line1>.' '.<line2>)
- :com -range -addr=loaded_buffers RangeLoadedBuffers :call add(g:lines, 'RangeLoadedBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=loaded_buffers RangeLoadedBuffersAll :call add(g:lines, 'RangeLoadedBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=buffers RangeBuffers :call add(g:lines, 'RangeBuffers '.<line1>.' '.<line2>)
- :com -range=% -addr=buffers RangeBuffersAll :call add(g:lines, 'RangeBuffersAll '.<line1>.' '.<line2>)
- :com -range -addr=windows RangeWindows :call add(g:lines, 'RangeWindows '.<line1>.' '.<line2>)
- :com -range=% -addr=windows RangeWindowsAll :call add(g:lines, 'RangeWindowsAll '.<line1>.' '.<line2>)
- :com -range -addr=tabs RangeTabs :call add(g:lines, 'RangeTabs '.<line1>.' '.<line2>)
- :com -range=% -addr=tabs RangeTabsAll :call add(g:lines, 'RangeTabsAll '.<line1>.' '.<line2>)
- :set hidden
- :arga a b c d
- :argdo echo "loading buffers"
- :argu 3
- :.-,$-RangeArguments
- :%RangeArguments
- :RangeArgumentsAll
- :N
- :.RangeArguments
- :split|split|split|split
- :3wincmd w
- :.,$RangeWindows
- :%RangeWindows
- :RangeWindowsAll
- :only
- :blast|bd
- :.,$RangeLoadedBuffers
- :%RangeLoadedBuffers
- :RangeLoadedBuffersAll
- :.,$RangeBuffers
- :%RangeBuffers
- :RangeBuffersAll
- :tabe|tabe|tabe|tabe
- :normal 2gt
- :.,$RangeTabs
- :%RangeTabs
- :RangeTabsAll
- :1tabonly
- :s/\n/\r\r\r\r\r/
- :2ma<
- :$-ma>
- :'<,'>RangeLines
- :com -range=% -buffer LocalRangeLines :call add(g:lines, 'LocalRangeLines '.<line1>.' '.<line2>)
- :'<,'>LocalRangeLines
- :b1
- ENDTEST
- 
- STARTTEST
- :call add(g:lines, '')
- :%argd
- :arga a b c d
- :let v:errmsg = ''
- :5argu
- :call add(g:lines, '5argu ' . v:errmsg)
- :$argu
- :call add(g:lines, '4argu ' . expand('%:t'))
- :let v:errmsg = ''
- :1argu
- :call add(g:lines, '1argu ' . expand('%:t'))
- :let v:errmsg = ''
- :100b
- :call add(g:lines, '100b ' . v:errmsg)
- :split|split|split|split
- :let v:errmsg = ''
- :0close
- :call add(g:lines, '0close ' . v:errmsg)
- :$wincmd w
- :$close
- :call add(g:lines, '$close ' . winnr())
- :let v:errmsg = ''
- :$+close
- :call add(g:lines, '$+close ' . v:errmsg)
- :$tabe
- :call add(g:lines, '$tabe ' . tabpagenr())
- :let v:errmsg = ''
- :$+tabe
- :call add(g:lines, '$+tabe ' . v:errmsg)
- :only!
- :e x
- :0tabm
- :normal 1gt
- :call add(g:lines, '0tabm ' . expand('%:t'))
- :tabonly!
- :only!
- :e! test.out
- :call append(0, g:lines)
- :unlet g:lines
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :let g:lines = []
- :func BufStatus()
- :  call add(g:lines, 'aaa: ' . buflisted(g:buf_aaa) . ' bbb: ' . buflisted(g:buf_bbb) . ' ccc: ' . buflisted(g:buf_ccc))
- :endfunc
- :se nohidden
- :e aaa
- :let buf_aaa = bufnr('%')
- :e bbb
- :let buf_bbb = bufnr('%')
- :e ccc
- :let buf_ccc = bufnr('%')
- :b1
- :call BufStatus()
- :exe buf_bbb . "," . buf_ccc . "bdelete"
- :call BufStatus()
- :exe buf_aaa . "bdelete"
- :call BufStatus()
- :e! test.out
- :call append('$', g:lines)
- :unlet g:lines
- :delfunc BufStatus
- :w|bd
- :b1
- ENDTEST
- 
- STARTTEST
- :se hidden
- :only!
- :let g:lines = []
- :%argd
- :arga a b c d e f
- :3argu
- :let args = ''
- :.,$-argdo let args .= ' '.expand('%')
- :call add(g:lines, 'argdo:' . args)
- :split|split|split|split
- :2wincmd w
- :let windows = ''
- :.,$-windo let windows .= ' '.winnr()
- :call add(g:lines, 'windo:'. windows)
- :b2
- :let buffers = ''
- :.,$-bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :3bd
- :let buffers = ''
- :3,7bufdo let buffers .= ' '.bufnr('%')
- :call add(g:lines, 'bufdo:' . buffers)
- :tabe|tabe|tabe|tabe
- :normal! 2gt
- :let tabpages = ''
- :.,$-tabdo let tabpages .= ' '.tabpagenr()
- :call add(g:lines, 'tabdo:' . tabpages)
- :e! test.out
- :call append('$', g:lines)
- :w|qa!
- ENDTEST
- 
- 
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.ok	2015-02-27 20:03:15.000000000 +0100
--- src/testdir/test_command_count.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,38 ****
- RangeArguments 2 4
- RangeArguments 1 5
- RangeArgumentsAll 1 5
- RangeArguments 2 2
- RangeWindows 3 5
- RangeWindows 1 5
- RangeWindowsAll 1 5
- RangeLoadedBuffers 2 4
- RangeLoadedBuffers 1 4
- RangeLoadedBuffersAll 1 4
- RangeBuffers 2 5
- RangeBuffers 1 5
- RangeBuffersAll 1 5
- RangeTabs 2 5
- RangeTabs 1 5
- RangeTabsAll 1 5
- RangeLines 2 5
- LocalRangeLines 2 5
- 
- 5argu E16: Invalid range
- 4argu d
- 1argu a
- 100b E16: Invalid range
- 0close 
- $close 3
- $+close E16: Invalid range
- $tabe 2
- $+tabe E16: Invalid range
- 0tabm x
- 
- aaa: 1 bbb: 1 ccc: 1
- aaa: 1 bbb: 0 ccc: 0
- aaa: 0 bbb: 0 ccc: 0
- argdo: c d e
- windo: 2 3 4
- bufdo: 2 3 4 5 6 7 8 9 10 15
- bufdo: 4 5 6 7
- tabdo: 2 3 4
--- 0 ----
*** ../vim-8.0.0018/src/testdir/test_command_count.vim	2016-09-29 20:53:54.971440078 +0200
--- src/testdir/test_command_count.vim	2016-09-29 20:49:32.317263612 +0200
***************
*** 0 ****
--- 1,191 ----
+ " Test for user command counts.
+ 
+ func Test_command_count_0()
+   set hidden
+   set noswapfile
+ 
+   split DoesNotExistEver
+   let lastbuf = bufnr('$')
+   call setline(1, 'asdf')
+   quit!
+ 
+   command! -range -addr=loaded_buffers RangeLoadedBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=loaded_buffers RangeLoadedBuffersAll :let lines = [<line1>, <line2>]
+   command! -range -addr=buffers RangeBuffers :let lines = [<line1>, <line2>]
+   command! -range=% -addr=buffers RangeBuffersAll :let lines = [<line1>, <line2>]
+ 
+   .,$RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   %RangeLoadedBuffers
+   call assert_equal([1, 1], lines)
+   RangeLoadedBuffersAll
+   call assert_equal([1, 1], lines)
+   .,$RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   %RangeBuffers
+   call assert_equal([1, lastbuf], lines)
+   RangeBuffersAll
+   call assert_equal([1, lastbuf], lines)
+ 
+   delcommand RangeLoadedBuffers
+   delcommand RangeLoadedBuffersAll
+   delcommand RangeBuffers
+   delcommand RangeBuffersAll
+ 
+   set hidden&
+   set swapfile&
+ endfunc
+ 
+ func Test_command_count_1()
+   silent! %argd
+   arga a b c d e
+   argdo echo "loading buffers"
+   argu 3
+   command! -range -addr=arguments RangeArguments :let lines = [<line1>, <line2>]
+   command! -range=% -addr=arguments RangeArgumentsAll :let lines = [<line1>, <line2>]
+   .-,$-RangeArguments
+   call assert_equal([2, 4], lines)
+   %RangeArguments
+   call assert_equal([1, 5], lines)
+   RangeArgumentsAll
+   call assert_equal([1, 5], lines)
+   N
+   .RangeArguments
+   call assert_equal([2, 2], lines)
+   delcommand RangeArguments
+   delcommand RangeArgumentsAll
+ 
+   split|split|split|split
+   3wincmd w
+   command! -range -addr=windows RangeWindows :let lines = [<line1>, <line2>]
+   .,$RangeWindows
+   call assert_equal([3, 5], lines)
+   %RangeWindows
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindows
+ 
+   command! -range=% -addr=windows RangeWindowsAll :let lines = [<line1>, <line2>]
+   RangeWindowsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeWindowsAll
+   only
+   blast|bd
+ 
+   tabe|tabe|tabe|tabe
+   normal 2gt
+   command! -range -addr=tabs RangeTabs :let lines = [<line1>, <line2>]
+   .,$RangeTabs
+   call assert_equal([2, 5], lines)
+   %RangeTabs
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabs
+ 
+   command! -range=% -addr=tabs RangeTabsAll :let lines = [<line1>, <line2>]
+   RangeTabsAll
+   call assert_equal([1, 5], lines)
+   delcommand RangeTabsAll
+   1tabonly
+ 
+   s/\n/\r\r\r\r\r/
+   2ma<
+   $-ma>
+   command! -range=% RangeLines :let lines = [<line1>, <line2>]
+   '<,'>RangeLines
+   call assert_equal([2, 5], lines)
+   delcommand RangeLines
+ 
+   command! -range=% -buffer LocalRangeLines :let lines = [<line1>, <line2>]
+   '<,'>LocalRangeLines
+   call assert_equal([2, 5], lines)
+   delcommand LocalRangeLines
+ endfunc
+ 
+ func Test_command_count_2()
+   silent! %argd
+   arga a b c d
+   call assert_fails('5argu', 'E16:')
+ 
+   $argu
+   call assert_equal('d', expand('%:t'))
+ 
+   1argu
+   call assert_equal('a', expand('%:t'))
+ 
+   call assert_fails('300b', 'E16:')
+ 
+   split|split|split|split
+   0close
+ 
+   $wincmd w
+   $close
+   call assert_equal(3, winnr())
+ 
+   call assert_fails('$+close', 'E16:')
+ 
+   $tabe
+   call assert_equal(2, tabpagenr())
+ 
+   call assert_fails('$+tabe', 'E16:')
+ 
+   only!
+   e x
+   0tabm
+   normal 1gt
+   call assert_equal('x', expand('%:t'))
+ 
+   tabonly!
+   only!
+ endfunc
+ 
+ func Test_command_count_3()
+   se nohidden
+   e aaa
+   let buf_aaa = bufnr('%')
+   e bbb
+   let buf_bbb = bufnr('%')
+   e ccc
+   let buf_ccc = bufnr('%')
+   buf 1
+   call assert_equal([1, 1, 1], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_bbb . "," . buf_ccc . "bdelete"
+   call assert_equal([1, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+   exe buf_aaa . "bdelete"
+   call assert_equal([0, 0, 0], [buflisted(buf_aaa), buflisted(buf_bbb), buflisted(buf_ccc)])
+ endfunc
+ 
+ func Test_command_count_4()
+   %argd
+   let bufnr = bufnr('$') + 1
+   arga aa bb cc dd ee ff
+   3argu
+   let args = []
+   .,$-argdo call add(args, expand('%'))
+   call assert_equal(['cc', 'dd', 'ee'], args)
+ 
+   " create windows to get 5
+   split|split|split|split
+   2wincmd w
+   let windows = []
+   .,$-windo call add(windows, winnr())
+   call assert_equal([2, 3, 4], windows)
+   only!
+ 
+   exe bufnr . 'buf'
+   let buffers = []
+   .,$-bufdo call add(buffers, bufnr('%'))
+   call assert_equal([bufnr, bufnr + 1, bufnr + 2, bufnr + 3, bufnr + 4], buffers)
+ 
+   exe (bufnr + 3) . 'bdel'
+   let buffers = []
+   exe (bufnr + 2) . ',' . (bufnr + 5) . "bufdo call add(buffers, bufnr('%'))"
+   call assert_equal([bufnr + 2, bufnr + 4, bufnr +  5], buffers)
+ 
+   " create tabpages to get 5
+   tabe|tabe|tabe|tabe
+   normal! 2gt
+   let tabpages = []
+   .,$-tabdo call add(tabpages, tabpagenr())
+   call assert_equal([2, 3, 4], tabpages)
+   tabonly!
+   bwipe!
+ endfunc
*** ../vim-8.0.0018/src/version.c	2016-09-29 15:18:51.359768012 +0200
--- src/version.c	2016-09-29 20:50:17.684948652 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     19,
  /**/

-- 
A computer programmer is a device for turning requirements into
undocumented features.  It runs on cola, pizza and Dilbert cartoons.
					Bram Moolenaar

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0020
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0020
Problem:    The regexp engines are not reentrant.
Solution:   Add regexec_T and save/restore the state when needed.
Files:      src/regexp.c, src/regexp_nfa.c, src/testdir/test_expr.vim,
            runtime/doc/eval.txt, runtime/doc/change.txt


*** ../vim-8.0.0019/src/regexp.c	2016-09-09 20:20:20.000000000 +0200
--- src/regexp.c	2016-10-02 16:21:22.709068952 +0200
***************
*** 3509,3535 ****
  #endif
  
  /*
-  * Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
-  * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
-  * contains '\c' or '\C' the value is overruled.
-  */
- static int	ireg_ic;
- 
- #ifdef FEAT_MBYTE
- /*
-  * Similar to ireg_ic, but only for 'combining' characters.  Set with \Z flag
-  * in the regexp.  Defaults to false, always.
-  */
- static int	ireg_icombine;
- #endif
- 
- /*
-  * Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
-  * there is no maximum.
-  */
- static colnr_T	ireg_maxcol;
- 
- /*
   * Sometimes need to save a copy of a line.  Since alloc()/free() is very
   * slow, we keep one allocated piece of memory and only re-allocate it when
   * it's too small.  It's freed in bt_regexec_both() when finished.
--- 3509,3514 ----
***************
*** 3538,3544 ****
  static unsigned	reg_tofreelen;
  
  /*
!  * These variables are set when executing a regexp to speed up the execution.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
--- 3517,3523 ----
  static unsigned	reg_tofreelen;
  
  /*
!  * Structure used to store the execution state of the regex engine.
   * Which ones are set depends on whether a single-line or multi-line match is
   * done:
   *			single-line		multi-line
***************
*** 3554,3570 ****
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! static regmatch_T	*reg_match;
! static regmmatch_T	*reg_mmatch;
! static char_u		**reg_startp = NULL;
! static char_u		**reg_endp = NULL;
! static lpos_T		*reg_startpos = NULL;
! static lpos_T		*reg_endpos = NULL;
! static win_T		*reg_win;
! static buf_T		*reg_buf;
! static linenr_T		reg_firstlnum;
! static linenr_T		reg_maxline;
! static int		reg_line_lbr;	    /* "\n" in string is line break */
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
--- 3533,3570 ----
   * reg_maxline		0			last line nr
   * reg_line_lbr		FALSE or TRUE		FALSE
   */
! typedef struct {
!     regmatch_T		*reg_match;
!     regmmatch_T		*reg_mmatch;
!     char_u		**reg_startp;
!     char_u		**reg_endp;
!     lpos_T		*reg_startpos;
!     lpos_T		*reg_endpos;
!     win_T		*reg_win;
!     buf_T		*reg_buf;
!     linenr_T		reg_firstlnum;
!     linenr_T		reg_maxline;
!     int			reg_line_lbr;	/* "\n" in string is line break */
! 
!     /* Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().
!      * Normally it gets the value of "rm_ic" or "rmm_ic", but when the pattern
!      * contains '\c' or '\C' the value is overruled. */
!     int			reg_ic;
! 
! #ifdef FEAT_MBYTE
!     /* Similar to rex.reg_ic, but only for 'combining' characters.  Set with \Z
!      * flag in the regexp.  Defaults to false, always. */
!     int			reg_icombine;
! #endif
! 
!     /* Copy of "rmm_maxcol": maximum column to search for a match.  Zero when
!      * there is no maximum. */
!     colnr_T		reg_maxcol;
! } regexec_T;
! 
! static regexec_T	rex;
! static int		rex_in_use = FALSE;
! 
  
  /* Values for rs_state in regitem_T. */
  typedef enum regstate_E
***************
*** 3669,3680 ****
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(reg_buf, reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
--- 3669,3680 ----
  {
      /* when looking behind for a match/no-match lnum is negative.  But we
       * can't go before line 1 */
!     if (rex.reg_firstlnum + lnum < 1)
  	return NULL;
!     if (lnum > rex.reg_maxline)
  	/* Must have matched the "\n" in the last line. */
  	return (char_u *)"";
!     return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);
  }
  
  static regsave_T behind_pos;
***************
*** 3687,3696 ****
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(reg_match == NULL)
! 
! static int  bt_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col, int line_lbr);
! 
  
  /*
   * Match a regexp against a string.
--- 3687,3693 ----
  #endif
  
  /* TRUE if using multi-line regexp. */
! #define REG_MULTI	(rex.reg_match == NULL)
  
  /*
   * Match a regexp against a string.
***************
*** 3707,3729 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
- static long bt_regexec_multi(regmmatch_T *rmp, win_T *win, buf_T *buf, linenr_T lnum, colnr_T col, proftime_T *tm);
- 
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
--- 3704,3724 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
  
      return bt_regexec_both(line, col, NULL);
  }
  
  /*
   * Match a regexp against multiple lines.
   * "rmp->regprog" is a compiled regexp as returned by vim_regcomp().
***************
*** 3741,3758 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
--- 3736,3753 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return bt_regexec_both(NULL, col, tm);
  }
***************
*** 3794,3809 ****
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 3789,3804 ----
  
      if (REG_MULTI)
      {
! 	prog = (bt_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (bt_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 3818,3836 ****
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
--- 3813,3831 ----
  	goto theend;
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      /* If there is a "must appear" string, look for it. */
***************
*** 3850,3856 ****
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 3845,3851 ----
  	 * This is used very often, esp. for ":global".  Use three versions of
  	 * the loop to avoid overhead of conditions.
  	 */
! 	if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 3862,3868 ****
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!ireg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
--- 3857,3863 ----
  		++s;
  	    }
  #ifdef FEAT_MBYTE
! 	else if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))
  	    while ((s = vim_strchr(s, c)) != NULL)
  	    {
  		if (cstrncmp(s, prog->regmust, &prog->regmlen) == 0)
***************
*** 3898,3904 ****
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (ireg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
--- 3893,3899 ----
  	    c = regline[col];
  	if (prog->regstart == NUL
  		|| prog->regstart == c
! 		|| (rex.reg_ic && ((
  #ifdef FEAT_MBYTE
  			(enc_utf8 && utf_fold(prog->regstart) == utf_fold(c)))
  			|| (c < 255 && prog->regstart < 255 &&
***************
*** 3920,3926 ****
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!ireg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
--- 3915,3921 ----
  	    {
  		/* Skip until the char we know it must start with.
  		 * Used often, do some work to avoid call overhead. */
! 		if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  			    && !has_mbyte
  #endif
***************
*** 3937,3943 ****
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	    {
  		retval = 0;
  		break;
--- 3932,3938 ----
  	    }
  
  	    /* Check for maximum column to try. */
! 	    if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	    {
  		retval = 0;
  		break;
***************
*** 4056,4081 ****
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
--- 4051,4076 ----
      cleanup_subexpr();
      if (REG_MULTI)
      {
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  #ifdef FEAT_SYN_HL
      /* Package any found \z(...\) matches for export. Default is none. */
***************
*** 4125,4131 ****
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			    - (*mb_head_off)(regline, reginput - 1), reg_buf);
      return -1;
  }
  #endif
--- 4120,4126 ----
  {
      if (reginput > regline)
  	return mb_get_class_buf(reginput - 1
! 			 - (*mb_head_off)(regline, reginput - 1), rex.reg_buf);
      return -1;
  }
  #endif
***************
*** 4141,4154 ****
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = reg_win == NULL ? curwin : reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
--- 4136,4149 ----
      pos_T	top, bot;
      linenr_T    lnum;
      colnr_T	col;
!     win_T	*wp = rex.reg_win == NULL ? curwin : rex.reg_win;
      int		mode;
      colnr_T	start, end;
      colnr_T	start2, end2;
      colnr_T	cols;
  
      /* Check if the buffer is the current buffer. */
!     if (rex.reg_buf != curbuf || VIsual.lnum == 0)
  	return FALSE;
  
      if (VIsual_active)
***************
*** 4179,4185 ****
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
--- 4174,4180 ----
  	}
  	mode = curbuf->b_visual.vi_mode;
      }
!     lnum = reglnum + rex.reg_firstlnum;
      if (lnum < top.lnum || lnum > bot.lnum)
  	return FALSE;
  
***************
*** 4309,4320 ****
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!reg_line_lbr && WITH_NL(op) && REG_MULTI
! 				&& *reginput == NUL && reglnum <= reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
--- 4304,4315 ----
  
  	op = OP(scan);
  	/* Check for character class with NL added. */
! 	if (!rex.reg_line_lbr && WITH_NL(op) && REG_MULTI
! 			     && *reginput == NUL && reglnum <= rex.reg_maxline)
  	{
  	    reg_nextline();
  	}
! 	else if (rex.reg_line_lbr && WITH_NL(op) && *reginput == '\n')
  	{
  	    ADVANCE_REGINPUT();
  	}
***************
*** 4345,4365 ****
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 					  || (REG_MULTI && reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * reg_win->w_cursor position to the match position. */
! 	    if (reg_win == NULL
! 		    || (reglnum + reg_firstlnum != reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline) != reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
--- 4340,4362 ----
  	     * line where we started, not at the start of the line or we
  	     * didn't start at the first line of the buffer. */
  	    if (reglnum != 0 || reginput != regline
! 				       || (REG_MULTI && rex.reg_firstlnum > 1))
  		status = RA_NOMATCH;
  	    break;
  
  	  case RE_EOF:
! 	    if (reglnum != rex.reg_maxline || c != NUL)
  		status = RA_NOMATCH;
  	    break;
  
  	  case CURSOR:
  	    /* Check if the buffer is in a window and compare the
! 	     * rex.reg_win->w_cursor position to the match position. */
! 	    if (rex.reg_win == NULL
! 		    || (reglnum + rex.reg_firstlnum
! 						 != rex.reg_win->w_cursor.lnum)
! 		    || ((colnr_T)(reginput - regline)
! 						 != rex.reg_win->w_cursor.col))
  		status = RA_NOMATCH;
  	    break;
  
***************
*** 4370,4385 ****
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
--- 4367,4382 ----
  		int	cmp = OPERAND(scan)[1];
  		pos_T	*pos;
  
! 		pos = getmark_buf(rex.reg_buf, mark, FALSE);
  		if (pos == NULL		     /* mark doesn't exist */
  			|| pos->lnum <= 0    /* mark isn't set in reg_buf */
! 			|| (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? (cmp == '<' || cmp == '>')
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? cmp != '>'
  					: cmp != '<'))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? cmp != '>'
  				    : cmp != '<')))
  		    status = RA_NOMATCH;
***************
*** 4392,4398 ****
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
--- 4389,4395 ----
  	    break;
  
  	  case RE_LNUM:
! 	    if (!REG_MULTI || !re_num_cmp((long_u)(reglnum + rex.reg_firstlnum),
  									scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4404,4410 ****
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    reg_win == NULL ? curwin : reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
--- 4401,4407 ----
  
  	  case RE_VCOL:
  	    if (!re_num_cmp((long_u)win_linetabsize(
! 			    rex.reg_win == NULL ? curwin : rex.reg_win,
  			    regline, (colnr_T)(reginput - regline)) + 1, scan))
  		status = RA_NOMATCH;
  	    break;
***************
*** 4418,4424 ****
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
--- 4415,4421 ----
  		int this_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		if (this_class <= 1)
  		    status = RA_NOMATCH;  /* not on a word at all */
  		else if (reg_prev_class() == this_class)
***************
*** 4427,4434 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, reg_buf) || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
--- 4424,4431 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(c, rex.reg_buf) || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break;
***************
*** 4442,4448 ****
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
--- 4439,4445 ----
  		int this_class, prev_class;
  
  		/* Get class of current and previous char (if it exists). */
! 		this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		prev_class = reg_prev_class();
  		if (this_class == prev_class
  			|| prev_class == 0 || prev_class == 1)
***************
*** 4451,4458 ****
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], reg_buf)
! 			|| (reginput[0] != NUL && vim_iswordc_buf(c, reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
--- 4448,4456 ----
  #endif
  	    else
  	    {
! 		if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
! 			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(c, rex.reg_buf)))
  		    status = RA_NOMATCH;
  	    }
  	    break; /* Matched with EOW */
***************
*** 4480,4493 ****
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput) || !vim_iswordp_buf(reginput, reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
--- 4478,4492 ----
  	    break;
  
  	  case KWORD:
! 	    if (!vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
  	    break;
  
  	  case SKWORD:
! 	    if (VIM_ISDIGIT(*reginput)
! 				    || !vim_iswordp_buf(reginput, rex.reg_buf))
  		status = RA_NOMATCH;
  	    else
  		ADVANCE_REGINPUT();
***************
*** 4655,4661 ****
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!ireg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
--- 4654,4660 ----
  		opnd = OPERAND(scan);
  		/* Inline the first byte, for speed. */
  		if (*opnd != *reginput
! 			&& (!rex.reg_ic || (
  #ifdef FEAT_MBYTE
  			    !enc_utf8 &&
  #endif
***************
*** 4670,4676 ****
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && ireg_ic)
  #endif
  			)
  		    {
--- 4669,4675 ----
  		{
  		    if (opnd[1] == NUL
  #ifdef FEAT_MBYTE
! 			    && !(enc_utf8 && rex.reg_ic)
  #endif
  			)
  		    {
***************
*** 4689,4695 ****
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !ireg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
--- 4688,4694 ----
  		    if (status != RA_NOMATCH
  			    && enc_utf8
  			    && UTF_COMPOSINGLIKE(reginput, reginput + len)
! 			    && !rex.reg_icombine
  			    && OP(next) != RE_COMPOSING)
  		    {
  			/* raaron: This code makes a composing character get
***************
*** 4840,4847 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_startpos[no],
! 							     &reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4839,4846 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_startpos[no],
! 							  &rex.reg_startp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4900,4906 ****
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &reg_endpos[no], &reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
--- 4899,4906 ----
  		else
  		{
  		    rp->rs_no = no;
! 		    save_se(&rp->rs_un.sesave, &rex.reg_endpos[no],
! 							    &rex.reg_endp[no]);
  		    /* We simply continue and handle the result when done. */
  		}
  	    }
***************
*** 4949,4955 ****
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (reg_startp[no] == NULL || reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
--- 4949,4955 ----
  		cleanup_subexpr();
  		if (!REG_MULTI)		/* Single-line regexp */
  		{
! 		    if (rex.reg_startp[no] == NULL || rex.reg_endp[no] == NULL)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
***************
*** 4958,4983 ****
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(reg_endp[no] - reg_startp[no]);
! 			if (cstrncmp(reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (reg_startpos[no].lnum < 0 || reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (reg_startpos[no].lnum == reglnum
! 				&& reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = reg_endpos[no].col - reg_startpos[no].col;
! 			    if (cstrncmp(regline + reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
--- 4958,4985 ----
  		    {
  			/* Compare current input with back-ref in the same
  			 * line. */
! 			len = (int)(rex.reg_endp[no] - rex.reg_startp[no]);
! 			if (cstrncmp(rex.reg_startp[no], reginput, &len) != 0)
  			    status = RA_NOMATCH;
  		    }
  		}
  		else				/* Multi-line regexp */
  		{
! 		    if (rex.reg_startpos[no].lnum < 0
! 						|| rex.reg_endpos[no].lnum < 0)
  		    {
  			/* Backref was not set: Match an empty string. */
  			len = 0;
  		    }
  		    else
  		    {
! 			if (rex.reg_startpos[no].lnum == reglnum
! 				&& rex.reg_endpos[no].lnum == reglnum)
  			{
  			    /* Compare back-ref within the current line. */
! 			    len = rex.reg_endpos[no].col
! 						    - rex.reg_startpos[no].col;
! 			    if (cstrncmp(regline + rex.reg_startpos[no].col,
  							  reginput, &len) != 0)
  				status = RA_NOMATCH;
  			}
***************
*** 4986,4995 ****
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    reg_startpos[no].lnum,
! 					    reg_startpos[no].col,
! 					    reg_endpos[no].lnum,
! 					    reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
--- 4988,4997 ----
  			    /* Messy situation: Need to compare between two
  			     * lines. */
  			    int r = match_with_backref(
! 					    rex.reg_startpos[no].lnum,
! 					    rex.reg_startpos[no].col,
! 					    rex.reg_endpos[no].lnum,
! 					    rex.reg_endpos[no].col,
  					    &len);
  
  			    if (r != RA_MATCH)
***************
*** 5154,5160 ****
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (ireg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
--- 5156,5162 ----
  		if (OP(next) == EXACTLY)
  		{
  		    rst.nextb = *OPERAND(next);
! 		    if (rex.reg_ic)
  		    {
  			if (MB_ISUPPER(rst.nextb))
  			    rst.nextb_ic = MB_TOLOWER(rst.nextb);
***************
*** 5282,5291 ****
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > reg_maxline
! 			     || reg_line_lbr) && (c != '\n' || !reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 5284,5294 ----
  	    break;
  
  	  case NEWL:
! 	    if ((c != NUL || !REG_MULTI || reglnum > rex.reg_maxline
! 			     || rex.reg_line_lbr)
! 					   && (c != '\n' || !rex.reg_line_lbr))
  		status = RA_NOMATCH;
! 	    else if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 5331,5338 ****
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_startpos[rp->rs_no],
! 						  &reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5334,5341 ----
  	  case RS_MOPEN:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_startpos[rp->rs_no],
! 						  &rex.reg_startp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5349,5356 ****
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &reg_endpos[rp->rs_no],
! 						    &reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
--- 5352,5359 ----
  	  case RS_MCLOSE:
  	    /* Pop the state.  Restore pointers when there is no match. */
  	    if (status == RA_NOMATCH)
! 		restore_se(&rp->rs_un.sesave, &rex.reg_endpos[rp->rs_no],
! 						    &rex.reg_endp[rp->rs_no]);
  	    regstack_pop(&scan);
  	    break;
  
***************
*** 5785,5792 ****
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 					 || reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
--- 5788,5795 ----
  		++count;
  		mb_ptr_adv(scan);
  	    }
! 	    if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 				      || rex.reg_line_lbr || count == maxcount)
  		break;
  	    ++count;		/* count the line-break */
  	    reg_nextline();
***************
*** 5810,5824 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5813,5827 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5834,5855 ****
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5837,5858 ----
        case SKWORD + ADD_NL:
  	while (count < maxcount)
  	{
! 	    if (vim_iswordp_buf(scan, rex.reg_buf)
  					  && (testval || !VIM_ISDIGIT(*scan)))
  	    {
  		mb_ptr_adv(scan);
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5871,5885 ****
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5874,5888 ----
  	    }
  	    else if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5897,5904 ****
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5900,5907 ----
  	{
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5910,5916 ****
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5913,5919 ----
  	    {
  		mb_ptr_adv(scan);
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 5929,5936 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
--- 5932,5939 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
***************
*** 5947,5953 ****
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
--- 5950,5956 ----
  #endif
  	    else if ((class_tab[*scan] & mask) == testval)
  		++scan;
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  	    else
  		break;
***************
*** 6031,6037 ****
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (ireg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
--- 6034,6040 ----
  	    /* This doesn't do a multi-byte character, because a MULTIBYTECODE
  	     * would have been used for it.  It does handle single-byte
  	     * characters, such as latin1. */
! 	    if (rex.reg_ic)
  	    {
  		cu = MB_TOUPPER(*opnd);
  		cl = MB_TOLOWER(*opnd);
***************
*** 6062,6075 ****
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (ireg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!ireg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
--- 6065,6078 ----
  	     * compiling the program). */
  	    if ((len = (*mb_ptr2len)(opnd)) > 1)
  	    {
! 		if (rex.reg_ic && enc_utf8)
  		    cf = utf_fold(utf_ptr2char(opnd));
  		while (count < maxcount && (*mb_ptr2len)(scan) >= len)
  		{
  		    for (i = 0; i < len; ++i)
  			if (opnd[i] != scan[i])
  			    break;
! 		    if (i < len && (!rex.reg_ic || !enc_utf8
  					|| utf_fold(utf_ptr2char(scan)) != cf))
  			break;
  		    scan += len;
***************
*** 6094,6108 ****
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > reg_maxline
! 							      || reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
--- 6097,6111 ----
  #endif
  	    if (*scan == NUL)
  	    {
! 		if (!REG_MULTI || !WITH_NL(OP(p)) || reglnum > rex.reg_maxline
! 							   || rex.reg_line_lbr)
  		    break;
  		reg_nextline();
  		scan = reginput;
  		if (got_int)
  		    break;
  	    }
! 	    else if (rex.reg_line_lbr && *scan == '\n' && WITH_NL(OP(p)))
  		++scan;
  #ifdef FEAT_MBYTE
  	    else if (has_mbyte && (len = (*mb_ptr2len)(scan)) > 1)
***************
*** 6124,6134 ****
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= reg_maxline && !reg_line_lbr
! 			    && REG_MULTI) || (*scan == '\n' && reg_line_lbr)))
  	{
  	    count++;
! 	    if (reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
--- 6127,6138 ----
  
        case NEWL:
  	while (count < maxcount
! 		&& ((*scan == NUL && reglnum <= rex.reg_maxline
! 				       && !rex.reg_line_lbr && REG_MULTI)
! 		    || (*scan == '\n' && rex.reg_line_lbr)))
  	{
  	    count++;
! 	    if (rex.reg_line_lbr)
  		ADVANCE_REGINPUT();
  	    else
  		reg_nextline();
***************
*** 6183,6189 ****
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? reg_mmatch->regprog : reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
--- 6187,6193 ----
  {
      regprog_T	*prog;
  
!     prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;
      if (prog->engine == &nfa_regengine)
  	/* For NFA matcher we don't check the magic */
  	return FALSE;
***************
*** 6209,6221 ****
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
--- 6213,6225 ----
  	if (REG_MULTI)
  	{
  	    /* Use 0xff to set lnum to -1 */
! 	    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);
! 	    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);
  	}
  	else
  	{
! 	    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);
! 	    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);
  	}
  	need_clear_subexpr = FALSE;
      }
***************
*** 6261,6273 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = reg_startpos[i];
! 		bp->save_end[i].se_u.pos = reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = reg_startp[i];
! 		bp->save_end[i].se_u.ptr = reg_endp[i];
  	    }
  	}
      }
--- 6265,6277 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		bp->save_start[i].se_u.pos = rex.reg_startpos[i];
! 		bp->save_end[i].se_u.pos = rex.reg_endpos[i];
  	    }
  	    else
  	    {
! 		bp->save_start[i].se_u.ptr = rex.reg_startp[i];
! 		bp->save_end[i].se_u.ptr = rex.reg_endp[i];
  	    }
  	}
      }
***************
*** 6289,6301 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
--- 6293,6305 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[i] = bp->save_start[i].se_u.pos;
! 		rex.reg_endpos[i] = bp->save_end[i].se_u.pos;
  	    }
  	    else
  	    {
! 		rex.reg_startp[i] = bp->save_start[i].se_u.ptr;
! 		rex.reg_endp[i] = bp->save_end[i].se_u.ptr;
  	    }
  	}
      }
***************
*** 6454,6460 ****
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
--- 6458,6464 ----
  	    *bytelen += len;
  	if (clnum == end_lnum)
  	    break;		/* match and at end! */
! 	if (reglnum >= rex.reg_maxline)
  	    return RA_NOMATCH;  /* text too short */
  
  	/* Advance to next line. */
***************
*** 7039,7045 ****
  #endif
  
  /*
!  * Compare two strings, ignore case if ireg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
--- 7043,7049 ----
  #endif
  
  /*
!  * Compare two strings, ignore case if rex.reg_ic set.
   * Return 0 if strings match, non-zero otherwise.
   * Correct the length "*n" when composing characters are ignored.
   */
***************
*** 7048,7061 ****
  {
      int		result;
  
!     if (!ireg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && ireg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
--- 7052,7065 ----
  {
      int		result;
  
!     if (!rex.reg_ic)
  	result = STRNCMP(s1, s2, *n);
      else
  	result = MB_STRNICMP(s1, s2, *n);
  
  #ifdef FEAT_MBYTE
      /* if it failed and it's utf8 and we want to combineignore: */
!     if (result != 0 && enc_utf8 && rex.reg_icombine)
      {
  	char_u	*str1, *str2;
  	int	c1, c2, c11, c12;
***************
*** 7074,7087 ****
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!ireg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12 && (!ireg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
--- 7078,7092 ----
  	    /* decompose the character if necessary, into 'base' characters
  	     * because I don't care about Arabic, I will hard-code the Hebrew
  	     * which I *do* care about!  So sue me... */
! 	    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))
  	    {
  		/* decomposition necessary? */
  		mb_decompose(c1, &c11, &junk, &junk);
  		mb_decompose(c2, &c12, &junk, &junk);
  		c1 = c11;
  		c2 = c12;
! 		if (c11 != c12
! 			    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))
  		    break;
  	    }
  	}
***************
*** 7103,7109 ****
      char_u	*p;
      int		cc;
  
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
--- 7108,7114 ----
      char_u	*p;
      int		cc;
  
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  	    || (!enc_utf8 && mb_char2len(c) > 1)
  #endif
***************
*** 7276,7289 ****
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used instead of reg_match and reg_mmatch for
!  * reg_submatch().  Needed for when the substitution string is an expression
!  * that contains a call to substitute() and submatch(). */
! static regmatch_T	*submatch_match;
! static regmmatch_T	*submatch_mmatch;
! static linenr_T		submatch_firstlnum;
! static linenr_T		submatch_maxline;
! static int		submatch_line_lbr;
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
--- 7281,7298 ----
  #ifdef FEAT_EVAL
  static int can_f_submatch = FALSE;	/* TRUE when submatch() can be used */
  
! /* These pointers are used for reg_submatch().  Needed for when the
!  * substitution string is an expression that contains a call to substitute()
!  * and submatch(). */
! typedef struct {
!     regmatch_T	*sm_match;
!     regmmatch_T	*sm_mmatch;
!     linenr_T	sm_firstlnum;
!     linenr_T	sm_maxline;
!     int		sm_line_lbr;
! } regsubmatch_T;
! 
! static regsubmatch_T rsm;  /* can only be used when can_f_submatch is TRUE */
  #endif
  
  #if defined(FEAT_MODIFY_FNAME) || defined(FEAT_EVAL) || defined(PROTO)
***************
*** 7310,7320 ****
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = submatch_match->startp[i];
! 	if (s == NULL || submatch_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(submatch_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
--- 7319,7329 ----
      li = argv->vval.v_list->lv_first;
      for (i = 0; i < 10; ++i)
      {
! 	s = rsm.sm_match->startp[i];
! 	if (s == NULL || rsm.sm_match->endp[i] == NULL)
  	    s = NULL;
  	else
! 	    s = vim_strnsave(s, (int)(rsm.sm_match->endp[i] - s));
  	li->li_tv.v_type = VAR_STRING;
  	li->li_tv.vval.v_string = s;
  	li = li->li_next;
***************
*** 7359,7370 ****
      int		magic,
      int		backslash)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_buf = curbuf;
!     reg_line_lbr = TRUE;
!     return vim_regsub_both(source, expr, dest, copy, magic, backslash);
  }
  #endif
  
--- 7368,7394 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_buf = curbuf;
!     rex.reg_line_lbr = TRUE;
!     result = vim_regsub_both(source, expr, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  #endif
  
***************
*** 7378,7390 ****
      int		magic,
      int		backslash)
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = curbuf;		/* always works on the current buffer! */
!     reg_firstlnum = lnum;
!     reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     return vim_regsub_both(source, NULL, dest, copy, magic, backslash);
  }
  
      static int
--- 7402,7429 ----
      int		magic,
      int		backslash)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = curbuf;	/* always works on the current buffer! */
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     result = vim_regsub_both(source, NULL, dest, copy, magic, backslash);
! 
!     rex_in_use = rex_in_use_save;
!     if (rex_in_use)
! 	rex = rex_save;
! 
!     return result;
  }
  
      static int
***************
*** 7424,7434 ****
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='
! #ifdef FEAT_EVAL
! 	    && !can_f_submatch	    /* can't do this recursively */
! #endif
! 	    ))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
--- 7463,7469 ----
      /*
       * When the substitute part starts with "\=" evaluate it as an expression.
       */
!     if (expr != NULL || (source[0] == '\\' && source[1] == '='))
      {
  #ifdef FEAT_EVAL
  	/* To make sure that the length doesn't change between checking the
***************
*** 7447,7470 ****
  	}
  	else
  	{
! 	    win_T	*save_reg_win;
! 	    int		save_ireg_ic;
! 	    int		prev_can_f_submatch = can_f_submatch;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level.  Don't need to save "reg_buf", because
! 	     * vim_regexec_multi() can't be called recursively. */
! 	    submatch_match = reg_match;
! 	    submatch_mmatch = reg_mmatch;
! 	    submatch_firstlnum = reg_firstlnum;
! 	    submatch_maxline = reg_maxline;
! 	    submatch_line_lbr = reg_line_lbr;
! 	    save_reg_win = reg_win;
! 	    save_ireg_ic = ireg_ic;
  	    can_f_submatch = TRUE;
  
  	    if (expr != NULL)
  	    {
--- 7482,7503 ----
  	}
  	else
  	{
! 	    int		    prev_can_f_submatch = can_f_submatch;
! 	    regsubmatch_T   rsm_save;
  
  	    vim_free(eval_result);
  
  	    /* The expression may contain substitute(), which calls us
  	     * recursively.  Make sure submatch() gets the text from the first
! 	     * level. */
! 	    if (can_f_submatch)
! 		rsm_save = rsm;
  	    can_f_submatch = TRUE;
+ 	    rsm.sm_match = rex.reg_match;
+ 	    rsm.sm_mmatch = rex.reg_mmatch;
+ 	    rsm.sm_firstlnum = rex.reg_firstlnum;
+ 	    rsm.sm_maxline = rex.reg_maxline;
+ 	    rsm.sm_line_lbr = rex.reg_line_lbr;
  
  	    if (expr != NULL)
  	    {
***************
*** 7476,7510 ****
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		if (prev_can_f_submatch)
! 		{
! 		    /* can't do this recursively */
! 		}
! 		else
! 		{
! 		    argv[0].v_type = VAR_LIST;
! 		    argv[0].vval.v_list = &matchList.sl_list;
! 		    matchList.sl_list.lv_len = 0;
! 		    if (expr->v_type == VAR_FUNC)
! 		    {
! 			s = expr->vval.v_string;
! 			call_func(s, (int)STRLEN(s), &rettv,
! 					1, argv, fill_submatch_list,
! 					     0L, 0L, &dummy, TRUE, NULL, NULL);
! 		    }
! 		    else if (expr->v_type == VAR_PARTIAL)
! 		    {
! 			partial_T   *partial = expr->vval.v_partial;
  
- 			s = partial_name(partial);
- 			call_func(s, (int)STRLEN(s), &rettv,
- 					1, argv, fill_submatch_list,
- 					  0L, 0L, &dummy, TRUE, partial, NULL);
- 		    }
- 		    if (matchList.sl_list.lv_len > 0)
- 			/* fill_submatch_list() was called */
- 			clear_submatch_list(&matchList);
- 		}
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
--- 7509,7537 ----
  
  		rettv.v_type = VAR_STRING;
  		rettv.vval.v_string = NULL;
! 		argv[0].v_type = VAR_LIST;
! 		argv[0].vval.v_list = &matchList.sl_list;
! 		matchList.sl_list.lv_len = 0;
! 		if (expr->v_type == VAR_FUNC)
! 		{
! 		    s = expr->vval.v_string;
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 					 0L, 0L, &dummy, TRUE, NULL, NULL);
! 		}
! 		else if (expr->v_type == VAR_PARTIAL)
! 		{
! 		    partial_T   *partial = expr->vval.v_partial;
! 
! 		    s = partial_name(partial);
! 		    call_func(s, (int)STRLEN(s), &rettv,
! 				    1, argv, fill_submatch_list,
! 				      0L, 0L, &dummy, TRUE, partial, NULL);
! 		}
! 		if (matchList.sl_list.lv_len > 0)
! 		    /* fill_submatch_list() was called */
! 		    clear_submatch_list(&matchList);
  
  		eval_result = get_tv_string_buf_chk(&rettv, buf);
  		if (eval_result != NULL)
  		    eval_result = vim_strsave(eval_result);
***************
*** 7522,7528 ****
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !submatch_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
--- 7549,7555 ----
  		    /* Change NL to CR, so that it becomes a line break,
  		     * unless called from vim_regexec_nl().
  		     * Skip over a backslashed character. */
! 		    if (*s == NL && !rsm.sm_line_lbr)
  			*s = CAR;
  		    else if (*s == '\\' && s[1] != NUL)
  		    {
***************
*** 7533,7539 ****
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !submatch_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
--- 7560,7566 ----
  			 *   def
  			 * Not when called from vim_regexec_nl().
  			 */
! 			if (*s == NL && !rsm.sm_line_lbr)
  			    *s = CAR;
  			had_backslash = TRUE;
  		    }
***************
*** 7552,7565 ****
  		dst += STRLEN(eval_result);
  	    }
  
! 	    reg_match = submatch_match;
! 	    reg_mmatch = submatch_mmatch;
! 	    reg_firstlnum = submatch_firstlnum;
! 	    reg_maxline = submatch_maxline;
! 	    reg_line_lbr = submatch_line_lbr;
! 	    reg_win = save_reg_win;
! 	    ireg_ic = save_ireg_ic;
! 	    can_f_submatch = FALSE;
  	}
  #endif
      }
--- 7579,7587 ----
  		dst += STRLEN(eval_result);
  	    }
  
! 	    can_f_submatch = prev_can_f_submatch;
! 	    if (can_f_submatch)
! 		rsm = rsm_save;
  	}
  #endif
      }
***************
*** 7688,7713 ****
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + reg_mmatch->startpos[no].col;
! 		    if (reg_mmatch->endpos[no].lnum == clnum)
! 			len = reg_mmatch->endpos[no].col
! 					       - reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = reg_match->startp[no];
! 		if (reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
--- 7710,7735 ----
  	{
  	    if (REG_MULTI)
  	    {
! 		clnum = rex.reg_mmatch->startpos[no].lnum;
! 		if (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)
  		    s = NULL;
  		else
  		{
! 		    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;
! 		    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 			len = rex.reg_mmatch->endpos[no].col
! 					    - rex.reg_mmatch->startpos[no].col;
  		    else
  			len = (int)STRLEN(s);
  		}
  	    }
  	    else
  	    {
! 		s = rex.reg_match->startp[no];
! 		if (rex.reg_match->endp[no] == NULL)
  		    s = NULL;
  		else
! 		    len = (int)(rex.reg_match->endp[no] - s);
  	    }
  	    if (s != NULL)
  	    {
***************
*** 7717,7730 ****
  		    {
  			if (REG_MULTI)
  			{
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (reg_mmatch->endpos[no].lnum == clnum)
! 				len = reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
--- 7739,7752 ----
  		    {
  			if (REG_MULTI)
  			{
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
  				break;
  			    if (copy)
  				*dst = CAR;
  			    ++dst;
  			    s = reg_getline(++clnum);
! 			    if (rex.reg_mmatch->endpos[no].lnum == clnum)
! 				len = rex.reg_mmatch->endpos[no].col;
  			    else
  				len = (int)STRLEN(s);
  			}
***************
*** 7824,7839 ****
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = reg_firstlnum;
!     linenr_T save_max = reg_maxline;
  
!     reg_firstlnum = submatch_firstlnum;
!     reg_maxline = submatch_maxline;
  
      s = reg_getline(lnum);
  
!     reg_firstlnum = save_first;
!     reg_maxline = save_max;
      return s;
  }
  
--- 7846,7861 ----
  reg_getline_submatch(linenr_T lnum)
  {
      char_u *s;
!     linenr_T save_first = rex.reg_firstlnum;
!     linenr_T save_max = rex.reg_maxline;
  
!     rex.reg_firstlnum = rsm.sm_firstlnum;
!     rex.reg_maxline = rsm.sm_maxline;
  
      s = reg_getline(lnum);
  
!     rex.reg_firstlnum = save_first;
!     rex.reg_maxline = save_max;
      return s;
  }
  
***************
*** 7854,7860 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
--- 7876,7882 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
  	/*
  	 * First round: compute the length and allocate memory.
***************
*** 7862,7879 ****
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = submatch_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || submatch_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + submatch_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (submatch_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = submatch_mmatch->endpos[no].col
! 					  - submatch_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
--- 7884,7901 ----
  	 */
  	for (round = 1; round <= 2; ++round)
  	{
! 	    lnum = rsm.sm_mmatch->startpos[no].lnum;
! 	    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)
  		return NULL;
  
! 	    s = reg_getline_submatch(lnum) + rsm.sm_mmatch->startpos[no].col;
  	    if (s == NULL)  /* anti-crash check, cannot happen? */
  		break;
! 	    if (rsm.sm_mmatch->endpos[no].lnum == lnum)
  	    {
  		/* Within one line: take form start to end col. */
! 		len = rsm.sm_mmatch->endpos[no].col
! 					  - rsm.sm_mmatch->startpos[no].col;
  		if (round == 2)
  		    vim_strncpy(retval, s, len);
  		++len;
***************
*** 7890,7896 ****
  		}
  		++len;
  		++lnum;
! 		while (lnum < submatch_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
--- 7912,7918 ----
  		}
  		++len;
  		++lnum;
! 		while (lnum < rsm.sm_mmatch->endpos[no].lnum)
  		{
  		    s = reg_getline_submatch(lnum++);
  		    if (round == 2)
***************
*** 7902,7909 ****
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     submatch_mmatch->endpos[no].col);
! 		len += submatch_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
--- 7924,7931 ----
  		}
  		if (round == 2)
  		    STRNCPY(retval + len, reg_getline_submatch(lnum),
! 					     rsm.sm_mmatch->endpos[no].col);
! 		len += rsm.sm_mmatch->endpos[no].col;
  		if (round == 2)
  		    retval[len] = NUL;
  		++len;
***************
*** 7919,7929 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(submatch_match->endp[no] - s));
      }
  
      return retval;
--- 7941,7951 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    retval = NULL;
  	else
! 	    retval = vim_strnsave(s, (int)(rsm.sm_match->endp[no] - s));
      }
  
      return retval;
***************
*** 7951,7965 ****
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (submatch_match == NULL)
      {
! 	slnum = submatch_mmatch->startpos[no].lnum;
! 	elnum = submatch_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = submatch_mmatch->startpos[no].col;
! 	ecol = submatch_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
--- 7973,7987 ----
      if (!can_f_submatch || no < 0)
  	return NULL;
  
!     if (rsm.sm_match == NULL)
      {
! 	slnum = rsm.sm_mmatch->startpos[no].lnum;
! 	elnum = rsm.sm_mmatch->endpos[no].lnum;
  	if (slnum < 0 || elnum < 0)
  	    return NULL;
  
! 	scol = rsm.sm_mmatch->startpos[no].col;
! 	ecol = rsm.sm_mmatch->endpos[no].col;
  
  	list = list_alloc();
  	if (list == NULL)
***************
*** 7988,8001 ****
      }
      else
      {
! 	s = submatch_match->startp[no];
! 	if (s == NULL || submatch_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(submatch_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
--- 8010,8023 ----
      }
      else
      {
! 	s = rsm.sm_match->startp[no];
! 	if (s == NULL || rsm.sm_match->endp[no] == NULL)
  	    return NULL;
  	list = list_alloc();
  	if (list == NULL)
  	    return NULL;
  	if (list_append_string(list, s,
! 				 (int)(rsm.sm_match->endp[no] - s)) == FAIL)
  	    error = TRUE;
      }
  
***************
*** 8173,8179 ****
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8195,8214 ----
      colnr_T	col,    /* column to start looking for match */
      int		nl)
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
!     rex.reg_startp = NULL;
!     rex.reg_endp = NULL;
!     rex.reg_startpos = NULL;
!     rex.reg_endpos = NULL;
! 
!     result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8198,8203 ****
--- 8233,8243 ----
  
  	p_re = save_p_re;
      }
+ 
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result > 0;
  }
  
***************
*** 8264,8271 ****
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int result = rmp->regprog->engine->regexec_multi(
! 						rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
--- 8304,8319 ----
      colnr_T     col,            /* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     int		result;
!     regexec_T	rex_save;
!     int		rex_in_use_save = rex_in_use;
! 
!     if (rex_in_use)
! 	/* Being called recursively, save the state. */
! 	rex_save = rex;
!     rex_in_use = TRUE;
! 
!     result = rmp->regprog->engine->regexec_multi(rmp, win, buf, lnum, col, tm);
  
      /* NFA engine aborted because it's very slow. */
      if (rmp->regprog->re_engine == AUTOMATIC_ENGINE
***************
*** 8291,8295 ****
--- 8339,8347 ----
  	p_re = save_p_re;
      }
  
+     rex_in_use = rex_in_use_save;
+     if (rex_in_use)
+ 	rex = rex_save;
+ 
      return result <= 0 ? 0 : result;
  }
*** ../vim-8.0.0019/src/regexp_nfa.c	2016-09-09 20:26:46.000000000 +0200
--- src/regexp_nfa.c	2016-10-02 15:51:12.173504331 +0200
***************
*** 5432,5438 ****
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!ireg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
--- 5432,5438 ----
      char_u *s;
  
      /* Used often, do some work to avoid call overhead. */
!     if (!rex.reg_ic
  #ifdef FEAT_MBYTE
  		&& !has_mbyte
  #endif
***************
*** 5467,5473 ****
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!ireg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
--- 5467,5473 ----
  	{
  	    c1 = PTR2CHAR(match_text + len1);
  	    c2 = PTR2CHAR(regline + col + len2);
! 	    if (c1 != c2 && (!rex.reg_ic || MB_TOLOWER(c1) != MB_TOLOWER(c2)))
  	    {
  		match = FALSE;
  		break;
***************
*** 5485,5499 ****
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		reg_startpos[0].lnum = reglnum;
! 		reg_startpos[0].col = col;
! 		reg_endpos[0].lnum = reglnum;
! 		reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		reg_startp[0] = regline + col;
! 		reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
--- 5485,5499 ----
  	    cleanup_subexpr();
  	    if (REG_MULTI)
  	    {
! 		rex.reg_startpos[0].lnum = reglnum;
! 		rex.reg_startpos[0].col = col;
! 		rex.reg_endpos[0].lnum = reglnum;
! 		rex.reg_endpos[0].col = col + len2;
  	    }
  	    else
  	    {
! 		rex.reg_startp[0] = regline + col;
! 		rex.reg_endp[0] = regline + col + len2;
  	    }
  	    return 1L;
  	}
***************
*** 5728,5735 ****
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * ireg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !ireg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
--- 5728,5735 ----
  	      {
  #ifdef FEAT_MBYTE
  		/* If the match ends before a composing characters and
! 		 * rex.reg_icombine is not set, that is not really a match. */
! 		if (enc_utf8 && !rex.reg_icombine && utf_iscomposing(curc))
  		    break;
  #endif
  		nfa_match = TRUE;
***************
*** 6048,6063 ****
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, reg_buf)
  			   || (reginput > regline
! 				   && vim_iswordc_buf(reginput[-1], reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6048,6063 ----
  		    int this_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    if (this_class <= 1)
  			result = FALSE;
  		    else if (reg_prev_class() == this_class)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(curc, rex.reg_buf)
  			   || (reginput > regline
! 				&& vim_iswordc_buf(reginput[-1], rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6076,6091 ****
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], reg_buf)
  			|| (reginput[0] != NUL
! 					   && vim_iswordc_buf(curc, reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
--- 6076,6091 ----
  		    int this_class, prev_class;
  
  		    /* Get class of current and previous char (if it exists). */
! 		    this_class = mb_get_class_buf(reginput, rex.reg_buf);
  		    prev_class = reg_prev_class();
  		    if (this_class == prev_class
  					|| prev_class == 0 || prev_class == 1)
  			result = FALSE;
  		}
  #endif
! 		else if (!vim_iswordc_buf(reginput[-1], rex.reg_buf)
  			|| (reginput[0] != NUL
! 					&& vim_iswordc_buf(curc, rex.reg_buf)))
  		    result = FALSE;
  		if (result)
  		{
***************
*** 6096,6102 ****
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 					&& (!REG_MULTI || reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6096,6102 ----
  
  	    case NFA_BOF:
  		if (reglnum == 0 && reginput == regline
! 				     && (!REG_MULTI || rex.reg_firstlnum == 1))
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6104,6110 ****
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
--- 6104,6110 ----
  		break;
  
  	    case NFA_EOF:
! 		if (reglnum == rex.reg_maxline && curc == NUL)
  		{
  		    add_here = TRUE;
  		    add_state = t->state->out;
***************
*** 6131,6137 ****
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (ireg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
--- 6131,6137 ----
  		     * (no preceding character). */
  		    len += mb_char2len(mc);
  		}
! 		if (rex.reg_icombine && len == 0)
  		{
  		    /* If \Z was present, then ignore composing characters.
  		     * When ignoring the base character this always matches. */
***************
*** 6190,6197 ****
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !reg_line_lbr && REG_MULTI
! 						    && reglnum <= reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
--- 6190,6197 ----
  #endif
  
  	    case NFA_NEWL:
! 		if (curc == NUL && !rex.reg_line_lbr && REG_MULTI
! 						 && reglnum <= rex.reg_maxline)
  		{
  		    go_to_nextline = TRUE;
  		    /* Pass -1 for the offset, which means taking the position
***************
*** 6199,6205 ****
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
--- 6199,6205 ----
  		    add_state = t->state->out;
  		    add_off = -1;
  		}
! 		else if (curc == '\n' && rex.reg_line_lbr)
  		{
  		    /* match \n as if it is an ordinary character */
  		    add_state = t->state->out;
***************
*** 6244,6250 ****
  			    result = result_if_matched;
  			    break;
  			}
! 			if (ireg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
--- 6244,6250 ----
  			    result = result_if_matched;
  			    break;
  			}
! 			if (rex.reg_ic)
  			{
  			    int curc_low = MB_TOLOWER(curc);
  			    int done = FALSE;
***************
*** 6262,6268 ****
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (ireg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
--- 6262,6268 ----
  		    }
  		    else if (state->c < 0 ? check_char_class(state->c, curc)
  			        : (curc == state->c
! 				   || (rex.reg_ic && MB_TOLOWER(curc)
  						    == MB_TOLOWER(state->c))))
  		    {
  			result = result_if_matched;
***************
*** 6320,6332 ****
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 					&& vim_iswordp_buf(reginput, reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6320,6332 ----
  		break;
  
  	    case NFA_KWORD:	/*  \k	*/
! 		result = vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_SKWORD:	/*  \K	*/
  		result = !VIM_ISDIGIT(curc)
! 				     && vim_iswordp_buf(reginput, rex.reg_buf);
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6441,6464 ****
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (ireg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			  && !(ri_lower(curc) || (ireg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (ireg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			  && !(ri_upper(curc) || (ireg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
--- 6441,6464 ----
  		break;
  
  	    case NFA_LOWER_IC:	/* [a-z] */
! 		result = ri_lower(curc) || (rex.reg_ic && ri_upper(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NLOWER_IC:	/* [^a-z] */
  		result = curc != NUL
! 			&& !(ri_lower(curc) || (rex.reg_ic && ri_upper(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_UPPER_IC:	/* [A-Z] */
! 		result = ri_upper(curc) || (rex.reg_ic && ri_lower(curc));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
  	    case NFA_NUPPER_IC:	/* ^[A-Z] */
  		result = curc != NUL
! 			&& !(ri_upper(curc) || (rex.reg_ic && ri_lower(curc)));
  		ADD_STATE_IF_MATCH(t->state);
  		break;
  
***************
*** 6549,6555 ****
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6549,6555 ----
  	    case NFA_LNUM_LT:
  		result = (REG_MULTI &&
  			nfa_re_num_cmp(t->state->val, t->state->c - NFA_LNUM,
! 			    (long_u)(reglnum + rex.reg_firstlnum)));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6575,6581 ****
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = reg_win == NULL ? curwin : reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
--- 6575,6581 ----
  		{
  		    int     op = t->state->c - NFA_VCOL;
  		    colnr_T col = (colnr_T)(reginput - regline);
! 		    win_T   *wp = rex.reg_win == NULL ? curwin : rex.reg_win;
  
  		    /* Bail out quickly when there can't be a match, avoid the
  		     * overhead of win_linetabsize() on long lines. */
***************
*** 6611,6628 ****
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
--- 6611,6628 ----
  	    case NFA_MARK_GT:
  	    case NFA_MARK_LT:
  	      {
! 		pos_T	*pos = getmark_buf(rex.reg_buf, t->state->val, FALSE);
  
  		/* Compare the mark position to the match position. */
  		result = (pos != NULL		     /* mark doesn't exist */
  			&& pos->lnum > 0    /* mark isn't set in reg_buf */
! 			&& (pos->lnum == reglnum + rex.reg_firstlnum
  				? (pos->col == (colnr_T)(reginput - regline)
  				    ? t->state->c == NFA_MARK
  				    : (pos->col < (colnr_T)(reginput - regline)
  					? t->state->c == NFA_MARK_GT
  					: t->state->c == NFA_MARK_LT))
! 				: (pos->lnum < reglnum + rex.reg_firstlnum
  				    ? t->state->c == NFA_MARK_GT
  				    : t->state->c == NFA_MARK_LT)));
  		if (result)
***************
*** 6634,6643 ****
  	      }
  
  	    case NFA_CURSOR:
! 		result = (reg_win != NULL
! 			&& (reglnum + reg_firstlnum == reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						   == reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
--- 6634,6644 ----
  	      }
  
  	    case NFA_CURSOR:
! 		result = (rex.reg_win != NULL
! 			&& (reglnum + rex.reg_firstlnum
! 						 == rex.reg_win->w_cursor.lnum)
  			&& ((colnr_T)(reginput - regline)
! 						== rex.reg_win->w_cursor.col));
  		if (result)
  		{
  		    add_here = TRUE;
***************
*** 6691,6702 ****
  #endif
  		result = (c == curc);
  
! 		if (!result && ireg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If ireg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !ireg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
--- 6692,6703 ----
  #endif
  		result = (c == curc);
  
! 		if (!result && rex.reg_ic)
  		    result = MB_TOLOWER(c) == MB_TOLOWER(curc);
  #ifdef FEAT_MBYTE
! 		/* If rex.reg_icombine is not set only skip over the character
  		 * itself.  When it is set skip over composing characters. */
! 		if (result && enc_utf8 && !rex.reg_icombine)
  		    clen = utf_ptr2len(reginput);
  #endif
  		ADD_STATE_IF_MATCH(t->state);
***************
*** 6815,6822 ****
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (ireg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < ireg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
--- 6816,6823 ----
  		&& ((toplevel
  			&& reglnum == 0
  			&& clen != 0
! 			&& (rex.reg_maxcol == 0
! 			    || (colnr_T)(reginput - regline) < rex.reg_maxcol))
  		    || (nfa_endp != NULL
  			&& (REG_MULTI
  			    ? (reglnum < nfa_endp->se_u.pos.lnum
***************
*** 6856,6863 ****
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!ireg_ic || MB_TOLOWER(c)
! 					       != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
--- 6857,6864 ----
  			/* Checking if the required start character matches is
  			 * cheaper than adding a state that won't match. */
  			c = PTR2CHAR(reginput + clen);
! 			if (c != prog->regstart && (!rex.reg_ic
! 			       || MB_TOLOWER(c) != MB_TOLOWER(prog->regstart)))
  			{
  #ifdef ENABLE_LOG
  			    fprintf(log_fd, "  Skipping start state, regstart does not match\n");
***************
*** 6997,7036 ****
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (reg_startpos[0].lnum < 0)
  	{
! 	    reg_startpos[0].lnum = 0;
! 	    reg_startpos[0].col = col;
  	}
! 	if (reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    reg_endpos[0].lnum = reglnum;
! 	    reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    reg_startp[i] = subs.norm.list.line[i].start;
! 	    reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (reg_startp[0] == NULL)
! 	    reg_startp[0] = regline + col;
! 	if (reg_endp[0] == NULL)
! 	    reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
--- 6998,7037 ----
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startpos[i].lnum = subs.norm.list.multi[i].start_lnum;
! 	    rex.reg_startpos[i].col = subs.norm.list.multi[i].start_col;
  
! 	    rex.reg_endpos[i].lnum = subs.norm.list.multi[i].end_lnum;
! 	    rex.reg_endpos[i].col = subs.norm.list.multi[i].end_col;
  	}
  
! 	if (rex.reg_startpos[0].lnum < 0)
  	{
! 	    rex.reg_startpos[0].lnum = 0;
! 	    rex.reg_startpos[0].col = col;
  	}
! 	if (rex.reg_endpos[0].lnum < 0)
  	{
  	    /* pattern has a \ze but it didn't match, use current end */
! 	    rex.reg_endpos[0].lnum = reglnum;
! 	    rex.reg_endpos[0].col = (int)(reginput - regline);
  	}
  	else
  	    /* Use line number of "\ze". */
! 	    reglnum = rex.reg_endpos[0].lnum;
      }
      else
      {
  	for (i = 0; i < subs.norm.in_use; i++)
  	{
! 	    rex.reg_startp[i] = subs.norm.list.line[i].start;
! 	    rex.reg_endp[i] = subs.norm.list.line[i].end;
  	}
  
! 	if (rex.reg_startp[0] == NULL)
! 	    rex.reg_startp[0] = regline + col;
! 	if (rex.reg_endp[0] == NULL)
! 	    rex.reg_endp[0] = reginput;
      }
  
  #ifdef FEAT_SYN_HL
***************
*** 7093,7108 ****
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	reg_startpos = reg_mmatch->startpos;
! 	reg_endpos = reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)reg_match->regprog;
! 	reg_startp = reg_match->startp;
! 	reg_endp = reg_match->endp;
      }
  
      /* Be paranoid... */
--- 7094,7109 ----
  
      if (REG_MULTI)
      {
! 	prog = (nfa_regprog_T *)rex.reg_mmatch->regprog;
  	line = reg_getline((linenr_T)0);    /* relative to the cursor */
! 	rex.reg_startpos = rex.reg_mmatch->startpos;
! 	rex.reg_endpos = rex.reg_mmatch->endpos;
      }
      else
      {
! 	prog = (nfa_regprog_T *)rex.reg_match->regprog;
! 	rex.reg_startp = rex.reg_match->startp;
! 	rex.reg_endp = rex.reg_match->endp;
      }
  
      /* Be paranoid... */
***************
*** 7112,7127 ****
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of ireg_ic */
      if (prog->regflags & RF_ICASE)
! 	ireg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	ireg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of ireg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	ireg_icombine = TRUE;
  #endif
  
      regline = line;
--- 7113,7128 ----
  	goto theend;
      }
  
!     /* If pattern contains "\c" or "\C": overrule value of rex.reg_ic */
      if (prog->regflags & RF_ICASE)
! 	rex.reg_ic = TRUE;
      else if (prog->regflags & RF_NOICASE)
! 	rex.reg_ic = FALSE;
  
  #ifdef FEAT_MBYTE
!     /* If pattern contains "\Z" overrule value of rex.reg_icombine */
      if (prog->regflags & RF_ICOMBINE)
! 	rex.reg_icombine = TRUE;
  #endif
  
      regline = line;
***************
*** 7160,7173 ****
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !ireg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (ireg_maxcol > 0 && col >= ireg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
--- 7161,7174 ----
  	 * Nothing else to try. Doesn't handle combining chars well. */
  	if (prog->match_text != NULL
  #ifdef FEAT_MBYTE
! 		    && !rex.reg_icombine
  #endif
  		)
  	    return find_match_text(col, prog->regstart, prog->match_text);
      }
  
      /* If the start column is past the maximum column: no need to try. */
!     if (rex.reg_maxcol > 0 && col >= rex.reg_maxcol)
  	goto theend;
  
      nstate = prog->nstate;
***************
*** 7326,7342 ****
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     reg_match = rmp;
!     reg_mmatch = NULL;
!     reg_maxline = 0;
!     reg_line_lbr = line_lbr;
!     reg_buf = curbuf;
!     reg_win = NULL;
!     ireg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
--- 7327,7343 ----
      colnr_T	col,	/* column to start looking for match */
      int		line_lbr)
  {
!     rex.reg_match = rmp;
!     rex.reg_mmatch = NULL;
!     rex.reg_maxline = 0;
!     rex.reg_line_lbr = line_lbr;
!     rex.reg_buf = curbuf;
!     rex.reg_win = NULL;
!     rex.reg_ic = rmp->rm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = 0;
      return nfa_regexec_both(line, col, NULL);
  }
  
***************
*** 7375,7392 ****
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     reg_match = NULL;
!     reg_mmatch = rmp;
!     reg_buf = buf;
!     reg_win = win;
!     reg_firstlnum = lnum;
!     reg_maxline = reg_buf->b_ml.ml_line_count - lnum;
!     reg_line_lbr = FALSE;
!     ireg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     ireg_icombine = FALSE;
  #endif
!     ireg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
--- 7376,7393 ----
      colnr_T	col,		/* column to start looking for match */
      proftime_T	*tm)		/* timeout limit or NULL */
  {
!     rex.reg_match = NULL;
!     rex.reg_mmatch = rmp;
!     rex.reg_buf = buf;
!     rex.reg_win = win;
!     rex.reg_firstlnum = lnum;
!     rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;
!     rex.reg_line_lbr = FALSE;
!     rex.reg_ic = rmp->rmm_ic;
  #ifdef FEAT_MBYTE
!     rex.reg_icombine = FALSE;
  #endif
!     rex.reg_maxcol = rmp->rmm_maxcol;
  
      return nfa_regexec_both(NULL, col, tm);
  }
*** ../vim-8.0.0019/src/testdir/test_expr.vim	2016-09-14 22:16:09.863803610 +0200
--- src/testdir/test_expr.vim	2016-10-02 16:29:45.285611327 +0200
***************
*** 405,413 ****
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y*', {-> g:val}, '')
    endfunc
!   call assert_equal('--', substitute('xxx', 'x*', {-> '-' . Recurse() . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
--- 405,414 ----
  	\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))
  
    func Recurse()
!     return substitute('yyy', 'y\(.\)y', {-> submatch(1)}, '')
    endfunc
!   " recursive call works
!   call assert_equal('-y-x-', substitute('xxx', 'x\(.\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))
  endfunc
  
  func Test_invalid_submatch()
*** ../vim-8.0.0019/runtime/doc/eval.txt	2016-09-27 21:28:52.905342034 +0200
--- runtime/doc/eval.txt	2016-10-02 16:39:09.841721025 +0200
***************
*** 7379,7384 ****
--- 7390,7398 ----
  		|substitute()| this list will always contain one or zero
  		items, since there are no real line breaks.
  
+ 		When substitute() is used recursively only the submatches in
+ 		the current (deepest) call can be obtained.
+ 
  		Example: >
  			:s/\d\+/\=submatch(0) + 1/
  <		This finds the first number in the line and adds one to it.
*** ../vim-8.0.0019/runtime/doc/change.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/change.txt	2016-10-02 16:37:35.170373987 +0200
***************
*** 1,4 ****
! *change.txt*    For Vim version 8.0.  Last change: 2016 Sep 11
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
--- 1,4 ----
! *change.txt*    For Vim version 8.0.  Last change: 2016 Oct 02
  
  
  		  VIM REFERENCE MANUAL    by Bram Moolenaar
***************
*** 913,920 ****
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.  This does not work recursively: a |substitute()| function inside
! the expression cannot use "\=" for the substitute string.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
--- 913,919 ----
  Substitute with an expression			*sub-replace-expression*
  						*sub-replace-\=* *s/\=*
  When the substitute string starts with "\=" the remainder is interpreted as an
! expression.
  
  The special meaning for characters as mentioned at |sub-replace-special| does
  not apply except for "<CR>".  A <NL> character is used as a line break, you
*** ../vim-8.0.0019/src/version.c	2016-09-29 20:54:42.407110721 +0200
--- src/version.c	2016-10-02 15:27:58.639175908 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     20,
  /**/

-- 
    With sufficient thrust, pigs fly just fine.
                   -- RFC 1925

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0021
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0021
Problem:    In the GUI when redrawing the cursor it may be on the second half
            of a double byte character.
Solution:   Correct the cursor column. (Yasuhiro Matsumoto)
Files:      src/screen.c


*** ../vim-8.0.0020/src/screen.c	2016-08-29 22:42:20.000000000 +0200
--- src/screen.c	2016-10-02 23:04:57.705033401 +0200
***************
*** 765,770 ****
--- 765,773 ----
  	     * uses that. */
  	    gui.col = gui_cursor_col;
  	    gui.row = gui_cursor_row;
+ # ifdef FEAT_MBYTE
+ 	    gui.col = mb_fix_col(gui.col, gui.row);
+ # endif
  	    gui_update_cursor(FALSE, FALSE);
  	    screen_cur_col = gui.col;
  	    screen_cur_row = gui.row;
*** ../vim-8.0.0020/src/version.c	2016-10-02 16:51:32.748592858 +0200
--- src/version.c	2016-10-02 23:06:01.632588200 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     21,
  /**/

-- 
BLACK KNIGHT:  I move for no man.
ARTHUR:        So be it!
    [hah] [parry thrust]
    [ARTHUR chops the BLACK KNIGHT's left arm off]
ARTHUR:        Now stand aside, worthy adversary.
BLACK KNIGHT:  'Tis but a scratch.
                                  The Quest for the Holy Grail (Monty Python)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0022
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0022
Problem:    If a channel in NL mode is missing the NL at the end the remaining
            characters are dropped.
Solution:   When the channel is closed use the remaining text. (Ozaki Kiichi)
Files:      src/channel.c, src/testdir/test_channel.vim


*** ../vim-8.0.0021/src/channel.c	2016-09-29 15:18:51.351768068 +0200
--- src/channel.c	2016-10-03 21:35:54.516547182 +0200
***************
*** 2355,2362 ****
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
!     cbq_T	*cbhead = &channel->ch_part[part].ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
--- 2355,2363 ----
      typval_T	*listtv = NULL;
      typval_T	argv[CH_JSON_MAX_ARGS];
      int		seq_nr = -1;
!     chanpart_T	*ch_part = &channel->ch_part[part];
!     ch_mode_T	ch_mode = ch_part->ch_mode;
!     cbq_T	*cbhead = &ch_part->ch_cb_head;
      cbq_T	*cbitem;
      char_u	*callback = NULL;
      partial_T	*partial = NULL;
***************
*** 2376,2385 ****
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (channel->ch_part[part].ch_callback != NULL)
      {
! 	callback = channel->ch_part[part].ch_callback;
! 	partial = channel->ch_part[part].ch_partial;
      }
      else
      {
--- 2377,2386 ----
  	callback = cbitem->cq_callback;
  	partial = cbitem->cq_partial;
      }
!     else if (ch_part->ch_callback != NULL)
      {
! 	callback = ch_part->ch_callback;
! 	partial = ch_part->ch_partial;
      }
      else
      {
***************
*** 2387,2397 ****
  	partial = channel->ch_partial;
      }
  
!     buffer = channel->ch_part[part].ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&channel->ch_part[part].ch_bufref))
      {
  	/* buffer was wiped out */
! 	channel->ch_part[part].ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
--- 2388,2398 ----
  	partial = channel->ch_partial;
      }
  
!     buffer = ch_part->ch_bufref.br_buf;
!     if (buffer != NULL && !bufref_valid(&ch_part->ch_bufref))
      {
  	/* buffer was wiped out */
! 	ch_part->ch_bufref.br_buf = NULL;
  	buffer = NULL;
      }
  
***************
*** 2452,2458 ****
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl;
  	    char_u  *buf;
  	    readq_T *node;
  
--- 2453,2459 ----
  
  	if (ch_mode == MODE_NL)
  	{
! 	    char_u  *nl = NULL;
  	    char_u  *buf;
  	    readq_T *node;
  
***************
*** 2465,2474 ****
--- 2466,2490 ----
  		if (nl != NULL)
  		    break;
  		if (channel_collapse(channel, part, TRUE) == FAIL)
+ 		{
+ 		    if (ch_part->ch_fd == INVALID_FD && node->rq_buflen > 0)
+ 			break;
  		    return FALSE; /* incomplete message */
+ 		}
  	    }
  	    buf = node->rq_buffer;
  
+ 	    if (nl == NULL)
+ 	    {
+ 		/* Flush remaining message that is missing a NL. */
+ 		buf = vim_realloc(buf, node->rq_buflen + 1);
+ 		if (buf == NULL)
+ 		    return FALSE;
+ 		node->rq_buffer = buf;
+ 		nl = buf + node->rq_buflen++;
+ 		*nl = NUL;
+ 	    }
+ 
  	    /* Convert NUL to NL, the internal representation. */
  	    for (p = buf; p < nl && p < buf + node->rq_buflen; ++p)
  		if (*p == NUL)
*** ../vim-8.0.0021/src/testdir/test_channel.vim	2016-09-26 22:36:50.615386371 +0200
--- src/testdir/test_channel.vim	2016-10-03 21:31:14.246500828 +0200
***************
*** 1484,1489 ****
--- 1484,1510 ----
    bwipe!
  endfunc
  
+ func MyLineCountCb(ch, msg)
+   let g:linecount += 1
+ endfunc
+ 
+ func Test_read_nonl_line()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes
+     let arg = 'import sys;sys.stdout.write(\"1\n2\n3\")'
+   else
+     let arg = 'import sys;sys.stdout.write("1\n2\n3")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('3 <= g:linecount')
+   call assert_equal(3, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0021/src/version.c	2016-10-02 23:09:27.643153731 +0200
--- src/version.c	2016-10-03 21:33:11.837681063 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     22,
  /**/

-- 
"It's so simple to be wise.  Just think of something stupid to say
and then don't say it."        -- Sam Levenson

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0023
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0023
Problem:    "gd" and "gD" may find a match in a comment or string.
Solution:   Ignore matches in comments and strings. (Anton Lindqvist)
Files:      src/normal.c, src/testdir/test_goto.vim


*** ../vim-8.0.0022/src/normal.c	2016-09-11 16:52:37.000000000 +0200
--- src/normal.c	2016-10-08 19:05:10.213933460 +0200
***************
*** 4240,4245 ****
--- 4240,4291 ----
  }
  
  /*
+  * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE
+  * otherwise.
+  */
+     static int
+ is_ident(char_u *line, int offset)
+ {
+     int	i;
+     int	incomment = FALSE;
+     int	instring = 0;
+     int	prev = 0;
+ 
+     for (i = 0; i < offset && line[i] != NUL; i++)
+     {
+ 	if (instring != 0)
+ 	{
+ 	    if (prev != '\\' && line[i] == instring)
+ 		instring = 0;
+ 	}
+ 	else if ((line[i] == '"' || line[i] == '\'') && !incomment)
+ 	{
+ 	    instring = line[i];
+ 	}
+ 	else
+ 	{
+ 	    if (incomment)
+ 	    {
+ 		if (prev == '*' && line[i] == '/')
+ 		    incomment = FALSE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '*')
+ 	    {
+ 		incomment = TRUE;
+ 	    }
+ 	    else if (prev == '/' && line[i] == '/')
+ 	    {
+ 		return FALSE;
+ 	    }
+ 	}
+ 
+ 	prev = line[i];
+     }
+ 
+     return incomment == FALSE && instring == 0;
+ }
+ 
+ /*
   * Search for variable declaration of "ptr[len]".
   * When "locally" is TRUE in the current function ("gd"), otherwise in the
   * current file ("gD").
***************
*** 4264,4269 ****
--- 4310,4316 ----
      int		retval = OK;
      int		incll;
      int		searchflags = flags_arg;
+     int		valid;
  
      if ((pat = alloc(len + 7)) == NULL)
  	return FAIL;
***************
*** 4301,4306 ****
--- 4348,4354 ----
      clearpos(&found_pos);
      for (;;)
      {
+ 	valid = FALSE;
  	t = searchit(curwin, curbuf, &curwin->w_cursor, FORWARD,
  			    pat, 1L, searchflags, RE_LAST, (linenr_T)0, NULL);
  	if (curwin->w_cursor.lnum >= old_pos.lnum)
***************
*** 4337,4345 ****
  	    continue;
  	}
  #endif
! 	if (!locally)	/* global search: use first match found */
  	    break;
! 	if (curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
--- 4385,4404 ----
  	    continue;
  	}
  #endif
! 	valid = is_ident(ml_get_curline(), curwin->w_cursor.col);
! 
! 	/* If the current position is not a valid identifier and a previous
! 	 * match is present, favor that one instead. */
! 	if (!valid && found_pos.lnum != 0)
! 	{
! 	    curwin->w_cursor = found_pos;
  	    break;
! 	}
! 
! 	/* Global search: use first valid match found */
! 	if (valid && !locally)
! 	    break;
! 	if (valid && curwin->w_cursor.lnum >= par_pos.lnum)
  	{
  	    /* If we previously found a valid position, use it. */
  	    if (found_pos.lnum != 0)
***************
*** 4347,4357 ****
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" search
! 	 * to find a later match.  For K&R style function declarations this
! 	 * skips the function header without types.  Remove SEARCH_START from
! 	 * flags to avoid getting stuck at one position. */
! 	found_pos = curwin->w_cursor;
  	searchflags &= ~SEARCH_START;
      }
  
--- 4406,4425 ----
  	    break;
  	}
  
! 	/* For finding a local variable and the match is before the "{" or
! 	 * inside a comment, continue searching.  For K&R style function
! 	 * declarations this skips the function header without types. */
! 	if (!valid)
! 	{
! 	    /* Braces needed due to macro expansion of clearpos. */
! 	    clearpos(&found_pos);
! 	}
! 	else
! 	{
! 	    found_pos = curwin->w_cursor;
! 	}
! 	/* Remove SEARCH_START from flags to avoid getting stuck at one
! 	 * position. */
  	searchflags &= ~SEARCH_START;
      }
  
*** ../vim-8.0.0022/src/testdir/test_goto.vim	2016-06-15 21:58:47.000000000 +0200
--- src/testdir/test_goto.vim	2016-10-08 19:20:00.495818284 +0200
***************
*** 1,20 ****
  " Test commands that jump somewhere.
  
! func Test_geeDEE()
    new
!   call setline(1, ["Filename x;", "", "int Filename", "int func() {", "Filename y;"])
!   /y;/
!   normal gD
!   call assert_equal(1, line('.'))
    quit!
  endfunc
  
! func Test_gee_dee()
!   new
!   call setline(1, ["int x;", "", "int func(int x)", "{", "  return x;", "}"])
!   /return/
!   normal $hgd
!   call assert_equal(3, line('.'))
!   call assert_equal(14, col('.'))
!   quit!
  endfunc
--- 1,275 ----
  " Test commands that jump somewhere.
  
! " Create a new buffer using "lines" and place the cursor on the word after the
! " first occurrence of return and invoke "cmd". The cursor should now be
! " positioned at the given line and col.
! func XTest_goto_decl(cmd, lines, line, col)
    new
!   call setline(1, a:lines)
!   /return/
!   normal! W
!   execute 'norm! ' . a:cmd
!   call assert_equal(a:line, line('.'))
!   call assert_equal(a:col, col('.'))
    quit!
  endfunc
  
! func Test_gD()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 5)
! endfunc
! 
! func Test_gD_too()
!   let lines = [
! 	\ 'Filename x;',
! 	\ '',
! 	\ 'int Filename',
! 	\ 'int func() {',
! 	\ '  Filename x;',
! 	\ '  return x;',
! 	\ ]
!   call XTest_goto_decl('gD', lines, 1, 10)
! endfunc
! 
! func Test_gD_comment()
!   let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_inline_comment()
!   let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string()
!   let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gD_string_same_line()
!   let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 1, 22)
! endfunc
! 
! func Test_gD_char()
!   let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gD', lines, 2, 5)
! endfunc
! 
! func Test_gd()
!   let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 14)
! endfunc
! 
! func Test_gd_not_local()
!   let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_kr_style()
!   let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 2, 7)
! endfunc
! 
! func Test_gd_missing_braces()
!   let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 11)
! endfunc
! 
! func Test_gd_comment()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_comment_in_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 22)
! endfunc
! 
! func Test_gd_string_in_comment()
!   set comments=
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
!   call XTest_goto_decl('gd', lines, 3, 15)
!   set comments&
! endfunc
! 
! func Test_gd_inline_comment()
!   let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 32)
! endfunc
! 
! func Test_gd_inline_comment_only()
!   let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 3, 10)
! endfunc
! 
! func Test_gd_inline_comment_body()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
!   call XTest_goto_decl('gd', lines, 7, 7)
! endfunc
! 
! func Test_gd_trailing_multiline_comment()
!   let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_trailing_comment()
!   let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 1, 14)
! endfunc
! 
! func Test_gd_string()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 4, 7)
! endfunc
! 
! func Test_gd_string_only()
!   let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
!   call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0022/src/version.c	2016-10-03 21:37:37.619829811 +0200
--- src/version.c	2016-10-08 19:20:57.867423971 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     23,
  /**/

-- 
Two cows are standing together in a field.  One asks the other:
"So what do you think about this Mad Cow Disease?"
The other replies: "That doesn't concern me. I'm a helicopter."

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0024
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0024
Problem:    When the netbeans channel closes, "DETACH" is put in the output
            part. (Ozaki Kiichi)
Solution:   Write "DETACH" in the socket part.
Files:      src/channel.c, src/testdir/test_netbeans.vim


*** ../vim-8.0.0023/src/channel.c	2016-10-03 21:37:37.619829811 +0200
--- src/channel.c	2016-10-09 15:42:14.971496844 +0200
***************
*** 3061,3067 ****
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_OUT, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
--- 3061,3067 ----
       * Only send "DETACH" for a netbeans channel.
       */
      if (channel->ch_nb_close_cb != NULL)
! 	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
      /* When reading from stdout is not possible, assume the other side has
*** ../vim-8.0.0023/src/testdir/test_netbeans.vim	2016-09-09 15:28:11.000000000 +0200
--- src/testdir/test_netbeans.vim	2016-10-09 15:39:35.824606229 +0200
***************
*** 35,40 ****
--- 35,41 ----
    nbclose
  
    call WaitFor('len(readfile("Xnetbeans")) > 6')
+   call assert_false(has("netbeans_enabled"))
    let lines = readfile("Xnetbeans")
    call assert_equal('AUTH bunny', lines[0])
    call assert_equal('0:version=0 "2.5"', lines[1])
*** ../vim-8.0.0023/src/version.c	2016-10-08 19:21:26.083230027 +0200
--- src/version.c	2016-10-09 15:25:08.486659955 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     24,
  /**/

-- 
TALL KNIGHT: We are now no longer the Knights Who Say Ni!
ONE KNIGHT:  Ni!
OTHERS:      Sh!
ONE KNIGHT:  (whispers) Sorry.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0025
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0025
Problem:    Inconsistent use of spaces vs tabs in gd test.
Solution:   Use tabs. (Anton Lindqvist)
Files:      src/testdir/test_goto.vim


*** ../vim-8.0.0024/src/testdir/test_goto.vim	2016-10-08 19:21:26.083230027 +0200
--- src/testdir/test_goto.vim	2016-10-09 15:47:40.725228290 +0200
***************
*** 16,28 ****
  
  func Test_gD()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
--- 16,28 ----
  
  func Test_gD()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 5)
  endfunc
  
***************
*** 40,275 ****
  
  func Test_gD_comment()
    let lines = [
!     \ '/* int x; */',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
!     \ 'int y /* , x */;',
!     \ 'int x;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
!     \ 'char *s[] = "x";',
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
!     \ 'char *s[] = "x", int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
!     \ "char c = 'x';",
!     \ 'int x = 1;',
!     \ '',
!     \ 'int func(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
!     \ 'int x;',
!     \ '',
!     \ 'int func(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
!     \ 'int func1(void)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ '',
!     \ 'int func2(int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
!     \ 'int func(x)',
!     \ '  int x;',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
!     \ 'def func1(a)',
!     \ '  a + 1',
!     \ 'end',
!     \ '',
!     \ 'a = 1',
!     \ '',
!     \ 'def func2()',
!     \ '  return a',
!     \ 'end',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* int x; */',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s ="//"; int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  /* " */ int x;',
!     \ '  int x;',
!     \ '  return x;',
!     \ '}',
!     \]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
!     \ 'int func(/* x is an int */ int x)',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
!     \ 'int func(void) /* one lonely x */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  int y /* , x */;',
!     \ '',
!     \ '  for (/* int x = 0 */; y < 2; y++);',
!     \ '',
!     \ '  int x = 0;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!   \ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
!     \ 'int func(int x) /* x is an int */',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
!     \ 'int func(int x) // x is an int',
!     \ '{',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '  int x = 1;',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
!     \ 'int func(void)',
!     \ '{',
!     \ '  char *s = "x";',
!     \ '',
!     \ '  return x;',
!     \ '}',
!     \ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
--- 40,275 ----
  
  func Test_gD_comment()
    let lines = [
! 	\ '/* int x; */',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_inline_comment()
    let lines = [
! 	\ 'int y /* , x */;',
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string()
    let lines = [
! 	\ 'char *s[] = "x";',
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gD_string_same_line()
    let lines = [
! 	\ 'char *s[] = "x", int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 1, 22)
  endfunc
  
  func Test_gD_char()
    let lines = [
! 	\ "char c = 'x';",
! 	\ 'int x = 1;',
! 	\ '',
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gD', lines, 2, 5)
  endfunc
  
  func Test_gd()
    let lines = [
! 	\ 'int x;',
! 	\ '',
! 	\ 'int func(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 14)
  endfunc
  
  func Test_gd_not_local()
    let lines = [
! 	\ 'int func1(void)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ '',
! 	\ 'int func2(int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_kr_style()
    let lines = [
! 	\ 'int func(x)',
! 	\ '  int x;',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 2, 7)
  endfunc
  
  func Test_gd_missing_braces()
    let lines = [
! 	\ 'def func1(a)',
! 	\ '  a + 1',
! 	\ 'end',
! 	\ '',
! 	\ 'a = 1',
! 	\ '',
! 	\ 'def func2()',
! 	\ '  return a',
! 	\ 'end',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 11)
  endfunc
  
  func Test_gd_comment()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* int x; */',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_comment_in_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s ="//"; int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 22)
  endfunc
  
  func Test_gd_string_in_comment()
    set comments=
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  /* " */ int x;',
! 	\ '  int x;',
! 	\ '  return x;',
! 	\ '}',
! 	\]
    call XTest_goto_decl('gd', lines, 3, 15)
    set comments&
  endfunc
  
  func Test_gd_inline_comment()
    let lines = [
! 	\ 'int func(/* x is an int */ int x)',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 32)
  endfunc
  
  func Test_gd_inline_comment_only()
    let lines = [
! 	\ 'int func(void) /* one lonely x */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 3, 10)
  endfunc
  
  func Test_gd_inline_comment_body()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  int y /* , x */;',
! 	\ '',
! 	\ '  for (/* int x = 0 */; y < 2; y++);',
! 	\ '',
! 	\ '  int x = 0;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 7, 7)
  endfunc
  
  func Test_gd_trailing_multiline_comment()
    let lines = [
! 	\ 'int func(int x) /* x is an int */',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_trailing_comment()
    let lines = [
! 	\ 'int func(int x) // x is an int',
! 	\ '{',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 1, 14)
  endfunc
  
  func Test_gd_string()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '  int x = 1;',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 4, 7)
  endfunc
  
  func Test_gd_string_only()
    let lines = [
! 	\ 'int func(void)',
! 	\ '{',
! 	\ '  char *s = "x";',
! 	\ '',
! 	\ '  return x;',
! 	\ '}',
! 	\ ]
    call XTest_goto_decl('gd', lines, 5, 10)
  endfunc
*** ../vim-8.0.0024/src/version.c	2016-10-09 15:43:22.459026620 +0200
--- src/version.c	2016-10-09 15:49:39.288398847 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     25,
  /**/

-- 
The war between Emacs and Vi is over.  Vi has won with 3 to 1.
http://m.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/030/3044/3044s1.html

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0026
Problem:    Error format with %W, %C and %Z does not work. (Gerd Wachsmuth)
Solution:   Skip code when qf_multiignore is set. (Lcd)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0025/src/quickfix.c	2016-09-27 21:28:52.901342062 +0200
--- src/quickfix.c	2016-10-09 16:02:48.394927690 +0200
***************
*** 1010,1048 ****
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 	    if (qfprev == NULL)
! 		return QF_FAIL;
! 	    if (*fields->errmsg && !qi->qf_multiignore)
  	    {
! 		len = (int)STRLEN(qfprev->qf_text);
! 		if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			== NULL)
  		    return QF_FAIL;
! 		STRCPY(ptr, qfprev->qf_text);
! 		vim_free(qfprev->qf_text);
! 		qfprev->qf_text = ptr;
! 		*(ptr += len) = '\n';
! 		STRCPY(++ptr, fields->errmsg);
! 	    }
! 	    if (qfprev->qf_nr == -1)
! 		qfprev->qf_nr = fields->enr;
! 	    if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		/* only printable chars allowed */
! 		qfprev->qf_type = fields->type;
  
! 	    if (!qfprev->qf_lnum)
! 		qfprev->qf_lnum = fields->lnum;
! 	    if (!qfprev->qf_col)
! 		qfprev->qf_col = fields->col;
! 	    qfprev->qf_viscol = fields->use_viscol;
! 	    if (!qfprev->qf_fnum)
! 		qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			*fields->namebuf || qi->qf_directory != NULL
! 			? fields->namebuf
! 			: qi->qf_currfile != NULL && fields->valid
! 			? qi->qf_currfile : 0);
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
--- 1010,1051 ----
  	}
  	else if (vim_strchr((char_u *)"CZ", idx) != NULL)
  	{				/* continuation of multi-line msg */
! 	    if (!qi->qf_multiignore)
  	    {
! 		qfline_T *qfprev = qi->qf_lists[qi->qf_curlist].qf_last;
! 
! 		if (qfprev == NULL)
  		    return QF_FAIL;
! 		if (*fields->errmsg && !qi->qf_multiignore)
! 		{
! 		    len = (int)STRLEN(qfprev->qf_text);
! 		    if ((ptr = alloc((unsigned)(len + STRLEN(fields->errmsg) + 2)))
! 			    == NULL)
! 			return QF_FAIL;
! 		    STRCPY(ptr, qfprev->qf_text);
! 		    vim_free(qfprev->qf_text);
! 		    qfprev->qf_text = ptr;
! 		    *(ptr += len) = '\n';
! 		    STRCPY(++ptr, fields->errmsg);
! 		}
! 		if (qfprev->qf_nr == -1)
! 		    qfprev->qf_nr = fields->enr;
! 		if (vim_isprintc(fields->type) && !qfprev->qf_type)
! 		    /* only printable chars allowed */
! 		    qfprev->qf_type = fields->type;
  
! 		if (!qfprev->qf_lnum)
! 		    qfprev->qf_lnum = fields->lnum;
! 		if (!qfprev->qf_col)
! 		    qfprev->qf_col = fields->col;
! 		qfprev->qf_viscol = fields->use_viscol;
! 		if (!qfprev->qf_fnum)
! 		    qfprev->qf_fnum = qf_get_fnum(qi, qi->qf_directory,
! 			    *fields->namebuf || qi->qf_directory != NULL
! 			    ? fields->namebuf
! 			    : qi->qf_currfile != NULL && fields->valid
! 			    ? qi->qf_currfile : 0);
! 	    }
  	    if (idx == 'Z')
  		qi->qf_multiline = qi->qf_multiignore = FALSE;
  	    line_breakcheck();
*** ../vim-8.0.0025/src/testdir/test_quickfix.vim	2016-09-27 21:28:52.901342062 +0200
--- src/testdir/test_quickfix.vim	2016-10-09 16:01:59.319265564 +0200
***************
*** 818,823 ****
--- 818,846 ----
    call delete('habits1.txt')
  endfunction
  
+ " Test for resync after continuing an ignored message
+ function! Xefm_ignore_continuations(cchar)
+   call s:setup_commands(a:cchar)
+ 
+   let save_efm = &efm
+ 
+   let &efm =
+ 	\ '%Eerror %m %l,' .
+ 	\ '%-Wignored %m %l,' .
+ 	\ '%+Cmore ignored %m %l,' .
+ 	\ '%Zignored end'
+   Xgetexpr ['ignored warning 1', 'more ignored continuation 2', 'ignored end', 'error resync 4']
+   let l = map(g:Xgetlist(), '[v:val.text, v:val.valid, v:val.lnum, v:val.type]')
+   call assert_equal([['resync', 1, 4, 'E']], l)
+ 
+   let &efm = save_efm
+ endfunction
+ 
+ function! Test_efm_ignore_continuations()
+   call Xefm_ignore_continuations('c')
+   call Xefm_ignore_continuations('l')
+ endfunction
+ 
  " Tests for invalid error format specifies
  function Xinvalid_efm_Tests(cchar)
    call s:setup_commands(a:cchar)
*** ../vim-8.0.0025/src/version.c	2016-10-09 15:50:45.927932466 +0200
--- src/version.c	2016-10-09 16:03:43.222550240 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
Q: How do you tell the difference between a female cat and a male cat?
A: You ask it a question and if HE answers, it's a male but, if SHE
   answers, it's a female.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0027
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0027
Problem:    A channel is closed when reading on stderr or stdout fails, but
            there may still be something to read on another part.
Solution:   Turn ch_to_be_closed into a bitfield. (Ozaki Kiichi)
Files:      src/channel.c, src/eval.c, src/structs.h, src/proto/channel.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0026/src/channel.c	2016-10-09 15:43:22.455026647 +0200
--- src/channel.c	2016-10-09 17:08:57.303345580 +0200
***************
*** 54,60 ****
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, int part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
--- 54,60 ----
  # define fd_close(sd) close(sd)
  #endif
  
! static void channel_read(channel_T *channel, ch_part_T part, char *func);
  
  /* Whether a redraw is needed for appending a line to a buffer. */
  static int channel_need_redraw = FALSE;
***************
*** 309,315 ****
      channel_T *
  add_channel(void)
  {
!     int		part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
--- 309,315 ----
      channel_T *
  add_channel(void)
  {
!     ch_part_T	part;
      channel_T	*channel = (channel_T *)alloc_clear((int)sizeof(channel_T));
  
      if (channel == NULL)
***************
*** 318,324 ****
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part <= PART_IN; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
--- 318,324 ----
      channel->ch_id = next_ch_id++;
      ch_log(channel, "Created channel");
  
!     for (part = PART_SOCK; part < PART_COUNT; ++part)
      {
  	channel->ch_part[part].ch_fd = INVALID_FD;
  #ifdef FEAT_GUI_X11
***************
*** 421,429 ****
      if (!in_free_unref_items)
      {
  	if (safe_to_invoke_callback == 0)
- 	{
  	    channel->ch_to_be_freed = TRUE;
- 	}
  	else
  	{
  	    channel_free_contents(channel);
--- 421,427 ----
***************
*** 511,517 ****
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     int		part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
--- 509,515 ----
  channel_read_fd(int fd)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      channel = channel_fd2channel(fd, &part);
      if (channel == NULL)
***************
*** 557,563 ****
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, int part)
  {
      if (!CH_HAS_GUI)
  	return;
--- 555,561 ----
  #endif
  
      static void
! channel_gui_register_one(channel_T *channel, ch_part_T part)
  {
      if (!CH_HAS_GUI)
  	return;
***************
*** 627,633 ****
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, int part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
--- 625,631 ----
  }
  
      static void
! channel_gui_unregister_one(channel_T *channel, ch_part_T part)
  {
  # ifdef FEAT_GUI_X11
      if (channel->ch_part[part].ch_inputHandler != (XtInputId)NULL)
***************
*** 653,659 ****
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     int	    part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
--- 651,657 ----
      static void
  channel_gui_unregister(channel_T *channel)
  {
!     ch_part_T	part;
  
      for (part = PART_SOCK; part < PART_IN; ++part)
  	channel_gui_unregister_one(channel, part);
***************
*** 928,933 ****
--- 926,932 ----
      channel->ch_nb_close_cb = nb_close_cb;
      channel->ch_hostname = (char *)vim_strsave((char_u *)hostname);
      channel->ch_port = port_in;
+     channel->ch_to_be_closed |= (1 << PART_SOCK);
  
  #ifdef FEAT_GUI
      channel_gui_register_one(channel, PART_SOCK);
***************
*** 998,1009 ****
  }
  
      static void
! may_close_part(sock_T *fd)
  {
      if (*fd != INVALID_FD)
      {
! 	fd_close(*fd);
  	*fd = INVALID_FD;
      }
  }
  
--- 997,1015 ----
  }
  
      static void
! ch_close_part(channel_T *channel, ch_part_T part)
  {
+     sock_T *fd = &channel->ch_part[part].ch_fd;
+ 
      if (*fd != INVALID_FD)
      {
! 	if (part == PART_SOCK)
! 	    sock_close(*fd);
! 	else
! 	    fd_close(*fd);
  	*fd = INVALID_FD;
+ 
+ 	channel->ch_to_be_closed &= ~(1 << part);
      }
  }
  
***************
*** 1012,1018 ****
  {
      if (in != INVALID_FD)
      {
! 	may_close_part(&channel->CH_IN_FD);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
--- 1018,1024 ----
  {
      if (in != INVALID_FD)
      {
! 	ch_close_part(channel, PART_IN);
  	channel->CH_IN_FD = in;
      }
      if (out != INVALID_FD)
***************
*** 1020,1027 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	may_close_part(&channel->CH_OUT_FD);
  	channel->CH_OUT_FD = out;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
--- 1026,1034 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_OUT);
  # endif
! 	ch_close_part(channel, PART_OUT);
  	channel->CH_OUT_FD = out;
+ 	channel->ch_to_be_closed |= (1 << PART_OUT);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_OUT);
  # endif
***************
*** 1031,1038 ****
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	may_close_part(&channel->CH_ERR_FD);
  	channel->CH_ERR_FD = err;
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
--- 1038,1046 ----
  # if defined(FEAT_GUI)
  	channel_gui_unregister_one(channel, PART_ERR);
  # endif
! 	ch_close_part(channel, PART_ERR);
  	channel->CH_ERR_FD = err;
+ 	channel->ch_to_be_closed |= (1 << PART_ERR);
  # if defined(FEAT_GUI)
  	channel_gui_register_one(channel, PART_ERR);
  # endif
***************
*** 1151,1160 ****
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     int		part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
--- 1159,1168 ----
      void
  channel_set_options(channel_T *channel, jobopt_T *opt)
  {
!     ch_part_T	part;
  
      if (opt->jo_set & JO_MODE)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_mode = opt->jo_mode;
      if (opt->jo_set & JO_IN_MODE)
  	channel->ch_part[PART_IN].ch_mode = opt->jo_in_mode;
***************
*** 1164,1170 ****
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
--- 1172,1178 ----
  	channel->ch_part[PART_ERR].ch_mode = opt->jo_err_mode;
  
      if (opt->jo_set & JO_TIMEOUT)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    channel->ch_part[part].ch_timeout = opt->jo_timeout;
      if (opt->jo_set & JO_OUT_TIMEOUT)
  	channel->ch_part[PART_OUT].ch_timeout = opt->jo_out_timeout;
***************
*** 1282,1288 ****
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	int	    part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
--- 1290,1296 ----
      void
  channel_set_req_callback(
  	channel_T   *channel,
! 	ch_part_T   part,
  	char_u	    *callback,
  	partial_T   *partial,
  	int	    id)
***************
*** 1448,1454 ****
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	may_close_part(&channel->CH_IN_FD);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
--- 1456,1462 ----
  	ch_log(channel, "Finished writing all lines to channel");
  
  	/* Close the pipe/socket, so that the other side gets EOF. */
! 	ch_close_part(channel, PART_IN);
      }
      else
  	ch_logn(channel, "Still %d more lines to write",
***************
*** 1462,1471 ****
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part <= PART_IN; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
--- 1470,1479 ----
  channel_buffer_free(buf_T *buf)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
! 	for (part = PART_SOCK; part < PART_COUNT; ++part)
  	{
  	    chanpart_T  *ch_part = &channel->ch_part[part];
  
***************
*** 1574,1580 ****
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
--- 1582,1588 ----
   * Returns NULL if there is nothing.
   */
      readq_T *
! channel_peek(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
  
***************
*** 1604,1610 ****
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1612,1618 ----
   * Returns NULL if there is nothing.
   */
      char_u *
! channel_get(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1628,1634 ****
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, int part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1636,1642 ----
   * Replaces NUL bytes with NL.
   */
      static char_u *
! channel_get_all(channel_T *channel, ch_part_T part)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1677,1683 ****
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, int part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1685,1691 ----
   * Caller must check these bytes are available.
   */
      void
! channel_consume(channel_T *channel, ch_part_T part, int len)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1693,1699 ****
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, int part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
--- 1701,1707 ----
   * When "want_nl" is TRUE collapse more buffers until a NL is found.
   */
      int
! channel_collapse(channel_T *channel, ch_part_T part, int want_nl)
  {
      readq_T *head = &channel->ch_part[part].ch_head;
      readq_T *node = head->rq_next;
***************
*** 1753,1759 ****
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, int part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
--- 1761,1767 ----
   * Returns OK or FAIL.
   */
      static int
! channel_save(channel_T *channel, ch_part_T part, char_u *buf, int len,
  						      int prepend, char *lead)
  {
      readq_T *node;
***************
*** 1828,1834 ****
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     int		part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
--- 1836,1842 ----
  channel_fill(js_read_T *reader)
  {
      channel_T	*channel = (channel_T *)reader->js_cookie;
!     ch_part_T	part = reader->js_cookie_arg;
      char_u	*next = channel_get(channel, part);
      int		unused;
      int		len;
***************
*** 1866,1872 ****
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, int part)
  {
      js_read_T	reader;
      typval_T	listtv;
--- 1874,1880 ----
   * Return TRUE if there is more to read.
   */
      static int
! channel_parse_json(channel_T *channel, ch_part_T part)
  {
      js_read_T	reader;
      typval_T	listtv;
***************
*** 2046,2052 ****
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, int part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
--- 2054,2060 ----
   * Return FAIL otherwise.
   */
      static int
! channel_get_json(channel_T *channel, ch_part_T part, int id, typval_T **rettv)
  {
      jsonq_T   *head = &channel->ch_part[part].ch_json_head;
      jsonq_T   *item = head->jq_next;
***************
*** 2080,2086 ****
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, int part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
--- 2088,2094 ----
   * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
   */
      static void
! channel_exe_cmd(channel_T *channel, ch_part_T part, typval_T *argv)
  {
      char_u  *cmd = argv[0].vval.v_string;
      char_u  *arg;
***************
*** 2237,2243 ****
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, int part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
--- 2245,2251 ----
  }
  
      static void
! append_to_buffer(buf_T *buffer, char_u *msg, channel_T *channel, ch_part_T part)
  {
      buf_T	*save_curbuf = curbuf;
      linenr_T    lnum = buffer->b_ml.ml_line_count;
***************
*** 2332,2338 ****
  }
  
      static void
! drop_messages(channel_T *channel, int part)
  {
      char_u *msg;
  
--- 2340,2346 ----
  }
  
      static void
! drop_messages(channel_T *channel, ch_part_T part)
  {
      char_u *msg;
  
***************
*** 2349,2355 ****
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, int part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
--- 2357,2363 ----
   * Return TRUE when a message was handled, there might be another one.
   */
      static int
! may_invoke_callback(channel_T *channel, ch_part_T part)
  {
      char_u	*msg = NULL;
      typval_T	*listtv = NULL;
***************
*** 2596,2602 ****
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, int part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
--- 2604,2610 ----
   * Return TRUE if "channel" has JSON or other typeahead.
   */
      static int
! channel_has_readahead(channel_T *channel, ch_part_T part)
  {
      ch_mode_T	ch_mode = channel->ch_part[part].ch_mode;
  
***************
*** 2617,2623 ****
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     int part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
--- 2625,2631 ----
      char *
  channel_status(channel_T *channel, int req_part)
  {
!     ch_part_T part;
      int has_readahead = FALSE;
  
      if (channel == NULL)
***************
*** 2640,2646 ****
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
--- 2648,2654 ----
      {
  	if (channel_is_open(channel))
  	    return "open";
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	    if (channel_has_readahead(channel, part))
  	    {
  		has_readahead = TRUE;
***************
*** 2654,2660 ****
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, int part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
--- 2662,2668 ----
  }
  
      static void
! channel_part_info(channel_T *channel, dict_T *dict, char *name, ch_part_T part)
  {
      chanpart_T *chanpart = &channel->ch_part[part];
      char	namebuf[20];  /* longest is "sock_timeout" */
***************
*** 2736,2763 ****
      channel_gui_unregister(channel);
  #endif
  
!     if (channel->CH_SOCK_FD != INVALID_FD)
!     {
! 	sock_close(channel->CH_SOCK_FD);
! 	channel->CH_SOCK_FD = INVALID_FD;
!     }
!     may_close_part(&channel->CH_IN_FD);
!     may_close_part(&channel->CH_OUT_FD);
!     may_close_part(&channel->CH_ERR_FD);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  int		part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
--- 2744,2767 ----
      channel_gui_unregister(channel);
  #endif
  
!     ch_close_part(channel, PART_SOCK);
!     ch_close_part(channel, PART_IN);
!     ch_close_part(channel, PART_OUT);
!     ch_close_part(channel, PART_ERR);
  
      if (invoke_close_cb && channel->ch_close_cb != NULL)
      {
  	  typval_T	argv[1];
  	  typval_T	rettv;
  	  int		dummy;
! 	  ch_part_T	part;
  
  	  /* Invoke callbacks before the close callback, since it's weird to
  	   * first invoke the close callback.  Increment the refcount to avoid
  	   * the channel being freed halfway. */
  	  ++channel->ch_refcount;
  	  ch_log(channel, "Invoking callbacks before closing");
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      while (may_invoke_callback(channel, part))
  		  ;
  
***************
*** 2789,2795 ****
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part <= PART_ERR; ++part)
  	      drop_messages(channel, part);
      }
  
--- 2793,2799 ----
  	  }
  
  	  /* any remaining messages are useless now */
! 	  for (part = PART_SOCK; part < PART_IN; ++part)
  	      drop_messages(channel, part);
      }
  
***************
*** 2802,2815 ****
      void
  channel_close_in(channel_T *channel)
  {
!     may_close_part(&channel->CH_IN_FD);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, int part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
--- 2806,2819 ----
      void
  channel_close_in(channel_T *channel)
  {
!     ch_close_part(channel, PART_IN);
  }
  
  /*
   * Clear the read buffer on "channel"/"part".
   */
      static void
! channel_clear_one(channel_T *channel, ch_part_T part)
  {
      jsonq_T *json_head = &channel->ch_part[part].ch_json_head;
      cbq_T   *cb_head = &channel->ch_part[part].ch_cb_head;
***************
*** 3043,3053 ****
  }
  
      static void
! channel_close_on_error(channel_T *channel, char *func)
  {
!     /* Do not call emsg(), most likely the other end just exited. */
!     ch_errors(channel, "%s(): Cannot read from channel, will close it soon",
! 									func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
--- 3047,3066 ----
  }
  
      static void
! ch_close_part_on_error(
! 	channel_T *channel, ch_part_T part, int is_err, char *func)
  {
!     char	msgbuf[80];
! 
!     vim_snprintf(msgbuf, sizeof(msgbuf),
! 	    "%%s(): Read %s from ch_part[%d], closing",
! 					    (is_err ? "error" : "EOF"), part);
! 
!     if (is_err)
! 	/* Do not call emsg(), most likely the other end just exited. */
! 	ch_errors(channel, msgbuf, func);
!     else
! 	ch_logs(channel, msgbuf, func);
  
      /* Queue a "DETACH" netbeans message in the command queue in order to
       * terminate the netbeans session later. Do not end the session here
***************
*** 3064,3084 ****
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading from stdout is not possible, assume the other side has
!      * died.  Don't close the channel right away, it may be the wrong moment
!      * to invoke callbacks. */
!     channel->ch_to_be_closed = TRUE;
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister(channel);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because of previous read error");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
--- 3077,3096 ----
  	channel_save(channel, PART_SOCK, (char_u *)DETACH_MSG_RAW,
  			      (int)STRLEN(DETACH_MSG_RAW), FALSE, "PUT ");
  
!     /* When reading is not possible close this part of the channel.  Don't
!      * close the channel yet, there may be something to read on another part. */
!     ch_close_part(channel, part);
  
  #ifdef FEAT_GUI
      /* Stop listening to GUI events right away. */
!     channel_gui_unregister_one(channel, part);
  #endif
  }
  
      static void
  channel_close_now(channel_T *channel)
  {
!     ch_log(channel, "Closing channel because all readable fds are closed");
      channel_close(channel, TRUE);
      if (channel->ch_nb_close_cb != NULL)
  	(*channel->ch_nb_close_cb)();
***************
*** 3090,3096 ****
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, int part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
--- 3102,3108 ----
   * The data is put in the read queue.  No callbacks are invoked here.
   */
      static void
! channel_read(channel_T *channel, ch_part_T part, char *func)
  {
      static char_u	*buf = NULL;
      int			len = 0;
***************
*** 3098,3111 ****
      sock_T		fd;
      int			use_socket = FALSE;
  
-     /* If we detected a read error don't try reading again. */
-     if (channel->ch_to_be_closed)
- 	return;
- 
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_error(channel, "channel_read() called while socket is closed");
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
--- 3110,3120 ----
      sock_T		fd;
      int			use_socket = FALSE;
  
      fd = channel->ch_part[part].ch_fd;
      if (fd == INVALID_FD)
      {
! 	ch_errors(channel, "channel_read() called while %s part is closed",
! 							    part_names[part]);
  	return;
      }
      use_socket = fd == channel->CH_SOCK_FD;
***************
*** 3141,3147 ****
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	channel_close_on_error(channel, func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
--- 3150,3156 ----
  
      /* Reading a disconnection (readlen == 0), or an error. */
      if (readlen <= 0)
! 	ch_close_part_on_error(channel, part, (len < 0), func);
  
  #if defined(CH_HAS_GUI) && defined(FEAT_GUI_GTK)
      /* signal the main loop that there is something to read */
***************
*** 3157,3163 ****
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, int part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
--- 3166,3172 ----
   * Returns NULL in case of error or timeout.
   */
      char_u *
! channel_read_block(channel_T *channel, ch_part_T part, int timeout)
  {
      char_u	*buf;
      char_u	*msg;
***************
*** 3237,3243 ****
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	int	    part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
--- 3246,3252 ----
      int
  channel_read_json_block(
  	channel_T   *channel,
! 	ch_part_T   part,
  	int	    timeout_arg,
  	int	    id,
  	typval_T    **rettv)
***************
*** 3323,3329 ****
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     int		part = -1;
      jobopt_T	opt;
      int		mode;
      int		timeout;
--- 3332,3338 ----
  common_channel_read(typval_T *argvars, typval_T *rettv, int raw)
  {
      channel_T	*channel;
!     ch_part_T	part = PART_COUNT;
      jobopt_T	opt;
      int		mode;
      int		timeout;
***************
*** 3344,3350 ****
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part < 0)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
--- 3353,3359 ----
      channel = get_channel_arg(&argvars[0], TRUE, TRUE, part);
      if (channel != NULL)
      {
! 	if (part == PART_COUNT)
  	    part = channel_part_read(channel);
  	mode = channel_get_mode(channel, part);
  	timeout = channel_get_timeout(channel, part);
***************
*** 3382,3391 ****
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, int *partp)
  {
      channel_T	*channel;
!     int		part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
--- 3391,3400 ----
   * Returns NULL when the socket isn't found.
   */
      channel_T *
! channel_fd2channel(sock_T fd, ch_part_T *partp)
  {
      channel_T	*channel;
!     ch_part_T	part;
  
      if (fd != INVALID_FD)
  	for (channel = first_channel; channel != NULL;
***************
*** 3411,3427 ****
  channel_handle_events(void)
  {
      channel_T	*channel;
!     int		part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
- 	/* If we detected a read error don't try reading again. */
- 	if (channel->ch_to_be_closed)
- 	    continue;
- 
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part <= PART_ERR; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
--- 3420,3432 ----
  channel_handle_events(void)
  {
      channel_T	*channel;
!     ch_part_T	part;
      sock_T	fd;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
  	/* check the socket and pipes */
! 	for (part = PART_SOCK; part < PART_IN; ++part)
  	{
  	    fd = channel->ch_part[part].ch_fd;
  	    if (fd != INVALID_FD)
***************
*** 3431,3437 ****
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    channel_close_on_error(channel, "channel_handle_events()");
  	    }
  	}
      }
--- 3436,3443 ----
  		if (r == CW_READY)
  		    channel_read(channel, part, "channel_handle_events");
  		else if (r == CW_ERROR)
! 		    ch_close_part_on_error(channel, part, TRUE,
! 						     "channel_handle_events");
  	    }
  	}
      }
***************
*** 3444,3450 ****
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
--- 3450,3456 ----
   * Return FAIL or OK.
   */
      int
! channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun)
  {
      int		res;
      sock_T	fd;
***************
*** 3496,3502 ****
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
--- 3502,3508 ----
   * Sets "part_read" to the read fd.
   * Otherwise returns NULL.
   */
!     static channel_T *
  send_common(
  	typval_T    *argvars,
  	char_u	    *text,
***************
*** 3504,3513 ****
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	int	    *part_read)
  {
      channel_T	*channel;
!     int		part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
--- 3510,3519 ----
  	int	    eval,
  	jobopt_T    *opt,
  	char	    *fun,
! 	ch_part_T   *part_read)
  {
      channel_T	*channel;
!     ch_part_T	part_send;
  
      clear_job_options(opt);
      channel = get_channel_arg(&argvars[0], TRUE, FALSE, 0);
***************
*** 3550,3557 ****
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     int		part_send;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3556,3563 ----
      channel_T	*channel;
      int		id;
      ch_mode_T	ch_mode;
!     ch_part_T	part_send;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3610,3616 ****
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     int		part_read;
      jobopt_T    opt;
      int		timeout;
  
--- 3616,3622 ----
      char_u	buf[NUMBUFLEN];
      char_u	*text;
      channel_T	*channel;
!     ch_part_T	part_read;
      jobopt_T    opt;
      int		timeout;
  
***************
*** 3644,3650 ****
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3650,3656 ----
      int		nfd = nfd_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3678,3684 ****
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     int		part;
      int		idx;
      chanpart_T	*in_part;
  
--- 3684,3690 ----
      int		ret = ret_in;
      channel_T	*channel;
      struct	pollfd *fds = fds_in;
!     ch_part_T	part;
      int		idx;
      chanpart_T	*in_part;
  
***************
*** 3725,3731 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
--- 3731,3737 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
      {
***************
*** 3757,3763 ****
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     int		part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
--- 3763,3769 ----
      channel_T	*channel;
      fd_set	*rfds = rfds_in;
      fd_set	*wfds = wfds_in;
!     ch_part_T	part;
      chanpart_T	*in_part;
  
      for (channel = first_channel; channel != NULL; channel = channel->ch_next)
***************
*** 3803,3809 ****
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     int		part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
--- 3809,3815 ----
      channel_T	*channel = first_channel;
      int		ret = FALSE;
      int		r;
!     ch_part_T	part = PART_SOCK;
  
      ++safe_to_invoke_callback;
  
***************
*** 3816,3824 ****
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed)
  	{
! 	    channel->ch_to_be_closed = FALSE;
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
--- 3822,3830 ----
      }
      while (channel != NULL)
      {
! 	if (channel->ch_to_be_closed == 0)
  	{
! 	    channel->ch_to_be_closed = (1 << PART_COUNT);
  	    channel_close_now(channel);
  	    /* channel may have been freed, start over */
  	    channel = first_channel;
***************
*** 3840,3846 ****
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 		|| channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
--- 3846,3852 ----
  	    continue;
  	}
  	if (channel->ch_part[part].ch_fd != INVALID_FD
! 				      || channel_has_readahead(channel, part))
  	{
  	    /* Increase the refcount, in case the handler causes the channel
  	     * to be unreferenced or closed. */
***************
*** 3899,3905 ****
  /*
   * Return the "part" to write to for "channel".
   */
!     int
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3905,3911 ----
  /*
   * Return the "part" to write to for "channel".
   */
!     ch_part_T
  channel_part_send(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3910,3916 ****
  /*
   * Return the default "part" to read from for "channel".
   */
!     int
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
--- 3916,3922 ----
  /*
   * Return the default "part" to read from for "channel".
   */
!     ch_part_T
  channel_part_read(channel_T *channel)
  {
      if (channel->CH_SOCK_FD == INVALID_FD)
***************
*** 3923,3929 ****
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, int part)
  {
      if (channel == NULL)
  	return MODE_JSON;
--- 3929,3935 ----
   * If "channel" is invalid returns MODE_JSON.
   */
      ch_mode_T
! channel_get_mode(channel_T *channel, ch_part_T part)
  {
      if (channel == NULL)
  	return MODE_JSON;
***************
*** 3934,3940 ****
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, int part)
  {
      return channel->ch_part[part].ch_timeout;
  }
--- 3940,3946 ----
   * Return the timeout of "channel"/"part"
   */
      int
! channel_get_timeout(channel_T *channel, ch_part_T part)
  {
      return channel->ch_part[part].ch_timeout;
  }
***************
*** 3962,3968 ****
  }
  
      static int
! handle_io(typval_T *item, int part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
--- 3968,3974 ----
  }
  
      static int
! handle_io(typval_T *item, ch_part_T part, jobopt_T *opt)
  {
      char_u	*val = get_tv_string(item);
  
***************
*** 4045,4051 ****
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     int		part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
--- 4051,4057 ----
      dict_T	*dict;
      int		todo;
      hashitem_T	*hi;
!     ch_part_T	part;
  
      opt->jo_set = 0;
      if (tv->v_type == VAR_UNKNOWN)
***************
*** 4343,4352 ****
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when -1 use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, int part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
--- 4349,4358 ----
   * Returns NULL if the handle is invalid.
   * When "check_open" is TRUE check that the channel can be used.
   * When "reading" is TRUE "check_open" considers typeahead useful.
!  * "part" is used to check typeahead, when PART_COUNT use the default part.
   */
      channel_T *
! get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part)
  {
      channel_T	*channel = NULL;
      int		has_readahead = FALSE;
***************
*** 4367,4373 ****
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 			       part >= 0 ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
--- 4373,4379 ----
      }
      if (channel != NULL && reading)
  	has_readahead = channel_has_readahead(channel,
! 		       part != PART_COUNT ? part : channel_part_read(channel));
  
      if (check_open && (channel == NULL || (!channel_is_open(channel)
  					     && !(reading && has_readahead))))
***************
*** 4659,4665 ****
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     int		part;
  
      job = job_alloc();
      if (job == NULL)
--- 4665,4671 ----
      garray_T	ga;
  #endif
      jobopt_T	opt;
!     ch_part_T	part;
  
      job = job_alloc();
      if (job == NULL)
***************
*** 4679,4685 ****
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part <= PART_IN; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
--- 4685,4691 ----
  	goto theend;
  
      /* Check that when io is "file" that there is a file name. */
!     for (part = PART_OUT; part < PART_COUNT; ++part)
  	if ((opt.jo_set & (JO_OUT_IO << (part - PART_OUT)))
  		&& opt.jo_io[part] == JIO_FILE
  		&& (!(opt.jo_set & (JO_OUT_NAME << (part - PART_OUT)))
*** ../vim-8.0.0026/src/eval.c	2016-09-26 22:58:54.498255420 +0200
--- src/eval.c	2016-10-09 16:54:57.401187760 +0200
***************
*** 5622,5628 ****
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	int	    part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
--- 5622,5628 ----
      else if (tv->v_type == VAR_CHANNEL)
      {
  	channel_T   *ch =tv->vval.v_channel;
! 	ch_part_T   part;
  	typval_T    dtv;
  	jsonq_T	    *jq;
  	cbq_T	    *cq;
***************
*** 5630,5636 ****
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part <= PART_IN; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
--- 5630,5636 ----
  	if (ch != NULL && ch->ch_copyID != copyID)
  	{
  	    ch->ch_copyID = copyID;
! 	    for (part = PART_SOCK; part < PART_COUNT; ++part)
  	    {
  		for (jq = ch->ch_part[part].ch_json_head.jq_next; jq != NULL;
  							     jq = jq->jq_next)
*** ../vim-8.0.0026/src/structs.h	2016-09-07 22:48:11.000000000 +0200
--- src/structs.h	2016-10-09 16:39:57.571448152 +0200
***************
*** 1499,1517 ****
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! #define PART_SOCK   0
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
- 
  #ifdef FEAT_JOB_CHANNEL
! # define INVALID_FD  (-1)
! 
! # define PART_OUT   1
! # define PART_ERR   2
! # define PART_IN    3
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
  
  /* The per-fd info for a channel. */
  typedef struct {
--- 1499,1519 ----
  
  /* Ordering matters, it is used in for loops: IN is last, only SOCK/OUT/ERR
   * are polled. */
! typedef enum {
!     PART_SOCK = 0,
  #define CH_SOCK_FD	ch_part[PART_SOCK].ch_fd
  #ifdef FEAT_JOB_CHANNEL
!     PART_OUT,
  # define CH_OUT_FD	ch_part[PART_OUT].ch_fd
+     PART_ERR,
  # define CH_ERR_FD	ch_part[PART_ERR].ch_fd
+     PART_IN,
  # define CH_IN_FD	ch_part[PART_IN].ch_fd
  #endif
+     PART_COUNT
+ } ch_part_T;
+ 
+ #define INVALID_FD	(-1)
  
  /* The per-fd info for a channel. */
  typedef struct {
***************
*** 1566,1579 ****
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[4];	/* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* When TRUE reading or writing failed and
! 				  * the channel must be closed when it's safe
! 				  * to invoke callbacks. */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
--- 1568,1581 ----
      int		ch_id;		/* ID of the channel */
      int		ch_last_msg_id;	/* ID of the last message */
  
!     chanpart_T	ch_part[PART_COUNT]; /* info for socket, out, err and in */
  
      char	*ch_hostname;	/* only for socket, allocated */
      int		ch_port;	/* only for socket */
  
!     int		ch_to_be_closed; /* bitset of readable fds to be closed.
! 				  * When all readable fds have been closed,
! 				  * set to (1 << PART_COUNT). */
      int		ch_to_be_freed; /* When TRUE channel must be freed when it's
  				 * safe to invoke callbacks. */
      int		ch_error;	/* When TRUE an error was reported.  Avoids
*** ../vim-8.0.0026/src/proto/channel.pro	2016-09-29 15:18:51.351768068 +0200
--- src/proto/channel.pro	2016-10-09 17:00:24.546924836 +0200
***************
*** 14,28 ****
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, int part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, int part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, int part);
! void channel_consume(channel_T *channel, int part, int len);
! int channel_collapse(channel_T *channel, int part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
--- 14,28 ----
  void channel_set_pipes(channel_T *channel, sock_T in, sock_T out, sock_T err);
  void channel_set_job(channel_T *channel, job_T *job, jobopt_T *options);
  void channel_set_options(channel_T *channel, jobopt_T *opt);
! void channel_set_req_callback(channel_T *channel, ch_part_T part, char_u *callback, partial_T *partial, int id);
  void channel_buffer_free(buf_T *buf);
  void channel_write_any_lines(void);
  void channel_write_new_lines(buf_T *buf);
! readq_T *channel_peek(channel_T *channel, ch_part_T part);
  char_u *channel_first_nl(readq_T *node);
! char_u *channel_get(channel_T *channel, ch_part_T part);
! void channel_consume(channel_T *channel, ch_part_T part, int len);
! int channel_collapse(channel_T *channel, ch_part_T part, int want_nl);
  int channel_can_write_to(channel_T *channel);
  int channel_is_open(channel_T *channel);
  char *channel_status(channel_T *channel, int req_part);
***************
*** 31,43 ****
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, int part, int timeout);
! int channel_read_json_block(channel_T *channel, int part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, int *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, int part, char_u *buf, int len, char *fun);
! channel_T *send_common(typval_T *argvars, char_u *text, int id, int eval, jobopt_T *opt, char *fun, int *part_read);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
--- 31,42 ----
  void channel_close_in(channel_T *channel);
  void channel_clear(channel_T *channel);
  void channel_free_all(void);
! char_u *channel_read_block(channel_T *channel, ch_part_T part, int timeout);
! int channel_read_json_block(channel_T *channel, ch_part_T part, int timeout_arg, int id, typval_T **rettv);
  void common_channel_read(typval_T *argvars, typval_T *rettv, int raw);
! channel_T *channel_fd2channel(sock_T fd, ch_part_T *partp);
  void channel_handle_events(void);
! int channel_send(channel_T *channel, ch_part_T part, char_u *buf, int len, char *fun);
  void ch_expr_common(typval_T *argvars, typval_T *rettv, int eval);
  void ch_raw_common(typval_T *argvars, typval_T *rettv, int eval);
  int channel_poll_setup(int nfd_in, void *fds_in);
***************
*** 46,59 ****
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! int channel_part_send(channel_T *channel);
! int channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, int part);
! int channel_get_timeout(channel_T *channel, int part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, int part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
--- 45,58 ----
  int channel_select_check(int ret_in, void *rfds_in, void *wfds_in);
  int channel_parse_messages(void);
  int set_ref_in_channel(int copyID);
! ch_part_T channel_part_send(channel_T *channel);
! ch_part_T channel_part_read(channel_T *channel);
! ch_mode_T channel_get_mode(channel_T *channel, ch_part_T part);
! int channel_get_timeout(channel_T *channel, ch_part_T part);
  void clear_job_options(jobopt_T *opt);
  void free_job_options(jobopt_T *opt);
  int get_job_options(typval_T *tv, jobopt_T *opt, int supported);
! channel_T *get_channel_arg(typval_T *tv, int check_open, int reading, ch_part_T part);
  void job_free_all(void);
  int set_ref_in_job(int copyID);
  void job_unref(job_T *job);
*** ../vim-8.0.0026/src/testdir/test_channel.vim	2016-10-03 21:37:37.619829811 +0200
--- src/testdir/test_channel.vim	2016-10-09 16:28:59.732061278 +0200
***************
*** 1505,1510 ****
--- 1505,1527 ----
    call assert_equal(3, g:linecount)
  endfunc
  
+ func Test_read_from_terminated_job()
+   if !has('job')
+     return
+   endif
+ 
+   let g:linecount = 0
+   if has('win32')
+     " workaround: 'shellescape' does improper escaping double quotes 
+     let arg = 'import os,sys;os.close(1);sys.stderr.write(\"test\n\")'
+   else
+     let arg = 'import os,sys;os.close(1);sys.stderr.write("test\n")'
+   endif
+   call job_start([s:python, '-c', arg], {'callback': 'MyLineCountCb'})
+   call WaitFor('1 <= g:linecount')
+   call assert_equal(1, g:linecount)
+ endfunc
+ 
  function Ch_test_close_lambda(port)
    let handle = ch_open('localhost:' . a:port, s:chopt)
    if ch_status(handle) == "fail"
*** ../vim-8.0.0026/src/version.c	2016-10-09 16:10:02.135942266 +0200
--- src/version.c	2016-10-09 17:01:36.282423622 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     27,
  /**/

-- 
       [Autumn changed into Winter ... Winter changed into Spring ...  Spring
       changed back into Autumn and Autumn gave Winter and Spring a miss and
       went straight on into Summer ...  Until one day ...]
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0028
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0028
Problem:    Superfluous semicolons.
Solution:   Remove them. (Ozaki Kiichi)
Files:      src/ex_cmds2.c


*** ../vim-8.0.0027/src/ex_cmds2.c	2016-09-10 19:01:19.000000000 +0200
--- src/ex_cmds2.c	2016-10-12 12:11:16.417291809 +0200
***************
*** 1093,1103 ****
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000);
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000;
  # endif
  
  /*
--- 1093,1103 ----
  # ifdef WIN3264
  #  define GET_TIMEDIFF(timer, now) \
  	(long)(((double)(timer->tr_due.QuadPart - now.QuadPart) \
! 					   / (double)fr.QuadPart) * 1000)
  # else
  #  define GET_TIMEDIFF(timer, now) \
  	(timer->tr_due.tv_sec - now.tv_sec) * 1000 \
! 			   + (timer->tr_due.tv_usec - now.tv_usec) / 1000
  # endif
  
  /*
*** ../vim-8.0.0027/src/version.c	2016-10-09 17:27:56.863388510 +0200
--- src/version.c	2016-10-12 12:12:25.804801625 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     28,
  /**/

-- 
An indication you must be a manager:
You feel sorry for Dilbert's boss.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0029
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0029
Problem:    Code for MS-Windows is complicated because of the exceptions for
            old systems.
Solution:   Drop support for MS-Windows older than Windows XP. (Ken Takata)
Files:      runtime/doc/gui_w32.txt, runtime/doc/os_win32.txt,
            runtime/doc/todo.txt, src/GvimExt/Makefile, src/Make_mvc.mak,
            src/evalfunc.c, src/ex_cmds.c, src/ex_docmd.c, src/gui_w32.c,
            src/if_cscope.c, src/misc1.c, src/misc2.c, src/option.c,
            src/os_mswin.c, src/os_win32.c, src/os_win32.h,
            src/proto/os_mswin.pro, src/proto/os_win32.pro, src/version.c


*** ../vim-8.0.0028/runtime/doc/gui_w32.txt	2016-09-12 12:45:25.000000000 +0200
--- runtime/doc/gui_w32.txt	2016-10-12 14:00:10.218811720 +0200
***************
*** 49,58 ****
  vimrc or gvimrc file: >
  	au GUIEnter * simalt ~x
  <
- 								*gui-w32s*
- There is a specific version of gvim.exe that runs under the Win32s subsystem
- of Windows 3.1 or 3.11.  See |win32s|.
- 
  
  Using Vim as a plugin					*gui-w32-windowid*
  
--- 49,54 ----
***************
*** 100,108 ****
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
-    Windows 95: %windir%\sendto (e.g. "c:\windows\sendto")
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto").
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
--- 96,105 ----
  You can also install Vim in the "Send To" menu:
  1. Start a Windows Explorer
  2. Navigate to your sendto directory:
     Windows NT: %windir%\profiles\%user%\sendto (e.g.
! 	       "c:\winnt\profiles\mattha\sendto")
!    Windows XP: C:\Documents and Settings\%user%\SendTo
!    Windows Vista: C:\Users\%user%\AppData\Roaming\Microsoft\Windows\SendTo .
  3. Right-click in the file pane and select New->Shortcut
  4. Follow the shortcut wizard, using the full path to VIM/GVIM.
  
***************
*** 274,308 ****
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! In Windows 95, the window in which the commands are executed is always 25x80
! characters, to be as DOS compatible as possible (this matters!).  The default
! system font is used.  On NT, the window will be the default you have set up for
! "Console" in Control Panel.  On Win32s, the properties of the DOS box are
! determined by _default.pif in the windows directory.
! 
! 							*msdos-mode*
! If you get a dialog that says "This program is set to run in MS-DOS mode..."
! when you run an external program, you can solve this by changing the
! properties of the associated shortcut:
! - Use a Windows Explorer to find the command.com that is used.  It can be
!   c:\command.com, c:\dos\command.com, c:\windows\command.com, etc.
! - With the right mouse button, select properties of this command.com.
! - In the Program tab select "Advanced".
! - Unselect "MS-DOS mode".
! - Click "OK" twice.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax on W95 & NT: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
- On Win32s, you will have to go to another window instead.  Don't forget that
- you must tell Windows 3.1x to keep executing a DOS command in the background
- while you switch back to Vim.
- 
  ==============================================================================
  5. Special colors					*win32-colors*
  
--- 271,287 ----
  question if you really want to kill the application, Vim may be killed too!
  (This does not apply to commands run asynchronously with ":!start".)
  
! The window in which the commands are executed will be the default you have set
! up for "Console" in Control Panel.
  
  							*win32-!start*
  Normally, Vim waits for a command to complete before continuing (this makes
  sense for most shell commands which produce output for Vim to use).  If you
  want Vim to start a program and return immediately, you can use the following
! syntax: >
  	:!start [/min] {command}
  The optional "/min" causes the window to be minimized.
  
  ==============================================================================
  5. Special colors					*win32-colors*
  
***************
*** 311,317 ****
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.  Note: On Win32s not all of these colors are supported.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
--- 290,296 ----
  Additionally the system configured colors can also be used.  These are known
  by the names Sys_XXX, where XXX is the appropriate system color name, from the
  following list (see the Win32 documentation for full descriptions).  Case is
! ignored.
  
  Sys_3DDKShadow		Sys_3DFace			Sys_BTNFace
  Sys_3DHilight		Sys_3DHighlight			Sys_BTNHilight
*** ../vim-8.0.0028/runtime/doc/os_win32.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/os_win32.txt	2016-10-12 14:04:26.836987376 +0200
***************
*** 1,4 ****
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Aug 28
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
--- 1,4 ----
! *os_win32.txt*  For Vim version 8.0.  Last change: 2016 Oct 12
  
  
  		  VIM REFERENCE MANUAL    by George Reilly
***************
*** 7,26 ****
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows NT, 95, 98, ME, XP, Vista and
! Windows 7.  There are both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
- There is GUI version for use in the Win32s subsystem in Windows 3.1[1].  You
- can also use the 32-bit DOS version of Vim instead.  See |os_msdos.txt|.
- 
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 3.1	|win32-win3.1|
! 6. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
--- 7,24 ----
  						*win32* *Win32* *MS-Windows*
  This file documents the idiosyncrasies of the Win32 version of Vim.
  
! The Win32 version of Vim works on Windows XP, Vista, 7, 8 and 10.  There are
! both console and GUI versions.
  
  The 32 bit version also runs on 64 bit MS-Windows systems.
  
  1. Known problems		|win32-problems|
  2. Startup			|win32-startup|
  3. Restore screen contents	|win32-restore|
  4. Using the mouse		|win32-mouse|
! 5. Running under Windows 95	|win32-win95|
! 6. Running under Windows 3.1	|win32-win3.1|
! 7. Win32 mini FAQ		|win32-faq|
  
  Additionally, there are a number of common Win32 and DOS items:
  File locations			|dos-locations|
***************
*** 43,62 ****
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems				*windows95* *win32-problems*
! 
! There are a few known problems with running in a console on Windows 95.  As
! far as we know, this is the same in Windows 98 and Windows ME.
! 
! Comments from somebody working at Microsoft: "Win95 console support has always
! been and will always be flaky".
! 1.  Dead key support doesn't work.
! 2.  Resizing the window with ":set columns=nn lines=nn" works, but executing
!     external commands MAY CAUSE THE SYSTEM TO HANG OR CRASH.
! 3.  Screen updating is slow, unless you change 'columns' or 'lines' to a
!     non-DOS value.  But then the second problem applies!
! 
! If this bothers you, use the 32 bit MS-DOS version or the Win32 GUI version.
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
--- 41,47 ----
  For compiling see "src/INSTALLpc.txt".			*win32-compiling*
  
  ==============================================================================
! 1. Known problems					*win32-problems*
  
  When doing file name completion, Vim also finds matches for the short file
  name.  But Vim will still find and use the corresponding long file name.  For
***************
*** 141,200 ****
  the console.
  
  ==============================================================================
! 5. Running under Windows 3.1				*win32-win3.1*
  
! 						*win32s* *windows-3.1*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 6. Win32 mini FAQ					*win32-faq*
! 
! Q. Why does the Win32 version of Vim update the screen so slowly on Windows 95?
! A. The support for Win32 console mode applications is very buggy in Win95.
!    For some unknown reason, the screen updates very slowly when Vim is run at
!    one of the standard resolutions (80x25, 80x43, or 80x50) and the 16-bit DOS
!    version updates the screen much more quickly than the Win32 version.
!    However, if the screen is set to some other resolution, such as by ":set
!    columns=100" or ":set lines=40", screen updating becomes about as fast as
!    it is with the 16-bit version.
! 
!    WARNING: Changing 'columns' may make Windows 95 crash while updating the
!    window (complaints --> Microsoft).  Since this mostly works, this has not
!    been disabled, but be careful with changing 'columns'.
! 
!    Changing the screen resolution makes updates faster, but it brings
!    additional problems.  External commands (e.g., ":!dir") can cause Vim to
!    freeze when the screen is set to a non-standard resolution, particularly
!    when 'columns' is not equal to 80.  It is not possible for Vim to reliably
!    set the screen resolution back to the value it had upon startup before
!    running external commands, so if you change the number of 'lines' or
!    'columns', be very, very careful.  In fact, Vim will not allow you to
!    execute external commands when 'columns' is not equal to 80, because it is
!    so likely to freeze up afterwards.
! 
!    None of the above applies on Windows NT.  Screen updates are fast, no
!    matter how many 'lines' or 'columns' the window has, and external commands
!    do not cause Vim to freeze.
! 
! Q. So if the Win32 version updates the screen so slowly on Windows 95 and the
!    16-bit DOS version updates the screen quickly, why would I want to run the
!    Win32 version?
! A. Firstly, the Win32 version isn't that slow, especially when the screen is
!    set to some non-standard number of 'lines' or 'columns'.  Secondly, the
!    16-bit DOS version has some severe limitations: It can't do big changes and
!    it doesn't know about long file names.  The Win32 version doesn't have these
!    limitations and it's faster overall (the same is true for the 32-bit DJGPP
!    DOS version of Vim).  The Win32 version is smarter about handling the
!    screen, the mouse, and the keyboard than the DJGPP version is.
! 
! Q. And what about the 16-bit DOS version versus the Win32 version on NT?
! A. There are no good reasons to run the 16-bit DOS version on NT.  The Win32
!    version updates the screen just as fast as the 16-bit version does when
!    running on NT.  All of the above disadvantages apply.  Finally, DOS
!    applications can take a long time to start up and will run more slowly.  On
!    non-Intel NT platforms, the DOS version is almost unusably slow, because it
!    runs on top of an 80x86 emulator.
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
--- 126,145 ----
  the console.
  
  ==============================================================================
! 5. Running under Windows 95				*win32-win95*
! 					*windows95* *windows98* *windowsme*
! Windows 95/98/ME support was removed in patch 8.0.0029  If you want to use it
! you will need to get a version older than that.
  
! ==============================================================================
! 6. Running under Windows 3.1				*win32-win3.1*
! 
! 					*win32s* *windows-3.1* *gui-w32s*
  There was a special version of Gvim that runs under Windows 3.1 and 3.11.
  Support was removed in patch 7.4.1363.
  
  ==============================================================================
! 7. Win32 mini FAQ					*win32-faq*
  
  Q. How do I change the font?
  A. In the GUI version, you can use the 'guifont' option.  Example: >
***************
*** 202,248 ****
  <  In the console version, you need to set the font of the console itself.
     You cannot do this from within Vim.
  
- Q. When I change the size of the console window with ':set lines=xx' or
-    similar, the font changes! (Win95)
- A. You have the console font set to 'Auto' in Vim's (or your MS-DOS prompt's)
-    properties.  This makes W95 guess (badly!) what font is best.  Set an explicit
-    font instead.
- 
- Q. Why can't I paste into Vim when running Windows 95?
- A. In the properties dialog box for the MS-DOS window, go to "MS-DOS
-    Prompt/Misc/Fast pasting" and make sure that it is NOT checked.  You should
-    also do ":set paste" in Vim to avoid unexpected effects.	|'paste'|
- 
- Q. How do I type dead keys on Windows 95, in the console version?
-    (A dead key is an accent key, such as acute, grave, or umlaut, that doesn't
-    produce a character by itself, but when followed by another key, produces
-    an accented character, such as a-acute, e-grave, u-umlaut, n-tilde, and so
-    on.  Very useful for most European languages.  English-language keyboard
-    layouts don't use dead keys, as far as we know.)
- A. You don't.  The console mode input routines simply do not work correctly in
-    Windows 95, and I have not been able to work around them.  In the words
-    of a senior developer at Microsoft:
- 	Win95 console support has always been and will always be flaky.
- 
- 	The flakiness is unavoidable because we are stuck between the world of
- 	MS-DOS keyboard TSRs like KEYB (which wants to cook the data;
- 	important for international) and the world of Win32.
- 
- 	So keys that don't "exist" in MS-DOS land (like dead keys) have a
- 	very tenuous existence in Win32 console land.  Keys that act
- 	differently between MS-DOS land and Win32 console land (like
- 	capslock) will act flaky.
- 
- 	Don't even _mention_ the problems with multiple language keyboard
- 	layouts...
- 
-    You may be able to fashion some sort of workaround with the digraphs
-    mechanism.							|digraphs|
- 
-    The best solution is to use the Win32 GUI version gvim.exe.  Alternatively,
-    you can try one of the DOS versions of Vim where dead keys reportedly do
-    work.
- 
  Q. How do I type dead keys on Windows NT?
  A. Dead keys work on NT 3.51.  Just type them as you would in any other
     application.
--- 147,152 ----
***************
*** 349,376 ****
  <  The first command runs notepad minimized and the second one runs it
     normally.
  
- Q. I'm using Win32s, and when I try to run an external command like "make",
-    Vim doesn't wait for it to finish!  Help!
- A. The problem is that a 32-bit application (Vim) can't get notification from
-    Windows that a 16-bit application (your DOS session) has finished.  Vim
-    includes a work-around for this, but you must set up your DOS commands to
-    run in a window, not full-screen.  Unfortunately the default when you
-    install Windows is full-screen.  To change this:
-    1) Start PIF editor (in the Main program group).
-    2) Open the file "_DEFAULT.PIF" in your Windows directory.
-    3) Changes the display option from "Full Screen" to "Windowed".
-    4) Save and exit.
- 
-    To test, start Vim and type >
- 	:!dir C:\<CR>".
- <  You should see a DOS box window appear briefly with the directory listing.
- 
- Q. I use Vim under Win32s and NT.  In NT, I can define the console to default to
-    50 lines, so that I get a 80x50 shell when I ':sh'.  Can I do the same in
-    W3.1x, or am I stuck with 80x25?
- A. Edit SYSTEM.INI and add 'ScreenLines=50' to the [NonWindowsApp] section.  DOS
-    prompts and external DOS commands will now run in a 50-line window.
- 
  						*windows-icon*
  Q. I don't like the Vim icon, can I change it?
  A. Yes, place your favorite icon in bitmaps/vim.ico in a directory of
--- 253,258 ----
*** ../vim-8.0.0028/src/GvimExt/Makefile	2016-02-02 18:48:30.000000000 +0100
--- src/GvimExt/Makefile	2016-10-12 14:00:10.222811692 +0200
***************
*** 3,9 ****
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=BOTH
  !ifndef APPVER
  APPVER=5.0
  !endif
--- 3,9 ----
  #   DEBUG=yes		Build debug version (for VC7 and maybe later)
  #
  
! TARGETOS=WINNT
  !ifndef APPVER
  APPVER=5.0
  !endif
*** ../vim-8.0.0028/src/Make_mvc.mak	2016-09-08 20:25:34.000000000 +0200
--- src/Make_mvc.mak	2016-10-12 14:00:10.222811692 +0200
***************
*** 1,7 ****
! # Makefile for Vim on Win32 (Windows NT/2000/XP/2003 and Windows 95/98/Me)
! # and Win64, using the Microsoft Visual C++ compilers. Known to work with
! # VC5, VC6 (VS98), VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005),
! # VC9 (VS2008), VC10 (VS2010) and VC11 (VS2012)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
--- 1,7 ----
! # Makefile for Vim on Win32 (Windows XP/2003/Vista/7/8/10) and Win64,
! # using the Microsoft Visual C++ compilers. Known to work with VC5, VC6 (VS98),
! # VC7.0 (VS2002), VC7.1 (VS2003), VC8 (VS2005), VC9 (VS2008), VC10 (VS2010),
! # VC11 (VS2012), VC12 (VS2013) and VC14 (VS2015)
  #
  # To build using other Windows compilers, see INSTALLpc.txt
  #
***************
*** 119,125 ****
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 only)
  #
  # You can combine any of these interfaces
  #
--- 119,125 ----
  #	  yes:   Write a normal mapfile.
  #	  lines: Write a mapfile with line numbers (only for VC6 and later)
  #
! #	Static Code Analysis: ANALYZE=yes (works with VS2012 or later)
  #
  # You can combine any of these interfaces
  #
***************
*** 162,170 ****
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on both Windows NT/XP and Windows 9x
  
! TARGETOS = BOTH
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
--- 162,170 ----
  # you can set DEFINES on the command line, e.g.,
  #	nmake -f Make_mvc.mvc "DEFINES=-DEMACS_TAGS"
  
! # Build on Windows NT/XP
  
! TARGETOS = WINNT
  
  # Select one of eight object code directories, depends on GUI, OLE, DEBUG and
  # interfaces.
***************
*** 436,448 ****
  #>>>>> end of choices
  ###########################################################################
  
- !ifdef OS
- OS_TYPE	= winnt
  DEL_TREE = rmdir /s /q
- !else
- OS_TYPE	= win95
- DEL_TREE = deltree /y
- !endif
  
  INTDIR=$(OBJDIR)
  OUTDIR=$(OBJDIR)
--- 436,442 ----
*** ../vim-8.0.0028/src/evalfunc.c	2016-09-26 22:36:50.615386371 +0200
--- src/evalfunc.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 6017,6023 ****
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = mch_windows95();
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
--- 6017,6023 ----
  #endif
  #if defined(WIN3264)
  	else if (STRICMP(name, "win95") == 0)
! 	    n = FALSE;		/* Win9x is no more supported. */
  #endif
  #ifdef FEAT_NETBEANS_INTG
  	else if (STRICMP(name, "netbeans_enabled") == 0)
*** ../vim-8.0.0028/src/ex_cmds.c	2016-09-04 21:08:45.000000000 +0200
--- src/ex_cmds.c	2016-10-12 14:00:10.226811664 +0200
***************
*** 1175,1188 ****
      if (*cmd == NUL)	    /* no filter command */
  	return;
  
- #ifdef WIN3264
-     /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- #endif
- 
      cursor_save = curwin->w_cursor;
      linecount = line2 - line1 + 1;
      curwin->w_cursor.lnum = line1;
--- 1175,1180 ----
***************
*** 1460,1471 ****
  
  #ifdef MSWIN
      /*
-      * Check if external commands are allowed now.
-      */
-     if (can_end_termcap_mode(TRUE) == FALSE)
- 	return;
- 
-     /*
       * Check if ":!start" is used.
       */
      if (cmd != NULL)
--- 1452,1457 ----
*** ../vim-8.0.0028/src/ex_docmd.c	2016-09-29 15:18:51.355768041 +0200
--- src/ex_docmd.c	2016-10-12 14:00:10.230811635 +0200
***************
*** 7611,7624 ****
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted()
! #ifdef WIN3264
! 	/*
! 	 * Check if external commands are allowed now.
! 	 */
! 	&& can_end_termcap_mode(TRUE)
! #endif
! 					)
      {
  	if (!eap->forceit)
  	    autowrite_all();
--- 7611,7617 ----
      /*
       * Disallow suspending for "rvim".
       */
!     if (!check_restricted())
      {
  	if (!eap->forceit)
  	    autowrite_all();
*** ../vim-8.0.0028/src/gui_w32.c	2016-08-29 22:42:20.000000000 +0200
--- src/gui_w32.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 319,325 ****
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
--- 319,325 ----
  #ifdef MSWIN_FIND_REPLACE
  static UINT		s_findrep_msg = 0;	/* set in gui_w[16/32].c */
  static FINDREPLACE	s_findrep_struct;
! # ifdef FEAT_MBYTE
  static FINDREPLACEW	s_findrep_struct_w;
  # endif
  static HWND		s_findrep_hwnd = NULL;
***************
*** 369,375 ****
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
--- 369,375 ----
  # define MyTranslateMessage(x) TranslateMessage(x)
  #endif
  
! #if defined(FEAT_MBYTE) || defined(GLOBAL_IME)
    /* use of WindowProc depends on wide_WindowProc */
  # define MyWindowProc vim_WindowProc
  #else
***************
*** 473,482 ****
  static int	s_timed_out = FALSE;
  static int	dead_key = 0;	/* 0: no dead key, 1: dead key pressed */
  
- #ifdef WIN3264
- static OSVERSIONINFO os_version;    /* like it says.  Init in gui_mch_init() */
- #endif
- 
  #ifdef FEAT_BEVAL
  /* balloon-eval WM_NOTIFY_HANDLER */
  static void Handle_WM_Notify(HWND hwnd, LPNMHDR pnmh);
--- 473,478 ----
***************
*** 695,755 ****
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     if (os_version.dwPlatformId != VER_PLATFORM_WIN32_NT)
!     {
! 	/* On Windows 95/98 we apparently get the character in the active
! 	 * codepage, not in UCS-2.  If conversion is needed convert it to
! 	 * UCS-2 first. */
! 	if ((int)GetACP() == enc_codepage)
! 	    len = 0;	    /* no conversion required */
! 	else
  	{
! 	    string[0] = ch;
! 	    len = MultiByteToWideChar(GetACP(), 0, (LPCSTR)string,
! 		    1, wstring, 2);
  	}
      }
      else
      {
- 	wstring[0] = ch;
  	len = 1;
!     }
! 
!     if (len > 0)
!     {
! 	/* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
! 	 * "enc_codepage" is non-zero use the standard Win32 function,
! 	 * otherwise use our own conversion function (e.g., for UTF-8). */
! 	if (enc_codepage > 0)
! 	{
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 	    /* If we had included the ALT key into the character but now the
! 	     * upper bit is no longer set, that probably means the conversion
! 	     * failed.  Convert the original character and set the upper bit
! 	     * afterwards. */
! 	    if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
! 	    {
! 		wstring[0] = ch & 0x7f;
! 		len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 					       (LPSTR)string, slen, 0, NULL);
! 		if (len == 1) /* safety check */
! 		    string[0] |= 0x80;
! 	    }
! 	}
  	else
  	{
! 	    len = 1;
! 	    ws = utf16_to_enc(wstring, &len);
! 	    if (ws == NULL)
! 		len = 0;
! 	    else
! 	    {
! 		if (len > slen)	/* just in case */
! 		    len = slen;
! 		mch_memmove(string, ws, len);
! 		vim_free(ws);
! 	    }
  	}
      }
  
--- 691,731 ----
      WCHAR	wstring[2];
      char_u	*ws = NULL;
  
!     wstring[0] = ch;
!     len = 1;
! 
!     /* "ch" is a UTF-16 character.  Convert it to a string of bytes.  When
!      * "enc_codepage" is non-zero use the standard Win32 function,
!      * otherwise use our own conversion function (e.g., for UTF-8). */
!     if (enc_codepage > 0)
!     {
! 	len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		(LPSTR)string, slen, 0, NULL);
! 	/* If we had included the ALT key into the character but now the
! 	 * upper bit is no longer set, that probably means the conversion
! 	 * failed.  Convert the original character and set the upper bit
! 	 * afterwards. */
! 	if (had_alt && len == 1 && ch >= 0x80 && string[0] < 0x80)
  	{
! 	    wstring[0] = ch & 0x7f;
! 	    len = WideCharToMultiByte(enc_codepage, 0, wstring, len,
! 		    (LPSTR)string, slen, 0, NULL);
! 	    if (len == 1) /* safety check */
! 		string[0] |= 0x80;
  	}
      }
      else
      {
  	len = 1;
! 	ws = utf16_to_enc(wstring, &len);
! 	if (ws == NULL)
! 	    len = 0;
  	else
  	{
! 	    if (len > slen)	/* just in case */
! 		len = slen;
! 	    mch_memmove(string, ws, len);
! 	    vim_free(ws);
  	}
      }
  
***************
*** 1079,1085 ****
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
--- 1055,1061 ----
  #endif
  
  #ifdef MSWIN_FIND_REPLACE
! # ifdef FEAT_MBYTE
  /*
   * copy useful data from structure LPFINDREPLACE to structure LPFINDREPLACEW
   */
***************
*** 1127,1137 ****
      int	    flags = 0;
      int	    down;
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 			&& enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
--- 1103,1112 ----
      int	    flags = 0;
      int	    down;
  
! # ifdef FEAT_MBYTE
      /* If the OS is Windows NT, and 'encoding' differs from active codepage:
       * convert text from wide string. */
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	findrep_wtoa(&s_findrep_struct, &s_findrep_struct_w);
      }
***************
*** 1279,1285 ****
      }
  }
  
! #if (defined(WIN3264) && defined(FEAT_MBYTE)) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
--- 1254,1260 ----
      }
  }
  
! #if defined(FEAT_MBYTE) \
  	|| defined(GLOBAL_IME) \
  	|| defined(PROTO)
  # ifdef PROTO
***************
*** 1586,1595 ****
  
      static SysColorTable sys_table[] =
      {
- #ifdef WIN3264
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifndef __MINGW32__
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
--- 1561,1569 ----
  
      static SysColorTable sys_table[] =
      {
  	{"SYS_3DDKSHADOW", COLOR_3DDKSHADOW},
  	{"SYS_3DHILIGHT", COLOR_3DHILIGHT},
! #ifdef COLOR_3DHIGHLIGHT
  	{"SYS_3DHIGHLIGHT", COLOR_3DHIGHLIGHT},
  #endif
  	{"SYS_BTNHILIGHT", COLOR_BTNHILIGHT},
***************
*** 1600,1606 ****
  	{"SYS_INFOBK", COLOR_INFOBK},
  	{"SYS_INFOTEXT", COLOR_INFOTEXT},
  	{"SYS_3DFACE", COLOR_3DFACE},
- #endif
  	{"SYS_BTNFACE", COLOR_BTNFACE},
  	{"SYS_BTNSHADOW", COLOR_BTNSHADOW},
  	{"SYS_ACTIVEBORDER", COLOR_ACTIVEBORDER},
--- 1574,1579 ----
***************
*** 2094,2104 ****
  
  	if (s_need_activate)
  	{
- #ifdef WIN32
  	    (void)SetForegroundWindow(s_hwnd);
- #else
- 	    (void)SetActiveWindow(s_hwnd);
- #endif
  	    s_need_activate = FALSE;
  	}
  
--- 2067,2073 ----
***************
*** 2421,2427 ****
  {
  #ifdef FEAT_MBYTE
      WCHAR	*wn = NULL;
-     int		n;
  
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
--- 2390,2395 ----
***************
*** 2438,2448 ****
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    n = InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
- 	    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		/* Failed, try using non-wide function. */
- 		wn = NULL;
  	}
      }
  
--- 2406,2413 ----
  	    infow.fType = MFT_STRING;
  	    infow.dwTypeData = wn;
  	    infow.cch = (UINT)wcslen(wn);
! 	    InsertMenuItemW(pmenu, item_id, FALSE, &infow);
  	    vim_free(wn);
  	}
      }
  
***************
*** 2563,2569 ****
      if (s_tabhwnd == NULL)
  	return;
  
! #if defined(FEAT_MBYTE)
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
--- 2528,2534 ----
      if (s_tabhwnd == NULL)
  	return;
  
! #ifdef FEAT_MBYTE
  # ifndef CCM_SETUNICODEFORMAT
      /* For older compilers.  We assume this never changes. */
  #  define CCM_SETUNICODEFORMAT 0x2005
***************
*** 2708,2725 ****
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
- 	int	n;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    n = SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
- 	    if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 		return;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
--- 2673,2687 ----
      if (title != NULL && enc_codepage >= 0 && enc_codepage != (int)GetACP())
      {
  	WCHAR	*wbuf;
  
  	/* Convert the title from 'encoding' to UTF-16. */
  	wbuf = (WCHAR *)enc_to_utf16((char_u *)title, NULL);
  	if (wbuf != NULL)
  	{
! 	    SetWindowTextW(hwnd, wbuf);
  	    vim_free(wbuf);
  	}
+ 	return;
      }
  #endif
      (void)SetWindowText(hwnd, (LPCSTR)title);
***************
*** 2737,2747 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
--- 2699,2708 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: convert text and use wide function. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = FindTextW(
***************
*** 2774,2782 ****
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # if defined(FEAT_MBYTE) && defined(WIN3264)
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
--- 2735,2742 ----
  	if (!IsWindow(s_findrep_hwnd))
  	{
  	    initialise_findrep(eap->arg);
! # ifdef FEAT_MBYTE
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  		findrep_atow(&s_findrep_struct_w, &s_findrep_struct);
  		s_findrep_hwnd = ReplaceTextW(
***************
*** 3466,3476 ****
      IDC_SIZEWE,			/* leftright */
      IDC_SIZEWE,			/* lrsizing */
      IDC_WAIT,			/* busy */
- #ifdef WIN3264
      IDC_NO,			/* no */
- #else
-     IDC_ICON,			/* no */
- #endif
      IDC_ARROW,			/* crosshair */
      IDC_ARROW,			/* hand1 */
      IDC_ARROW,			/* hand2 */
--- 3426,3432 ----
***************
*** 3497,3507 ****
  #ifdef SetClassLongPtr
  	SetClassLongPtr(s_textArea, GCLP_HCURSOR, (__int3264)(LONG_PTR)LoadCursor(NULL, idc));
  #else
- # ifdef WIN32
  	SetClassLong(s_textArea, GCL_HCURSOR, (long_u)LoadCursor(NULL, idc));
- # else /* Win16 */
- 	SetClassWord(s_textArea, GCW_HCURSOR, (WORD)LoadCursor(NULL, idc));
- # endif
  #endif
  	if (!p_mh)
  	{
--- 3453,3459 ----
***************
*** 3523,3529 ****
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  /*
   * Wide version of convert_filter().
   */
--- 3475,3481 ----
   * Windows NT/2000/XP the "W" functions are used.
   */
  
! # ifdef FEAT_MBYTE
  /*
   * Wide version of convert_filter().
   */
***************
*** 3728,3744 ****
  	char_u *initdir,
  	char_u *filter)
  {
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
- # if defined(FEAT_MBYTE) && defined(WIN3264)
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
- 	return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
- # endif
- 
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
--- 3680,3694 ----
  	char_u *initdir,
  	char_u *filter)
  {
+ # ifdef FEAT_MBYTE
+     return gui_mch_browseW(saving, title, dflt, ext, initdir, filter);
+ # else
      OPENFILENAME	fileStruct;
      char_u		fileBuf[MAXPATHL];
      char_u		*initdirp = NULL;
      char_u		*filterp;
      char_u		*p;
  
      if (dflt == NULL)
  	fileBuf[0] = NUL;
      else
***************
*** 3748,3759 ****
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #else
      fileStruct.lStructSize = sizeof(fileStruct);
! #endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
--- 3698,3709 ----
      filterp = convert_filter(filter);
  
      vim_memset(&fileStruct, 0, sizeof(OPENFILENAME));
! #  ifdef OPENFILENAME_SIZE_VERSION_400
      /* be compatible with Windows NT 4.0 */
      fileStruct.lStructSize = OPENFILENAME_SIZE_VERSION_400;
! #  else
      fileStruct.lStructSize = sizeof(fileStruct);
! #  endif
  
      fileStruct.lpstrTitle = (LPSTR)title;
      fileStruct.lpstrDefExt = (LPSTR)ext;
***************
*** 3783,3792 ****
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
--- 3733,3742 ----
       * Don't use OFN_OVERWRITEPROMPT, Vim has its own ":confirm" dialog.
       */
      fileStruct.Flags = (OFN_NOCHANGEDIR | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY);
! #  ifdef FEAT_SHORTCUT
      if (curbuf->b_p_bin)
  	fileStruct.Flags |= OFN_NODEREFERENCELINKS;
! #  endif
      if (saving)
      {
  	if (!GetSaveFileName(&fileStruct))
***************
*** 3806,3811 ****
--- 3756,3762 ----
  
      /* Shorten the file name if possible */
      return vim_strsave(shorten_fname1((char_u *)fileBuf));
+ # endif
  }
  #endif /* FEAT_BROWSE */
  
***************
*** 3816,3831 ****
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
- #ifdef WIN3264
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! #else
! # define BUFPATHLEN MAXPATHL
! # define DRAGQVAL 0xFFFF
! #endif
! #ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! #endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
--- 3767,3777 ----
      HDROP hDrop)
  {
  #ifdef FEAT_WINDOWS
  # define BUFPATHLEN _MAX_PATH
  # define DRAGQVAL 0xFFFFFFFF
! # ifdef FEAT_MBYTE
      WCHAR   wszFile[BUFPATHLEN];
! # endif
      char    szFile[BUFPATHLEN];
      UINT    cFiles = DragQueryFile(hDrop, DRAGQVAL, NULL, 0);
      UINT    i;
***************
*** 3846,3856 ****
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! #ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! #endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
--- 3792,3802 ----
      if (fnames != NULL)
  	for (i = 0; i < cFiles; ++i)
  	{
! # ifdef FEAT_MBYTE
  	    if (DragQueryFileW(hDrop, i, wszFile, BUFPATHLEN) > 0)
  		fnames[i] = utf16_to_enc(wszFile, NULL);
  	    else
! # endif
  	    {
  		DragQueryFile(hDrop, i, szFile, BUFPATHLEN);
  		fnames[i] = vim_strsave((char_u *)szFile);
***************
*** 3888,3901 ****
      long	val;
      int		dragging = FALSE;
      int		dont_scroll_save = dont_scroll;
- #ifndef WIN3264
-     int		nPos;
- #else
      SCROLLINFO	si;
  
      si.cbSize = sizeof(si);
      si.fMask = SIF_POS;
- #endif
  
      sb = gui_mswin_find_scrollbar(hwndCtl);
      if (sb == NULL)
--- 3834,3843 ----
***************
*** 3960,3972 ****
      }
      prev_code = code;
  
- #ifdef WIN3264
      si.nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
      SetScrollInfo(hwndCtl, SB_CTL, &si, TRUE);
- #else
-     nPos = (sb->scroll_shift > 0) ? val >> sb->scroll_shift : val;
-     SetScrollPos(hwndCtl, SB_CTL, nPos, TRUE);
- #endif
  
      /*
       * When moving a vertical scrollbar, move the other vertical scrollbar too.
--- 3902,3909 ----
***************
*** 3976,3986 ****
  	scrollbar_T *sba = sb->wp->w_scrollbars;
  	HWND    id = sba[ (sb == sba + SBAR_LEFT) ? SBAR_RIGHT : SBAR_LEFT].id;
  
- #ifdef WIN3264
  	SetScrollInfo(id, SB_CTL, &si, TRUE);
- #else
- 	SetScrollPos(id, SB_CTL, nPos, TRUE);
- #endif
      }
  
      /* Don't let us be interrupted here by another message. */
--- 3913,3919 ----
***************
*** 4448,4454 ****
  
  /* Intellimouse support */
  static int mouse_scroll_lines = 0;
- static UINT msh_msgmousewheel = 0;
  
  static int	s_usenewlook;	    /* emulate W95/NT4 non-bold dialogs */
  #ifdef FEAT_TOOLBAR
--- 4381,4386 ----
***************
*** 4505,4538 ****
  # define pImmSetConversionStatus  ImmSetConversionStatus
  #endif
  
- /* multi monitor support */
- typedef struct _MONITORINFOstruct
- {
-     DWORD cbSize;
-     RECT rcMonitor;
-     RECT rcWork;
-     DWORD dwFlags;
- } _MONITORINFO;
- 
- typedef HANDLE _HMONITOR;
- typedef _HMONITOR (WINAPI *TMonitorFromWindow)(HWND, DWORD);
- typedef BOOL (WINAPI *TGetMonitorInfo)(_HMONITOR, _MONITORINFO *);
- 
- static TMonitorFromWindow   pMonitorFromWindow = NULL;
- static TGetMonitorInfo	    pGetMonitorInfo = NULL;
- static HANDLE		    user32_lib = NULL;
- /*
-  * Return TRUE when running under Windows NT 3.x or Win32s, both of which have
-  * less fancy GUI APIs.
-  */
-     static int
- is_winnt_3(void)
- {
-     return ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		&& os_version.dwMajorVersion == 3)
- 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32s));
- }
- 
  #ifdef FEAT_MENU
  /*
   * Figure out how high the menu bar is at the moment.
--- 4437,4442 ----
***************
*** 4564,4608 ****
      }
      else
      {
! 	if (is_winnt_3())	/* for NT 3.xx */
  	{
! 	    if (gui.starting)
! 		menu_height = GetSystemMetrics(SM_CYMENU);
! 	    else
! 	    {
! 		RECT r1, r2;
! 		int frameht = GetSystemMetrics(SM_CYFRAME);
! 		int capht = GetSystemMetrics(SM_CYCAPTION);
! 
! 		/* get window rect of s_hwnd
! 		 * get client rect of s_hwnd
! 		 * get cap height
! 		 * subtract from window rect, the sum of client height,
! 		 * (if not maximized)frame thickness, and caption height.
! 		 */
! 		GetWindowRect(s_hwnd, &r1);
! 		GetClientRect(s_hwnd, &r2);
! 		menu_height = r1.bottom - r1.top - (r2.bottom - r2.top
! 				 + 2 * frameht * (!IsZoomed(s_hwnd)) + capht);
! 	    }
! 	}
! 	else			/* win95 and variants (NT 4.0, I guess) */
! 	{
! 	    /*
! 	     * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	     * seem to have been set yet, so menu wraps in default window
! 	     * width which is very narrow.  Instead just return height of a
! 	     * single menu item.  Will still be wrong when the menu really
! 	     * should wrap over more than one line.
! 	     */
! 	    GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	    if (gui.starting)
! 		menu_height = rc1.bottom - rc1.top + 1;
! 	    else
! 	    {
! 		GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 		menu_height = rc2.bottom - rc1.top + 1;
! 	    }
  	}
      }
  
--- 4468,4487 ----
      }
      else
      {
! 	/*
! 	 * In case 'lines' is set in _vimrc/_gvimrc window width doesn't
! 	 * seem to have been set yet, so menu wraps in default window
! 	 * width which is very narrow.  Instead just return height of a
! 	 * single menu item.  Will still be wrong when the menu really
! 	 * should wrap over more than one line.
! 	 */
! 	GetMenuItemRect(s_hwnd, s_menuBar, 0, &rc1);
! 	if (gui.starting)
! 	    menu_height = rc1.bottom - rc1.top + 1;
! 	else
  	{
! 	    GetMenuItemRect(s_hwnd, s_menuBar, num - 1, &rc2);
! 	    menu_height = rc2.bottom - rc1.top + 1;
  	}
      }
  
***************
*** 4636,4677 ****
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
-     HWND hdl_mswheel;
-     UINT msh_msgscrolllines;
- 
-     msh_msgmousewheel = 0;
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     if ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion >= 4)
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 		&& ((os_version.dwMajorVersion == 4
! 			&& os_version.dwMinorVersion >= 10)
! 		    || os_version.dwMajorVersion >= 5)))
!     {
! 	/* if NT 4.0+ (or Win98) get scroll lines directly from system */
! 	SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 		&mouse_scroll_lines, 0);
!     }
!     else if (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
! 	    || (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		&& os_version.dwMajorVersion < 4))
!     {	/*
! 	 * If Win95 or NT 3.51,
! 	 * try to find the hidden point32 window.
! 	 */
! 	hdl_mswheel = FindWindow(VMOUSEZ_CLASSNAME, VMOUSEZ_TITLE);
! 	if (hdl_mswheel)
! 	{
! 	    msh_msgscrolllines = RegisterWindowMessage(VMSH_SCROLL_LINES);
! 	    if (msh_msgscrolllines)
! 	    {
! 		mouse_scroll_lines = (int)SendMessage(hdl_mswheel,
! 			msh_msgscrolllines, 0, 0);
! 		msh_msgmousewheel  = RegisterWindowMessage(VMSH_MOUSEWHEEL);
! 	    }
! 	}
!     }
  }
  
  
--- 4515,4525 ----
  #define VMSH_MOUSEWHEEL    "MSWHEEL_ROLLMSG"
  #define VMSH_SCROLL_LINES  "MSH_SCROLL_LINES_MSG"
  
      mouse_scroll_lines = 3;	/* reasonable default */
  
!     /* if NT 4.0+ (or Win98) get scroll lines directly from system */
!     SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0,
! 	    &mouse_scroll_lines, 0);
  }
  
  
***************
*** 5210,5222 ****
  #endif
  
      default:
- 	if (uMsg == msh_msgmousewheel && msh_msgmousewheel != 0)
- 	{   /* handle MSH_MOUSEWHEEL messages for Intellimouse */
- 	    _OnMouseWheel(hwnd, HIWORD(wParam));
- 	    return 0L;
- 	}
  #ifdef MSWIN_FIND_REPLACE
! 	else if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
--- 5058,5065 ----
  #endif
  
      default:
  #ifdef MSWIN_FIND_REPLACE
! 	if (uMsg == s_findrep_msg && s_findrep_msg != 0)
  	{
  	    _OnFindRepl();
  	}
***************
*** 5376,5417 ****
  	    }
      }
  #endif
- 
-     /* get the OS version info */
-     os_version.dwOSVersionInfoSize = sizeof(os_version);
-     GetVersionEx(&os_version); /* this call works on Win32s, Win95 and WinNT */
- 
-     /* try and load the user32.dll library and get the entry points for
-      * multi-monitor-support. */
-     if ((user32_lib = vimLoadLib("User32.dll")) != NULL)
-     {
- 	pMonitorFromWindow = (TMonitorFromWindow)GetProcAddress(user32_lib,
- 							 "MonitorFromWindow");
- 
- 	/* there are ...A and ...W version of GetMonitorInfo - looking at
- 	 * winuser.h, they have exactly the same declaration. */
- 	pGetMonitorInfo = (TGetMonitorInfo)GetProcAddress(user32_lib,
- 							  "GetMonitorInfoA");
-     }
- 
- #ifdef FEAT_MBYTE
-     /* If the OS is Windows NT, use wide functions;
-      * this enables common dialogs input unicode from IME. */
-     if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT)
-     {
- 	pDispatchMessage = DispatchMessageW;
- 	pGetMessage = GetMessageW;
- 	pIsDialogMessage = IsDialogMessageW;
- 	pPeekMessage = PeekMessageW;
-     }
-     else
-     {
- 	pDispatchMessage = DispatchMessageA;
- 	pGetMessage = GetMessageA;
- 	pIsDialogMessage = IsDialogMessageA;
- 	pPeekMessage = PeekMessageA;
-     }
- #endif
  }
  
  /*
--- 5219,5224 ----
***************
*** 5475,5486 ****
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	{
! 	    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return FAIL;
! 
! 	    /* Must be Windows 98, fall back to non-wide function. */
! 	}
  	else
  	    wide_WindowProc = TRUE;
      }
--- 5282,5288 ----
  		    atom =
  #endif
  		    RegisterClassW(&wndclassw)) == 0)
! 	    return FAIL;
  	else
  	    wide_WindowProc = TRUE;
      }
***************
*** 5710,5716 ****
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # if defined(FEAT_MBYTE) && defined(WIN3264)
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
--- 5512,5518 ----
      s_findrep_struct.lpstrReplaceWith[0] = NUL;
      s_findrep_struct.wFindWhatLen = MSWIN_FR_BUFSIZE;
      s_findrep_struct.wReplaceWithLen = MSWIN_FR_BUFSIZE;
! # ifdef FEAT_MBYTE
      s_findrep_struct_w.lStructSize = sizeof(s_findrep_struct_w);
      s_findrep_struct_w.lpstrFindWhat =
  			      (LPWSTR)alloc(MSWIN_FR_BUFSIZE * sizeof(WCHAR));
***************
*** 5753,5774 ****
      static void
  get_work_area(RECT *spi_rect)
  {
!     _HMONITOR	    mon;
!     _MONITORINFO    moninfo;
  
!     /* use these functions only if available */
!     if (pMonitorFromWindow != NULL && pGetMonitorInfo != NULL)
      {
! 	/* work out which monitor the window is on, and get *it's* work area */
! 	mon = pMonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
! 	if (mon != NULL)
  	{
! 	    moninfo.cbSize = sizeof(_MONITORINFO);
! 	    if (pGetMonitorInfo(mon, &moninfo))
! 	    {
! 		*spi_rect = moninfo.rcWork;
! 		return;
! 	    }
  	}
      }
      /* this is the old method... */
--- 5555,5572 ----
      static void
  get_work_area(RECT *spi_rect)
  {
!     HMONITOR	    mon;
!     MONITORINFO	    moninfo;
  
!     /* work out which monitor the window is on, and get *it's* work area */
!     mon = MonitorFromWindow(s_hwnd, 1 /*MONITOR_DEFAULTTOPRIMARY*/);
!     if (mon != NULL)
      {
! 	moninfo.cbSize = sizeof(MONITORINFO);
! 	if (GetMonitorInfo(mon, &moninfo))
  	{
! 	    *spi_rect = moninfo.rcWork;
! 	    return;
  	}
      }
      /* this is the old method... */
***************
*** 6307,6335 ****
  	CONST INT *padding)
  {
      int		ix;
-     static int	special = -1;
- 
-     if (special == -1)
-     {
- 	/* Check windows version: special treatment is needed if it is NT 5 or
- 	 * Win98 or higher. */
- 	if  ((os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
- 		    && os_version.dwMajorVersion >= 5)
- 		|| (os_version.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS
- 		    && (os_version.dwMajorVersion > 4
- 			|| (os_version.dwMajorVersion == 4
- 			    && os_version.dwMinorVersion > 0))))
- 	    special = 1;
- 	else
- 	    special = 0;
-     }
  
!     if (special)
! 	for (ix = 0; ix < (int)len; ++ix)
! 	    ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					    pcliprect, text + ix, 1, padding);
!     else
! 	ExtTextOut(s_hdc, col, row, foptions, pcliprect, text, len, padding);
  }
  #endif
  
--- 6105,6114 ----
  	CONST INT *padding)
  {
      int		ix;
  
!     for (ix = 0; ix < (int)len; ++ix)
! 	ExtTextOut(s_hdc, col + TEXT_X(ix), row, foptions,
! 					pcliprect, text + ix, 1, padding);
  }
  #endif
  
***************
*** 6718,6780 ****
  
      if (menu_is_menubar(menu->name))
      {
- 	if (is_winnt_3())
- 	{
- 	    InsertMenu((parent == NULL) ? s_menuBar : parent->submenu_id,
- 		    (UINT)pos, MF_POPUP | MF_STRING | MF_BYPOSITION,
- 		    (long_u)menu->submenu_id, (LPCTSTR) menu->name);
- 	}
- 	else
- 	{
  #ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
! 	    int		n;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
! 		/* 'encoding' differs from active codepage: convert menu name
! 		 * and use wide function */
! 		wn = enc_to_utf16(menu->name, NULL);
! 		if (wn != NULL)
! 		{
! 		    MENUITEMINFOW	infow;
  
! 		    infow.cbSize = sizeof(infow);
! 		    infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 							       | MIIM_SUBMENU;
! 		    infow.dwItemData = (long_u)menu;
! 		    infow.wID = menu->id;
! 		    infow.fType = MFT_STRING;
! 		    infow.dwTypeData = wn;
! 		    infow.cch = (UINT)wcslen(wn);
! 		    infow.hSubMenu = menu->submenu_id;
! 		    n = InsertMenuItemW((parent == NULL)
! 					    ? s_menuBar : parent->submenu_id,
! 					    (UINT)pos, TRUE, &infow);
! 		    vim_free(wn);
! 		    if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 			/* Failed, try using non-wide function. */
! 			wn = NULL;
! 		}
  	    }
  
! 	    if (wn == NULL)
  #endif
! 	    {
! 		MENUITEMINFO	info;
  
! 		info.cbSize = sizeof(info);
! 		info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 		info.dwItemData = (long_u)menu;
! 		info.wID = menu->id;
! 		info.fType = MFT_STRING;
! 		info.dwTypeData = (LPTSTR)menu->name;
! 		info.cch = (UINT)STRLEN(menu->name);
! 		info.hSubMenu = menu->submenu_id;
! 		InsertMenuItem((parent == NULL)
! 					? s_menuBar : parent->submenu_id,
! 					(UINT)pos, TRUE, &info);
! 	    }
  	}
      }
  
--- 6497,6546 ----
  
      if (menu_is_menubar(menu->name))
      {
  #ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	{
! 	    /* 'encoding' differs from active codepage: convert menu name
! 	     * and use wide function */
! 	    wn = enc_to_utf16(menu->name, NULL);
! 	    if (wn != NULL)
  	    {
! 		MENUITEMINFOW	infow;
  
! 		infow.cbSize = sizeof(infow);
! 		infow.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID
! 		    | MIIM_SUBMENU;
! 		infow.dwItemData = (long_u)menu;
! 		infow.wID = menu->id;
! 		infow.fType = MFT_STRING;
! 		infow.dwTypeData = wn;
! 		infow.cch = (UINT)wcslen(wn);
! 		infow.hSubMenu = menu->submenu_id;
! 		InsertMenuItemW((parent == NULL)
! 			? s_menuBar : parent->submenu_id,
! 			(UINT)pos, TRUE, &infow);
! 		vim_free(wn);
  	    }
+ 	}
  
! 	if (wn == NULL)
  #endif
! 	{
! 	    MENUITEMINFO	info;
  
! 	    info.cbSize = sizeof(info);
! 	    info.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID | MIIM_SUBMENU;
! 	    info.dwItemData = (long_u)menu;
! 	    info.wID = menu->id;
! 	    info.fType = MFT_STRING;
! 	    info.dwTypeData = (LPTSTR)menu->name;
! 	    info.cch = (UINT)STRLEN(menu->name);
! 	    info.hSubMenu = menu->submenu_id;
! 	    InsertMenuItem((parent == NULL)
! 		    ? s_menuBar : parent->submenu_id,
! 		    (UINT)pos, TRUE, &info);
  	}
      }
  
***************
*** 6890,6896 ****
      {
  #ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
- 	int	n;
  
  	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
--- 6656,6661 ----
***************
*** 6899,6912 ****
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		n = InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
- 		if (n == 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 		    /* Failed, try using non-wide function. */
- 		    wn = NULL;
  	    }
  	}
  	if (wn == NULL)
--- 6664,6674 ----
  	    wn = enc_to_utf16(menu->name, NULL);
  	    if (wn != NULL)
  	    {
! 		InsertMenuW(parent->submenu_id, (UINT)idx,
  			(menu_is_separator(menu->name)
  				 ? MF_SEPARATOR : MF_STRING) | MF_BYPOSITION,
  			(UINT)menu->id, wn);
  		vim_free(wn);
  	    }
  	}
  	if (wn == NULL)
***************
*** 7105,7115 ****
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # if defined(FEAT_MBYTE) && defined(WIN3264)
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (os_version.dwPlatformId == VER_PLATFORM_WIN32_NT
! 		    && enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
--- 6867,6876 ----
  	/* If the edit box exists, copy the string. */
  	if (s_textfield != NULL)
  	{
! # ifdef FEAT_MBYTE
  	    /* If the OS is Windows NT, and 'encoding' differs from active
  	     * codepage: use wide function and convert text. */
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	    {
  	       WCHAR  *wp = (WCHAR *)alloc(IOSIZE * sizeof(WCHAR));
  	       char_u *p;
***************
*** 7866,7903 ****
  
      s_usenewlook = FALSE;
  
-     /*
-      * For NT3.51 and Win32s, we stick with the old look
-      * because it matches everything else.
-      */
-     if (!is_winnt_3())
-     {
  #ifdef USE_SYSMENU_FONT
! 	if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	    hfontTools = CreateFontIndirect(&lfSysmenu);
! 	else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
! 	if (hfontTools)
! 	{
! 	    hdc = GetDC(s_hwnd);
! 	    SelectObject(hdc, hfontTools);
! 	    /*
! 	     * GetTextMetrics() doesn't return the right value in
! 	     * tmAveCharWidth, so we have to figure out the dialog base units
! 	     * ourselves.
! 	     */
! 	    GetTextExtentPoint(hdc,
! 		    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		    52, &size);
! 	    ReleaseDC(s_hwnd, hdc);
! 
! 	    s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	    s_dlgfntheight = (WORD)size.cy;
! 	    s_usenewlook = TRUE;
! 	}
      }
  
      if (!s_usenewlook)
--- 7627,7657 ----
  
      s_usenewlook = FALSE;
  
  #ifdef USE_SYSMENU_FONT
!     if (gui_w32_get_menu_font(&lfSysmenu) == OK)
! 	hfontTools = CreateFontIndirect(&lfSysmenu);
!     else
  #endif
  	hfontTools = CreateFont(-DLG_FONT_POINT_SIZE, 0, 0, 0, 0, 0, 0, 0,
  				0, 0, 0, 0, VARIABLE_PITCH , DLG_FONT_NAME);
  
!     if (hfontTools)
!     {
! 	hdc = GetDC(s_hwnd);
! 	SelectObject(hdc, hfontTools);
! 	/*
! 	 * GetTextMetrics() doesn't return the right value in
! 	 * tmAveCharWidth, so we have to figure out the dialog base units
! 	 * ourselves.
! 	 */
! 	GetTextExtentPoint(hdc,
! 		"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
! 		52, &size);
! 	ReleaseDC(s_hwnd, hdc);
! 
! 	s_dlgfntwidth = (WORD)((size.cx / 26 + 1) / 2);
! 	s_dlgfntheight = (WORD)size.cy;
! 	s_usenewlook = TRUE;
      }
  
      if (!s_usenewlook)
***************
*** 8044,8053 ****
  	dlgwidth = textWidth;
      dlgwidth += 2 * TEAROFF_PADDING_X + TEAROFF_BUTTON_PAD_X;
  
-     /* W95 can't do thin dialogs, they look v. weird! */
-     if (mch_windows95() && dlgwidth < TEAROFF_MIN_WIDTH)
- 	dlgwidth = TEAROFF_MIN_WIDTH;
- 
      /* start to fill in the dlgtemplate information.  addressing by WORDs */
      if (s_usenewlook)
  	lStyle = DS_MODALFRAME | WS_CAPTION| WS_SYSMENU |DS_SETFONT| WS_VISIBLE;
--- 7798,7803 ----
***************
*** 8299,8305 ****
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!is_winnt_3() && !menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
--- 8049,8055 ----
      /*
       * Check user bitmaps first, unless builtin is specified.
       */
!     if (!menu->icon_builtin)
      {
  	char_u fname[MAXPATHL];
  	HANDLE hbitmap = NULL;
***************
*** 8556,8567 ****
      signicon_t	sign, *psign;
      char_u	*ext;
  
-     if (is_winnt_3())
-     {
- 	EMSG(_(e_signdata));
- 	return NULL;
-     }
- 
      sign.hImage = NULL;
      ext = signfile + STRLEN(signfile) - 4; /* get extension */
      if (ext > signfile)
--- 8306,8311 ----
*** ../vim-8.0.0028/src/if_cscope.c	2016-08-29 22:42:20.000000000 +0200
--- src/if_cscope.c	2016-10-12 14:00:10.234811607 +0200
***************
*** 839,852 ****
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # ifdef __BORLANDC__
! #  define OPEN_OH_ARGTYPE long
  # else
! #  if (_MSC_VER >= 1300) || defined(__MINGW32__)
! #   define OPEN_OH_ARGTYPE intptr_t
! #  else
! #   define OPEN_OH_ARGTYPE long
! #  endif
  # endif
  #endif
  
--- 839,848 ----
      HANDLE	stdin_rd, stdout_rd;
      HANDLE	stdout_wr, stdin_wr;
      BOOL	created;
! # if (defined(_MSC_VER) && (_MSC_VER >= 1300)) || defined(__MINGW32__)
! #  define OPEN_OH_ARGTYPE intptr_t
  # else
! #  define OPEN_OH_ARGTYPE long
  # endif
  #endif
  
***************
*** 1427,1437 ****
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     /* On windows 9x GetFileInformationByHandle doesn't work, so skip it */
!     if (!mch_windows95())
      {
- 	switch (win32_fileinfo((char_u *)fname, &bhfi))
- 	{
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
--- 1423,1430 ----
  #ifndef UNIX
      BY_HANDLE_FILE_INFORMATION bhfi;
  
!     switch (win32_fileinfo((char_u *)fname, &bhfi))
      {
  	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
  	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
  	    if (p_csverbose)
***************
*** 1454,1460 ****
  	    if (p_csverbose)
  		(void)EMSG(_("E626: cannot get cscope database information"));
  	    return -1;
- 	}
      }
  #endif
  
--- 1447,1452 ----
***************
*** 1468,1476 ****
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* if not Windows 9x, test index file attributes too */
! 		|| (!mch_windows95()
! 		    && csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
--- 1460,1467 ----
  	    /* compare pathnames first */
  	    && ((fullpathcmp((char_u *)csinfo[j].fname,
  			(char_u *)fname, FALSE) & FPC_SAME)
! 		/* test index file attributes too */
! 		|| (csinfo[j].nVolume == bhfi.dwVolumeSerialNumber
  		    && csinfo[j].nIndexHigh == bhfi.nFileIndexHigh
  		    && csinfo[j].nIndexLow == bhfi.nFileIndexLow))
  #endif
*** ../vim-8.0.0028/src/misc1.c	2016-09-10 15:43:04.000000000 +0200
--- src/misc1.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 9450,9459 ****
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! #ifdef WIN3264
! 	if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	    stoptermcap();
  	out_flush();
      }
  }
--- 9450,9456 ----
  	 * screen (if there are two screens).
  	 */
  	settmode(TMODE_COOK);
! 	stoptermcap();
  	out_flush();
      }
  }
*** ../vim-8.0.0028/src/misc2.c	2016-09-04 20:34:12.000000000 +0200
--- src/misc2.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 1420,1426 ****
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	{
  	    if (*p == '"')
--- 1420,1426 ----
      length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; mb_ptr_adv(p))
      {
! # ifdef WIN32
  	if (!p_ssl)
  	{
  	    if (*p == '"')
***************
*** 1451,1457 ****
  	d = escaped_string;
  
  	/* add opening quote */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1451,1457 ----
  	d = escaped_string;
  
  	/* add opening quote */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
***************
*** 1460,1466 ****
  
  	for (p = string; *p != NUL; )
  	{
! # if defined(WIN32) || defined(DOS)
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
--- 1460,1466 ----
  
  	for (p = string; *p != NUL; )
  	{
! # ifdef WIN32
  	    if (!p_ssl)
  	    {
  		if (*p == '"')
***************
*** 1503,1509 ****
  	}
  
  	/* add terminating quote and finish with a NUL */
! # if defined(WIN32) || defined(DOS)
  	if (!p_ssl)
  	    *d++ = '"';
  	else
--- 1503,1509 ----
  	}
  
  	/* add terminating quote and finish with a NUL */
! # ifdef WIN32
  	if (!p_ssl)
  	    *d++ = '"';
  	else
*** ../vim-8.0.0028/src/option.c	2016-09-12 19:51:07.685659713 +0200
--- src/option.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 22,28 ****
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/help.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
--- 22,28 ----
   * - If it's a list of flags, add some code in do_set(), search for WW_ALL.
   * - When adding an option with expansion (P_EXPAND), but with a different
   *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.
!  * - Add documentation!  One line in doc/quickref.txt, full description in
   *   options.txt, and any other related places.
   * - Add an entry in runtime/optwin.vim.
   * When making changes:
***************
*** 9944,9956 ****
      if (gui.starting)
  	clear_xterm_clip();
  #endif
! #ifdef WIN3264
!     /*
!      * Check if this is allowed now.
!      */
!     if (can_end_termcap_mode(FALSE) == TRUE)
! #endif
! 	stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
--- 9944,9950 ----
      if (gui.starting)
  	clear_xterm_clip();
  #endif
!     stoptermcap();			/* stop termcap mode */
  
      free_termoptions();
  }
*** ../vim-8.0.0028/src/os_mswin.c	2016-08-29 22:42:20.000000000 +0200
--- src/os_mswin.c	2016-10-12 14:00:10.238811579 +0200
***************
*** 38,48 ****
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  ifdef WIN3264
! #   include <winspool.h>
! #  else
! #   include <print.h>
! #  endif
  #  include <commdlg.h>
  #endif
  
--- 38,44 ----
  
  # if defined(FEAT_PRINTER) && !defined(FEAT_POSTSCRIPT)
  #  include <dlgs.h>
! #  include <winspool.h>
  #  include <commdlg.h>
  #endif
  
***************
*** 130,139 ****
  FILE* fdDump = NULL;
  #endif
  
- #ifdef WIN3264
- extern DWORD g_PlatformId;
- #endif
- 
  #ifndef FEAT_GUI_MSWIN
  extern char g_szOrigTitle[];
  #endif
--- 126,131 ----
***************
*** 248,267 ****
  {
      int		i;
  
- #ifdef WIN3264
      PlatformId();
- #endif
  
      /* Init the tables for toupper() and tolower() */
      for (i = 0; i < 256; ++i)
  	toupper_tab[i] = tolower_tab[i] = i;
- #ifdef WIN3264
      CharUpperBuff((LPSTR)toupper_tab, 256);
      CharLowerBuff((LPSTR)tolower_tab, 256);
- #else
-     AnsiUpperBuff((LPSTR)toupper_tab, 256);
-     AnsiLowerBuff((LPSTR)tolower_tab, 256);
- #endif
  }
  
  
--- 240,252 ----
***************
*** 299,312 ****
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
- 	    int	n;
  
  	    if (wp != NULL)
  	    {
! 		n = SetConsoleTitleW(wp);
  		vim_free(wp);
! 		if (n != 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		    return;
  	    }
  	}
  #  endif
--- 284,295 ----
  	{
  	    /* Convert the title from 'encoding' to the active codepage. */
  	    WCHAR	*wp = enc_to_utf16(title, NULL);
  
  	    if (wp != NULL)
  	    {
! 		SetConsoleTitleW(wp);
  		vim_free(wp);
! 		return;
  	    }
  	}
  #  endif
***************
*** 379,390 ****
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 		/* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 		&& g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
! 	   )
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
--- 362,368 ----
  #endif
      {
  #ifdef FEAT_MBYTE
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	{
  	    WCHAR	*wname;
  	    WCHAR	wbuf[MAX_PATH];
***************
*** 641,652 ****
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
--- 619,625 ----
  	}
      }
  #ifdef FEAT_MBYTE
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wp = enc_to_utf16(buf, NULL);
  	int	n;
***************
*** 655,665 ****
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    if (n >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wstat() fails for missing wide functions. */
  	}
      }
  #endif
--- 628,634 ----
  	{
  	    n = wstat_symlink_aware(wp, stp);
  	    vim_free(wp);
! 	    return n;
  	}
      }
  #endif
***************
*** 823,831 ****
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    if (n == 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 792,798 ----
  	{
  	    n = _wchdir(p);
  	    vim_free(p);
! 	    return n;
  	}
      }
  #endif
***************
*** 834,860 ****
  }
  
  
- /*
-  * Switching off termcap mode is only allowed when Columns is 80, otherwise a
-  * crash may result.  It's always allowed on NT or when running the GUI.
-  */
- /*ARGSUSED*/
-     int
- can_end_termcap_mode(
-     int give_msg)
- {
- #ifdef FEAT_GUI_MSWIN
-     return TRUE;	/* GUI starts a new console anyway */
- #else
-     if (g_PlatformId == VER_PLATFORM_WIN32_NT || Columns == 80)
- 	return TRUE;
-     if (give_msg)
- 	msg((char_u *)
- 		_("'columns' is not 80, cannot execute external commands"));
-     return FALSE;
- #endif
- }
- 
  #ifdef FEAT_GUI_MSWIN
  /*
   * return non-zero if a character is available
--- 801,806 ----
***************
*** 887,903 ****
   * and returns an allocated string.
   * Return OK if it worked, FAIL if not.
   */
- # ifdef WIN3264
  typedef LPTSTR (*MYSTRPROCSTR)(LPTSTR);
  typedef LPTSTR (*MYINTPROCSTR)(int);
  typedef int (*MYSTRPROCINT)(LPTSTR);
  typedef int (*MYINTPROCINT)(int);
- # else
- typedef LPSTR (*MYSTRPROCSTR)(LPSTR);
- typedef LPSTR (*MYINTPROCSTR)(int);
- typedef int (*MYSTRPROCINT)(LPSTR);
- typedef int (*MYINTPROCINT)(int);
- # endif
  
  /*
   * Check if a pointer points to a valid NUL terminated string.
--- 833,842 ----
***************
*** 1093,1099 ****
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # if defined(FEAT_TITLE) && defined(WIN3264)
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
--- 1032,1038 ----
  #endif //_DEBUG
  
  #if !defined(FEAT_GUI) || defined(PROTO)
! # ifdef FEAT_TITLE
  extern HWND g_hWnd;	/* This is in os_win32.c. */
  # endif
  
***************
*** 1114,1120 ****
      if (s_hwnd != 0)
  	return;
  
! # if defined(FEAT_TITLE) && defined(WIN3264)
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
--- 1053,1059 ----
      if (s_hwnd != 0)
  	return;
  
! # ifdef FEAT_TITLE
      /* Window handle may have been found by init code (Windows NT only) */
      if (g_hWnd != 0)
      {
***************
*** 1539,1545 ****
  	    )
      {
  	prt_dlg.Flags |= PD_RETURNDEFAULT;
- #ifdef WIN3264
  	/*
  	 * MSDN suggests setting the first parameter to WINSPOOL for
  	 * NT, but NULL appears to work just as well.
--- 1478,1483 ----
***************
*** 1547,1553 ****
  	if (*p_pdev != NUL)
  	    prt_dlg.hDC = CreateDC(NULL, (LPCSTR)p_pdev, NULL, NULL);
  	else
- #endif
  	{
  	    prt_dlg.Flags |= PD_RETURNDEFAULT;
  	    if (PrintDlg(&prt_dlg) == 0)
--- 1485,1490 ----
***************
*** 1593,1602 ****
      mem = (DEVMODE *)GlobalLock(prt_dlg.hDevMode);
      if (mem != NULL)
      {
- #ifdef WIN3264
  	if (mem->dmCopies != 1)
  	    stored_nCopies = mem->dmCopies;
- #endif
  	if ((mem->dmFields & DM_DUPLEX) && (mem->dmDuplex & ~DMDUP_SIMPLEX))
  	    psettings->duplex = TRUE;
  	if ((mem->dmFields & DM_COLOR) && (mem->dmColor & DMCOLOR_COLOR))
--- 1530,1537 ----
***************
*** 1953,1959 ****
  		goto shortcut_end;
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  # endif
      // create a link manager object and request its interface
--- 1888,1894 ----
  		goto shortcut_end;
  	    }
  	}
! 	goto shortcut_end;
      }
  # endif
      // create a link manager object and request its interface
***************
*** 2681,2687 ****
      {"OEM",		OEM_CHARSET},
      {"SHIFTJIS",	SHIFTJIS_CHARSET},
      {"SYMBOL",		SYMBOL_CHARSET},
- #ifdef WIN3264
      {"ARABIC",		ARABIC_CHARSET},
      {"BALTIC",		BALTIC_CHARSET},
      {"EASTEUROPE",	EASTEUROPE_CHARSET},
--- 2616,2621 ----
***************
*** 2693,2702 ****
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! # if (!defined(_MSC_VER) || (_MSC_VER > 1010)) \
! 	&& (!defined(__BORLANDC__) || (__BORLANDC__ > 0x0500))
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
- # endif
  #endif
      {NULL,		0}
  };
--- 2627,2634 ----
      {"RUSSIAN",		RUSSIAN_CHARSET},
      {"THAI",		THAI_CHARSET},
      {"TURKISH",		TURKISH_CHARSET},
! #ifdef VIETNAMESE_CHARSET
      {"VIETNAMESE",	VIETNAMESE_CHARSET},
  #endif
      {NULL,		0}
  };
*** ../vim-8.0.0028/src/os_win32.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_win32.c	2016-10-12 14:00:10.242811549 +0200
***************
*** 141,183 ****
  # define __stdcall /* empty */
  #endif
  
- #ifndef FEAT_GUI_W32
- /* Undocumented API in kernel32.dll needed to work around dead key bug in
-  * console-mode applications in NT 4.0.  If you switch keyboard layouts
-  * in a console app to a layout that includes dead keys and then hit a
-  * dead key, a call to ToAscii will trash the stack.  My thanks to Ian James
-  * and Michael Dietrich for helping me figure out this workaround.
-  */
- 
- /* WINAPI BOOL WINAPI GetConsoleKeyboardLayoutNameA(LPSTR); */
- #ifndef WINAPI
- # define WINAPI __stdcall
- #endif
- #if defined(__BORLANDC__)
- typedef BOOL (__stdcall *PFNGCKLN)(LPSTR);
- #else
- typedef BOOL (WINAPI *PFNGCKLN)(LPSTR);
- #endif
- static PFNGCKLN    s_pfnGetConsoleKeyboardLayoutName = NULL;
- #endif
- 
  #if defined(__BORLANDC__)
  /* Strangely Borland uses a non-standard name. */
  # define wcsicmp(a, b) wcscmpi((a), (b))
  #endif
  
- #ifndef PROTO
- 
- /* Enable common dialogs input unicode from IME if possible. */
- #ifdef FEAT_MBYTE
- LRESULT (WINAPI *pDispatchMessage)(CONST MSG *) = DispatchMessage;
- BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT) = GetMessage;
- BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG) = IsDialogMessage;
- BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT) = PeekMessage;
- #endif
- 
- #endif /* PROTO */
- 
  #ifndef FEAT_GUI_W32
  /* Win32 Console handles for input and output */
  static HANDLE g_hConIn  = INVALID_HANDLE_VALUE;
--- 141,151 ----
***************
*** 430,436 ****
  vimLoadLib(char *name)
  {
      HINSTANCE	dll = NULL;
-     char	old_dir[MAXPATHL];
  
      /* NOTE: Do not use mch_dirname() and mch_chdir() here, they may call
       * vimLoadLib() recursively, which causes a stack overflow. */
--- 398,403 ----
***************
*** 438,444 ****
  	get_exe_name();
      if (exe_path != NULL)
      {
- #ifdef FEAT_MBYTE
  	WCHAR old_dirw[MAXPATHL];
  
  	if (GetCurrentDirectoryW(MAXPATHL, old_dirw) != 0)
--- 405,410 ----
***************
*** 451,468 ****
  	    SetCurrentDirectoryW(old_dirw);
  	    return dll;
  	}
- 	/* Retry with non-wide function (for Windows 98). */
- 	if (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- #endif
- 	    if (GetCurrentDirectory(MAXPATHL, old_dir) != 0)
- 	    {
- 		/* Change directory to where the executable is, both to make
- 		 * sure we find a .dll there and to avoid looking for a .dll
- 		 * in the current directory. */
- 		SetCurrentDirectory((LPCSTR)exe_path);
- 		dll = LoadLibrary(name);
- 		SetCurrentDirectory(old_dir);
- 	    }
      }
      return dll;
  }
--- 417,422 ----
***************
*** 621,658 ****
  # ifndef PROTECTED_DACL_SECURITY_INFORMATION
  #  define PROTECTED_DACL_SECURITY_INFORMATION	0x80000000L
  # endif
- 
- /*
-  * These are needed to dynamically load the ADVAPI DLL, which is not
-  * implemented under Windows 95 (and causes VIM to crash)
-  */
- typedef DWORD (WINAPI *PSNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFO) (LPSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # ifdef FEAT_MBYTE
- typedef DWORD (WINAPI *PSNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID, PSID, PACL, PACL);
- typedef DWORD (WINAPI *PGNSECINFOW) (LPWSTR, SE_OBJECT_TYPE,
- 	SECURITY_INFORMATION, PSID *, PSID *, PACL *, PACL *,
- 	PSECURITY_DESCRIPTOR *);
- # endif
- 
- static HANDLE advapi_lib = NULL;	/* Handle for ADVAPI library */
- static PSNSECINFO pSetNamedSecurityInfo;
- static PGNSECINFO pGetNamedSecurityInfo;
- # ifdef FEAT_MBYTE
- static PSNSECINFOW pSetNamedSecurityInfoW;
- static PGNSECINFOW pGetNamedSecurityInfoW;
- # endif
  #endif
  
- typedef BOOL (WINAPI *PSETHANDLEINFORMATION)(HANDLE, DWORD, DWORD);
- 
- static BOOL allowPiping = FALSE;
- static PSETHANDLEINFORMATION pSetHandleInformation;
- 
  #ifdef HAVE_ACL
  /*
   * Enables or disables the specified privilege.
--- 575,582 ----
***************
*** 712,804 ****
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/*
! 	 * Load the ADVAPI runtime if we are on anything
! 	 * other than Windows 95
! 	 */
! 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	{
! 	    /*
! 	     * do this load.  Problems: Doesn't unload at end of run (this is
! 	     * theoretically okay, since Windows should unload it when VIM
! 	     * terminates).  Should we be using the 'mch_libcall' routines?
! 	     * Seems like a lot of overhead to load/unload ADVAPI32.DLL each
! 	     * time we verify security...
! 	     */
! 	    advapi_lib = vimLoadLib("ADVAPI32.DLL");
! 	    if (advapi_lib != NULL)
! 	    {
! 		pSetNamedSecurityInfo = (PSNSECINFO)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoA");
! 		pGetNamedSecurityInfo = (PGNSECINFO)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoA");
! # ifdef FEAT_MBYTE
! 		pSetNamedSecurityInfoW = (PSNSECINFOW)GetProcAddress(advapi_lib,
! 						      "SetNamedSecurityInfoW");
! 		pGetNamedSecurityInfoW = (PGNSECINFOW)GetProcAddress(advapi_lib,
! 						      "GetNamedSecurityInfoW");
! # endif
! 		if (pSetNamedSecurityInfo == NULL
! 			|| pGetNamedSecurityInfo == NULL
! # ifdef FEAT_MBYTE
! 			|| pSetNamedSecurityInfoW == NULL
! 			|| pGetNamedSecurityInfoW == NULL
! # endif
! 			)
! 		{
! 		    /* If we can't get the function addresses, set advapi_lib
! 		     * to NULL so that we don't use them. */
! 		    FreeLibrary(advapi_lib);
! 		    advapi_lib = NULL;
! 		}
! 		/* Enable privilege for getting or setting SACLs. */
! 		win32_enable_privilege(SE_SECURITY_NAME, TRUE);
! 	    }
! 	}
  #endif
- 	/*
- 	 * If we are on windows NT, try to load the pipe functions, only
- 	 * available from Win2K.
- 	 */
- 	if (g_PlatformId == VER_PLATFORM_WIN32_NT)
- 	{
- 	    HANDLE kernel32 = GetModuleHandle("kernel32");
- 	    pSetHandleInformation = (PSETHANDLEINFORMATION)GetProcAddress(
- 					    kernel32, "SetHandleInformation");
- 
- 	    allowPiping = pSetHandleInformation != NULL;
- 	}
  	done = TRUE;
      }
  }
  
- /*
-  * Return TRUE when running on Windows 95 (or 98 or ME).
-  * Only to be used after mch_init().
-  */
-     int
- mch_windows95(void)
- {
-     return g_PlatformId == VER_PLATFORM_WIN32_WINDOWS;
- }
- 
- #ifdef FEAT_GUI_W32
- /*
-  * Used to work around the "can't do synchronous spawn"
-  * problem on Win32s, without resorting to Universal Thunk.
-  */
- static int old_num_windows;
- static int num_windows;
- 
- /*ARGSUSED*/
-     static BOOL CALLBACK
- win32ssynch_cb(HWND hwnd, LPARAM lparam)
- {
-     num_windows++;
-     return TRUE;
- }
- #endif
- 
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
--- 636,648 ----
  	    win8_or_later = TRUE;
  
  #ifdef HAVE_ACL
! 	/* Enable privilege for getting or setting SACLs. */
! 	win32_enable_privilege(SE_SECURITY_NAME, TRUE);
  #endif
  	done = TRUE;
      }
  }
  
  #ifndef FEAT_GUI_W32
  
  #define SHIFT  (SHIFT_PRESSED)
***************
*** 926,940 ****
  
      vim_memset(abKeystate, 0, sizeof (abKeystate));
  
-     // Should only be non-NULL on NT 4.0
-     if (s_pfnGetConsoleKeyboardLayoutName != NULL)
-     {
- 	CHAR szKLID[KL_NAMELENGTH];
- 
- 	if ((*s_pfnGetConsoleKeyboardLayoutName)(szKLID))
- 	    (void)LoadKeyboardLayout(szKLID, KLF_ACTIVATE);
-     }
- 
      /* Clear any pending dead keys */
      ToUnicode(VK_SPACE, MapVirtualKey(VK_SPACE, 0), abKeystate, awAnsiCode, 2, 0);
  
--- 770,775 ----
***************
*** 1977,1993 ****
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n > 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		if (n == 0)
! 		    return FALSE;
! 		if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		    return FALSE;
! 		if (path != NULL)
! 		    *path = utf16_to_enc(fnamew, NULL);
! 		return TRUE;
! 	    }
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 1812,1824 ----
  	    n = (long)SearchPathW(wnewpath, p, NULL, _MAX_PATH, fnamew, &dumw);
  	    vim_free(wnewpath);
  	    vim_free(p);
! 	    if (n == 0)
! 		return FALSE;
! 	    if (GetFileAttributesW(fnamew) & FILE_ATTRIBUTE_DIRECTORY)
! 		return FALSE;
! 	    if (path != NULL)
! 		*path = utf16_to_enc(fnamew, NULL);
! 	    return TRUE;
  	}
      }
  #endif
***************
*** 2462,2469 ****
      static void
  SaveConsoleTitleAndIcon(void)
  {
-     GETCONSOLEWINDOWPROC GetConsoleWindowProc;
- 
      /* Save the original title. */
      if (!GetConsoleTitle(g_szOrigTitle, sizeof(g_szOrigTitle)))
  	return;
--- 2293,2298 ----
***************
*** 2475,2486 ****
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     if ((GetConsoleWindowProc = (GETCONSOLEWINDOWPROC)
! 	    GetProcAddress(GetModuleHandle("KERNEL32.DLL"),
! 		    "GetConsoleWindow")) != NULL)
!     {
! 	g_hWnd = (*GetConsoleWindowProc)();
!     }
      if (g_hWnd == NULL)
  	return;
  
--- 2304,2310 ----
       * 2000.  On older operating systems, we can't change the window icon
       * anyway.
       */
!     g_hWnd = GetConsoleWindow();
      if (g_hWnd == NULL)
  	return;
  
***************
*** 2589,2599 ****
  #ifdef FEAT_CLIPBOARD
      win_clip_init();
  #endif
- 
-     /* This will be NULL on anything but NT 4.0 */
-     s_pfnGetConsoleKeyboardLayoutName =
- 	(PFNGCKLN) GetProcAddress(GetModuleHandle("kernel32.dll"),
- 				  "GetConsoleKeyboardLayoutNameA");
  }
  
  /*
--- 2413,2418 ----
***************
*** 2775,2783 ****
  	    *porig = c;
  	    ptrue = ptruePrev + wcslen(ptruePrev);
  	}
- 	else if (hFind == INVALID_HANDLE_VALUE
- 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
      }
  
      wcscpy(name, szTrueName);
--- 2594,2599 ----
***************
*** 2836,2842 ****
  		}
  	    }
  	}
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
--- 2652,2658 ----
  		}
  	    }
  	}
! 	return;
      }
  #endif
  
***************
*** 2966,2974 ****
  		return OK;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return FAIL;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (GetUserName(szUserName, &cch))
--- 2782,2787 ----
***************
*** 3008,3016 ****
  		return;
  	    }
  	}
- 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
- 	    return;
- 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      if (!GetComputerName((LPSTR)s, &cch))
--- 2821,2826 ----
***************
*** 3059,3067 ****
  		return OK;
  	    }
  	}
! 	else if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return FAIL;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
--- 2869,2875 ----
  		return OK;
  	    }
  	}
! 	return FAIL;
      }
  #endif
      return (GetCurrentDirectory(len, (LPSTR)buf) != 0 ? OK : FAIL);
***************
*** 3101,3109 ****
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1 && g_PlatformId == VER_PLATFORM_WIN32_NT)
  		return FAIL;
- 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
      if (n == -1)
--- 2909,2916 ----
  	{
  	    n = _wchmod(p, perm);
  	    vim_free(p);
! 	    if (n == -1)
  		return FAIL;
  	}
      }
      if (n == -1)
***************
*** 3251,3268 ****
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind == INVALID_HANDLE_VALUE
! 		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    hFind = FindFirstFile((LPCSTR)name, &findDataA);
! 	    if (hFind != INVALID_HANDLE_VALUE)
! 	    {
! 		fileFlags = findDataA.dwFileAttributes;
! 		reparseTag = findDataA.dwReserved0;
! 	    }
! 	}
! 	else
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
--- 3058,3064 ----
      {
  	hFind = FindFirstFileW(wn, &findDataW);
  	vim_free(wn);
! 	if (hFind != INVALID_HANDLE_VALUE)
  	{
  	    fileFlags = findDataW.dwFileAttributes;
  	    reparseTag = findDataW.dwReserved0;
***************
*** 3321,3327 ****
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    res = FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
--- 3117,3123 ----
      {
  	wn = enc_to_utf16(fname, NULL);
  	if (wn == NULL)
! 	    return FILEINFO_ENC_FAIL;
      }
      if (wn != NULL)
      {
***************
*** 3332,3346 ****
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(wn);
! 	    wn = NULL;
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
--- 3128,3136 ----
  		    OPEN_EXISTING,	/* creation disposition */
  		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
  		    NULL);		/* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)fname,    /* file name */
  		    GENERIC_READ,	    /* access mode */
***************
*** 3359,3367 ****
  	CloseHandle(hFile);
      }
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      return res;
  }
  
--- 3149,3154 ----
***************
*** 3383,3401 ****
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	if (attr < 0 && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	attr = GetFileAttributes((char *)name);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return attr;
  }
  
--- 3170,3181 ----
      if (p != NULL)
      {
  	attr = GetFileAttributesW(p);
! 	vim_free(p);
      }
!     else
  #endif
  	attr = GetFileAttributes((char *)name);
! 
      return attr;
  }
  
***************
*** 3418,3437 ****
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	if (res == FALSE
! 	    && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	{
! 	    /* Retry with non-wide function (for Windows 98). */
! 	    vim_free(p);
! 	    p = NULL;
! 	}
      }
!     if (p == NULL)
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! #ifdef FEAT_MBYTE
!     vim_free(p);
! #endif
      return res ? 0 : -1;
  }
  
--- 3198,3209 ----
      if (p != NULL)
      {
  	res = SetFileAttributesW(p, attrs);
! 	vim_free(p);
      }
!     else
  #endif
  	res = SetFileAttributes((char *)name, attrs);
! 
      return res ? 0 : -1;
  }
  
***************
*** 3539,3565 ****
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
-     {
  	wn = enc_to_utf16(name, NULL);
! 	if (wn != NULL)
! 	{
! 	    hFile = CreateFileW(wn,	/* file name */
! 			GENERIC_WRITE,	/* access mode */
! 			0,		/* share mode */
! 			NULL,		/* security descriptor */
! 			OPEN_EXISTING,	/* creation disposition */
! 			0,		/* file attributes */
! 			NULL);		/* handle to template file */
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
      }
!     if (wn == NULL)
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
--- 3311,3330 ----
  
  #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
  	wn = enc_to_utf16(name, NULL);
! 
!     if (wn != NULL)
!     {
! 	hFile = CreateFileW(wn,		    /* file name */
! 		    GENERIC_WRITE,	    /* access mode */
! 		    0,			    /* share mode */
! 		    NULL,		    /* security descriptor */
! 		    OPEN_EXISTING,	    /* creation disposition */
! 		    0,			    /* file attributes */
! 		    NULL);		    /* handle to template file */
! 	vim_free(wn);
      }
!     else
  #endif
  	hFile = CreateFile((LPCSTR)name,    /* file name */
  		    GENERIC_WRITE,	    /* access mode */
***************
*** 3569,3577 ****
  		    0,			    /* file attributes */
  		    NULL);		    /* handle to template file */
  
- #ifdef FEAT_MBYTE
-     vim_free(wn);
- #endif
      if (hFile == INVALID_HANDLE_VALUE)
  	return NODE_NORMAL;
  
--- 3334,3339 ----
***************
*** 3608,3695 ****
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     /* This only works on Windows NT and 2000. */
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT && advapi_lib != NULL)
      {
- 	p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
- 	if (p != NULL)
- 	{
  # ifdef FEAT_MBYTE
! 	    WCHAR	*wn = NULL;
  
! 	    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 		wn = enc_to_utf16(fname, NULL);
! 	    if (wn != NULL)
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfoW(
! 			    wn,			// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfoW(
! 			    wn,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
! 		vim_free(wn);
  	    }
! 	    else
  # endif
  	    {
! 		/* Try to retrieve the entire security descriptor. */
! 		err = pGetNamedSecurityInfo(
! 			    (LPSTR)fname,	// Abstract filename
! 			    SE_FILE_OBJECT,	// File Object
! 			    OWNER_SECURITY_INFORMATION |
! 			    GROUP_SECURITY_INFORMATION |
! 			    DACL_SECURITY_INFORMATION |
! 			    SACL_SECURITY_INFORMATION,
! 			    &p->pSidOwner,	// Ownership information.
! 			    &p->pSidGroup,	// Group membership.
! 			    &p->pDacl,		// Discretionary information.
! 			    &p->pSacl,		// For auditing purposes.
! 			    &p->pSecurityDescriptor);
! 		if (err == ERROR_ACCESS_DENIED ||
! 			err == ERROR_PRIVILEGE_NOT_HELD)
! 		{
! 		    /* Retrieve only DACL. */
! 		    (void)pGetNamedSecurityInfo(
! 			    (LPSTR)fname,
! 			    SE_FILE_OBJECT,
! 			    DACL_SECURITY_INFORMATION,
! 			    NULL,
! 			    NULL,
! 			    &p->pDacl,
! 			    NULL,
! 			    &p->pSecurityDescriptor);
! 		}
! 		if (p->pSecurityDescriptor == NULL)
! 		{
! 		    mch_free_acl((vim_acl_T)p);
! 		    p = NULL;
! 		}
  	    }
  	}
      }
--- 3370,3453 ----
      struct my_acl   *p = NULL;
      DWORD   err;
  
!     p = (struct my_acl *)alloc_clear((unsigned)sizeof(struct my_acl));
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
! 	WCHAR	*wn = NULL;
  
! 	if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
! 	    wn = enc_to_utf16(fname, NULL);
! 	if (wn != NULL)
! 	{
! 	    /* Try to retrieve the entire security descriptor. */
! 	    err = GetNamedSecurityInfoW(
! 		    wn,			// Abstract filename
! 		    SE_FILE_OBJECT,	// File Object
! 		    OWNER_SECURITY_INFORMATION |
! 		    GROUP_SECURITY_INFORMATION |
! 		    DACL_SECURITY_INFORMATION |
! 		    SACL_SECURITY_INFORMATION,
! 		    &p->pSidOwner,	// Ownership information.
! 		    &p->pSidGroup,	// Group membership.
! 		    &p->pDacl,		// Discretionary information.
! 		    &p->pSacl,		// For auditing purposes.
! 		    &p->pSecurityDescriptor);
! 	    if (err == ERROR_ACCESS_DENIED ||
! 		    err == ERROR_PRIVILEGE_NOT_HELD)
! 	    {
! 		/* Retrieve only DACL. */
! 		(void)GetNamedSecurityInfoW(
! 			wn,
! 			SE_FILE_OBJECT,
! 			DACL_SECURITY_INFORMATION,
! 			NULL,
! 			NULL,
! 			&p->pDacl,
! 			NULL,
! 			&p->pSecurityDescriptor);
! 	    }
! 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
! 	    vim_free(wn);
! 	}
! 	else
  # endif
+ 	{
+ 	    /* Try to retrieve the entire security descriptor. */
+ 	    err = GetNamedSecurityInfo(
+ 		    (LPSTR)fname,	// Abstract filename
+ 		    SE_FILE_OBJECT,	// File Object
+ 		    OWNER_SECURITY_INFORMATION |
+ 		    GROUP_SECURITY_INFORMATION |
+ 		    DACL_SECURITY_INFORMATION |
+ 		    SACL_SECURITY_INFORMATION,
+ 		    &p->pSidOwner,	// Ownership information.
+ 		    &p->pSidGroup,	// Group membership.
+ 		    &p->pDacl,		// Discretionary information.
+ 		    &p->pSacl,		// For auditing purposes.
+ 		    &p->pSecurityDescriptor);
+ 	    if (err == ERROR_ACCESS_DENIED ||
+ 		    err == ERROR_PRIVILEGE_NOT_HELD)
+ 	    {
+ 		/* Retrieve only DACL. */
+ 		(void)GetNamedSecurityInfo(
+ 			(LPSTR)fname,
+ 			SE_FILE_OBJECT,
+ 			DACL_SECURITY_INFORMATION,
+ 			NULL,
+ 			NULL,
+ 			&p->pDacl,
+ 			NULL,
+ 			&p->pSecurityDescriptor);
+ 	    }
+ 	    if (p->pSecurityDescriptor == NULL)
  	    {
! 		mch_free_acl((vim_acl_T)p);
! 		p = NULL;
  	    }
  	}
      }
***************
*** 3733,3739 ****
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL && advapi_lib != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
--- 3491,3497 ----
      struct my_acl   *p = (struct my_acl *)acl;
      SECURITY_INFORMATION    sec_info = 0;
  
!     if (p != NULL)
      {
  # ifdef FEAT_MBYTE
  	WCHAR	*wn = NULL;
***************
*** 3761,3767 ****
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)pSetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3519,3525 ----
  	    wn = enc_to_utf16(fname, NULL);
  	if (wn != NULL)
  	{
! 	    (void)SetNamedSecurityInfoW(
  			wn,			// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 3775,3781 ****
  	else
  # endif
  	{
! 	    (void)pSetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
--- 3533,3539 ----
  	else
  # endif
  	{
! 	    (void)SetNamedSecurityInfo(
  			(LPSTR)fname,		// Abstract filename
  			SE_FILE_OBJECT,		// File Object
  			sec_info,
***************
*** 4076,4082 ****
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #  ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
--- 3834,3840 ----
      STARTUPINFO		*si,
      PROCESS_INFORMATION *pi)
  {
! #ifdef FEAT_MBYTE
      if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  	WCHAR	*wcmd = enc_to_utf16((char_u *)cmd, NULL);
***************
*** 4138,4168 ****
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window, but in
!      * Windows 95 this makes the command MUCH slower.  We can't do it under
!      * Win32s either as it stops the synchronous spawn workaround working.
       * Don't activate the window to keep focus on Vim.
       */
!     if ((options & SHELL_DOOUT) && !mch_windows95())
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
-     /* There is a strange error on Windows 95 when using "c:\command.com".
-      * When the "c:\\" is left out it works OK...? */
-     if (mch_windows95()
- 	    && (STRNICMP(cmd, "c:/command.com", 14) == 0
- 		|| STRNICMP(cmd, "c:\\command.com", 14) == 0))
- 	cmd += 3;
- 
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
-     if (g_PlatformId != VER_PLATFORM_WIN32s)
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
--- 3896,3916 ----
      si.lpTitle = NULL;
      si.dwFlags = STARTF_USESHOWWINDOW;
      /*
!      * It's nicer to run a filter command in a minimized window.
       * Don't activate the window to keep focus on Vim.
       */
!     if (options & SHELL_DOOUT)
  	si.wShowWindow = SW_SHOWMINNOACTIVE;
      else
  	si.wShowWindow = SW_SHOWNORMAL;
      si.cbReserved2 = 0;
      si.lpReserved2 = NULL;
  
      /* Now, run the command */
      vim_create_process(cmd, FALSE,
  	    CREATE_DEFAULT_ERROR_MODE |	CREATE_NEW_CONSOLE, &si, &pi);
  
      /* Wait for the command to terminate before continuing */
      {
  #ifdef FEAT_GUI
  	int	    delay = 1;
***************
*** 4195,4217 ****
  	/* Get the command exit code */
  	GetExitCodeProcess(pi.hProcess, &ret);
      }
-     else
-     {
- 	/*
- 	 * This ugly code is the only quick way of performing
- 	 * a synchronous spawn under Win32s. Yuk.
- 	 */
- 	num_windows = 0;
- 	EnumWindows(win32ssynch_cb, 0);
- 	old_num_windows = num_windows;
- 	do
- 	{
- 	    Sleep(1000);
- 	    num_windows = 0;
- 	    EnumWindows(win32ssynch_cb, 0);
- 	} while (num_windows == old_num_windows);
- 	ret = 0;
-     }
  
      /* Close the handles to the subprocess, so that it goes away */
      CloseHandle(pi.hThread);
--- 3943,3948 ----
***************
*** 4453,4463 ****
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! pSetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
--- 4184,4194 ----
  
      if ( ! CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0)
  	/* Ensure the read handle to the pipe for STDOUT is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0)
  	/* Create a pipe for the child process's STDIN. */
         || ! CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0)
  	/* Ensure the write handle to the pipe for STDIN is not inherited. */
!        || ! SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0) )
      {
  	CloseHandle(g_hChildStd_IN_Rd);
  	CloseHandle(g_hChildStd_IN_Wr);
***************
*** 4707,4713 ****
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (allowPiping && !p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
--- 4438,4444 ----
  mch_system(char *cmd, int options)
  {
      /* if we can pipe and the shelltemp option is off */
!     if (!p_stmp)
  	return mch_system_piped(cmd, options);
      else
  	return mch_system_classic(cmd, options);
***************
*** 4960,4966 ****
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(allowPiping && !p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
--- 4691,4697 ----
  	{
  	    cmdlen = (
  #ifdef FEAT_GUI_W32
! 		(!p_stmp ? 0 : STRLEN(vimrun_path)) +
  #endif
  		STRLEN(p_sh) + STRLEN(p_shcf) + STRLEN(cmd) + 10);
  
***************
*** 4978,4984 ****
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && (!allowPiping || p_stmp))
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
--- 4709,4715 ----
  			    MB_ICONWARNING);
  		    need_vimrun_warning = FALSE;
  		}
! 		if (!s_dont_use_vimrun && p_stmp)
  		    /* Use vimrun to execute the command.  It opens a console
  		     * window, which can be closed without killing Vim. */
  		    vim_snprintf((char *)newcmd, cmdlen, "%s%s%s %s %s",
***************
*** 5002,5009 ****
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun
! 						  || (allowPiping && !p_stmp))
  #endif
  	    )
      {
--- 4733,4739 ----
      /* Print the return value, unless "vimrun" was used. */
      if (x != 0 && !(options & SHELL_SILENT) && !emsg_silent
  #if defined(FEAT_GUI_W32)
! 		&& ((options & SHELL_DOOUT) || s_dont_use_vimrun || !p_stmp)
  #endif
  	    )
      {
***************
*** 5051,5064 ****
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
              vim_free(wn);
-             if (h == INVALID_HANDLE_VALUE
-                           && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
-                 wn = NULL;
          }
      }
      if (wn == NULL)
  # endif
- 
          h = CreateFile((LPCSTR)fname, dwDesiredAccess, dwShareMode,
                       lpSecurityAttributes, dwCreationDisposition,
                       dwFlagsAndAttributes, NULL);
--- 4781,4790 ----
***************
*** 5127,5133 ****
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
--- 4853,4859 ----
      }
      else if (!use_null_for_in &&
  	    (!CreatePipe(&ifd[0], &ifd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ifd[1], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_out)
***************
*** 5145,5151 ****
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
--- 4871,4877 ----
      }
      else if (!use_null_for_out &&
  	    (!CreatePipe(&ofd[0], &ofd[1], &saAttr, 0)
! 	    || !SetHandleInformation(ofd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      if (use_file_for_err)
***************
*** 5163,5169 ****
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !pSetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
--- 4889,4895 ----
      }
      else if (!use_out_for_err && !use_null_for_err &&
  	    (!CreatePipe(&efd[0], &efd[1], &saAttr, 0)
! 	    || !SetHandleInformation(efd[0], HANDLE_FLAG_INHERIT, 0)))
  	goto failed;
  
      si.dwFlags |= STARTF_USESTDHANDLES;
***************
*** 6176,6184 ****
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    if (n == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 		return n;
! 	    /* Retry with non-wide function (for Windows 98). */
  	}
      }
  #endif
--- 5902,5908 ----
  	{
  	    n = DeleteFileW(wn) ? 0 : -1;
  	    vim_free(wn);
! 	    return n;
  	}
      }
  #endif
***************
*** 6203,6209 ****
  
  /* physical RAM to leave for the OS */
  #define WINNT_RESERVE_BYTES     (256*1024*1024)
- #define WIN95_RESERVE_BYTES       (8*1024*1024)
  
  /*
   * How much main memory in KiB that can be used by VIM.
--- 5927,5932 ----
***************
*** 6212,6265 ****
      long_u
  mch_total_mem(int special)
  {
!     PlatformId();
! #if (defined(_MSC_VER) && (WINVER > 0x0400)) || defined(MEMORYSTATUSEX)
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
!     {
! 	MEMORYSTATUSEX  ms;
  
! 	/* Need to use GlobalMemoryStatusEx() when there is more memory than
! 	 * what fits in 32 bits. But it's not always available. */
! 	ms.dwLength = sizeof(MEMORYSTATUSEX);
! 	GlobalMemoryStatusEx(&ms);
! 	if (ms.ullAvailVirtual < ms.ullTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.ullAvailVirtual / 1024);
! 	}
! 	if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
! 	{
! 	    /* Catch old NT box or perverse hardware setup. */
! 	    return (long_u)((ms.ullTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
      }
!     else
! #endif
      {
! 	/* Pre-XP or 95 OS handling. */
! 	MEMORYSTATUS    ms;
! 	long_u		os_reserve_bytes;
! 
! 	ms.dwLength = sizeof(MEMORYSTATUS);
! 	GlobalMemoryStatus(&ms);
! 	if (ms.dwAvailVirtual < ms.dwTotalPhys)
! 	{
! 	    /* Process address space fits in physical RAM, use all of it. */
! 	    return (long_u)(ms.dwAvailVirtual / 1024);
! 	}
! 	os_reserve_bytes = (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    ? WINNT_RESERVE_BYTES
! 	    : WIN95_RESERVE_BYTES;
! 	if (ms.dwTotalPhys <= os_reserve_bytes)
! 	{
! 	    /* Catch old boxes or perverse hardware setup. */
! 	    return (long_u)((ms.dwTotalPhys / 2) / 1024);
! 	}
! 	/* Use physical RAM less reserve for OS + data. */
! 	return (long_u)((ms.dwTotalPhys - os_reserve_bytes) / 1024);
      }
  }
  
  #ifdef FEAT_MBYTE
--- 5935,5959 ----
      long_u
  mch_total_mem(int special)
  {
!     MEMORYSTATUSEX  ms;
  
!     PlatformId();
!     /* Need to use GlobalMemoryStatusEx() when there is more memory than
!      * what fits in 32 bits. But it's not always available. */
!     ms.dwLength = sizeof(MEMORYSTATUSEX);
!     GlobalMemoryStatusEx(&ms);
!     if (ms.ullAvailVirtual < ms.ullTotalPhys)
!     {
! 	/* Process address space fits in physical RAM, use all of it. */
! 	return (long_u)(ms.ullAvailVirtual / 1024);
      }
!     if (ms.ullTotalPhys <= WINNT_RESERVE_BYTES)
      {
! 	/* Catch old NT box or perverse hardware setup. */
! 	return (long_u)((ms.ullTotalPhys / 2) / 1024);
      }
+     /* Use physical RAM less reserve for OS + data. */
+     return (long_u)((ms.ullTotalPhys - WINNT_RESERVE_BYTES) / 1024);
  }
  
  #ifdef FEAT_MBYTE
***************
*** 6276,6291 ****
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     if (!mch_windows95())
!     {
! 	p = wold;
! 	for (i = 0; wold[i] != NUL; ++i)
! 	    if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		    && wold[i + 1] != 0)
! 		p = wold + i + 1;
! 	if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	    return (MoveFileW(wold, wnew) == 0);
!     }
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
--- 5970,5982 ----
      WCHAR	szNewPath[_MAX_PATH + 1];
      HANDLE	hf;
  
!     p = wold;
!     for (i = 0; wold[i] != NUL; ++i)
! 	if ((wold[i] == '/' || wold[i] == '\\' || wold[i] == ':')
! 		&& wold[i + 1] != 0)
! 	    p = wold + i + 1;
!     if ((int)(wold + i - p) < 8 || p[6] != '~')
! 	return (MoveFileW(wold, wnew) == 0);
  
      if (GetFullPathNameW(wnew, _MAX_PATH, szNewPath, &p) == 0 || p == NULL)
  	return -1;
***************
*** 6363,6384 ****
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	if (retval == 0 || GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 	    return retval;
! 	/* Retry with non-wide function (for Windows 98). */
      }
  #endif
  
      /*
!      * No need to play tricks if not running Windows 95, unless the file name
!      * contains a "~" as the seventh character.
       */
!     if (!mch_windows95())
!     {
! 	pszFilePart = (char *)gettail((char_u *)pszOldFile);
! 	if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	    return rename(pszOldFile, pszNewFile);
!     }
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
--- 6054,6070 ----
  	    retval = mch_wrename(wold, wnew);
  	vim_free(wold);
  	vim_free(wnew);
! 	return retval;
      }
  #endif
  
      /*
!      * No need to play tricks unless the file name contains a "~" as the
!      * seventh character.
       */
!     pszFilePart = (char *)gettail((char_u *)pszOldFile);
!     if (STRLEN(pszFilePart) < 8 || pszFilePart[6] != '~')
! 	return rename(pszOldFile, pszNewFile);
  
      /* Get base path of new file name.  Undocumented feature: If pszNewFile is
       * a directory, no error is returned and pszFilePart will be NULL. */
***************
*** 6441,6456 ****
      char *
  default_shell(void)
  {
-     char* psz = NULL;
- 
      PlatformId();
  
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)		/* Windows NT */
! 	psz = "cmd.exe";
!     else if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS) /* Windows 95 */
! 	psz = "command.com";
! 
!     return psz;
  }
  
  /*
--- 6127,6135 ----
      char *
  default_shell(void)
  {
      PlatformId();
  
!     return "cmd.exe";
  }
  
  /*
***************
*** 6496,6513 ****
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		char		    *pch;
--- 6175,6185 ----
  
  		hFile = FindFirstFileW(TempNameW, &d);
  		if (hFile == INVALID_HANDLE_VALUE)
! 		    goto getout;
  		else
  		    (void)FindClose(hFile);
  	    }
! 	    else
  #endif
  	    {
  		char		    *pch;
***************
*** 6537,6554 ****
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		{
! 		    if (GetLastError() != ERROR_CALL_NOT_IMPLEMENTED)
! 			goto getout;
! 
! 		    /* Retry with non-wide function (for Windows 98). */
! 		    vim_free(wn);
! 		    wn = NULL;
! 		}
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    if (wn == NULL)
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
--- 6209,6219 ----
  	    if (wn != NULL)
  	    {
  		if (!GetTempFileNameW(wn, L"VIM", 0, TempNameW))
! 		    goto getout;
  		else
  		    DeleteFileW(TempNameW);
  	    }
! 	    else
  #endif
  	    {
  		if (!GetTempFileName(n, "VIM", 0, TempName))
***************
*** 6565,6581 ****
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
- 	{
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	    if (hFile == INVALID_HANDLE_VALUE
! 			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
! 	    {
! 		/* Retry with non-wide function (for Windows 98). */
! 		vim_free(wn);
! 		wn = NULL;
! 	    }
! 	}
! 	if (wn == NULL)
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
--- 6230,6237 ----
  		| ((p & R_OK) ? GENERIC_READ : 0);
  #ifdef FEAT_MBYTE
  	if (wn != NULL)
  	    hFile = CreateFileW(wn, am, 0, NULL, OPEN_EXISTING, 0, NULL);
! 	else
  #endif
  	    hFile = CreateFile(n, am, 0, NULL, OPEN_EXISTING, 0, NULL);
  	if (hFile == INVALID_HANDLE_VALUE)
***************
*** 6610,6620 ****
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    if (f >= 0 || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 		return f;
! 	    /* Retry with non-wide function (for Windows 98). Can't use
! 	     * GetLastError() here and it's unclear what errno gets set to if
! 	     * the _wopen() fails for missing wide functions. */
  	}
      }
  # endif
--- 6266,6272 ----
  	{
  	    f = _wopen(wn, flags, mode);
  	    vim_free(wn);
! 	    return f;
  	}
      }
  # endif
***************
*** 6638,6649 ****
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage
! # ifdef __BORLANDC__
! 	    /* Wide functions of Borland C 5.5 do not work on Windows 98. */
! 	    && g_PlatformId == VER_PLATFORM_WIN32_NT
! # endif
!        )
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
--- 6290,6296 ----
      WCHAR	*wn, *wm;
      FILE	*f = NULL;
  
!     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
      {
  # if defined(DEBUG) && _MSC_VER >= 1400
  	/* Work around an annoying assertion in the Microsoft debug CRT
***************
*** 6667,6678 ****
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 
! 	if (f != NULL || g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	    return f;
! 	/* Retry with non-wide function (for Windows 98). Can't use
! 	 * GetLastError() here and it's unclear what errno gets set to if
! 	 * the _wfopen() fails for missing wide functions. */
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
--- 6314,6320 ----
  # if defined(DEBUG) && _MSC_VER >= 1400
  	_set_fmode(oldMode);
  # endif
! 	return f;
      }
  
      /* fopen() can open a file which name is longer than _MAX_PATH bytes
***************
*** 6843,6850 ****
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     if (g_PlatformId == VER_PLATFORM_WIN32_NT)
! 	copy_infostreams(from, to);
  #endif
      return 0;
  }
--- 6485,6491 ----
  #ifdef FEAT_MBYTE
      /* File streams only work on Windows NT and later. */
      PlatformId();
!     copy_infostreams(from, to);
  #endif
      return 0;
  }
***************
*** 6856,6862 ****
   */
  
  /* These magic numbers are from the MS header files */
- #define MIN_STACK_WIN9X 17
  #define MIN_STACK_WINNT 2
  
  /*
--- 6497,6502 ----
***************
*** 6876,6885 ****
      DWORD	nPageSize;
      DWORD	dummy;
  
-     /* This code will not work on win32s. */
      PlatformId();
-     if (g_PlatformId == VER_PLATFORM_WIN32s)
- 	return 0;
  
      /* We need to know the system page size. */
      GetSystemInfo(&si);
--- 6516,6522 ----
***************
*** 6895,6923 ****
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + ((g_PlatformId == VER_PLATFORM_WIN32_NT)
! 			     ? MIN_STACK_WINNT : MIN_STACK_WIN9X) * nPageSize;
  
-     /* On Win95, we want the next page down from the end of the stack. */
-     if (g_PlatformId == VER_PLATFORM_WIN32_WINDOWS)
      {
! 	/* Find the page that's only 1 page down from the page that the stack
! 	 * ptr is in. */
! 	pGuardPage = (BYTE*)((DWORD)nPageSize * (((DWORD)pStackPtr
! 						    / (DWORD)nPageSize) - 1));
! 	if (pGuardPage < pLowestPossiblePage)
! 	    return 0;
! 
! 	/* Apply the noaccess attribute to the page -- there's no guard
! 	 * attribute in win95-type OSes. */
! 	if (!VirtualProtect(pGuardPage, nPageSize, PAGE_NOACCESS, &dummy))
! 	    return 0;
!     }
!     else
!     {
! 	/* On NT, however, we want the first committed page in the stack Start
! 	 * at the stack base and move forward through memory until we find a
! 	 * committed block. */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
--- 6532,6543 ----
  
      /* ...and the page thats min_stack_req pages away from stack base; this is
       * the lowest page we could use. */
!     pLowestPossiblePage = pStackBase + MIN_STACK_WINNT * nPageSize;
  
      {
! 	/* We want the first committed page in the stack Start at the stack
! 	 * base and move forward through memory until we find a committed block.
! 	 */
  	BYTE *pBlock = pStackBase;
  
  	for (;;)
*** ../vim-8.0.0028/src/os_win32.h	2016-08-29 22:42:20.000000000 +0200
--- src/os_win32.h	2016-10-12 14:00:10.242811549 +0200
***************
*** 210,229 ****
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
- #ifndef PROTO
- 
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
!     /* The variables are defined in os_win32.c. */
! extern LRESULT (WINAPI *pDispatchMessage)(CONST MSG *);
! extern BOOL (WINAPI *pGetMessage)(LPMSG, HWND, UINT, UINT);
! extern BOOL (WINAPI *pIsDialogMessage)(HWND, LPMSG);
! extern BOOL (WINAPI *pPeekMessage)(LPMSG, HWND, UINT, UINT, UINT);
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
- 
- #endif /* PROTO */
--- 210,224 ----
  # define vim_mkdir(x, y) mch_mkdir(x)
  #endif
  
  /* Enable common dialogs input unicode from IME if possible. */
  #ifdef FEAT_MBYTE
! # define pDispatchMessage DispatchMessageW
! # define pGetMessage GetMessageW
! # define pIsDialogMessage IsDialogMessageW
! # define pPeekMessage PeekMessageW
  #else
  # define pDispatchMessage DispatchMessage
  # define pGetMessage GetMessage
  # define pIsDialogMessage IsDialogMessage
  # define pPeekMessage PeekMessage
  #endif
*** ../vim-8.0.0028/src/proto/os_mswin.pro	2016-09-12 13:04:30.000000000 +0200
--- src/proto/os_mswin.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 19,25 ****
  int mch_has_exp_wildcard(char_u *p);
  int mch_has_wildcard(char_u *p);
  int mch_chdir(char *path);
- int can_end_termcap_mode(int give_msg);
  int mch_screenmode(char_u *arg);
  int mch_icon_load(HANDLE *iconp);
  int mch_libcall(char_u *libname, char_u *funcname, char_u *argstring, int argint, char_u **string_result, int *number_result);
--- 19,24 ----
*** ../vim-8.0.0028/src/proto/os_win32.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_win32.pro	2016-10-12 14:00:10.242811549 +0200
***************
*** 3,9 ****
  int dyn_libintl_init(void);
  void dyn_libintl_end(void);
  void PlatformId(void);
- int mch_windows95(void);
  void mch_setmouse(int on);
  void mch_update_cursor(void);
  int mch_char_avail(void);
--- 3,8 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 962,976 ****
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  if defined(_MSC_VER) && (_MSC_VER <= 1010)
!     /* Only MS VC 4.1 and earlier can do Win32s */
!     MSG_PUTS(_("\nMS-Windows 16/32-bit GUI version"));
! #  else
! #   ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #   else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
- #   endif
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
--- 964,973 ----
      MSG(longVersion);
  #ifdef WIN3264
  # ifdef FEAT_GUI_W32
! #  ifdef _WIN64
      MSG_PUTS(_("\nMS-Windows 64-bit GUI version"));
! #  else
      MSG_PUTS(_("\nMS-Windows 32-bit GUI version"));
  #  endif
  # ifdef FEAT_OLE
      MSG_PUTS(_(" with OLE support"));
***************
*** 1332,1341 ****
      blanklines = (int)Rows - ((sizeof(lines) / sizeof(char *)) - 1);
      if (!p_cp)
  	blanklines += 4;  /* add 4 for not showing "Vi compatible" message */
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
-     if (mch_windows95())
- 	blanklines -= 3;  /* subtract 3 for showing "Windows 95" message */
- #endif
  
  #ifdef FEAT_WINDOWS
      /* Don't overwrite a statusline.  Depends on 'cmdheight'. */
--- 1329,1334 ----
***************
*** 1384,1400 ****
  		do_intro_line(row, (char_u *)_(p), i == 2, 0);
  	    ++row;
  	}
- #if defined(WIN3264) && !defined(FEAT_GUI_W32)
- 	if (mch_windows95())
- 	{
- 	    do_intro_line(++row,
- 		    (char_u *)_("WARNING: Windows 95/98/ME detected"),
- 							FALSE, hl_attr(HLF_E));
- 	    do_intro_line(++row,
- 		(char_u *)_("type  :help windows95<Enter>  for info on this"),
- 								    FALSE, 0);
- 	}
- #endif
      }
  
      /* Make the wait-return message appear just below the text. */
--- 1377,1382 ----
*** ../vim-8.0.0028/src/version.c	2016-10-12 12:13:30.488344697 +0200
--- src/version.c	2016-10-12 14:02:29.605820741 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     29,
  /**/

-- 
Lose weight, NEVER Diet again with
                  The "Invisible Weight Loss Patch"
						(spam e-mail)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0030
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0030
Problem:    Mouse mode is not automatically detected for tmux.
Solution:   Check for 'term' to be "tmux". (Michael Henry)
Files:      src/os_unix.c


*** ../vim-8.0.0029/src/os_unix.c	2016-09-29 15:18:51.359768012 +0200
--- src/os_unix.c	2016-10-12 14:36:03.887453490 +0200
***************
*** 2261,2266 ****
--- 2261,2267 ----
      return (name != NULL
  	    && (term_is_xterm
  		|| STRNICMP(name, "screen", 6) == 0
+ 		|| STRNICMP(name, "tmux", 4) == 0
  		|| STRICMP(name, "st") == 0
  		|| STRNICMP(name, "st-", 3) == 0
  		|| STRNICMP(name, "stterm", 6) == 0));
***************
*** 2324,2329 ****
--- 2325,2331 ----
      return (   STRNICMP(name, "hpterm", 6) == 0
  	    || STRNICMP(name, "sun-cmd", 7) == 0
  	    || STRNICMP(name, "screen", 6) == 0
+ 	    || STRNICMP(name, "tmux", 4) == 0
  	    || STRNICMP(name, "dtterm", 6) == 0);
  }
  
*** ../vim-8.0.0029/src/version.c	2016-10-12 14:19:55.754357695 +0200
--- src/version.c	2016-10-12 14:50:38.049202893 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     30,
  /**/

-- 
Compilation process failed successfully.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0031
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0031
Problem:    After ":bwipeout" 'fileformat' is not set to the right default.
Solution:   Get the default from 'fileformats'. (Mike Williams)
Files:      src/option.c, src/Makefile, src/testdir/test_fileformat.vim,
            src/testdir/test_alot.vim


*** ../vim-8.0.0030/src/option.c	2016-10-12 14:19:55.750357722 +0200
--- src/option.c	2016-10-12 17:36:42.482477038 +0200
***************
*** 10729,10735 ****
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		buf->b_p_ff = vim_strsave(p_ff);
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
--- 10729,10747 ----
  #ifdef FEAT_MBYTE
  		buf->b_p_fenc = vim_strsave(p_fenc);
  #endif
! 		switch (*p_ffs)
! 		{
! 		    case 'm':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_MAC); break;
! 		    case 'd':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_DOS); break;
! 		    case 'u':
! 			buf->b_p_ff = vim_strsave((char_u *)FF_UNIX); break;
! 		    default:
! 			buf->b_p_ff = vim_strsave(p_ff);
! 		}
! 		if (buf->b_p_ff != NULL)
! 		    buf->b_start_ffc = *buf->b_p_ff;
  #if defined(FEAT_QUICKFIX)
  		buf->b_p_bh = empty_option;
  		buf->b_p_bt = empty_option;
*** ../vim-8.0.0030/src/Makefile	2016-09-29 20:54:42.399110777 +0200
--- src/Makefile	2016-10-12 16:24:51.984989904 +0200
***************
*** 2081,2086 ****
--- 2081,2087 ----
  	test_farsi \
  	test_feedkeys \
  	test_file_perm \
+ 	test_fileformat \
  	test_filter_cmd \
  	test_filter_map \
  	test_fnameescape \
*** ../vim-8.0.0030/src/testdir/test_fileformat.vim	2016-10-12 17:43:54.755416077 +0200
--- src/testdir/test_fileformat.vim	2016-10-12 16:29:46.522911119 +0200
***************
*** 0 ****
--- 1,17 ----
+ " Test behavior of fileformat after bwipeout of last buffer
+ 
+ func Test_fileformat_after_bw()
+   bwipeout
+   set fileformat&
+   if &fileformat == 'dos'
+     let test_fileformats = 'unix'
+   elseif &fileformat == 'unix'
+     let test_fileformats = 'mac'
+   else  " must be mac
+     let test_fileformats = 'dos'
+   endif
+   exec 'set fileformats='.test_fileformats
+   bwipeout!
+   call assert_equal(test_fileformats, &fileformat)
+   set fileformats&
+ endfunc
*** ../vim-8.0.0030/src/testdir/test_alot.vim	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/test_alot.vim	2016-10-12 16:24:26.933166652 +0200
***************
*** 12,21 ****
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
- source test_fnamemodify.vim
  source test_file_perm.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
--- 12,22 ----
  source test_expr.vim
  source test_expand_dllpath.vim
  source test_feedkeys.vim
  source test_file_perm.vim
+ source test_fileformat.vim
  source test_filter_cmd.vim
  source test_filter_map.vim
+ source test_fnamemodify.vim
  source test_glob2regpat.vim
  source test_goto.vim
  source test_help_tagjump.vim
*** ../vim-8.0.0030/src/version.c	2016-10-12 14:50:50.233115689 +0200
--- src/version.c	2016-10-12 16:27:46.415758987 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     31,
  /**/

-- 
   Arthur pulls Pin out.  The MONK blesses the grenade as ...
ARTHUR:  (quietly) One, two, five ...
GALAHAD: Three, sir!
ARTHUR:  Three.
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0032
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0032
Problem:    Tests may change the input file when something goes wrong.
Solution:   Avoid writing the input file.
Files:      src/testdir/test51.in, src/testdir/test67.in,
            src/testdir/test97.in, src/testdir/test_tabpage.vim


*** ../vim-8.0.0031/src/testdir/test51.in	2012-11-15 22:30:32.000000000 +0100
--- src/testdir/test51.in	2016-10-12 16:53:02.513047817 +0200
***************
*** 24,30 ****
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
--- 24,30 ----
  :hi Crash term='asdf
  :redir END
  :" filter ctermfg and ctermbg, the numbers depend on the terminal
! :e! test.out
  :%s/ctermfg=\d*/ctermfg=2/
  :%s/ctermbg=\d*/ctermbg=3/
  :" filter out possibly translated error message
*** ../vim-8.0.0031/src/testdir/test67.in	2012-11-15 22:30:49.000000000 +0100
--- src/testdir/test67.in	2016-10-12 16:54:27.692445533 +0200
***************
*** 24,30 ****
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e test.out
  :call append(0, results)
  :$d
  :w
--- 24,30 ----
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
  :edit testfile2.test
  :call add(results, "#BufEnter#<buffer>: " . exists("#BufEnter#<buffer>"))
! :e! test.out
  :call append(0, results)
  :$d
  :w
*** ../vim-8.0.0031/src/testdir/test97.in	2014-05-08 11:42:37.000000000 +0200
--- src/testdir/test97.in	2016-10-12 16:55:32.683985962 +0200
***************
*** 7,13 ****
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
--- 7,13 ----
  :set shell=doesnotexist
  :" consistent sorting of file names
  :set nofileignorecase
! :e! test.out
  :$put =glob('Xxx\{')
  :$put =glob('Xxx\$')
  :w! Xxx{
*** ../vim-8.0.0031/src/testdir/test_tabpage.vim	2016-09-06 21:31:11.000000000 +0200
--- src/testdir/test_tabpage.vim	2016-09-29 20:07:58.098576056 +0200
***************
*** 11,16 ****
--- 11,17 ----
    0tabnew
    1tabnew
    $tabnew
+   %del
    tabdo call append(line('$'), tabpagenr())
    tabclose! 2
    tabrewind
*** ../vim-8.0.0031/src/version.c	2016-10-12 17:45:13.642857417 +0200
--- src/version.c	2016-10-12 17:51:56.632003323 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     32,
  /**/

-- 
ARTHUR:          What does it say?
BROTHER MAYNARD: It reads ... "Here may be found the last words of Joseph of
                 Aramathea." "He who is valorous and pure of heart may find
                 the Holy Grail in the aaaaarrrrrrggghhh..."
ARTHUR:          What?
BROTHER MAYNARD: "The Aaaaarrrrrrggghhh..."
                 "Monty Python and the Holy Grail" PYTHON (MONTY) PICTURES LTD

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0033
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0033
Problem:    Cannot use overlapping positions with matchaddpos().
Solution:   Check end of match. (Ozaki Kiichi) Add a test (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0032/src/screen.c	2016-10-02 23:09:27.643153731 +0200
--- src/screen.c	2016-10-15 14:52:51.297854046 +0200
***************
*** 7786,7806 ****
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	if (posmatch->pos[i].lnum == 0)
  	    break;
! 	if (posmatch->pos[i].col < mincol)
  	    continue;
! 	if (posmatch->pos[i].lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (posmatch->pos[i].col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = posmatch->pos[i];
  
! 		    posmatch->pos[i] = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
--- 7786,7808 ----
      shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
! 	llpos_T	*pos = &posmatch->pos[i];
! 
! 	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
! 	if (pos->lnum == lnum)
  	{
  	    if (shl->lnum == lnum)
  	    {
  		/* partially sort positions by column numbers
  		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
! 		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
  		    posmatch->pos[bot] = tmp;
  		}
  	    }
*** ../vim-8.0.0032/src/testdir/test_match.vim	2016-08-27 18:28:13.000000000 +0200
--- src/testdir/test_match.vim	2016-10-15 14:50:58.442694482 +0200
***************
*** 181,186 ****
--- 181,196 ----
    redraw!
    call assert_equal(screenattr(2,2), screenattr(1,6))
  
+   " Check overlapping pos
+   call clearmatches()
+   call setline(1, ['1234567890', 'NH'])
+   call matchaddpos('Error', [[1,1,5], [1,3,5], [2,2]])
+   redraw!
+   call assert_notequal(screenattr(2,2), 0)
+   call assert_equal(screenattr(2,2), screenattr(1,5))
+   call assert_equal(screenattr(2,2), screenattr(1,7))
+   call assert_notequal(screenattr(2,2), screenattr(1,8))
+ 
    nohl
    syntax off
    set hlsearch&
*** ../vim-8.0.0032/src/version.c	2016-10-12 17:52:39.199701825 +0200
--- src/version.c	2016-10-15 14:54:57.816912413 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     33,
  /**/

-- 
Q: Why does /dev/null accept only integers?
A: You can't sink a float.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0034
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0034
Problem:    No completion for ":messages".
Solution:   Complete "clear" argument. (Hirohito Higashi)
Files:      src/ex_docmd.c, src/ex_getln.c, src/proto/ex_docmd.pro,
            src/testdir/test_cmdline.vim, src/vim.h,
            runtime/doc/eval.txt, runtime/doc/map.txt


*** ../vim-8.0.0033/src/ex_docmd.c	2016-10-12 14:19:55.742357780 +0200
--- src/ex_docmd.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4281,4286 ****
--- 4281,4291 ----
  	    xp->xp_pattern = arg;
  	    break;
  
+ 	case CMD_messages:
+ 	    xp->xp_context = EXPAND_MESSAGES;
+ 	    xp->xp_pattern = arg;
+ 	    break;
+ 
  #if defined(FEAT_CMDHIST)
  	case CMD_history:
  	    xp->xp_context = EXPAND_HISTORY;
***************
*** 5893,5898 ****
--- 5898,5904 ----
  #endif
      {EXPAND_MAPPINGS, "mapping"},
      {EXPAND_MENUS, "menu"},
+     {EXPAND_MESSAGES, "messages"},
      {EXPAND_OWNSYNTAX, "syntax"},
  #if defined(FEAT_PROFILE)
      {EXPAND_SYNTIME, "syntime"},
***************
*** 11901,11906 ****
--- 11907,11924 ----
  	return (char_u *)"xterm";
      return NULL;
  }
+ 
+ /*
+  * Function given to ExpandGeneric() to obtain the possible arguments of the
+  * ":messages {clear}" command.
+  */
+     char_u *
+ get_messages_arg(expand_T *xp UNUSED, int idx)
+ {
+     if (idx == 0)
+ 	return (char_u *)"clear";
+     return NULL;
+ }
  #endif
  
  #ifdef FEAT_AUTOCMD
*** ../vim-8.0.0033/src/ex_getln.c	2016-09-09 21:35:27.000000000 +0200
--- src/ex_getln.c	2016-10-15 15:22:09.672808290 +0200
***************
*** 4832,4837 ****
--- 4832,4838 ----
  	{
  	    {EXPAND_COMMANDS, get_command_name, FALSE, TRUE},
  	    {EXPAND_BEHAVE, get_behave_arg, TRUE, TRUE},
+ 	    {EXPAND_MESSAGES, get_messages_arg, TRUE, TRUE},
  #ifdef FEAT_CMDHIST
  	    {EXPAND_HISTORY, get_history_arg, TRUE, TRUE},
  #endif
*** ../vim-8.0.0033/src/proto/ex_docmd.pro	2016-09-12 13:04:02.000000000 +0200
--- src/proto/ex_docmd.pro	2016-10-15 15:22:09.672808290 +0200
***************
*** 61,64 ****
--- 61,65 ----
  int put_line(FILE *fd, char *s);
  void dialog_msg(char_u *buff, char *format, char_u *fname);
  char_u *get_behave_arg(expand_T *xp, int idx);
+ char_u *get_messages_arg(expand_T *xp, int idx);
  /* vim: set ft=c : */
*** ../vim-8.0.0033/src/testdir/test_cmdline.vim	2016-08-28 13:34:01.000000000 +0200
--- src/testdir/test_cmdline.vim	2016-10-15 15:22:09.672808290 +0200
***************
*** 129,134 ****
--- 129,139 ----
    let l = getcompletion('dark', 'highlight')
    call assert_equal([], l)
  
+   let l = getcompletion('', 'messages')
+   call assert_true(index(l, 'clear') >= 0)
+   let l = getcompletion('not', 'messages')
+   call assert_equal([], l)
+ 
    if has('cscope')
      let l = getcompletion('', 'cscope')
      let cmds = ['add', 'find', 'help', 'kill', 'reset', 'show']
*** ../vim-8.0.0033/src/vim.h	2016-09-04 21:27:13.000000000 +0200
--- src/vim.h	2016-10-15 15:22:09.672808290 +0200
***************
*** 793,798 ****
--- 793,799 ----
  #define EXPAND_SYNTIME		43
  #define EXPAND_USER_ADDR_TYPE	44
  #define EXPAND_PACKADD		45
+ #define EXPAND_MESSAGES		46
  
  /* Values for exmode_active (0 is no exmode) */
  #define EXMODE_NORMAL		1
*** ../vim-8.0.0033/runtime/doc/eval.txt	2016-10-02 16:51:32.748592858 +0200
--- runtime/doc/eval.txt	2016-10-15 15:24:39.175697407 +0200
***************
*** 4281,4287 ****
--- 4287,4295 ----
  		locale		locale names (as output of locale -a)
  		mapping		mapping name
  		menu		menus
+ 		messages	|:messages| suboptions
  		option		options
+ 		packadd		optional package |pack-add| names
  		shellcmd	Shell command
  		sign		|:sign| suboptions
  		syntax		syntax file names |'syntax'|
*** ../vim-8.0.0033/runtime/doc/map.txt	2016-09-12 12:45:26.000000000 +0200
--- runtime/doc/map.txt	2016-10-15 15:24:55.571575607 +0200
***************
*** 1280,1285 ****
--- 1280,1286 ----
  	-complete=locale	locale names (as output of locale -a)
  	-complete=mapping	mapping name
  	-complete=menu		menus
+ 	-complete=messages	|:messages| suboptions
  	-complete=option	options
  	-complete=packadd	optional package |pack-add| names
  	-complete=shellcmd	Shell command
*** ../vim-8.0.0033/src/version.c	2016-10-15 14:56:25.868257421 +0200
--- src/version.c	2016-10-15 15:23:36.340164248 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     34,
  /**/

-- 
SIGFUN -- signature too funny (core dumped)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0035
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0035 (after 7.4.2013)
Problem:    Order of matches for 'omnifunc' is messed up. (Danny Su)
Solution:   Do not set compl_curr_match when called from complete_check().
            (closes #1168)
Files:      src/edit.c, src/evalfunc.c, src/proto/edit.pro, src/search.c,
            src/spell.c, src/tag.c, src/testdir/test76.in, 
            src/testdir/test76.ok, src/testdir/test_popup.vim, src/Makefile,
            src/testdir/Make_all.mak


*** ../vim-8.0.0034/src/edit.c	2016-09-05 20:53:05.000000000 +0200
--- src/edit.c	2016-10-15 17:01:00.865374961 +0200
***************
*** 179,186 ****
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(void);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
--- 179,186 ----
  #endif
  static int  ins_compl_get_exp(pos_T *ini);
  static void ins_compl_delete(void);
! static void ins_compl_insert(int in_compl_func);
! static int  ins_compl_next(int allow_get_expansion, int count, int insert_match, int in_compl_func);
  static int  ins_compl_key2dir(int c);
  static int  ins_compl_pum_key(int c);
  static int  ins_compl_key2count(int c);
***************
*** 861,867 ****
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert();
  		}
  	    }
  	}
--- 861,867 ----
  				   && (c == CAR || c == K_KENTER || c == NL)))
  		{
  		    ins_compl_delete();
! 		    ins_compl_insert(FALSE);
  		}
  	    }
  	}
***************
*** 3297,3303 ****
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50);
  	    }
  	    fclose(fp);
  	}
--- 3297,3303 ----
  			break;
  		}
  		line_breakcheck();
! 		ins_compl_check_keys(50, FALSE);
  	    }
  	    fclose(fp);
  	}
***************
*** 4036,4043 ****
  }
  
  #ifdef FEAT_COMPL_FUNC
- static void expand_by_function(int type, char_u *base);
- 
  /*
   * Execute user defined complete function 'completefunc' or 'omnifunc', and
   * get matches in "matches".
--- 4036,4041 ----
***************
*** 4596,4602 ****
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
--- 4594,4600 ----
  		break;
  	    /* Fill the popup menu as soon as possible. */
  	    if (type != -1)
! 		ins_compl_check_keys(0, FALSE);
  
  	    if ((ctrl_x_mode != 0 && !CTRL_X_MODE_LINE_OR_EVAL(ctrl_x_mode))
  							 || compl_interrupted)
***************
*** 4653,4661 ****
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /* Insert the new text being completed. */
      static void
! ins_compl_insert(void)
  {
      dict_T	*dict;
  
--- 4651,4662 ----
      set_vim_var_dict(VV_COMPLETED_ITEM, dict_alloc());
  }
  
! /*
!  * Insert the new text being completed.
!  * "in_compl_func" is TRUE when called from complete_check().
!  */
      static void
! ins_compl_insert(int in_compl_func)
  {
      dict_T	*dict;
  
***************
*** 4682,4688 ****
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     compl_curr_match = compl_shown_match;
  }
  
  /*
--- 4683,4690 ----
  		    EMPTY_IF_NULL(compl_shown_match->cp_text[CPT_INFO]));
      }
      set_vim_var_dict(VV_COMPLETED_ITEM, dict);
!     if (!in_compl_func)
! 	compl_curr_match = compl_shown_match;
  }
  
  /*
***************
*** 4706,4712 ****
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match)	/* Insert the newly selected match */
  {
      int	    num_matches = -1;
      int	    i;
--- 4708,4715 ----
      int	    allow_get_expansion,
      int	    count,		/* repeat completion this many times; should
  				   be at least 1 */
!     int	    insert_match,	/* Insert the newly selected match */
!     int	    in_compl_func)	/* called from complete_check() */
  {
      int	    num_matches = -1;
      int	    i;
***************
*** 4856,4862 ****
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert();
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
--- 4859,4865 ----
      else if (insert_match)
      {
  	if (!compl_get_longest || compl_used_match)
! 	    ins_compl_insert(in_compl_func);
  	else
  	    ins_bytes(compl_leader + ins_compl_len());
      }
***************
*** 4921,4929 ****
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
   */
      void
! ins_compl_check_keys(int frequency)
  {
      static int	count = 0;
  
--- 4924,4934 ----
   * mode.  Also, when compl_pending is not zero, show a completion as soon as
   * possible. -- webb
   * "frequency" specifies out of how many calls we actually check.
+  * "in_compl_func" is TRUE when called from complete_check(), don't set
+  * compl_curr_match.
   */
      void
! ins_compl_check_keys(int frequency, int in_compl_func)
  {
      static int	count = 0;
  
***************
*** 4949,4955 ****
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 						    c != K_UP && c != K_DOWN);
  	}
  	else
  	{
--- 4954,4960 ----
  	    c = safe_vgetc();	/* Eat the character */
  	    compl_shows_dir = ins_compl_key2dir(c);
  	    (void)ins_compl_next(FALSE, ins_compl_key2count(c),
! 				      c != K_UP && c != K_DOWN, in_compl_func);
  	}
  	else
  	{
***************
*** 4972,4978 ****
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE);
      }
  }
  
--- 4977,4983 ----
  	int todo = compl_pending > 0 ? compl_pending : -compl_pending;
  
  	compl_pending = 0;
! 	(void)ins_compl_next(FALSE, todo, TRUE, in_compl_func);
      }
  }
  
***************
*** 5490,5496 ****
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c), ins_compl_use_match(c));
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
--- 5495,5502 ----
       * Find next match (and following matches).
       */
      save_w_wrow = curwin->w_wrow;
!     n = ins_compl_next(TRUE, ins_compl_key2count(c),
! 						ins_compl_use_match(c), FALSE);
  
      /* may undisplay the popup menu */
      ins_compl_upd_pum();
*** ../vim-8.0.0034/src/evalfunc.c	2016-10-12 14:19:55.738357808 +0200
--- src/evalfunc.c	2016-10-15 16:22:08.458346817 +0200
***************
*** 2175,2181 ****
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
--- 2175,2181 ----
      int		saved = RedrawingDisabled;
  
      RedrawingDisabled = 0;
!     ins_compl_check_keys(0, TRUE);
      rettv->vval.v_number = compl_interrupted;
      RedrawingDisabled = saved;
  }
*** ../vim-8.0.0034/src/proto/edit.pro	2016-09-12 13:04:00.000000000 +0200
--- src/proto/edit.pro	2016-10-15 16:23:24.833787216 +0200
***************
*** 15,21 ****
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
--- 15,21 ----
  char_u *find_word_end(char_u *ptr);
  int ins_compl_active(void);
  int ins_compl_add_tv(typval_T *tv, int dir);
! void ins_compl_check_keys(int frequency, int in_compl_func);
  int get_literal(void);
  void insertchar(int c, int flags, int second_indent);
  void auto_format(int trailblank, int prev_line);
*** ../vim-8.0.0034/src/search.c	2016-09-09 21:20:55.000000000 +0200
--- src/search.c	2016-10-15 16:26:52.640264523 +0200
***************
*** 5429,5435 ****
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
--- 5429,5435 ----
  	line_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	if (action == ACTION_EXPAND)
! 	    ins_compl_check_keys(30, FALSE);
  	if (got_int || compl_interrupted)
  #else
  	if (got_int)
*** ../vim-8.0.0034/src/spell.c	2016-08-29 22:42:20.000000000 +0200
--- src/spell.c	2016-10-15 16:27:13.788109555 +0200
***************
*** 8694,8700 ****
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50);
  		}
  		else
  		{
--- 8694,8700 ----
  		    /* Done all bytes at this node, go up one level. */
  		    --depth;
  		    line_breakcheck();
! 		    ins_compl_check_keys(50, FALSE);
  		}
  		else
  		{
*** ../vim-8.0.0034/src/tag.c	2016-09-06 21:20:44.000000000 +0200
--- src/tag.c	2016-10-15 16:27:34.955954439 +0200
***************
*** 1587,1593 ****
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
--- 1587,1593 ----
  		fast_breakcheck();
  #ifdef FEAT_INS_EXPAND
  	    if ((flags & TAG_INS_COMP))	/* Double brackets for gcc */
! 		ins_compl_check_keys(30, FALSE);
  	    if (got_int || compl_interrupted)
  #else
  	    if (got_int)
*** ../vim-8.0.0034/src/testdir/test76.in	2010-11-10 16:38:45.000000000 +0100
--- src/testdir/test76.in	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,46 ****
- Tests for completefunc/omnifunc. vim: set ft=vim :
- 
- STARTTEST
- :"Test that nothing happens if the 'completefunc' opens
- :"a new window (no completion, no crash)
- :so small.vim
- :function! DummyCompleteOne(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    wincmd n
- :    return ['onedef', 'oneDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteOne
- /^one
- A:q!
- :function! DummyCompleteTwo(findstart, base)
- :  if a:findstart
- :    wincmd n
- :    return 0
- :  else
- :    return ['twodef', 'twoDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteTwo
- /^two
- A:q!
- :"Test that 'completefunc' works when it's OK.
- :function! DummyCompleteThree(findstart, base)
- :  if a:findstart
- :    return 0
- :  else
- :    return ['threedef', 'threeDEF']
- :  endif
- :endfunction
- :setlocal completefunc=DummyCompleteThree
- /^three
- A:/^+++/,/^three/w! test.out
- :qa!
- ENDTEST
- 
- +++
- one
- two
- three
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test76.ok	2010-11-10 16:38:58.000000000 +0100
--- src/testdir/test76.ok	1970-01-01 01:00:00.000000000 +0100
***************
*** 1,4 ****
- +++
- 
- two
- threeDEF
--- 0 ----
*** ../vim-8.0.0034/src/testdir/test_popup.vim	2016-09-22 21:27:08.360782126 +0200
--- src/testdir/test_popup.vim	2016-10-15 17:00:08.237755020 +0200
***************
*** 289,292 ****
--- 289,403 ----
    bwipe!
  endfunc
  
+ func DummyCompleteOne(findstart, base)
+   if a:findstart
+     return 0
+   else
+     wincmd n
+     return ['onedef', 'oneDEF']
+   endif
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_one()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteOne
+   call setline(1, 'one')
+   /^one
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E839:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('', getline(1))
+   q!
+ endfunc
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func DummyCompleteTwo(findstart, base)
+   if a:findstart
+     wincmd n
+     return 0
+   else
+     return ['twodef', 'twoDEF']
+   endif
+ endfunction
+ 
+ " Test that nothing happens if the 'completefunc' opens
+ " a new window (no completion, no crash)
+ func Test_completefunc_opens_new_window_two()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteTwo
+   call setline(1, 'two')
+   /^two
+   call assert_fails('call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")', 'E764:')
+   call assert_notequal(winid, win_getid())
+   q!
+   call assert_equal(winid, win_getid())
+   call assert_equal('two', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteThree(findstart, base)
+   if a:findstart
+     return 0
+   else
+     return ['threedef', 'threeDEF']
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_completefunc_works()
+   new
+   let winid = win_getid()
+   setlocal completefunc=DummyCompleteThree
+   call setline(1, 'three')
+   /^three
+   call feedkeys("A\<C-X>\<C-U>\<C-N>\<Esc>", "x")
+   call assert_equal(winid, win_getid())
+   call assert_equal('threeDEF', getline(1))
+   q!
+ endfunc
+ 
+ func DummyCompleteFour(findstart, base)
+   if a:findstart
+     return 0
+   else
+     call complete_add('four1')
+     call complete_add('four2')
+     call complete_check()
+     call complete_add('four3')
+     call complete_add('four4')
+     call complete_check()
+     call complete_add('four5')
+     call complete_add('four6')
+     return []
+   endif
+ endfunc
+ 
+ :"Test that 'completefunc' works when it's OK.
+ func Test_omnifunc_with_check()
+   new
+   setlocal omnifunc=DummyCompleteFour
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<Esc>", "x")
+   call assert_equal('four2', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four3', getline(1))
+ 
+   call setline(1, 'four')
+   /^four
+   call feedkeys("A\<C-X>\<C-O>\<C-N>\<C-N>\<C-N>\<C-N>\<Esc>", "x")
+   call assert_equal('four5', getline(1))
+ 
+   q!
+ endfunc
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0034/src/Makefile	2016-10-12 17:45:13.642857417 +0200
--- src/Makefile	2016-10-15 16:53:46.808507474 +0200
***************
*** 2047,2053 ****
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test76 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
--- 2047,2053 ----
  	test40 test41 test42 test43 test44 test45 test48 test49 \
  	test50 test51 test52 test53 test54 test55 test56 test57 test58 test59 \
  	test60 test64 test65 test66 test67 test68 test69 \
! 	test70 test72 test73 test74 test75 test77 test78 test79 \
  	test80 test82 test83 test84 test85 test86 test87 test88 test89 \
  	test90 test91 test92 test93 test94 test95 test97 test98 test99 \
  	test100 test101 test103 test104 test107 test108:
*** ../vim-8.0.0034/src/testdir/Make_all.mak	2016-09-29 20:54:42.403110749 +0200
--- src/testdir/Make_all.mak	2016-10-15 16:53:57.008433920 +0200
***************
*** 55,61 ****
  	test70.out \
  	test73.out \
  	test75.out \
- 	test76.out \
  	test77.out \
  	test79.out \
  	test80.out \
--- 55,60 ----
*** ../vim-8.0.0034/src/version.c	2016-10-15 15:39:34.693059595 +0200
--- src/version.c	2016-10-15 17:05:26.303457035 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     35,
  /**/

-- 
Every exit is an entrance into something else.

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0036
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0036
Problem:    Detecting that a job has finished may take a while.
Solution:   Check for a finished job more often (Ozaki Kiichi)
Files:      src/channel.c, src/os_unix.c, src/os_win32.c,
            src/proto/os_unix.pro, src/proto/os_win32.pro,
            src/testdir/test_channel.vim


*** ../vim-8.0.0035/src/channel.c	2016-10-09 17:27:56.859388538 +0200
--- src/channel.c	2016-10-15 18:34:49.054767438 +0200
***************
*** 4428,4433 ****
--- 4428,4466 ----
      }
  }
  
+     static void
+ job_cleanup(job_T *job)
+ {
+     if (job->jv_status != JOB_ENDED)
+ 	return;
+ 
+     if (job->jv_exit_cb != NULL)
+     {
+ 	typval_T	argv[3];
+ 	typval_T	rettv;
+ 	int		dummy;
+ 
+ 	/* invoke the exit callback; make sure the refcount is > 0 */
+ 	++job->jv_refcount;
+ 	argv[0].v_type = VAR_JOB;
+ 	argv[0].vval.v_job = job;
+ 	argv[1].v_type = VAR_NUMBER;
+ 	argv[1].vval.v_number = job->jv_exitval;
+ 	call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
+ 	    &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
+ 	    job->jv_exit_partial, NULL);
+ 	clear_tv(&rettv);
+ 	--job->jv_refcount;
+ 	channel_need_redraw = TRUE;
+     }
+     if (job->jv_refcount == 0)
+     {
+ 	/* The job was already unreferenced, now that it ended it can be
+ 	 * freed. Careful: caller must not use "job" after this! */
+ 	job_free(job);
+     }
+ }
+ 
  #if defined(EXITFREE) || defined(PROTO)
      void
  job_free_all(void)
***************
*** 4445,4454 ****
      static int
  job_still_useful(job_T *job)
  {
!     return job->jv_status == JOB_STARTED
! 	       && (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 		   || (job->jv_channel != NULL
! 		       && channel_still_useful(job->jv_channel)));
  }
  
  /*
--- 4478,4492 ----
      static int
  job_still_useful(job_T *job)
  {
!     return (job->jv_stoponexit != NULL || job->jv_exit_cb != NULL
! 	    || (job->jv_channel != NULL
! 		&& channel_still_useful(job->jv_channel)));
! }
! 
!     static int
! job_still_alive(job_T *job)
! {
!     return (job->jv_status == JOB_STARTED) && job_still_useful(job);
  }
  
  /*
***************
*** 4462,4468 ****
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_useful(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
--- 4500,4506 ----
      typval_T	tv;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	{
  	    tv.v_type = VAR_JOB;
  	    tv.vval.v_job = job;
***************
*** 4478,4484 ****
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_useful(job))
  	{
  	    job_free(job);
  	}
--- 4516,4522 ----
      {
  	/* Do not free the job when it has not ended yet and there is a
  	 * "stoponexit" flag or an exit callback. */
! 	if (!job_still_alive(job))
  	{
  	    job_free(job);
  	}
***************
*** 4503,4509 ****
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
--- 4541,4547 ----
  
      for (job = first_job; job != NULL; job = job->jv_next)
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the channel and ordinary items it contains, but don't
  	     * recurse into Lists, Dictionaries etc. */
***************
*** 4523,4529 ****
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						    && !job_still_useful(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
--- 4561,4567 ----
      {
  	job_next = job->jv_next;
  	if ((job->jv_copyID & mask) != (copyID & mask)
! 						     && !job_still_alive(job))
  	{
  	    /* Free the job struct itself. */
  	    job_free_job(job);
***************
*** 4614,4647 ****
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job->jv_status == JOB_STARTED && job_still_useful(job))
  	    return TRUE;
      return FALSE;
  }
  
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     static time_t   last_check = 0;
!     time_t	    now;
!     job_T	    *job;
!     job_T	    *next;
  
!     /* Only do this once in 10 seconds. */
!     now = time(NULL);
!     if (last_check + 10 < now)
!     {
! 	last_check = now;
! 	for (job = first_job; job != NULL; job = next)
! 	{
! 	    next = job->jv_next;
! 	    if (job->jv_status == JOB_STARTED && job_still_useful(job))
! 		job_status(job); /* may free "job" */
! 	}
      }
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
--- 4652,4682 ----
      job_T	    *job;
  
      for (job = first_job; job != NULL; job = job->jv_next)
! 	if (job_still_alive(job))
  	    return TRUE;
      return FALSE;
  }
  
+ #define MAX_CHECK_ENDED 8
+ 
  /*
   * Called once in a while: check if any jobs that seem useful have ended.
   */
      void
  job_check_ended(void)
  {
!     int		i;
  
!     for (i = 0; i < MAX_CHECK_ENDED; ++i)
!     {
! 	job_T	*job = mch_detect_ended_job(first_job);
! 
! 	if (job == NULL)
! 	    break;
! 	if (job_still_useful(job))
! 	    job_cleanup(job); /* may free "job" */
      }
+ 
      if (channel_need_redraw)
      {
  	channel_need_redraw = FALSE;
***************
*** 4862,4893 ****
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    ch_log(job->jv_channel, "Job ended");
! 	if (job->jv_status == JOB_ENDED && job->jv_exit_cb != NULL)
! 	{
! 	    typval_T	argv[3];
! 	    typval_T	rettv;
! 	    int		dummy;
! 
! 	    /* invoke the exit callback; make sure the refcount is > 0 */
! 	    ++job->jv_refcount;
! 	    argv[0].v_type = VAR_JOB;
! 	    argv[0].vval.v_job = job;
! 	    argv[1].v_type = VAR_NUMBER;
! 	    argv[1].vval.v_number = job->jv_exitval;
! 	    call_func(job->jv_exit_cb, (int)STRLEN(job->jv_exit_cb),
! 			   &rettv, 2, argv, NULL, 0L, 0L, &dummy, TRUE,
! 			   job->jv_exit_partial, NULL);
! 	    clear_tv(&rettv);
! 	    --job->jv_refcount;
! 	    channel_need_redraw = TRUE;
! 	}
! 	if (job->jv_status == JOB_ENDED && job->jv_refcount == 0)
! 	{
! 	    /* The job was already unreferenced, now that it ended it can be
! 	     * freed. Careful: caller must not use "job" after this! */
! 	    job_free(job);
! 	}
      }
      return result;
  }
--- 4897,4903 ----
      {
  	result = mch_job_status(job);
  	if (job->jv_status == JOB_ENDED)
! 	    job_cleanup(job);
      }
      return result;
  }
*** ../vim-8.0.0035/src/os_unix.c	2016-10-12 14:50:50.233115689 +0200
--- src/os_unix.c	2016-10-15 18:33:46.303229935 +0200
***************
*** 5294,5301 ****
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (wait_pid == 0)
  	return "run";
--- 5294,5300 ----
      if (wait_pid == -1)
      {
  	/* process must have exited */
! 	goto return_dead;
      }
      if (wait_pid == 0)
  	return "run";
***************
*** 5303,5318 ****
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	job->jv_status = JOB_ENDED;
! 	return "dead";
      }
      return "run";
  }
  
      int
--- 5302,5363 ----
      {
  	/* LINTED avoid "bitwise operation on signed value" */
  	job->jv_exitval = WEXITSTATUS(status);
! 	goto return_dead;
      }
      if (WIFSIGNALED(status))
      {
  	job->jv_exitval = -1;
! 	goto return_dead;
      }
      return "run";
+ 
+ return_dead:
+     if (job->jv_status != JOB_ENDED)
+     {
+ 	ch_log(job->jv_channel, "Job ended");
+ 	job->jv_status = JOB_ENDED;
+     }
+     return "dead";
+ }
+ 
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+ # ifdef HAVE_UNION_WAIT
+     union wait	status;
+ # else
+     int		status = -1;
+ # endif
+     pid_t	wait_pid = 0;
+     job_T	*job;
+ 
+ # ifdef __NeXT__
+     wait_pid = wait4(-1, &status, WNOHANG, (struct rusage *)0);
+ # else
+     wait_pid = waitpid(-1, &status, WNOHANG);
+ # endif
+     if (wait_pid <= 0)
+ 	/* no process ended */
+ 	return NULL;
+     for (job = job_list; job != NULL; job = job->jv_next)
+     {
+ 	if (job->jv_pid == wait_pid)
+ 	{
+ 	    if (WIFEXITED(status))
+ 		/* LINTED avoid "bitwise operation on signed value" */
+ 		job->jv_exitval = WEXITSTATUS(status);
+ 	    else if (WIFSIGNALED(status))
+ 		job->jv_exitval = -1;
+ 	    if (job->jv_status != JOB_ENDED)
+ 	    {
+ 		ch_log(job->jv_channel, "Job ended");
+ 		job->jv_status = JOB_ENDED;
+ 	    }
+ 	    return job;
+ 	}
+     }
+     return NULL;
+ 
  }
  
      int
*** ../vim-8.0.0035/src/os_win32.c	2016-10-12 14:19:55.754357695 +0200
--- src/os_win32.c	2016-10-15 18:34:13.379030378 +0200
***************
*** 4973,4985 ****
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
- 	job->jv_status = JOB_ENDED;
  	job->jv_exitval = (int)dwExitCode;
  	return "dead";
      }
      return "run";
  }
  
      int
  mch_stop_job(job_T *job, char_u *how)
  {
--- 4973,5025 ----
      if (!GetExitCodeProcess(job->jv_proc_info.hProcess, &dwExitCode)
  	    || dwExitCode != STILL_ACTIVE)
      {
  	job->jv_exitval = (int)dwExitCode;
+ 	if (job->jv_status != JOB_ENDED)
+ 	{
+ 	    ch_log(job->jv_channel, "Job ended");
+ 	    job->jv_status = JOB_ENDED;
+ 	}
  	return "dead";
      }
      return "run";
  }
  
+     job_T *
+ mch_detect_ended_job(job_T *job_list)
+ {
+     HANDLE jobHandles[MAXIMUM_WAIT_OBJECTS];
+     job_T *jobArray[MAXIMUM_WAIT_OBJECTS];
+     job_T *job = job_list;
+ 
+     while (job != NULL)
+     {
+ 	DWORD n;
+ 	DWORD result;
+ 
+ 	for (n = 0; n < MAXIMUM_WAIT_OBJECTS
+ 				       && job != NULL; job = job->jv_next)
+ 	{
+ 	    if (job->jv_status == JOB_STARTED)
+ 	    {
+ 		jobHandles[n] = job->jv_proc_info.hProcess;
+ 		jobArray[n] = job;
+ 		++n;
+ 	    }
+ 	}
+ 	if (n == 0)
+ 	    continue;
+ 	result = WaitForMultipleObjects(n, jobHandles, FALSE, 0);
+ 	if (result >= WAIT_OBJECT_0 && result < WAIT_OBJECT_0 + n)
+ 	{
+ 	    job_T *wait_job = jobArray[result - WAIT_OBJECT_0];
+ 
+ 	    if (STRCMP(mch_job_status(wait_job), "dead") == 0)
+ 		return wait_job;
+ 	}
+     }
+     return NULL;
+ }
+ 
      int
  mch_stop_job(job_T *job, char_u *how)
  {
*** ../vim-8.0.0035/src/proto/os_unix.pro	2016-09-29 15:18:51.359768012 +0200
--- src/proto/os_unix.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 59,64 ****
--- 59,65 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char **argv, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_breakcheck(int force);
*** ../vim-8.0.0035/src/proto/os_win32.pro	2016-10-12 14:19:55.754357695 +0200
--- src/proto/os_win32.pro	2016-10-15 18:26:49.770299911 +0200
***************
*** 41,46 ****
--- 41,47 ----
  int mch_call_shell(char_u *cmd, int options);
  void mch_start_job(char *cmd, job_T *job, jobopt_T *options);
  char *mch_job_status(job_T *job);
+ job_T *mch_detect_ended_job(job_T *job_list);
  int mch_stop_job(job_T *job, char_u *how);
  void mch_clear_job(job_T *job);
  void mch_set_normal_colors(void);
*** ../vim-8.0.0035/src/testdir/test_channel.vim	2016-10-09 17:27:56.863388510 +0200
--- src/testdir/test_channel.vim	2016-10-15 18:26:49.770299911 +0200
***************
*** 1362,1367 ****
--- 1362,1385 ----
    endif
  endfunc
  
+ let g:exit_cb_time = {'start': 0, 'end': 0}
+ function MyExitTimeCb(job, status)
+   let g:exit_cb_time.end = reltime(g:exit_cb_time.start)
+ endfunction
+ 
+ func Test_exit_callback_interval()
+   if !has('job')
+     return
+   endif
+ 
+   let g:exit_cb_time.start = reltime()
+   let job = job_start([s:python, '-c', 'import time;time.sleep(0.5)'], {'exit_cb': 'MyExitTimeCb'})
+   call WaitFor('g:exit_cb_time.end != 0')
+   let elapsed = reltimefloat(g:exit_cb_time.end)
+   call assert_true(elapsed > 0.3)
+   call assert_true(elapsed < 1.0)
+ endfunc
+ 
  """""""""
  
  let g:Ch_close_ret = 'alive'
*** ../vim-8.0.0035/src/version.c	2016-10-15 17:06:42.094912699 +0200
--- src/version.c	2016-10-15 18:28:19.269640273 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     36,
  /**/

-- 
It is illegal for a driver to be blindfolded while operating a vehicle.
		[real standing law in Alabama, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0037
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0037
Problem:    Get E924 when switching tabs.
Solution:   Use win_valid_any_tab() instead of win_valid(). (Martin Vuille,
            closes #1167, closes #1171)
Files:      src/quickfix.c, src/testdir/test_quickfix.vim


*** ../vim-8.0.0036/src/quickfix.c	2016-10-09 16:10:02.135942266 +0200
--- src/quickfix.c	2016-10-15 19:20:23.402614457 +0200
***************
*** 2266,2272 ****
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
--- 2266,2272 ----
  
  	    ok = buflist_getfile(qf_ptr->qf_fnum,
  			    (linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);
! 	    if (qi != &ql_info && !win_valid_any_tab(oldwin))
  	    {
  		EMSG(_("E924: Current window was closed"));
  		is_abort = TRUE;
*** ../vim-8.0.0036/src/testdir/test_quickfix.vim	2016-10-09 16:10:02.135942266 +0200
--- src/testdir/test_quickfix.vim	2016-10-15 19:19:46.170888867 +0200
***************
*** 617,622 ****
--- 617,638 ----
      augroup! testgroup
  endfunction
  
+ function Test_locationlist_cross_tab_jump()
+   call writefile(['loclistfoo'], 'loclistfoo')
+   call writefile(['loclistbar'], 'loclistbar')
+   set switchbuf=usetab
+ 
+   edit loclistfoo
+   tabedit loclistbar
+   silent lgrep loclistfoo loclist*
+   call assert_equal(1, tabpagenr())
+ 
+   enew | only | tabonly
+   set switchbuf&vim
+   call delete('loclistfoo')
+   call delete('loclistbar')
+ endfunction
+ 
  " More tests for 'errorformat'
  function! Test_efm1()
      if !has('unix')
*** ../vim-8.0.0036/src/version.c	2016-10-15 18:36:45.353910276 +0200
--- src/version.c	2016-10-15 19:22:55.749491613 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     37,
  /**/

-- 
You can be stopped by the police for biking over 65 miles per hour.
You are not allowed to walk across a street on your hands.
		[real standing laws in Connecticut, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0038
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0038
Problem:    OPEN_CHR_FILES not defined for FreeBSD using Debian userland
            files.
Solution:   Check for __FreeBSD_kernel__. (James McCoy, closes #1166)
Files:      src/vim.h


*** ../vim-8.0.0037/src/vim.h	2016-10-15 15:39:34.689059624 +0200
--- src/vim.h	2016-10-15 19:32:06.017435971 +0200
***************
*** 2495,2501 ****
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__)) && defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
--- 2495,2502 ----
  #define FNE_INCL_BR	1	/* include [] in name */
  #define FNE_CHECK_START	2	/* check name starts with valid character */
  
! #if (defined(sun) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__)) \
! 	&& defined(S_ISCHR)
  # define OPEN_CHR_FILES
  #endif
  
*** ../vim-8.0.0037/src/version.c	2016-10-15 19:28:09.243181069 +0200
--- src/version.c	2016-10-15 19:33:06.036993609 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     38,
  /**/

-- 
A special law prohibits unmarried women from parachuting on Sunday or she
shall risk arrest, fine, and/or jailing.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0039
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0039
Problem:    When Vim 8 reads an old viminfo and exits, the next time marks are
            not read from viminfo. (Ned Batchelder)
Solution:   Set a mark when it wasn't set before, even when the timestamp is
            zero. (closes #1170)
Files:      src/mark.c, src/testdir/test_viminfo.vim


*** ../vim-8.0.0038/src/mark.c	2016-08-29 22:42:20.000000000 +0200
--- src/mark.c	2016-10-15 20:42:31.522292708 +0200
***************
*** 1597,1603 ****
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
--- 1597,1604 ----
  
      if (fm != NULL)
      {
! 	if (vi_namedfm != NULL || fm->fmark.mark.lnum == 0
! 					  || fm->time_set < timestamp || force)
  	{
  	    fm->fmark.mark.lnum = lnum;
  	    fm->fmark.mark.col = col;
*** ../vim-8.0.0038/src/testdir/test_viminfo.vim	2016-08-26 20:35:50.000000000 +0200
--- src/testdir/test_viminfo.vim	2016-10-15 20:38:48.599935714 +0200
***************
*** 1,6 ****
  " Test for reading and writing .viminfo
  
! function Test_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
--- 1,6 ----
  " Test for reading and writing .viminfo
  
! function Test_viminfo_read_and_write()
    call histdel(':')
    let lines = [
  	\ '# comment line',
***************
*** 17,23 ****
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
--- 17,23 ----
    let lines = readfile('Xviminfo')
    let done = 0
    for line in lines
!     if line[0] == '|' && line !~ '^|[234],' && line !~ '^|<'
        if done == 0
  	call assert_equal('|1,4', line)
        elseif done == 1
***************
*** 469,475 ****
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
--- 469,495 ----
    silent! bwipe Xtestfileintab
  endfunc
  
! func Test_viminfo_file_mark_zero_time()
!   let lines = [
! 	\ '# Viminfo version',
! 	\ '|1,4',
! 	\ '',
! 	\ '*encoding=utf-8',
! 	\ '',
! 	\ '# File marks:',
! 	\ "'B  1  0  /tmp/nothing",
! 	\ '|4,66,1,0,0,"/tmp/nothing"',
! 	\ "",
! 	\ ]
!   call writefile(lines, 'Xviminfo')
!   delmark B
!   rviminfo Xviminfo
!   call delete('Xviminfo')
!   call assert_equal(1, line("'B"))
!   delmark B
! endfunc
! 
! func Test_viminfo_oldfiles()
    let v:oldfiles = []
    let lines = [
  	\ '# comment line',
*** ../vim-8.0.0038/src/version.c	2016-10-15 19:33:47.264689748 +0200
--- src/version.c	2016-10-15 20:41:39.246677996 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     39,
  /**/

-- 
If an elephant is left tied to a parking meter, the parking fee has to be paid
just as it would for a vehicle.
		[real standing law in Florida, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0040
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0040 (after 8.0.0033)
Problem:    Whole line highlighting with matchaddpos() does not work.
Solution:   Check for zero length. (Hirohito Higashi)
Files:      src/screen.c, src/testdir/test_match.vim


*** ../vim-8.0.0039/src/screen.c	2016-10-15 14:56:25.868257421 +0200
--- src/screen.c	2016-10-16 14:28:48.026766302 +0200
***************
*** 7773,7778 ****
--- 7773,7782 ----
      }
  }
  
+ /*
+  * If there is a match fill "shl" and return one.
+  * Return zero otherwise.
+  */
      static int
  next_search_hl_pos(
      match_T	    *shl,	/* points to a match */
***************
*** 7781,7835 ****
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    bot = -1;
  
-     shl->lnum = 0;
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->col + pos->len - 1 <= mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (shl->lnum == lnum)
  	    {
! 		/* partially sort positions by column numbers
! 		 * on the same line */
! 		if (pos->col < posmatch->pos[bot].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[bot];
! 		    posmatch->pos[bot] = tmp;
  		}
  	    }
  	    else
! 	    {
! 		bot = i;
! 		shl->lnum = lnum;
! 	    }
  	}
      }
      posmatch->cur = 0;
!     if (shl->lnum == lnum && bot >= 0)
      {
! 	colnr_T	start = posmatch->pos[bot].col == 0
! 					     ? 0 : posmatch->pos[bot].col - 1;
! 	colnr_T	end = posmatch->pos[bot].col == 0
! 				    ? MAXCOL : start + posmatch->pos[bot].len;
  
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = bot + 1;
! 	return TRUE;
      }
!     return FALSE;
  }
  #endif
  
--- 7785,7836 ----
      colnr_T	    mincol)	/* minimal column for a match */
  {
      int	    i;
!     int	    found = -1;
  
      for (i = posmatch->cur; i < MAXPOSMATCH; i++)
      {
  	llpos_T	*pos = &posmatch->pos[i];
  
  	if (pos->lnum == 0)
  	    break;
! 	if (pos->len == 0 && pos->col < mincol)
  	    continue;
  	if (pos->lnum == lnum)
  	{
! 	    if (found >= 0)
  	    {
! 		/* if this match comes before the one at "found" then swap
! 		 * them */
! 		if (pos->col < posmatch->pos[found].col)
  		{
  		    llpos_T	tmp = *pos;
  
! 		    *pos = posmatch->pos[found];
! 		    posmatch->pos[found] = tmp;
  		}
  	    }
  	    else
! 		found = i;
  	}
      }
      posmatch->cur = 0;
!     if (found >= 0)
      {
! 	colnr_T	start = posmatch->pos[found].col == 0
! 					    ? 0 : posmatch->pos[found].col - 1;
! 	colnr_T	end = posmatch->pos[found].col == 0
! 				   ? MAXCOL : start + posmatch->pos[found].len;
  
+ 	shl->lnum = lnum;
  	shl->rm.startpos[0].lnum = 0;
  	shl->rm.startpos[0].col = start;
  	shl->rm.endpos[0].lnum = 0;
  	shl->rm.endpos[0].col = end;
  	shl->is_addpos = TRUE;
! 	posmatch->cur = found + 1;
! 	return 1;
      }
!     return 0;
  }
  #endif
  
*** ../vim-8.0.0039/src/testdir/test_match.vim	2016-10-15 14:56:25.868257421 +0200
--- src/testdir/test_match.vim	2016-10-16 14:16:10.376350417 +0200
***************
*** 191,197 ****
--- 191,205 ----
    call assert_equal(screenattr(2,2), screenattr(1,7))
    call assert_notequal(screenattr(2,2), screenattr(1,8))
  
+   call clearmatches()
+   call matchaddpos('Error', [[1], [2,2]])
+   redraw!
+   call assert_equal(screenattr(2,2), screenattr(1,1))
+   call assert_equal(screenattr(2,2), screenattr(1,10))
+   call assert_notequal(screenattr(2,2), screenattr(1,11))
+ 
    nohl
+   call clearmatches()
    syntax off
    set hlsearch&
  endfunc
*** ../vim-8.0.0039/src/version.c	2016-10-15 20:46:13.580656069 +0200
--- src/version.c	2016-10-16 14:30:29.174020816 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     40,
  /**/

-- 
It is illegal for anyone to give lighted cigars to dogs, cats, and other
domesticated animal kept as pets.
		[real standing law in Illinois, United States of America]

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
To: vim_dev@googlegroups.com
Subject: Patch 8.0.0041
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.0.0041
Problem:    When using Insert mode completion but not actually inserting
            anything an undo item is still created. (Tommy Allen)
Solution:   Do not call stop_arrow() when not inserting anything.
Files:      src/edit.c, src/testdir/test_popup.vim


*** ../vim-8.0.0040/src/edit.c	2016-10-15 17:06:42.086912756 +0200
--- src/edit.c	2016-10-16 15:34:26.985734970 +0200
***************
*** 2799,2807 ****
  	ins_compl_prep(' ');
      ins_compl_clear();
  
-     if (stop_arrow() == FAIL)
- 	return;
- 
      compl_direction = FORWARD;
      if (startcol > curwin->w_cursor.col)
  	startcol = curwin->w_cursor.col;
--- 2799,2804 ----
***************
*** 3876,3882 ****
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		if (stop_arrow() == OK)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
--- 3873,3880 ----
  		/* put the cursor on the last char, for 'tw' formatting */
  		if (prev_col > 0)
  		    dec_cursor();
! 		/* only format when something was inserted */
! 		if (!arrow_used && !ins_need_undo)
  		    insertchar(NUL, 0, -1);
  		if (prev_col > 0
  			     && ml_get_curline()[curwin->w_cursor.col] != NUL)
*** ../vim-8.0.0040/src/testdir/test_popup.vim	2016-10-15 17:06:42.094912699 +0200
--- src/testdir/test_popup.vim	2016-10-16 15:33:41.586069579 +0200
***************
*** 378,384 ****
    endif
  endfunc
  
! :"Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
--- 378,384 ----
    endif
  endfunc
  
! " Test that 'completefunc' works when it's OK.
  func Test_omnifunc_with_check()
    new
    setlocal omnifunc=DummyCompleteFour
***************
*** 400,403 ****
--- 400,429 ----
    q!
  endfunc
  
+ function UndoComplete()
+   call complete(1, ['January', 'February', 'March',
+         \ 'April', 'May', 'June', 'July', 'August', 'September',
+         \ 'October', 'November', 'December'])
+   return ''
+ endfunc
+ 
+ " Test that no undo item is created when no completion is inserted
+ func Test_complete_no_undo()
+   set completeopt=menu,preview,noinsert,noselect
+   inoremap <Right> <C-R>=UndoComplete()<CR>
+   new
+   call feedkeys("ixxx\<CR>\<CR>yyy\<Esc>k", 'xt')
+   call feedkeys("iaaa\<Esc>0", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("i\<Right>\<Esc>", 'xt')
+   call assert_equal('aaa', getline(2))
+   call feedkeys("u", 'xt')
+   call assert_equal('', getline(2))
+ 
+   iunmap <Right>
+   set completeopt&
+   q!
+ endfunc
+ 
+ 
  " vim: shiftwidth=2 sts=2 expandtab
*** ../vim-8.0.0040/src/version.c	2016-10-16 14:35:44.547696415 +0200
--- src/version.c	2016-10-16 15:35:09.805419375 +0200
***************
*** 766,767 ****
--- 766,769 ----
  {   /* Add new patch number below this line */
+ /**/
+     41,
  /**/

-- 
Sometimes I think the surest sign that intelligent life exists elsewhere
in the universe is that none of it has tried to contact us.     (Calvin)

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
