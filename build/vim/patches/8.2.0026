To: vim_dev@googlegroups.com
Subject: Patch 8.2.0026
Fcc: outbox
From: Bram Moolenaar <Bram@moolenaar.net>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
------------

Patch 8.2.0026
Problem:    Still some /* */ comments.
Solution:   Convert to // comments.
Files:	    src/message.c, src/message_test.c, src/misc1.c, src/misc2.c,
            src/move.c


*** ../vim-8.2.0025/src/message.c	2019-12-11 18:55:01.000000000 +0100
--- src/message.c	2019-12-21 18:17:53.907258172 +0100
***************
*** 11,17 ****
   * message.c: functions for displaying messages on the command line
   */
  
! #define MESSAGE_FILE		/* don't include prototype for smsg() */
  #define USING_FLOAT_STUFF
  
  #include "vim.h"
--- 11,17 ----
   * message.c: functions for displaying messages on the command line
   */
  
! #define MESSAGE_FILE		// don't include prototype for smsg()
  #define USING_FLOAT_STUFF
  
  #include "vim.h"
***************
*** 33,41 ****
  static void redir_write(char_u *s, int maxlen);
  #ifdef FEAT_CON_DIALOG
  static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);
! static int	confirm_msg_used = FALSE;	/* displaying confirm_msg */
! static char_u	*confirm_msg = NULL;		/* ":confirm" message */
! static char_u	*confirm_msg_tail;		/* tail of confirm_msg */
  static void display_confirm_msg(void);
  #endif
  #ifdef FEAT_JOB_CHANNEL
--- 33,41 ----
  static void redir_write(char_u *s, int maxlen);
  #ifdef FEAT_CON_DIALOG
  static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton);
! static int	confirm_msg_used = FALSE;	// displaying confirm_msg
! static char_u	*confirm_msg = NULL;		// ":confirm" message
! static char_u	*confirm_msg_tail;		// tail of confirm_msg
  static void display_confirm_msg(void);
  #endif
  #ifdef FEAT_JOB_CHANNEL
***************
*** 128,141 ****
  msg_attr_keep(
      char	*s,
      int		attr,
!     int		keep)	    /* TRUE: set keep_msg if it doesn't scroll */
  {
      static int	entered = 0;
      int		retval;
      char_u	*buf = NULL;
  
!     /* Skip messages not matching ":filter pattern".
!      * Don't filter when there is an error. */
      if (!emsg_on_display && message_filtered((char_u *)s))
  	return TRUE;
  
--- 128,141 ----
  msg_attr_keep(
      char	*s,
      int		attr,
!     int		keep)	    // TRUE: set keep_msg if it doesn't scroll
  {
      static int	entered = 0;
      int		retval;
      char_u	*buf = NULL;
  
!     // Skip messages not matching ":filter pattern".
!     // Don't filter when there is an error.
      if (!emsg_on_display && message_filtered((char_u *)s))
  	return TRUE;
  
***************
*** 153,160 ****
  	return TRUE;
      ++entered;
  
!     /* Add message to history (unless it's a repeated kept message or a
!      * truncated message) */
      if ((char_u *)s != keep_msg
  	    || (*s != '<'
  		&& last_msg_hist != NULL
--- 153,160 ----
  	return TRUE;
      ++entered;
  
!     // Add message to history (unless it's a repeated kept message or a
!     // truncated message)
      if ((char_u *)s != keep_msg
  	    || (*s != '<'
  		&& last_msg_hist != NULL
***************
*** 164,174 ****
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
! 	/* Write message in the channel log. */
  	ch_log(NULL, "ERROR: %s", (char *)s);
  #endif
  
!     /* Truncate the message if needed. */
      msg_start();
      buf = msg_strtrunc((char_u *)s, FALSE);
      if (buf != NULL)
--- 164,174 ----
  
  #ifdef FEAT_JOB_CHANNEL
      if (emsg_to_channel_log)
! 	// Write message in the channel log.
  	ch_log(NULL, "ERROR: %s", (char *)s);
  #endif
  
!     // Truncate the message if needed.
      msg_start();
      buf = msg_strtrunc((char_u *)s, FALSE);
      if (buf != NULL)
***************
*** 194,224 ****
      char_u *
  msg_strtrunc(
      char_u	*s,
!     int		force)	    /* always truncate */
  {
      char_u	*buf = NULL;
      int		len;
      int		room;
  
!     /* May truncate message to avoid a hit-return prompt */
      if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)
  			       && !exmode_active && msg_silent == 0) || force)
      {
  	len = vim_strsize(s);
  	if (msg_scrolled != 0)
! 	    /* Use all the columns. */
  	    room = (int)(Rows - msg_row) * Columns - 1;
  	else
! 	    /* Use up to 'showcmd' column. */
  	    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;
  	if (len > room && room > 0)
  	{
  	    if (enc_utf8)
! 		/* may have up to 18 bytes per cell (6 per char, up to two
! 		 * composing chars) */
  		len = (room + 2) * 18;
  	    else if (enc_dbcs == DBCS_JPNU)
! 		/* may have up to 2 bytes per cell for euc-jp */
  		len = (room + 2) * 2;
  	    else
  		len = room + 2;
--- 194,224 ----
      char_u *
  msg_strtrunc(
      char_u	*s,
!     int		force)	    // always truncate
  {
      char_u	*buf = NULL;
      int		len;
      int		room;
  
!     // May truncate message to avoid a hit-return prompt
      if ((!msg_scroll && !need_wait_return && shortmess(SHM_TRUNCALL)
  			       && !exmode_active && msg_silent == 0) || force)
      {
  	len = vim_strsize(s);
  	if (msg_scrolled != 0)
! 	    // Use all the columns.
  	    room = (int)(Rows - msg_row) * Columns - 1;
  	else
! 	    // Use up to 'showcmd' column.
  	    room = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;
  	if (len > room && room > 0)
  	{
  	    if (enc_utf8)
! 		// may have up to 18 bytes per cell (6 per char, up to two
! 		// composing chars)
  		len = (room + 2) * 18;
  	    else if (enc_dbcs == DBCS_JPNU)
! 		// may have up to 2 bytes per cell for euc-jp
  		len = (room + 2) * 2;
  	    else
  		len = room + 2;
***************
*** 241,247 ****
      int		room_in,
      int		buflen)
  {
!     size_t	room = room_in - 3; /* "..." takes 3 chars */
      size_t	half;
      size_t	len = 0;
      int		e;
--- 241,247 ----
      int		room_in,
      int		buflen)
  {
!     size_t	room = room_in - 3; // "..." takes 3 chars
      size_t	half;
      size_t	len = 0;
      int		e;
***************
*** 252,263 ****
  	room = 0;
      half = room / 2;
  
!     /* First part: Start of the string. */
      for (e = 0; len < half && e < buflen; ++e)
      {
  	if (s[e] == NUL)
  	{
! 	    /* text fits without truncating! */
  	    buf[e] = NUL;
  	    return;
  	}
--- 252,263 ----
  	room = 0;
      half = room / 2;
  
!     // First part: Start of the string.
      for (e = 0; len < half && e < buflen; ++e)
      {
  	if (s[e] == NUL)
  	{
! 	    // text fits without truncating!
  	    buf[e] = NUL;
  	    return;
  	}
***************
*** 275,287 ****
  	    }
      }
  
!     /* Last part: End of the string. */
      i = e;
      if (enc_dbcs != 0)
      {
! 	/* For DBCS going backwards in a string is slow, but
! 	 * computing the cell width isn't too slow: go forward
! 	 * until the rest fits. */
  	n = vim_strsize(s + i);
  	while (len + n > room)
  	{
--- 275,287 ----
  	    }
      }
  
!     // Last part: End of the string.
      i = e;
      if (enc_dbcs != 0)
      {
! 	// For DBCS going backwards in a string is slow, but
! 	// computing the cell width isn't too slow: go forward
! 	// until the rest fits.
  	n = vim_strsize(s + i);
  	while (len + n > room)
  	{
***************
*** 291,297 ****
      }
      else if (enc_utf8)
      {
! 	/* For UTF-8 we can go backwards easily. */
  	half = i = (int)STRLEN(s);
  	for (;;)
  	{
--- 291,297 ----
      }
      else if (enc_utf8)
      {
! 	// For UTF-8 we can go backwards easily.
  	half = i = (int)STRLEN(s);
  	for (;;)
  	{
***************
*** 314,320 ****
  
      if (i <= e + 3)
      {
! 	/* text fits without truncating */
  	if (s != buf)
  	{
  	    len = STRLEN(s);
--- 314,320 ----
  
      if (i <= e + 3)
      {
! 	// text fits without truncating
  	if (s != buf)
  	{
  	    len = STRLEN(s);
***************
*** 329,335 ****
      }
      else if (e + 3 < buflen)
      {
! 	/* set the middle and copy the last part */
  	mch_memmove(buf + e, "...", (size_t)3);
  	len = STRLEN(s + i) + 1;
  	if (len >= (size_t)buflen - e - 3)
--- 329,335 ----
      }
      else if (e + 3 < buflen)
      {
! 	// set the middle and copy the last part
  	mch_memmove(buf + e, "...", (size_t)3);
  	len = STRLEN(s + i) + 1;
  	if (len >= (size_t)buflen - e - 3)
***************
*** 339,345 ****
      }
      else
      {
! 	/* can't fit in the "...", just truncate it */
  	buf[e - 1] = NUL;
      }
  }
--- 339,345 ----
      }
      else
      {
! 	// can't fit in the "...", just truncate it
  	buf[e - 1] = NUL;
      }
  }
***************
*** 479,486 ****
  {
      char_u	*Buf, *p;
  
!     /* lnum is 0 when executing a command from the command line
!      * argument, we don't want a line number then */
      if (sourcing_name != NULL
  	    && (other_sourcing_name() || sourcing_lnum != last_sourcing_lnum)
  	    && sourcing_lnum != 0)
--- 479,486 ----
  {
      char_u	*Buf, *p;
  
!     // lnum is 0 when executing a command from the command line
!     // argument, we don't want a line number then
      if (sourcing_name != NULL
  	    && (other_sourcing_name() || sourcing_lnum != last_sourcing_lnum)
  	    && sourcing_lnum != 0)
***************
*** 516,525 ****
      {
  	msg_attr((char *)p, HL_ATTR(HLF_N));
  	vim_free(p);
! 	last_sourcing_lnum = sourcing_lnum;  /* only once for each line */
      }
  
!     /* remember the last sourcing name printed, also when it's empty */
      if (sourcing_name == NULL || other_sourcing_name())
      {
  	vim_free(last_sourcing_name);
--- 516,525 ----
      {
  	msg_attr((char *)p, HL_ATTR(HLF_N));
  	vim_free(p);
! 	last_sourcing_lnum = sourcing_lnum;  // only once for each line
      }
  
!     // remember the last sourcing name printed, also when it's empty
      if (sourcing_name == NULL || other_sourcing_name())
      {
  	vim_free(last_sourcing_name);
***************
*** 614,630 ****
  #endif
  
  #ifdef FEAT_EVAL
!     /* When testing some errors are turned into a normal message. */
      if (ignore_error(s))
! 	/* don't call msg() if it results in a dialog */
  	return msg_use_printf() ? FALSE : msg((char *)s);
  #endif
  
      called_emsg = TRUE;
  
  #ifdef FEAT_EVAL
!     /* If "emsg_severe" is TRUE: When an error exception is to be thrown,
!      * prefer this message over previous messages for the same command. */
      severe = emsg_severe;
      emsg_severe = FALSE;
  #endif
--- 614,630 ----
  #endif
  
  #ifdef FEAT_EVAL
!     // When testing some errors are turned into a normal message.
      if (ignore_error(s))
! 	// don't call msg() if it results in a dialog
  	return msg_use_printf() ? FALSE : msg((char *)s);
  #endif
  
      called_emsg = TRUE;
  
  #ifdef FEAT_EVAL
!     // If "emsg_severe" is TRUE: When an error exception is to be thrown,
!     // prefer this message over previous messages for the same command.
      severe = emsg_severe;
      emsg_severe = FALSE;
  #endif
***************
*** 646,652 ****
  	    return TRUE;
  	}
  
! 	/* set "v:errmsg", also when using ":silent! cmd" */
  	set_vim_var_string(VV_ERRMSG, s, -1);
  #endif
  
--- 646,652 ----
  	    return TRUE;
  	}
  
! 	// set "v:errmsg", also when using ":silent! cmd"
  	set_vim_var_string(VV_ERRMSG, s, -1);
  #endif
  
***************
*** 683,698 ****
  
  	ex_exitval = 1;
  
! 	/* Reset msg_silent, an error causes messages to be switched back on.
! 	 */
  	msg_silent = 0;
  	cmd_silent = FALSE;
  
! 	if (global_busy)		/* break :global command */
  	    ++global_busy;
  
  	if (p_eb)
! 	    beep_flush();		/* also includes flush_buffers() */
  	else
  	    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers
  	++did_emsg;			   // flag for DoOneCmd()
--- 683,697 ----
  
  	ex_exitval = 1;
  
! 	// Reset msg_silent, an error causes messages to be switched back on.
  	msg_silent = 0;
  	cmd_silent = FALSE;
  
! 	if (global_busy)		// break :global command
  	    ++global_busy;
  
  	if (p_eb)
! 	    beep_flush();		// also includes flush_buffers()
  	else
  	    flush_buffers(FLUSH_MINIMAL);  // flush internal buffers
  	++did_emsg;			   // flag for DoOneCmd()
***************
*** 701,714 ****
  #endif
      }
  
!     emsg_on_display = TRUE;	/* remember there is an error message */
!     ++msg_scroll;		/* don't overwrite a previous message */
!     attr = HL_ATTR(HLF_E);	/* set highlight mode for error messages */
      if (msg_scrolled != 0)
! 	need_wait_return = TRUE;    /* needed in case emsg() is called after
! 				     * wait_return has reset need_wait_return
! 				     * and a redraw is expected because
! 				     * msg_scrolled is non-zero */
  
  #ifdef FEAT_JOB_CHANNEL
      emsg_to_channel_log = TRUE;
--- 700,713 ----
  #endif
      }
  
!     emsg_on_display = TRUE;	// remember there is an error message
!     ++msg_scroll;		// don't overwrite a previous message
!     attr = HL_ATTR(HLF_E);	// set highlight mode for error messages
      if (msg_scrolled != 0)
! 	need_wait_return = TRUE;    // needed in case emsg() is called after
! 				    // wait_return has reset need_wait_return
! 				    // and a redraw is expected because
! 				    // msg_scrolled is non-zero
  
  #ifdef FEAT_JOB_CHANNEL
      emsg_to_channel_log = TRUE;
***************
*** 721,727 ****
      /*
       * Display the error message itself.
       */
!     msg_nowait = FALSE;			/* wait for this msg */
      r = msg_attr((char *)s, attr);
  
  #ifdef FEAT_JOB_CHANNEL
--- 720,726 ----
      /*
       * Display the error message itself.
       */
!     msg_nowait = FALSE;			// wait for this msg
      r = msg_attr((char *)s, attr);
  
  #ifdef FEAT_JOB_CHANNEL
***************
*** 736,745 ****
      int
  emsg(char *s)
  {
!     /* Skip this if not giving error messages at the moment. */
      if (!emsg_not_now())
  	return emsg_core((char_u *)s);
!     return TRUE;		/* no error messages at the moment */
  }
  
  #ifndef PROTO  // manual proto with __attribute__
--- 735,744 ----
      int
  emsg(char *s)
  {
!     // Skip this if not giving error messages at the moment.
      if (!emsg_not_now())
  	return emsg_core((char_u *)s);
!     return TRUE;		// no error messages at the moment
  }
  
  #ifndef PROTO  // manual proto with __attribute__
***************
*** 831,837 ****
      siemsg(_(e_intern2), where);
  }
  
! /* emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes. */
  
      void
  emsg_invreg(int name)
--- 830,836 ----
      siemsg(_(e_intern2), where);
  }
  
! // emsg3() and emsgn() are in misc2.c to avoid warnings for the prototypes.
  
      void
  emsg_invreg(int name)
***************
*** 851,857 ****
      int		n;
      char	*ts;
  
!     /* Add message to history before truncating */
      add_msg_hist((char_u *)s, -1, attr);
  
      ts = (char *)msg_may_trunc(force, (char_u *)s);
--- 850,856 ----
      int		n;
      char	*ts;
  
!     // Add message to history before truncating
      add_msg_hist((char_u *)s, -1, attr);
  
      ts = (char *)msg_may_trunc(force, (char_u *)s);
***************
*** 884,890 ****
  	{
  	    int	size = vim_strsize(s);
  
! 	    /* There may be room anyway when there are multibyte chars. */
  	    if (size <= room)
  		return s;
  
--- 883,889 ----
  	{
  	    int	size = vim_strsize(s);
  
! 	    // There may be room anyway when there are multibyte chars.
  	    if (size <= room)
  		return s;
  
***************
*** 904,910 ****
      static void
  add_msg_hist(
      char_u	*s,
!     int		len,		/* -1 for undetermined length */
      int		attr)
  {
      struct msg_hist *p;
--- 903,909 ----
      static void
  add_msg_hist(
      char_u	*s,
!     int		len,		// -1 for undetermined length
      int		attr)
  {
      struct msg_hist *p;
***************
*** 912,928 ****
      if (msg_hist_off || msg_silent != 0)
  	return;
  
!     /* Don't let the message history get too big */
      while (msg_hist_len > MAX_MSG_HIST_LEN)
  	(void)delete_first_msg();
  
!     /* allocate an entry and add the message at the end of the history */
      p = ALLOC_ONE(struct msg_hist);
      if (p != NULL)
      {
  	if (len < 0)
  	    len = (int)STRLEN(s);
! 	/* remove leading and trailing newlines */
  	while (len > 0 && *s == '\n')
  	{
  	    ++s;
--- 911,927 ----
      if (msg_hist_off || msg_silent != 0)
  	return;
  
!     // Don't let the message history get too big
      while (msg_hist_len > MAX_MSG_HIST_LEN)
  	(void)delete_first_msg();
  
!     // allocate an entry and add the message at the end of the history
      p = ALLOC_ONE(struct msg_hist);
      if (p != NULL)
      {
  	if (len < 0)
  	    len = (int)STRLEN(s);
! 	// remove leading and trailing newlines
  	while (len > 0 && *s == '\n')
  	{
  	    ++s;
***************
*** 956,962 ****
      p = first_msg_hist;
      first_msg_hist = p->next;
      if (first_msg_hist == NULL)
! 	last_msg_hist = NULL;  /* history is empty */
      vim_free(p->msg);
      vim_free(p);
      --msg_hist_len;
--- 955,961 ----
      p = first_msg_hist;
      first_msg_hist = p->next;
      if (first_msg_hist == NULL)
! 	last_msg_hist = NULL;  // history is empty
      vim_free(p->msg);
      vim_free(p);
      --msg_hist_len;
***************
*** 993,1005 ****
      p = first_msg_hist;
      if (eap->addr_count != 0)
      {
! 	/* Count total messages */
  	for (; p != NULL && !got_int; p = p->next)
  	    c++;
  
  	c -= eap->line2;
  
! 	/* Skip without number of messages specified */
  	for (p = first_msg_hist; p != NULL && !got_int && c > 0;
  						    p = p->next, c--);
      }
--- 992,1004 ----
      p = first_msg_hist;
      if (eap->addr_count != 0)
      {
! 	// Count total messages
  	for (; p != NULL && !got_int; p = p->next)
  	    c++;
  
  	c -= eap->line2;
  
! 	// Skip without number of messages specified
  	for (p = first_msg_hist; p != NULL && !got_int && c > 0;
  						    p = p->next, c--);
      }
***************
*** 1017,1023 ****
  		    HL_ATTR(HLF_T));
      }
  
!     /* Display what was not skipped. */
      for (; p != NULL && !got_int; p = p->next)
  	if (p->msg != NULL)
  	    msg_attr((char *)p->msg, p->attr);
--- 1016,1022 ----
  		    HL_ATTR(HLF_T));
      }
  
!     // Display what was not skipped.
      for (; p != NULL && !got_int; p = p->next)
  	if (p->msg != NULL)
  	    msg_attr((char *)p->msg, p->attr);
***************
*** 1061,1068 ****
      if (redraw == TRUE)
  	must_redraw = CLEAR;
  
!     /* If using ":silent cmd", don't wait for a return.  Also don't set
!      * need_wait_return to do it later. */
      if (msg_silent != 0)
  	return;
  
--- 1060,1067 ----
      if (redraw == TRUE)
  	must_redraw = CLEAR;
  
!     // If using ":silent cmd", don't wait for a return.  Also don't set
!     // need_wait_return to do it later.
      if (msg_silent != 0)
  	return;
  
***************
*** 1082,1117 ****
  	return;
      }
  
!     redir_off = TRUE;		/* don't redirect this message */
      oldState = State;
      if (quit_more)
      {
! 	c = CAR;		/* just pretend CR was hit */
  	quit_more = FALSE;
  	got_int = FALSE;
      }
      else if (exmode_active)
      {
! 	msg_puts(" ");		/* make sure the cursor is on the right line */
! 	c = CAR;		/* no need for a return in ex mode */
  	got_int = FALSE;
      }
      else
      {
! 	/* Make sure the hit-return prompt is on screen when 'guioptions' was
! 	 * just changed. */
  	screenalloc(FALSE);
  
  	State = HITRETURN;
  	setmouse();
  #ifdef USE_ON_FLY_SCROLL
! 	dont_scroll = TRUE;		/* disallow scrolling here */
  #endif
  	cmdline_row = msg_row;
  
! 	/* Avoid the sequence that the user types ":" at the hit-return prompt
! 	 * to start an Ex command, but the file-changed dialog gets in the
! 	 * way. */
  	if (need_check_timestamps)
  	    check_timestamps(FALSE);
  
--- 1081,1116 ----
  	return;
      }
  
!     redir_off = TRUE;		// don't redirect this message
      oldState = State;
      if (quit_more)
      {
! 	c = CAR;		// just pretend CR was hit
  	quit_more = FALSE;
  	got_int = FALSE;
      }
      else if (exmode_active)
      {
! 	msg_puts(" ");		// make sure the cursor is on the right line
! 	c = CAR;		// no need for a return in ex mode
  	got_int = FALSE;
      }
      else
      {
! 	// Make sure the hit-return prompt is on screen when 'guioptions' was
! 	// just changed.
  	screenalloc(FALSE);
  
  	State = HITRETURN;
  	setmouse();
  #ifdef USE_ON_FLY_SCROLL
! 	dont_scroll = TRUE;		// disallow scrolling here
  #endif
  	cmdline_row = msg_row;
  
! 	// Avoid the sequence that the user types ":" at the hit-return prompt
! 	// to start an Ex command, but the file-changed dialog gets in the
! 	// way.
  	if (need_check_timestamps)
  	    check_timestamps(FALSE);
  
***************
*** 1119,1136 ****
  
  	do
  	{
! 	    /* Remember "got_int", if it is set vgetc() probably returns a
! 	     * CTRL-C, but we need to loop then. */
  	    had_got_int = got_int;
  
! 	    /* Don't do mappings here, we put the character back in the
! 	     * typeahead buffer. */
  	    ++no_mapping;
  	    ++allow_keys;
  
! 	    /* Temporarily disable Recording. If Recording is active, the
! 	     * character will be recorded later, since it will be added to the
! 	     * typebuf after the loop */
  	    save_reg_recording = reg_recording;
  	    save_scriptout = scriptout;
  	    reg_recording = 0;
--- 1118,1135 ----
  
  	do
  	{
! 	    // Remember "got_int", if it is set vgetc() probably returns a
! 	    // CTRL-C, but we need to loop then.
  	    had_got_int = got_int;
  
! 	    // Don't do mappings here, we put the character back in the
! 	    // typeahead buffer.
  	    ++no_mapping;
  	    ++allow_keys;
  
! 	    // Temporarily disable Recording. If Recording is active, the
! 	    // character will be recorded later, since it will be added to the
! 	    // typebuf after the loop
  	    save_reg_recording = reg_recording;
  	    save_scriptout = scriptout;
  	    reg_recording = 0;
***************
*** 1144,1152 ****
  	    scriptout = save_scriptout;
  
  #ifdef FEAT_CLIPBOARD
! 	    /* Strange way to allow copying (yanking) a modeless selection at
! 	     * the hit-enter prompt.  Use CTRL-Y, because the same is used in
! 	     * Cmdline-mode and it's harmless when there is no selection. */
  	    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)
  	    {
  		clip_copy_modeless_selection(TRUE);
--- 1143,1151 ----
  	    scriptout = save_scriptout;
  
  #ifdef FEAT_CLIPBOARD
! 	    // Strange way to allow copying (yanking) a modeless selection at
! 	    // the hit-enter prompt.  Use CTRL-Y, because the same is used in
! 	    // Cmdline-mode and it's harmless when there is no selection.
  	    if (c == Ctrl_Y && clip_star.state == SELECT_DONE)
  	    {
  		clip_copy_modeless_selection(TRUE);
***************
*** 1166,1172 ****
  						|| c == K_UP || c == K_PAGEUP)
  		{
  		    if (msg_scrolled > Rows)
! 			/* scroll back to show older messages */
  			do_more_prompt(c);
  		    else
  		    {
--- 1165,1171 ----
  						|| c == K_UP || c == K_PAGEUP)
  		{
  		    if (msg_scrolled > Rows)
! 			// scroll back to show older messages
  			do_more_prompt(c);
  		    else
  		    {
***************
*** 1180,1186 ****
  		    }
  		    if (quit_more)
  		    {
! 			c = CAR;		/* just pretend CR was hit */
  			quit_more = FALSE;
  			got_int = FALSE;
  		    }
--- 1179,1185 ----
  		    }
  		    if (quit_more)
  		    {
! 			c = CAR;		// just pretend CR was hit
  			quit_more = FALSE;
  			got_int = FALSE;
  		    }
***************
*** 1223,1233 ****
  	    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);
  	else if (vim_strchr((char_u *)"\r\n ", c) == NULL && c != Ctrl_C)
  	{
! 	    /* Put the character back in the typeahead buffer.  Don't use the
! 	     * stuff buffer, because lmaps wouldn't work. */
  	    ins_char_typebuf(c);
! 	    do_redraw = TRUE;	    /* need a redraw even though there is
! 				       typeahead */
  	}
      }
      redir_off = FALSE;
--- 1222,1232 ----
  	    (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);
  	else if (vim_strchr((char_u *)"\r\n ", c) == NULL && c != Ctrl_C)
  	{
! 	    // Put the character back in the typeahead buffer.  Don't use the
! 	    // stuff buffer, because lmaps wouldn't work.
  	    ins_char_typebuf(c);
! 	    do_redraw = TRUE;	    // need a redraw even though there is
! 				    // typeahead
  	}
      }
      redir_off = FALSE;
***************
*** 1240,1246 ****
      {
  	if (!exmode_active)
  	    cmdline_row = msg_row;
! 	skip_redraw = TRUE;	    /* skip redraw once */
  	do_redraw = FALSE;
  #ifdef FEAT_TERMINAL
  	skip_term_loop = TRUE;
--- 1239,1245 ----
      {
  	if (!exmode_active)
  	    cmdline_row = msg_row;
! 	skip_redraw = TRUE;	    // skip redraw once
  	do_redraw = FALSE;
  #ifdef FEAT_TERMINAL
  	skip_term_loop = TRUE;
***************
*** 1253,1259 ****
       * typed.
       */
      tmpState = State;
!     State = oldState;		    /* restore State before set_shellsize */
      setmouse();
      msg_check();
  
--- 1252,1258 ----
       * typed.
       */
      tmpState = State;
!     State = oldState;		    // restore State before set_shellsize
      setmouse();
      msg_check();
  
***************
*** 1267,1288 ****
  
      need_wait_return = FALSE;
      did_wait_return = TRUE;
!     emsg_on_display = FALSE;	/* can delete error message now */
!     lines_left = -1;		/* reset lines_left at next msg_start() */
      reset_last_sourcing();
      if (keep_msg != NULL && vim_strsize(keep_msg) >=
  				  (Rows - cmdline_row - 1) * Columns + sc_col)
! 	VIM_CLEAR(keep_msg);	    /* don't redisplay message, it's too long */
  
!     if (tmpState == SETWSIZE)	    /* got resize event while in vgetc() */
      {
! 	starttermcap();		    /* start termcap before redrawing */
  	shell_resized();
      }
      else if (!skip_redraw
  	    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))
      {
! 	starttermcap();		    /* start termcap before redrawing */
  	redraw_later(VALID);
      }
  }
--- 1266,1287 ----
  
      need_wait_return = FALSE;
      did_wait_return = TRUE;
!     emsg_on_display = FALSE;	// can delete error message now
!     lines_left = -1;		// reset lines_left at next msg_start()
      reset_last_sourcing();
      if (keep_msg != NULL && vim_strsize(keep_msg) >=
  				  (Rows - cmdline_row - 1) * Columns + sc_col)
! 	VIM_CLEAR(keep_msg);	    // don't redisplay message, it's too long
  
!     if (tmpState == SETWSIZE)	    // got resize event while in vgetc()
      {
! 	starttermcap();		    // start termcap before redrawing
  	shell_resized();
      }
      else if (!skip_redraw
  	    && (redraw == TRUE || (msg_scrolled != 0 && redraw != -1)))
      {
! 	starttermcap();		    // start termcap before redrawing
  	redraw_later(VALID);
      }
  }
***************
*** 1295,1302 ****
  {
      int		save_p_more = p_more;
  
!     p_more = FALSE;	/* don't want see this message when scrolling back */
!     if (msg_didout)	/* start on a new line */
  	msg_putchar('\n');
      if (got_int)
  	msg_puts(_("Interrupt: "));
--- 1294,1301 ----
  {
      int		save_p_more = p_more;
  
!     p_more = FALSE;	// don't want see this message when scrolling back
!     if (msg_didout)	// start on a new line
  	msg_putchar('\n');
      if (got_int)
  	msg_puts(_("Interrupt: "));
***************
*** 1350,1363 ****
  #ifdef FEAT_EVAL
      if (need_clr_eos)
      {
! 	/* Halfway an ":echo" command and getting an (error) message: clear
! 	 * any text from the command. */
  	need_clr_eos = FALSE;
  	msg_clr_eos();
      }
  #endif
  
!     if (!msg_scroll && full_screen)	/* overwrite last message */
      {
  	msg_row = cmdline_row;
  	msg_col =
--- 1349,1362 ----
  #ifdef FEAT_EVAL
      if (need_clr_eos)
      {
! 	// Halfway an ":echo" command and getting an (error) message: clear
! 	// any text from the command.
  	need_clr_eos = FALSE;
  	msg_clr_eos();
      }
  #endif
  
!     if (!msg_scroll && full_screen)	// overwrite last message
      {
  	msg_row = cmdline_row;
  	msg_col =
***************
*** 1366,1372 ****
  #endif
  	    0;
      }
!     else if (msg_didout)		    /* start message on next line */
      {
  	msg_putchar('\n');
  	did_return = TRUE;
--- 1365,1371 ----
  #endif
  	    0;
      }
!     else if (msg_didout)		    // start message on next line
      {
  	msg_putchar('\n');
  	did_return = TRUE;
***************
*** 1377,1387 ****
  	msg_starthere();
      if (msg_silent == 0)
      {
! 	msg_didout = FALSE;		    /* no output on current line yet */
  	cursor_off();
      }
  
!     /* when redirecting, may need to start a new line. */
      if (!did_return)
  	redir_write((char_u *)"\n", -1);
  }
--- 1376,1386 ----
  	msg_starthere();
      if (msg_silent == 0)
      {
! 	msg_didout = FALSE;		    // no output on current line yet
  	cursor_off();
      }
  
!     // when redirecting, may need to start a new line.
      if (!did_return)
  	redir_write((char_u *)"\n", -1);
  }
***************
*** 1505,1519 ****
      int		mb_l;
      int		c;
  
!     /* if MSG_HIST flag set, add message to history */
      if (attr & MSG_HIST)
      {
  	add_msg_hist(str, len, attr);
  	attr &= ~MSG_HIST;
      }
  
!     /* If the string starts with a composing character first draw a space on
!      * which the composing char can be drawn. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))
  	msg_puts_attr(" ", attr);
  
--- 1504,1518 ----
      int		mb_l;
      int		c;
  
!     // if MSG_HIST flag set, add message to history
      if (attr & MSG_HIST)
      {
  	add_msg_hist(str, len, attr);
  	attr &= ~MSG_HIST;
      }
  
!     // If the string starts with a composing character first draw a space on
!     // which the composing char can be drawn.
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(msgstr)))
  	msg_puts_attr(" ", attr);
  
***************
*** 1524,1530 ****
      while (--len >= 0)
      {
  	if (enc_utf8)
! 	    /* Don't include composing chars after the end. */
  	    mb_l = utfc_ptr2len_len(str, len + 1);
  	else if (has_mbyte)
  	    mb_l = (*mb_ptr2len)(str);
--- 1523,1529 ----
      while (--len >= 0)
      {
  	if (enc_utf8)
! 	    // Don't include composing chars after the end.
  	    mb_l = utfc_ptr2len_len(str, len + 1);
  	else if (has_mbyte)
  	    mb_l = (*mb_ptr2len)(str);
***************
*** 1534,1545 ****
  	{
  	    c = (*mb_ptr2char)(str);
  	    if (vim_isprintc(c))
! 		/* printable multi-byte char: count the cells. */
  		retval += (*mb_ptr2cells)(str);
  	    else
  	    {
! 		/* unprintable multi-byte char: print the printable chars so
! 		 * far and the translation of the unprintable char. */
  		if (str > plain_start)
  		    msg_puts_attr_len((char *)plain_start,
  					       (int)(str - plain_start), attr);
--- 1533,1544 ----
  	{
  	    c = (*mb_ptr2char)(str);
  	    if (vim_isprintc(c))
! 		// printable multi-byte char: count the cells.
  		retval += (*mb_ptr2cells)(str);
  	    else
  	    {
! 		// unprintable multi-byte char: print the printable chars so
! 		// far and the translation of the unprintable char.
  		if (str > plain_start)
  		    msg_puts_attr_len((char *)plain_start,
  					       (int)(str - plain_start), attr);
***************
*** 1556,1563 ****
  	    s = transchar_byte(*str);
  	    if (s[1] != NUL)
  	    {
! 		/* unprintable char: print the printable chars so far and the
! 		 * translation of the unprintable char. */
  		if (str > plain_start)
  		    msg_puts_attr_len((char *)plain_start,
  					       (int)(str - plain_start), attr);
--- 1555,1562 ----
  	    s = transchar_byte(*str);
  	    if (s[1] != NUL)
  	    {
! 		// unprintable char: print the printable chars so far and the
! 		// translation of the unprintable char.
  		if (str > plain_start)
  		    msg_puts_attr_len((char *)plain_start,
  					       (int)(str - plain_start), attr);
***************
*** 1572,1578 ****
      }
  
      if (str > plain_start)
! 	/* print the printable chars at the end */
  	msg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);
  
      return retval;
--- 1571,1577 ----
      }
  
      if (str > plain_start)
! 	// print the printable chars at the end
  	msg_puts_attr_len((char *)plain_start, (int)(str - plain_start), attr);
  
      return retval;
***************
*** 1627,1633 ****
      attr = HL_ATTR(HLF_8);
      while (*str != NUL)
      {
! 	/* Leading and trailing spaces need to be displayed in <> form. */
  	if ((str == strstart || str[1] == NUL) && *str == ' ')
  	{
  	    text = "<Space>";
--- 1626,1632 ----
      attr = HL_ATTR(HLF_8);
      while (*str != NUL)
      {
! 	// Leading and trailing spaces need to be displayed in <> form.
  	if ((str == strstart || str[1] == NUL) && *str == ' ')
  	{
  	    text = "<Space>";
***************
*** 1638,1644 ****
  	len = vim_strsize((char_u *)text);
  	if (maxlen > 0 && retval + len >= maxlen)
  	    break;
! 	/* Highlight special keys */
  	msg_puts_attr(text, len > 1
  		&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);
  	retval += len;
--- 1637,1643 ----
  	len = vim_strsize((char_u *)text);
  	if (maxlen > 0 && retval + len >= maxlen)
  	    break;
! 	// Highlight special keys
  	msg_puts_attr(text, len > 1
  		&& (*mb_ptr2len)((char_u *)text) <= 1 ? attr : 0);
  	retval += len;
***************
*** 1654,1660 ****
      char_u *
  str2special_save(
      char_u  *str,
!     int	    is_lhs)  /* TRUE for lhs, FALSE for rhs */
  {
      garray_T	ga;
      char_u	*p = str;
--- 1653,1659 ----
      char_u *
  str2special_save(
      char_u  *str,
!     int	    is_lhs)  // TRUE for lhs, FALSE for rhs
  {
      garray_T	ga;
      char_u	*p = str;
***************
*** 1675,1681 ****
      char_u *
  str2special(
      char_u	**sp,
!     int		from)	/* TRUE for lhs of mapping */
  {
      int			c;
      static char_u	buf[7];
--- 1674,1680 ----
      char_u *
  str2special(
      char_u	**sp,
!     int		from)	// TRUE for lhs of mapping
  {
      int			c;
      static char_u	buf[7];
***************
*** 1687,1694 ****
      {
  	char_u	*p;
  
! 	/* Try to un-escape a multi-byte character.  Return the un-escaped
! 	 * string if it is a multi-byte character. */
  	p = mb_unescape(sp);
  	if (p != NULL)
  	    return p;
--- 1686,1693 ----
      {
  	char_u	*p;
  
! 	// Try to un-escape a multi-byte character.  Return the un-escaped
! 	// string if it is a multi-byte character.
  	p = mb_unescape(sp);
  	if (p != NULL)
  	    return p;
***************
*** 1708,1714 ****
  	    c = TO_SPECIAL(str[1], str[2]);
  	    str += 2;
  	}
! 	if (IS_SPECIAL(c) || modifiers)	/* special key */
  	    special = TRUE;
      }
  
--- 1707,1713 ----
  	    c = TO_SPECIAL(str[1], str[2]);
  	    str += 2;
  	}
! 	if (IS_SPECIAL(c) || modifiers)	// special key
  	    special = TRUE;
      }
  
***************
*** 1716,1738 ****
      {
  	int len = (*mb_ptr2len)(str);
  
! 	/* For multi-byte characters check for an illegal byte. */
  	if (has_mbyte && MB_BYTE2LEN(*str) > len)
  	{
  	    transchar_nonprint(buf, c);
  	    *sp = str + 1;
  	    return buf;
  	}
! 	/* Since 'special' is TRUE the multi-byte character 'c' will be
! 	 * processed by get_special_key_name() */
  	c = (*mb_ptr2char)(str);
  	*sp = str + len;
      }
      else
  	*sp = str + 1;
  
!     /* Make unprintable characters in <> form, also <M-Space> and <Tab>.
!      * Use <Space> only for lhs of a mapping. */
      if (special || char2cells(c) > 1 || (from && c == ' '))
  	return get_special_key_name(c, modifiers);
      buf[0] = c;
--- 1715,1737 ----
      {
  	int len = (*mb_ptr2len)(str);
  
! 	// For multi-byte characters check for an illegal byte.
  	if (has_mbyte && MB_BYTE2LEN(*str) > len)
  	{
  	    transchar_nonprint(buf, c);
  	    *sp = str + 1;
  	    return buf;
  	}
! 	// Since 'special' is TRUE the multi-byte character 'c' will be
! 	// processed by get_special_key_name()
  	c = (*mb_ptr2char)(str);
  	*sp = str + len;
      }
      else
  	*sp = str + 1;
  
!     // Make unprintable characters in <> form, also <M-Space> and <Tab>.
!     // Use <Space> only for lhs of a mapping.
      if (special || char2cells(c) > 1 || (from && c == ' '))
  	return get_special_key_name(c, modifiers);
      buf[0] = c;
***************
*** 1768,1774 ****
      int		n_extra = 0;
      int		c_extra = 0;
      int		c_final = 0;
!     char_u	*p_extra = NULL;	    /* init to make SASC shut up */
      int		n;
      int		attr = 0;
      char_u	*trail = NULL;
--- 1767,1773 ----
      int		n_extra = 0;
      int		c_extra = 0;
      int		c_final = 0;
!     char_u	*p_extra = NULL;	    // init to make SASC shut up
      int		n;
      int		attr = 0;
      char_u	*trail = NULL;
***************
*** 1778,1784 ****
      if (curwin->w_p_list)
  	list = TRUE;
  
!     /* find start of trailing whitespace */
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
--- 1777,1783 ----
      if (curwin->w_p_list)
  	list = TRUE;
  
!     // find start of trailing whitespace
      if (list && lcs_trail)
      {
  	trail = s + STRLEN(s);
***************
*** 1786,1793 ****
  	    --trail;
      }
  
!     /* output a space for an empty line, otherwise the line will be
!      * overwritten */
      if (*s == NUL && !(list && lcs_eol != NUL))
  	msg_putchar(' ');
  
--- 1785,1792 ----
  	    --trail;
      }
  
!     // output a space for an empty line, otherwise the line will be
!     // overwritten
      if (*s == NUL && !(list && lcs_eol != NUL))
  	msg_putchar(' ');
  
***************
*** 1828,1834 ****
  	    c = *s++;
  	    if (c == TAB && (!list || lcs_tab1))
  	    {
! 		/* tab amount depends on current column */
  #ifdef FEAT_VARTABS
  		n_extra = tabstop_padding(col, curbuf->b_p_ts,
  						    curbuf->b_p_vts_array) - 1;
--- 1827,1833 ----
  	    c = *s++;
  	    if (c == TAB && (!list || lcs_tab1))
  	    {
! 		// tab amount depends on current column
  #ifdef FEAT_VARTABS
  		n_extra = tabstop_padding(col, curbuf->b_p_ts,
  						    curbuf->b_p_vts_array) - 1;
***************
*** 1871,1878 ****
  		c_extra = NUL;
  		c_final = NUL;
  		c = *p_extra++;
! 		/* Use special coloring to be able to distinguish <hex> from
! 		 * the same in plain text. */
  		attr = HL_ATTR(HLF_8);
  	    }
  	    else if (c == ' ' && trail != NULL && s > trail)
--- 1870,1877 ----
  		c_extra = NUL;
  		c_final = NUL;
  		c = *p_extra++;
! 		// Use special coloring to be able to distinguish <hex> from
! 		// the same in plain text.
  		attr = HL_ATTR(HLF_8);
  	    }
  	    else if (c == ' ' && trail != NULL && s > trail)
***************
*** 1905,1911 ****
  {
      int		cw;
  
!     msg_didout = TRUE;		/* remember that line is not empty */
      cw = (*mb_ptr2cells)(s);
      if (cw > 1 && (
  #ifdef FEAT_RIGHTLEFT
--- 1904,1910 ----
  {
      int		cw;
  
!     msg_didout = TRUE;		// remember that line is not empty
      cw = (*mb_ptr2cells)(s);
      if (cw > 1 && (
  #ifdef FEAT_RIGHTLEFT
***************
*** 1913,1919 ****
  #endif
  		msg_col == Columns - 1))
      {
! 	/* Doesn't fit, print a highlighted '>' to fill it up. */
  	msg_screen_putchar('>', HL_ATTR(HLF_AT));
  	return s;
      }
--- 1912,1918 ----
  #endif
  		msg_col == Columns - 1))
      {
! 	// Doesn't fit, print a highlighted '>' to fill it up.
  	msg_screen_putchar('>', HL_ATTR(HLF_AT));
  	return s;
      }
***************
*** 2013,2019 ****
      if (msg_silent != 0)
  	return;
  
!     /* if MSG_HIST flag set, add message to history */
      if ((attr & MSG_HIST) && maxlen < 0)
      {
  	add_msg_hist((char_u *)str, -1, attr);
--- 2012,2018 ----
      if (msg_silent != 0)
  	return;
  
!     // if MSG_HIST flag set, add message to history
      if ((attr & MSG_HIST) && maxlen < 0)
      {
  	add_msg_hist((char_u *)str, -1, attr);
***************
*** 2054,2061 ****
      int		recurse)
  {
      char_u	*s = str;
!     char_u	*t_s = str;	/* string from "t_s" to "s" is still todo */
!     int		t_col = 0;	/* screen cells todo, 0 when "t_s" not used */
      int		l;
      int		cw;
      char_u	*sb_str = str;
--- 2053,2060 ----
      int		recurse)
  {
      char_u	*s = str;
!     char_u	*t_s = str;	// string from "t_s" to "s" is still todo
!     int		t_col = 0;	// screen cells todo, 0 when "t_s" not used
      int		l;
      int		cw;
      char_u	*sb_str = str;
***************
*** 2091,2111 ****
  	     * ourselves).
  	     */
  	    if (t_col > 0)
! 		/* output postponed text */
  		t_puts(&t_col, t_s, s, attr);
  
! 	    /* When no more prompt and no more room, truncate here */
  	    if (msg_no_more && lines_left == 0)
  		break;
  
! 	    /* Scroll the screen up one line. */
  	    msg_scroll_up();
  
  	    msg_row = Rows - 2;
! 	    if (msg_col >= Columns)	/* can happen after screen resize */
  		msg_col = Columns - 1;
  
! 	    /* Display char in last column before showing more-prompt. */
  	    if (*s >= ' '
  #ifdef FEAT_RIGHTLEFT
  		    && !cmdmsg_rl
--- 2090,2110 ----
  	     * ourselves).
  	     */
  	    if (t_col > 0)
! 		// output postponed text
  		t_puts(&t_col, t_s, s, attr);
  
! 	    // When no more prompt and no more room, truncate here
  	    if (msg_no_more && lines_left == 0)
  		break;
  
! 	    // Scroll the screen up one line.
  	    msg_scroll_up();
  
  	    msg_row = Rows - 2;
! 	    if (msg_col >= Columns)	// can happen after screen resize
  		msg_col = Columns - 1;
  
! 	    // Display char in last column before showing more-prompt.
  	    if (*s >= ' '
  #ifdef FEAT_RIGHTLEFT
  		    && !cmdmsg_rl
***************
*** 2115,2121 ****
  		if (has_mbyte)
  		{
  		    if (enc_utf8 && maxlen >= 0)
! 			/* avoid including composing chars after the end */
  			l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));
  		    else
  			l = (*mb_ptr2len)(s);
--- 2114,2120 ----
  		if (has_mbyte)
  		{
  		    if (enc_utf8 && maxlen >= 0)
! 			// avoid including composing chars after the end
  			l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));
  		    else
  			l = (*mb_ptr2len)(s);
***************
*** 2129,2139 ****
  		did_last_char = FALSE;
  
  	    if (p_more)
! 		/* store text for scrolling back */
  		store_sb_text(&sb_str, s, attr, &sb_col, TRUE);
  
  	    inc_msg_scrolled();
! 	    need_wait_return = TRUE; /* may need wait_return in main() */
  	    redraw_cmdline = TRUE;
  	    if (cmdline_row > 0 && !exmode_active)
  		--cmdline_row;
--- 2128,2138 ----
  		did_last_char = FALSE;
  
  	    if (p_more)
! 		// store text for scrolling back
  		store_sb_text(&sb_str, s, attr, &sb_col, TRUE);
  
  	    inc_msg_scrolled();
! 	    need_wait_return = TRUE; // may need wait_return in main()
  	    redraw_cmdline = TRUE;
  	    if (cmdline_row > 0 && !exmode_active)
  		--cmdline_row;
***************
*** 2157,2164 ****
  		    return;
  	    }
  
! 	    /* When we displayed a char in last column need to check if there
! 	     * is still more. */
  	    if (did_last_char)
  		continue;
  	}
--- 2156,2163 ----
  		    return;
  	    }
  
! 	    // When we displayed a char in last column need to check if there
! 	    // is still more.
  	    if (did_last_char)
  		continue;
  	}
***************
*** 2169,2209 ****
  					    && msg_col + t_col >= Columns - 1);
  	if (t_col > 0 && (wrap || *s == '\r' || *s == '\b'
  						 || *s == '\t' || *s == BELL))
! 	    /* output any postponed text */
  	    t_puts(&t_col, t_s, s, attr);
  
  	if (wrap && p_more && !recurse)
! 	    /* store text for scrolling back */
  	    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);
  
! 	if (*s == '\n')		    /* go to next line */
  	{
! 	    msg_didout = FALSE;	    /* remember that line is empty */
  #ifdef FEAT_RIGHTLEFT
  	    if (cmdmsg_rl)
  		msg_col = Columns - 1;
  	    else
  #endif
  		msg_col = 0;
! 	    if (++msg_row >= Rows)  /* safety check */
  		msg_row = Rows - 1;
  	}
! 	else if (*s == '\r')	    /* go to column 0 */
  	{
  	    msg_col = 0;
  	}
! 	else if (*s == '\b')	    /* go to previous char */
  	{
  	    if (msg_col)
  		--msg_col;
  	}
! 	else if (*s == TAB)	    /* translate Tab into spaces */
  	{
  	    do
  		msg_screen_putchar(' ', attr);
  	    while (msg_col & 7);
  	}
! 	else if (*s == BELL)		/* beep (from ":sh") */
  	    vim_beep(BO_SH);
  	else
  	{
--- 2168,2208 ----
  					    && msg_col + t_col >= Columns - 1);
  	if (t_col > 0 && (wrap || *s == '\r' || *s == '\b'
  						 || *s == '\t' || *s == BELL))
! 	    // output any postponed text
  	    t_puts(&t_col, t_s, s, attr);
  
  	if (wrap && p_more && !recurse)
! 	    // store text for scrolling back
  	    store_sb_text(&sb_str, s, attr, &sb_col, TRUE);
  
! 	if (*s == '\n')		    // go to next line
  	{
! 	    msg_didout = FALSE;	    // remember that line is empty
  #ifdef FEAT_RIGHTLEFT
  	    if (cmdmsg_rl)
  		msg_col = Columns - 1;
  	    else
  #endif
  		msg_col = 0;
! 	    if (++msg_row >= Rows)  // safety check
  		msg_row = Rows - 1;
  	}
! 	else if (*s == '\r')	    // go to column 0
  	{
  	    msg_col = 0;
  	}
! 	else if (*s == '\b')	    // go to previous char
  	{
  	    if (msg_col)
  		--msg_col;
  	}
! 	else if (*s == TAB)	    // translate Tab into spaces
  	{
  	    do
  		msg_screen_putchar(' ', attr);
  	    while (msg_col & 7);
  	}
! 	else if (*s == BELL)		// beep (from ":sh")
  	    vim_beep(BO_SH);
  	else
  	{
***************
*** 2211,2217 ****
  	    {
  		cw = (*mb_ptr2cells)(s);
  		if (enc_utf8 && maxlen >= 0)
! 		    /* avoid including composing chars after the end */
  		    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));
  		else
  		    l = (*mb_ptr2len)(s);
--- 2210,2216 ----
  	    {
  		cw = (*mb_ptr2cells)(s);
  		if (enc_utf8 && maxlen >= 0)
! 		    // avoid including composing chars after the end
  		    l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));
  		else
  		    l = (*mb_ptr2len)(s);
***************
*** 2222,2230 ****
  		l = 1;
  	    }
  
! 	    /* When drawing from right to left or when a double-wide character
! 	     * doesn't fit, draw a single character here.  Otherwise collect
! 	     * characters and draw them all at once later. */
  	    if (
  # ifdef FEAT_RIGHTLEFT
  		    cmdmsg_rl ||
--- 2221,2229 ----
  		l = 1;
  	    }
  
! 	    // When drawing from right to left or when a double-wide character
! 	    // doesn't fit, draw a single character here.  Otherwise collect
! 	    // characters and draw them all at once later.
  	    if (
  # ifdef FEAT_RIGHTLEFT
  		    cmdmsg_rl ||
***************
*** 2238,2244 ****
  	    }
  	    else
  	    {
! 		/* postpone this character until later */
  		if (t_col == 0)
  		    t_s = s;
  		t_col += cw;
--- 2237,2243 ----
  	    }
  	    else
  	    {
! 		// postpone this character until later
  		if (t_col == 0)
  		    t_s = s;
  		t_col += cw;
***************
*** 2248,2254 ****
  	++s;
      }
  
!     /* output any postponed text */
      if (t_col > 0)
  	t_puts(&t_col, t_s, s, attr);
      if (p_more && !recurse)
--- 2247,2253 ----
  	++s;
      }
  
!     // output any postponed text
      if (t_col > 0)
  	t_puts(&t_col, t_s, s, attr);
      if (p_more && !recurse)
***************
*** 2279,2303 ****
  msg_scroll_up(void)
  {
  #ifdef FEAT_GUI
!     /* Remove the cursor before scrolling, ScreenLines[] is going
!      * to become invalid. */
      if (gui.in_use)
  	gui_undraw_cursor();
  #endif
!     /* scrolling up always works */
      mch_disable_flush();
      screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
      mch_enable_flush();
  
      if (!can_clear((char_u *)" "))
      {
! 	/* Scrolling up doesn't result in the right background.  Set the
! 	 * background here.  It's not efficient, but avoids that we have to do
! 	 * it all over the code. */
  	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
  
! 	/* Also clear the last char of the last but one line if it was not
! 	 * cleared before to avoid a scroll-up. */
  	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
  	    screen_fill((int)Rows - 2, (int)Rows - 1,
  				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
--- 2278,2302 ----
  msg_scroll_up(void)
  {
  #ifdef FEAT_GUI
!     // Remove the cursor before scrolling, ScreenLines[] is going
!     // to become invalid.
      if (gui.in_use)
  	gui_undraw_cursor();
  #endif
!     // scrolling up always works
      mch_disable_flush();
      screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
      mch_enable_flush();
  
      if (!can_clear((char_u *)" "))
      {
! 	// Scrolling up doesn't result in the right background.  Set the
! 	// background here.  It's not efficient, but avoids that we have to do
! 	// it all over the code.
  	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
  
! 	// Also clear the last char of the last but one line if it was not
! 	// cleared before to avoid a scroll-up.
  	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
  	    screen_fill((int)Rows - 2, (int)Rows - 1,
  				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
***************
*** 2317,2324 ****
  	char_u	    *tofree = NULL;
  	int	    len;
  
! 	/* v:scrollstart is empty, set it to the script/function name and line
! 	 * number */
  	if (p == NULL)
  	    p = (char_u *)_("Unknown");
  	else
--- 2316,2323 ----
  	char_u	    *tofree = NULL;
  	int	    len;
  
! 	// v:scrollstart is empty, set it to the script/function name and line
! 	// number
  	if (p == NULL)
  	    p = (char_u *)_("Unknown");
  	else
***************
*** 2350,2362 ****
  {
      msgchunk_T	*sb_next;
      msgchunk_T	*sb_prev;
!     char	sb_eol;		/* TRUE when line ends after this text */
!     int		sb_msg_col;	/* column in which text starts */
!     int		sb_attr;	/* text attributes */
!     char_u	sb_text[1];	/* text to be displayed, actually longer */
  };
  
! static msgchunk_T *last_msgchunk = NULL; /* last displayed text */
  
  static msgchunk_T *msg_sb_start(msgchunk_T *mps);
  
--- 2349,2361 ----
  {
      msgchunk_T	*sb_next;
      msgchunk_T	*sb_prev;
!     char	sb_eol;		// TRUE when line ends after this text
!     int		sb_msg_col;	// column in which text starts
!     int		sb_attr;	// text attributes
!     char_u	sb_text[1];	// text to be displayed, actually longer
  };
  
! static msgchunk_T *last_msgchunk = NULL; // last displayed text
  
  static msgchunk_T *msg_sb_start(msgchunk_T *mps);
  
***************
*** 2367,2373 ****
      SB_CLEAR_CMDLINE_DONE
  } sb_clear_T;
  
! /* When to clear text on next msg. */
  static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;
  
  /*
--- 2366,2372 ----
      SB_CLEAR_CMDLINE_DONE
  } sb_clear_T;
  
! // When to clear text on next msg.
  static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;
  
  /*
***************
*** 2375,2385 ****
   */
      static void
  store_sb_text(
!     char_u	**sb_str,	/* start of string */
!     char_u	*s,		/* just after string */
      int		attr,
      int		*sb_col,
!     int		finish)		/* line ends */
  {
      msgchunk_T	*mp;
  
--- 2374,2384 ----
   */
      static void
  store_sb_text(
!     char_u	**sb_str,	// start of string
!     char_u	*s,		// just after string
      int		attr,
      int		*sb_col,
!     int		finish)		// line ends
  {
      msgchunk_T	*mp;
  
***************
*** 2485,2492 ****
  {
      msgchunk_T	*mp;
  
!     /* Only show something if there is more than one line, otherwise it looks
!      * weird, typing a command without output results in one line. */
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
  	vim_beep(BO_MESS);
--- 2484,2491 ----
  {
      msgchunk_T	*mp;
  
!     // Only show something if there is more than one line, otherwise it looks
!     // weird, typing a command without output results in one line.
      mp = msg_sb_start(last_msgchunk);
      if (mp == NULL || mp->sb_prev == NULL)
  	vim_beep(BO_MESS);
***************
*** 2535,2541 ****
  	msg_row = row;
  	msg_col = mp->sb_msg_col;
  	p = mp->sb_text;
! 	if (*p == '\n')	    /* don't display the line break */
  	    ++p;
  	msg_puts_display(p, -1, mp->sb_attr, TRUE);
  	if (mp->sb_eol || mp->sb_next == NULL)
--- 2534,2540 ----
  	msg_row = row;
  	msg_col = mp->sb_msg_col;
  	p = mp->sb_text;
! 	if (*p == '\n')	    // don't display the line break
  	    ++p;
  	msg_puts_display(p, -1, mp->sb_attr, TRUE);
  	if (mp->sb_eol || mp->sb_next == NULL)
***************
*** 2555,2567 ****
      char_u	*s,
      int		attr)
  {
!     /* output postponed text */
!     msg_didout = TRUE;		/* remember that line is not empty */
      screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);
      msg_col += *t_col;
      *t_col = 0;
!     /* If the string starts with a composing character don't increment the
!      * column position for it. */
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))
  	--msg_col;
      if (msg_col >= Columns)
--- 2554,2566 ----
      char_u	*s,
      int		attr)
  {
!     // output postponed text
!     msg_didout = TRUE;		// remember that line is not empty
      screen_puts_len(t_s, (int)(s - t_s), msg_row, msg_col, attr);
      msg_col += *t_col;
      *t_col = 0;
!     // If the string starts with a composing character don't increment the
!     // column position for it.
      if (enc_utf8 && utf_iscomposing(utf_ptr2char(t_s)))
  	--msg_col;
      if (msg_col >= Columns)
***************
*** 2606,2612 ****
  
  #ifdef MSWIN
      if (!(silent_mode && p_verbose == 0))
! 	mch_settmode(TMODE_COOK);	/* handle CR and NL correctly */
  #endif
      while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
      {
--- 2605,2611 ----
  
  #ifdef MSWIN
      if (!(silent_mode && p_verbose == 0))
! 	mch_settmode(TMODE_COOK);	// handle CR and NL correctly
  #endif
      while ((maxlen < 0 || (int)(s - str) < maxlen) && *s != NUL)
      {
***************
*** 2702,2717 ****
      msgchunk_T	*mp;
      int		i;
  
!     /* We get called recursively when a timer callback outputs a message. In
!      * that case don't show another prompt. Also when at the hit-Enter prompt
!      * and nothing was typed. */
      if (entered || (State == HITRETURN && typed_char == 0))
  	return FALSE;
      entered = TRUE;
  
      if (typed_char == 'G')
      {
! 	/* "g<": Find first line on the last page. */
  	mp_last = msg_sb_start(last_msgchunk);
  	for (i = 0; i < Rows - 2 && mp_last != NULL
  					     && mp_last->sb_prev != NULL; ++i)
--- 2701,2716 ----
      msgchunk_T	*mp;
      int		i;
  
!     // We get called recursively when a timer callback outputs a message. In
!     // that case don't show another prompt. Also when at the hit-Enter prompt
!     // and nothing was typed.
      if (entered || (State == HITRETURN && typed_char == 0))
  	return FALSE;
      entered = TRUE;
  
      if (typed_char == 'G')
      {
! 	// "g<": Find first line on the last page.
  	mp_last = msg_sb_start(last_msgchunk);
  	for (i = 0; i < Rows - 2 && mp_last != NULL
  					     && mp_last->sb_prev != NULL; ++i)
***************
*** 2729,2735 ****
  	 */
  	if (used_typed_char != NUL)
  	{
! 	    c = used_typed_char;	/* was typed at hit-enter prompt */
  	    used_typed_char = NUL;
  	}
  	else
--- 2728,2734 ----
  	 */
  	if (used_typed_char != NUL)
  	{
! 	    c = used_typed_char;	// was typed at hit-enter prompt
  	    used_typed_char = NUL;
  	}
  	else
***************
*** 2740,2748 ****
  	{
  	    int idx = get_menu_index(current_menu, ASKMORE);
  
! 	    /* Used a menu.  If it starts with CTRL-Y, it must
! 	     * be a "Copy" for the clipboard.  Otherwise
! 	     * assume that we end */
  	    if (idx == MENU_INDEX_INVALID)
  		continue;
  	    c = *current_menu->strings[idx];
--- 2739,2747 ----
  	{
  	    int idx = get_menu_index(current_menu, ASKMORE);
  
! 	    // Used a menu.  If it starts with CTRL-Y, it must
! 	    // be a "Copy" for the clipboard.  Otherwise
! 	    // assume that we end
  	    if (idx == MENU_INDEX_INVALID)
  		continue;
  	    c = *current_menu->strings[idx];
***************
*** 2756,2827 ****
  	toscroll = 0;
  	switch (c)
  	{
! 	case BS:		/* scroll one line back */
  	case K_BS:
  	case 'k':
  	case K_UP:
  	    toscroll = -1;
  	    break;
  
! 	case CAR:		/* one extra line */
  	case NL:
  	case 'j':
  	case K_DOWN:
  	    toscroll = 1;
  	    break;
  
! 	case 'u':		/* Up half a page */
  	    toscroll = -(Rows / 2);
  	    break;
  
! 	case 'd':		/* Down half a page */
  	    toscroll = Rows / 2;
  	    break;
  
! 	case 'b':		/* one page back */
  	case K_PAGEUP:
  	    toscroll = -(Rows - 1);
  	    break;
  
! 	case ' ':		/* one extra page */
  	case 'f':
  	case K_PAGEDOWN:
  	case K_LEFTMOUSE:
  	    toscroll = Rows - 1;
  	    break;
  
! 	case 'g':		/* all the way back to the start */
  	    toscroll = -999999;
  	    break;
  
! 	case 'G':		/* all the way to the end */
  	    toscroll = 999999;
  	    lines_left = 999999;
  	    break;
  
! 	case ':':		/* start new command line */
  #ifdef FEAT_CON_DIALOG
  	    if (!confirm_msg_used)
  #endif
  	    {
! 		/* Since got_int is set all typeahead will be flushed, but we
! 		 * want to keep this ':', remember that in a special way. */
  		typeahead_noflush(':');
  #ifdef FEAT_TERMINAL
  		skip_term_loop = TRUE;
  #endif
! 		cmdline_row = Rows - 1;		/* put ':' on this line */
! 		skip_redraw = TRUE;		/* skip redraw once */
! 		need_wait_return = FALSE;	/* don't wait in main() */
  	    }
! 	    /* FALLTHROUGH */
! 	case 'q':		/* quit */
  	case Ctrl_C:
  	case ESC:
  #ifdef FEAT_CON_DIALOG
  	    if (confirm_msg_used)
  	    {
! 		/* Jump to the choices of the dialog. */
  		retval = TRUE;
  	    }
  	    else
--- 2755,2826 ----
  	toscroll = 0;
  	switch (c)
  	{
! 	case BS:		// scroll one line back
  	case K_BS:
  	case 'k':
  	case K_UP:
  	    toscroll = -1;
  	    break;
  
! 	case CAR:		// one extra line
  	case NL:
  	case 'j':
  	case K_DOWN:
  	    toscroll = 1;
  	    break;
  
! 	case 'u':		// Up half a page
  	    toscroll = -(Rows / 2);
  	    break;
  
! 	case 'd':		// Down half a page
  	    toscroll = Rows / 2;
  	    break;
  
! 	case 'b':		// one page back
  	case K_PAGEUP:
  	    toscroll = -(Rows - 1);
  	    break;
  
! 	case ' ':		// one extra page
  	case 'f':
  	case K_PAGEDOWN:
  	case K_LEFTMOUSE:
  	    toscroll = Rows - 1;
  	    break;
  
! 	case 'g':		// all the way back to the start
  	    toscroll = -999999;
  	    break;
  
! 	case 'G':		// all the way to the end
  	    toscroll = 999999;
  	    lines_left = 999999;
  	    break;
  
! 	case ':':		// start new command line
  #ifdef FEAT_CON_DIALOG
  	    if (!confirm_msg_used)
  #endif
  	    {
! 		// Since got_int is set all typeahead will be flushed, but we
! 		// want to keep this ':', remember that in a special way.
  		typeahead_noflush(':');
  #ifdef FEAT_TERMINAL
  		skip_term_loop = TRUE;
  #endif
! 		cmdline_row = Rows - 1;		// put ':' on this line
! 		skip_redraw = TRUE;		// skip redraw once
! 		need_wait_return = FALSE;	// don't wait in main()
  	    }
! 	    // FALLTHROUGH
! 	case 'q':		// quit
  	case Ctrl_C:
  	case ESC:
  #ifdef FEAT_CON_DIALOG
  	    if (confirm_msg_used)
  	    {
! 		// Jump to the choices of the dialog.
  		retval = TRUE;
  	    }
  	    else
***************
*** 2830,2852 ****
  		got_int = TRUE;
  		quit_more = TRUE;
  	    }
! 	    /* When there is some more output (wrapping line) display that
! 	     * without another prompt. */
  	    lines_left = Rows - 1;
  	    break;
  
  #ifdef FEAT_CLIPBOARD
  	case Ctrl_Y:
! 	    /* Strange way to allow copying (yanking) a modeless
! 	     * selection at the more prompt.  Use CTRL-Y,
! 	     * because the same is used in Cmdline-mode and at the
! 	     * hit-enter prompt.  However, scrolling one line up
! 	     * might be expected... */
  	    if (clip_star.state == SELECT_DONE)
  		clip_copy_modeless_selection(TRUE);
  	    continue;
  #endif
! 	default:		/* no valid response */
  	    msg_moremsg(TRUE);
  	    continue;
  	}
--- 2829,2851 ----
  		got_int = TRUE;
  		quit_more = TRUE;
  	    }
! 	    // When there is some more output (wrapping line) display that
! 	    // without another prompt.
  	    lines_left = Rows - 1;
  	    break;
  
  #ifdef FEAT_CLIPBOARD
  	case Ctrl_Y:
! 	    // Strange way to allow copying (yanking) a modeless
! 	    // selection at the more prompt.  Use CTRL-Y,
! 	    // because the same is used in Cmdline-mode and at the
! 	    // hit-enter prompt.  However, scrolling one line up
! 	    // might be expected...
  	    if (clip_star.state == SELECT_DONE)
  		clip_copy_modeless_selection(TRUE);
  	    continue;
  #endif
! 	default:		// no valid response
  	    msg_moremsg(TRUE);
  	    continue;
  	}
***************
*** 2855,2861 ****
  	{
  	    if (toscroll < 0)
  	    {
! 		/* go to start of last line */
  		if (mp_last == NULL)
  		    mp = msg_sb_start(last_msgchunk);
  		else if (mp_last->sb_prev != NULL)
--- 2854,2860 ----
  	{
  	    if (toscroll < 0)
  	    {
! 		// go to start of last line
  		if (mp_last == NULL)
  		    mp = msg_sb_start(last_msgchunk);
  		else if (mp_last->sb_prev != NULL)
***************
*** 2863,2876 ****
  		else
  		    mp = NULL;
  
! 		/* go to start of line at top of the screen */
  		for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;
  									  ++i)
  		    mp = msg_sb_start(mp->sb_prev);
  
  		if (mp != NULL && mp->sb_prev != NULL)
  		{
! 		    /* Find line to be displayed at top. */
  		    for (i = 0; i > toscroll; --i)
  		    {
  			if (mp == NULL || mp->sb_prev == NULL)
--- 2862,2875 ----
  		else
  		    mp = NULL;
  
! 		// go to start of line at top of the screen
  		for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;
  									  ++i)
  		    mp = msg_sb_start(mp->sb_prev);
  
  		if (mp != NULL && mp->sb_prev != NULL)
  		{
! 		    // Find line to be displayed at top.
  		    for (i = 0; i > toscroll; --i)
  		    {
  			if (mp == NULL || mp->sb_prev == NULL)
***************
*** 2885,2896 ****
  		    if (toscroll == -1 && screen_ins_lines(0, 0, 1,
  						     (int)Rows, 0, NULL) == OK)
  		    {
! 			/* display line at top */
  			(void)disp_sb_line(0, mp);
  		    }
  		    else
  		    {
! 			/* redisplay all lines */
  			screenclear();
  			for (i = 0; mp != NULL && i < Rows - 1; ++i)
  			{
--- 2884,2895 ----
  		    if (toscroll == -1 && screen_ins_lines(0, 0, 1,
  						     (int)Rows, 0, NULL) == OK)
  		    {
! 			// display line at top
  			(void)disp_sb_line(0, mp);
  		    }
  		    else
  		    {
! 			// redisplay all lines
  			screenclear();
  			for (i = 0; mp != NULL && i < Rows - 1; ++i)
  			{
***************
*** 2903,2912 ****
  	    }
  	    else
  	    {
! 		/* First display any text that we scrolled back. */
  		while (toscroll > 0 && mp_last != NULL)
  		{
! 		    /* scroll up, display line at bottom */
  		    msg_scroll_up();
  		    inc_msg_scrolled();
  		    screen_fill((int)Rows - 2, (int)Rows - 1, 0,
--- 2902,2911 ----
  	    }
  	    else
  	    {
! 		// First display any text that we scrolled back.
  		while (toscroll > 0 && mp_last != NULL)
  		{
! 		    // scroll up, display line at bottom
  		    msg_scroll_up();
  		    inc_msg_scrolled();
  		    screen_fill((int)Rows - 2, (int)Rows - 1, 0,
***************
*** 2918,2938 ****
  
  	    if (toscroll <= 0)
  	    {
! 		/* displayed the requested text, more prompt again */
  		screen_fill((int)Rows - 1, (int)Rows, 0,
  						   (int)Columns, ' ', ' ', 0);
  		msg_moremsg(FALSE);
  		continue;
  	    }
  
! 	    /* display more text, return to caller */
  	    lines_left = toscroll;
  	}
  
  	break;
      }
  
!     /* clear the --more-- message */
      screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
      State = oldState;
      setmouse();
--- 2917,2937 ----
  
  	    if (toscroll <= 0)
  	    {
! 		// displayed the requested text, more prompt again
  		screen_fill((int)Rows - 1, (int)Rows, 0,
  						   (int)Columns, ' ', ' ', 0);
  		msg_moremsg(FALSE);
  		continue;
  	    }
  
! 	    // display more text, return to caller
  	    lines_left = toscroll;
  	}
  
  	break;
      }
  
!     // clear the --more-- message
      screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
      State = oldState;
      setmouse();
***************
*** 3000,3008 ****
  #endif
  
  #if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
!     /* On Unix use stderr if it's a tty.
!      * When not going to start the GUI also use stderr.
!      * On Mac, when started from Finder, stderr is the console. */
      if (
  # ifdef UNIX
  #  ifdef MACOS_X
--- 2999,3007 ----
  #endif
  
  #if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
!     // On Unix use stderr if it's a tty.
!     // When not going to start the GUI also use stderr.
!     // On Mac, when started from Finder, stderr is the console.
      if (
  # ifdef UNIX
  #  ifdef MACOS_X
***************
*** 3035,3041 ****
  #endif
  
  #if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)
!     /* avoid a delay for a message that isn't there */
      emsg_on_display = FALSE;
  
      len = (int)STRLEN(str) + 1;
--- 3034,3040 ----
  #endif
  
  #if !defined(MSWIN) || defined(FEAT_GUI_MSWIN)
!     // avoid a delay for a message that isn't there
      emsg_on_display = FALSE;
  
      len = (int)STRLEN(str) + 1;
***************
*** 3049,3055 ****
  	mch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,
  							  (char_u *)str, len);
  # ifdef UNIX
! 	/* remove CR characters, they are displayed */
  	{
  	    char_u	*p;
  
--- 3048,3054 ----
  	mch_memmove((char_u *)error_ga.ga_data + error_ga.ga_len,
  							  (char_u *)str, len);
  # ifdef UNIX
! 	// remove CR characters, they are displayed
  	{
  	    char_u	*p;
  
***************
*** 3063,3069 ****
  	    }
  	}
  # endif
! 	--len;		/* don't count the NUL at the end */
  	error_ga.ga_len += len;
      }
  #endif
--- 3062,3068 ----
  	    }
  	}
  # endif
! 	--len;		// don't count the NUL at the end
  	error_ga.ga_len += len;
      }
  #endif
***************
*** 3103,3112 ****
  mch_msg(char *str)
  {
  #if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
!     /* On Unix use stdout if we have a tty.  This allows "vim -h | more" and
!      * uses mch_errmsg() when started from the desktop.
!      * When not going to start the GUI also use stdout.
!      * On Mac, when started from Finder, stderr is the console. */
      if (
  # ifdef UNIX
  #  ifdef MACOS_X
--- 3102,3111 ----
  mch_msg(char *str)
  {
  #if (defined(UNIX) || defined(FEAT_GUI)) && !defined(ALWAYS_USE_GUI) && !defined(VIMDLL)
!     // On Unix use stdout if we have a tty.  This allows "vim -h | more" and
!     // uses mch_errmsg() when started from the desktop.
!     // When not going to start the GUI also use stdout.
!     // On Mac, when started from Finder, stderr is the console.
      if (
  # ifdef UNIX
  #  ifdef MACOS_X
***************
*** 3141,3147 ****
      mch_errmsg(str);
  #endif
  }
! #endif /* USE_MCH_ERRMSG */
  
  /*
   * Put a character on the screen at the current message position and advance
--- 3140,3146 ----
      mch_errmsg(str);
  #endif
  }
! #endif // USE_MCH_ERRMSG
  
  /*
   * Put a character on the screen at the current message position and advance
***************
*** 3150,3156 ****
      static void
  msg_screen_putchar(int c, int attr)
  {
!     msg_didout = TRUE;		/* remember that line is not empty */
      screen_putchar(c, msg_row, msg_col, attr);
  #ifdef FEAT_RIGHTLEFT
      if (cmdmsg_rl)
--- 3149,3155 ----
      static void
  msg_screen_putchar(int c, int attr)
  {
!     msg_didout = TRUE;		// remember that line is not empty
      screen_putchar(c, msg_row, msg_col, attr);
  #ifdef FEAT_RIGHTLEFT
      if (cmdmsg_rl)
***************
*** 3195,3221 ****
  {
      if (State == ASKMORE)
      {
! 	msg_moremsg(TRUE);	/* display --more-- message again */
  	msg_row = Rows - 1;
      }
  #ifdef FEAT_CON_DIALOG
      else if (State == CONFIRM)
      {
! 	display_confirm_msg();	/* display ":confirm" message again */
  	msg_row = Rows - 1;
      }
  #endif
      else if (State == EXTERNCMD)
      {
! 	windgoto(msg_row, msg_col); /* put cursor back */
      }
      else if (State == HITRETURN || State == SETWSIZE)
      {
  	if (msg_row == Rows - 1)
  	{
! 	    /* Avoid drawing the "hit-enter" prompt below the previous one,
! 	     * overwrite it.  Esp. useful when regaining focus and a
! 	     * FocusGained autocmd exists but didn't draw anything. */
  	    msg_didout = FALSE;
  	    msg_col = 0;
  	    msg_clr_eos();
--- 3194,3220 ----
  {
      if (State == ASKMORE)
      {
! 	msg_moremsg(TRUE);	// display --more-- message again
  	msg_row = Rows - 1;
      }
  #ifdef FEAT_CON_DIALOG
      else if (State == CONFIRM)
      {
! 	display_confirm_msg();	// display ":confirm" message again
  	msg_row = Rows - 1;
      }
  #endif
      else if (State == EXTERNCMD)
      {
! 	windgoto(msg_row, msg_col); // put cursor back
      }
      else if (State == HITRETURN || State == SETWSIZE)
      {
  	if (msg_row == Rows - 1)
  	{
! 	    // Avoid drawing the "hit-enter" prompt below the previous one,
! 	    // overwrite it.  Esp. useful when regaining focus and a
! 	    // FocusGained autocmd exists but didn't draw anything.
  	    msg_didout = FALSE;
  	    msg_col = 0;
  	    msg_clr_eos();
***************
*** 3265,3276 ****
  {
      if (msg_use_printf())
      {
! 	if (full_screen)	/* only when termcap codes are valid */
  	{
  	    if (*T_CD)
! 		out_str(T_CD);	/* clear to end of display */
  	    else if (*T_CE)
! 		out_str(T_CE);	/* clear to end of line */
  	}
      }
      else
--- 3264,3275 ----
  {
      if (msg_use_printf())
      {
! 	if (full_screen)	// only when termcap codes are valid
  	{
  	    if (*T_CD)
! 		out_str(T_CD);	// clear to end of display
  	    else if (*T_CE)
! 		out_str(T_CE);	// clear to end of line
  	}
      }
      else
***************
*** 3349,3365 ****
      char_u	*s = str;
      static int	cur_col = 0;
  
!     /* Don't do anything for displaying prompts and the like. */
      if (redir_off)
  	return;
  
!     /* If 'verbosefile' is set prepare for writing in that file. */
      if (*p_vfile != NUL && verbose_fd == NULL)
  	verbose_open();
  
      if (redirecting())
      {
! 	/* If the string doesn't start with CR or NL, go to msg_col */
  	if (*s != '\n' && *s != '\r')
  	{
  	    while (cur_col < msg_col)
--- 3348,3364 ----
      char_u	*s = str;
      static int	cur_col = 0;
  
!     // Don't do anything for displaying prompts and the like.
      if (redir_off)
  	return;
  
!     // If 'verbosefile' is set prepare for writing in that file.
      if (*p_vfile != NUL && verbose_fd == NULL)
  	verbose_open();
  
      if (redirecting())
      {
! 	// If the string doesn't start with CR or NL, go to msg_col
  	if (*s != '\n' && *s != '\r')
  	{
  	    while (cur_col < msg_col)
***************
*** 3390,3396 ****
  	    var_redir_str(s, maxlen);
  #endif
  
! 	/* Write and adjust the current column. */
  	while (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))
  	{
  #ifdef FEAT_EVAL
--- 3389,3395 ----
  	    var_redir_str(s, maxlen);
  #endif
  
! 	// Write and adjust the current column.
  	while (*s != NUL && (maxlen < 0 || (int)(s - str) < maxlen))
  	{
  #ifdef FEAT_EVAL
***************
*** 3409,3415 ****
  	    ++s;
  	}
  
! 	if (msg_silent != 0)	/* should update msg_col */
  	    msg_col = cur_col;
      }
  }
--- 3408,3414 ----
  	    ++s;
  	}
  
! 	if (msg_silent != 0)	// should update msg_col
  	    msg_col = cur_col;
      }
  }
***************
*** 3456,3462 ****
      if (*p_vfile != NUL)
  	++msg_silent;
      else
! 	/* always scroll up, don't overwrite */
  	msg_scroll = TRUE;
  }
  
--- 3455,3461 ----
      if (*p_vfile != NUL)
  	++msg_silent;
      else
! 	// always scroll up, don't overwrite
  	msg_scroll = TRUE;
  }
  
***************
*** 3498,3504 ****
  {
      if (verbose_fd == NULL && !verbose_did_open)
      {
! 	/* Only give the error message once. */
  	verbose_did_open = TRUE;
  
  	verbose_fd = mch_fopen((char *)p_vfile, "a");
--- 3497,3503 ----
  {
      if (verbose_fd == NULL && !verbose_did_open)
      {
! 	// Only give the error message once.
  	verbose_did_open = TRUE;
  
  	verbose_fd = mch_fopen((char *)p_vfile, "a");
***************
*** 3518,3528 ****
      void
  give_warning(char_u *message, int hl)
  {
!     /* Don't do this for ":silent". */
      if (msg_silent != 0)
  	return;
  
!     /* Don't want a hit-enter prompt here. */
      ++no_wait_return;
  
  #ifdef FEAT_EVAL
--- 3517,3527 ----
      void
  give_warning(char_u *message, int hl)
  {
!     // Don't do this for ":silent".
      if (msg_silent != 0)
  	return;
  
!     // Don't want a hit-enter prompt here.
      ++no_wait_return;
  
  #ifdef FEAT_EVAL
***************
*** 3535,3542 ****
  	keep_msg_attr = 0;
      if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)
  	set_keep_msg(message, keep_msg_attr);
!     msg_didout = FALSE;	    /* overwrite this message */
!     msg_nowait = TRUE;	    /* don't wait for this message */
      msg_col = 0;
  
      --no_wait_return;
--- 3534,3541 ----
  	keep_msg_attr = 0;
      if (msg_attr((char *)message, keep_msg_attr) && msg_scrolled == 0)
  	set_keep_msg(message, keep_msg_attr);
!     msg_didout = FALSE;	    // overwrite this message
!     msg_nowait = TRUE;	    // don't wait for this message
      msg_col = 0;
  
      --no_wait_return;
***************
*** 3566,3577 ****
      void
  msg_advance(int col)
  {
!     if (msg_silent != 0)	/* nothing to advance to */
      {
! 	msg_col = col;		/* for redirection, may fill it up later */
  	return;
      }
!     if (col >= Columns)		/* not enough room */
  	col = Columns - 1;
  #ifdef FEAT_RIGHTLEFT
      if (cmdmsg_rl)
--- 3565,3576 ----
      void
  msg_advance(int col)
  {
!     if (msg_silent != 0)	// nothing to advance to
      {
! 	msg_col = col;		// for redirection, may fill it up later
  	return;
      }
!     if (col >= Columns)		// not enough room
  	col = Columns - 1;
  #ifdef FEAT_RIGHTLEFT
      if (cmdmsg_rl)
***************
*** 3609,3618 ****
      char_u	*message,
      char_u	*buttons,
      int		dfltbutton,
!     char_u	*textfield UNUSED,	/* IObuff for inputdialog(), NULL
! 					   otherwise */
!     int		ex_cmd)	    /* when TRUE pressing : accepts default and starts
! 			       Ex command */
  {
      int		oldState;
      int		retval = 0;
--- 3608,3617 ----
      char_u	*message,
      char_u	*buttons,
      int		dfltbutton,
!     char_u	*textfield UNUSED,	// IObuff for inputdialog(), NULL
! 					// otherwise
!     int		ex_cmd)	    // when TRUE pressing : accepts default and starts
! 			    // Ex command
  {
      int		oldState;
      int		retval = 0;
***************
*** 3621,3644 ****
      int		i;
  
  #ifndef NO_CONSOLE
!     /* Don't output anything in silent mode ("ex -s") */
      if (silent_mode)
! 	return dfltbutton;   /* return default option */
  #endif
  
  #ifdef FEAT_GUI_DIALOG
!     /* When GUI is running and 'c' not in 'guioptions', use the GUI dialog */
      if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)
      {
  	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
  							   textfield, ex_cmd);
! 	/* avoid a hit-enter prompt without clearing the cmdline */
  	need_wait_return = FALSE;
  	emsg_on_display = FALSE;
  	cmdline_row = msg_row;
  
! 	/* Flush output to avoid that further messages and redrawing is done
! 	 * in the wrong order. */
  	out_flush();
  	gui_mch_update();
  
--- 3620,3643 ----
      int		i;
  
  #ifndef NO_CONSOLE
!     // Don't output anything in silent mode ("ex -s")
      if (silent_mode)
! 	return dfltbutton;   // return default option
  #endif
  
  #ifdef FEAT_GUI_DIALOG
!     // When GUI is running and 'c' not in 'guioptions', use the GUI dialog
      if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)
      {
  	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
  							   textfield, ex_cmd);
! 	// avoid a hit-enter prompt without clearing the cmdline
  	need_wait_return = FALSE;
  	emsg_on_display = FALSE;
  	cmdline_row = msg_row;
  
! 	// Flush output to avoid that further messages and redrawing is done
! 	// in the wrong order.
  	out_flush();
  	gui_mch_update();
  
***************
*** 3661,3680 ****
      {
  	for (;;)
  	{
! 	    /* Get a typed character directly from the user. */
  	    c = get_keystroke();
  	    switch (c)
  	    {
! 	    case CAR:		/* User accepts default option */
  	    case NL:
  		retval = dfltbutton;
  		break;
! 	    case Ctrl_C:	/* User aborts/cancels */
  	    case ESC:
  		retval = 0;
  		break;
! 	    default:		/* Could be a hotkey? */
! 		if (c < 0)	/* special keys are ignored here */
  		    continue;
  		if (c == ':' && ex_cmd)
  		{
--- 3660,3679 ----
      {
  	for (;;)
  	{
! 	    // Get a typed character directly from the user.
  	    c = get_keystroke();
  	    switch (c)
  	    {
! 	    case CAR:		// User accepts default option
  	    case NL:
  		retval = dfltbutton;
  		break;
! 	    case Ctrl_C:	// User aborts/cancels
  	    case ESC:
  		retval = 0;
  		break;
! 	    default:		// Could be a hotkey?
! 		if (c < 0)	// special keys are ignored here
  		    continue;
  		if (c == ':' && ex_cmd)
  		{
***************
*** 3683,3689 ****
  		    break;
  		}
  
! 		/* Make the character lowercase, as chars in "hotkeys" are. */
  		c = MB_TOLOWER(c);
  		retval = 1;
  		for (i = 0; hotkeys[i]; ++i)
--- 3682,3688 ----
  		    break;
  		}
  
! 		// Make the character lowercase, as chars in "hotkeys" are.
  		c = MB_TOLOWER(c);
  		retval = 1;
  		for (i = 0; hotkeys[i]; ++i)
***************
*** 3701,3707 ****
  		}
  		if (hotkeys[i])
  		    break;
! 		/* No hotkey match, so keep waiting */
  		continue;
  	    }
  	    break;
--- 3700,3706 ----
  		}
  		if (hotkeys[i])
  		    break;
! 		// No hotkey match, so keep waiting
  		continue;
  	    }
  	    break;
***************
*** 3726,3732 ****
  copy_char(
      char_u	*from,
      char_u	*to,
!     int		lowercase)	/* make character lower case */
  {
      int		len;
      int		c;
--- 3725,3731 ----
  copy_char(
      char_u	*from,
      char_u	*to,
!     int		lowercase)	// make character lower case
  {
      int		len;
      int		c;
***************
*** 3772,3778 ****
  {
      int		len = 0;
  #define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)
!     int		lenhotkey = HOTK_LEN;	/* count first button */
      char_u	*hotk = NULL;
      char_u	*msgp = NULL;
      char_u	*hotkp = NULL;
--- 3771,3777 ----
  {
      int		len = 0;
  #define HOTK_LEN (has_mbyte ? MB_MAXBYTES : 1)
!     int		lenhotkey = HOTK_LEN;	// count first button
      char_u	*hotk = NULL;
      char_u	*msgp = NULL;
      char_u	*hotkp = NULL;
***************
*** 3780,3786 ****
      int		copy;
  #define HAS_HOTKEY_LEN 30
      char_u	has_hotkey[HAS_HOTKEY_LEN];
!     int		first_hotkey = FALSE;	/* first char of button is hotkey */
      int		idx;
  
      has_hotkey[0] = FALSE;
--- 3779,3785 ----
      int		copy;
  #define HAS_HOTKEY_LEN 30
      char_u	has_hotkey[HAS_HOTKEY_LEN];
!     int		first_hotkey = FALSE;	// first char of button is hotkey
      int		idx;
  
      has_hotkey[0] = FALSE;
***************
*** 3800,3808 ****
  		if (copy)
  		{
  		    *msgp++ = ',';
! 		    *msgp++ = ' ';	    /* '\n' -> ', ' */
  
! 		    /* advance to next hotkey and set default hotkey */
  		    if (has_mbyte)
  			hotkp += STRLEN(hotkp);
  		    else
--- 3799,3807 ----
  		if (copy)
  		{
  		    *msgp++ = ',';
! 		    *msgp++ = ' ';	    // '\n' -> ', '
  
! 		    // advance to next hotkey and set default hotkey
  		    if (has_mbyte)
  			hotkp += STRLEN(hotkp);
  		    else
***************
*** 3811,3824 ****
  		    if (dfltbutton)
  			--dfltbutton;
  
! 		    /* If no hotkey is specified first char is used. */
  		    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])
  			first_hotkey = TRUE;
  		}
  		else
  		{
! 		    len += 3;		    /* '\n' -> ', '; 'x' -> '(x)' */
! 		    lenhotkey += HOTK_LEN;  /* each button needs a hotkey */
  		    if (idx < HAS_HOTKEY_LEN - 1)
  			has_hotkey[++idx] = FALSE;
  		}
--- 3810,3823 ----
  		    if (dfltbutton)
  			--dfltbutton;
  
! 		    // If no hotkey is specified first char is used.
  		    if (idx < HAS_HOTKEY_LEN - 1 && !has_hotkey[++idx])
  			first_hotkey = TRUE;
  		}
  		else
  		{
! 		    len += 3;		    // '\n' -> ', '; 'x' -> '(x)'
! 		    lenhotkey += HOTK_LEN;  // each button needs a hotkey
  		    if (idx < HAS_HOTKEY_LEN - 1)
  			has_hotkey[++idx] = FALSE;
  		}
***************
*** 3830,3863 ****
  		first_hotkey = FALSE;
  		if (copy)
  		{
! 		    if (*r == DLG_HOTKEY_CHAR)		/* '&&a' -> '&a' */
  			*msgp++ = *r;
  		    else
  		    {
! 			/* '&a' -> '[a]' */
  			*msgp++ = (dfltbutton == 1) ? '[' : '(';
  			msgp += copy_char(r, msgp, FALSE);
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
! 			/* redefine hotkey */
  			hotkp[copy_char(r, hotkp, TRUE)] = NUL;
  		    }
  		}
  		else
  		{
! 		    ++len;	    /* '&a' -> '[a]' */
  		    if (idx < HAS_HOTKEY_LEN - 1)
  			has_hotkey[idx] = TRUE;
  		}
  	    }
  	    else
  	    {
! 		/* everything else copy literally */
  		if (copy)
  		    msgp += copy_char(r, msgp, FALSE);
  	    }
  
! 	    /* advance to the next character */
  	    MB_PTR_ADV(r);
  	}
  
--- 3829,3862 ----
  		first_hotkey = FALSE;
  		if (copy)
  		{
! 		    if (*r == DLG_HOTKEY_CHAR)		// '&&a' -> '&a'
  			*msgp++ = *r;
  		    else
  		    {
! 			// '&a' -> '[a]'
  			*msgp++ = (dfltbutton == 1) ? '[' : '(';
  			msgp += copy_char(r, msgp, FALSE);
  			*msgp++ = (dfltbutton == 1) ? ']' : ')';
  
! 			// redefine hotkey
  			hotkp[copy_char(r, hotkp, TRUE)] = NUL;
  		    }
  		}
  		else
  		{
! 		    ++len;	    // '&a' -> '[a]'
  		    if (idx < HAS_HOTKEY_LEN - 1)
  			has_hotkey[idx] = TRUE;
  		}
  	    }
  	    else
  	    {
! 		// everything else copy literally
  		if (copy)
  		    msgp += copy_char(r, msgp, FALSE);
  	    }
  
! 	    // advance to the next character
  	    MB_PTR_ADV(r);
  	}
  
***************
*** 3870,3885 ****
  	else
  	{
  	    len += (int)(STRLEN(message)
! 			+ 2			/* for the NL's */
  			+ STRLEN(buttons)
! 			+ 3);			/* for the ": " and NUL */
! 	    lenhotkey++;			/* for the NUL */
  
! 	    /* If no hotkey is specified first char is used. */
  	    if (!has_hotkey[0])
  	    {
  		first_hotkey = TRUE;
! 		len += 2;		/* "x" -> "[x]" */
  	    }
  
  	    /*
--- 3869,3884 ----
  	else
  	{
  	    len += (int)(STRLEN(message)
! 			+ 2			// for the NL's
  			+ STRLEN(buttons)
! 			+ 3);			// for the ": " and NUL
! 	    lenhotkey++;			// for the NUL
  
! 	    // If no hotkey is specified first char is used.
  	    if (!has_hotkey[0])
  	    {
  		first_hotkey = TRUE;
! 		len += 2;		// "x" -> "[x]"
  	    }
  
  	    /*
***************
*** 3900,3911 ****
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    /* Define first default hotkey.  Keep the hotkey string NUL
! 	     * terminated to avoid reading past the end. */
  	    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;
  
! 	    /* Remember where the choices start, displaying starts here when
! 	     * "hotkp" typed at the more prompt. */
  	    confirm_msg_tail = msgp;
  	    *msgp++ = '\n';
  	}
--- 3899,3910 ----
  	    msgp = confirm_msg + 1 + STRLEN(message);
  	    hotkp = hotk;
  
! 	    // Define first default hotkey.  Keep the hotkey string NUL
! 	    // terminated to avoid reading past the end.
  	    hotkp[copy_char(buttons, hotkp, TRUE)] = NUL;
  
! 	    // Remember where the choices start, displaying starts here when
! 	    // "hotkp" typed at the more prompt.
  	    confirm_msg_tail = msgp;
  	    *msgp++ = '\n';
  	}
***************
*** 3921,3934 ****
      static void
  display_confirm_msg(void)
  {
!     /* avoid that 'q' at the more prompt truncates the message here */
      ++confirm_msg_used;
      if (confirm_msg != NULL)
  	msg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));
      --confirm_msg_used;
  }
  
! #endif /* FEAT_CON_DIALOG */
  
  #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
  
--- 3920,3933 ----
      static void
  display_confirm_msg(void)
  {
!     // avoid that 'q' at the more prompt truncates the message here
      ++confirm_msg_used;
      if (confirm_msg != NULL)
  	msg_puts_attr((char *)confirm_msg, HL_ATTR(HLF_M));
      --confirm_msg_used;
  }
  
! #endif // FEAT_CON_DIALOG
  
  #if defined(FEAT_CON_DIALOG) || defined(FEAT_GUI_DIALOG)
  
***************
*** 3986,3992 ****
      return VIM_CANCEL;
  }
  
! #endif /* FEAT_GUI_DIALOG || FEAT_CON_DIALOG */
  
  #if defined(FEAT_EVAL)
  static char *e_printf = N_("E766: Insufficient arguments for printf()");
--- 3985,3991 ----
      return VIM_CANCEL;
  }
  
! #endif // FEAT_GUI_DIALOG || FEAT_CON_DIALOG
  
  #if defined(FEAT_EVAL)
  static char *e_printf = N_("E766: Insufficient arguments for printf()");
***************
*** 4134,4144 ****
   * "typval_T".  When the latter is not used it must be NULL.
   */
  
! /* When generating prototypes all of this is skipped, cproto doesn't
!  * understand this. */
  #ifndef PROTO
  
! /* Like vim_vsnprintf() but append to the string. */
      int
  vim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)
  {
--- 4133,4143 ----
   * "typval_T".  When the latter is not used it must be NULL.
   */
  
! // When generating prototypes all of this is skipped, cproto doesn't
! // understand this.
  #ifndef PROTO
  
! // Like vim_vsnprintf() but append to the string.
      int
  vim_snprintf_add(char *str, size_t str_m, const char *fmt, ...)
  {
***************
*** 4200,4206 ****
  	    char    *q = strchr(p + 1, '%');
  	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
  
! 	    /* Copy up to the next '%' or NUL without any changes. */
  	    if (str_l < str_m)
  	    {
  		size_t avail = str_m - str_l;
--- 4199,4205 ----
  	    char    *q = strchr(p + 1, '%');
  	    size_t  n = (q == NULL) ? STRLEN(p) : (size_t)(q - p);
  
! 	    // Copy up to the next '%' or NUL without any changes.
  	    if (str_l < str_m)
  	    {
  		size_t avail = str_m - str_l;
***************
*** 4216,4233 ****
  	    int	    zero_padding = 0, precision_specified = 0, justify_left = 0;
  	    int	    alternate_form = 0, force_sign = 0;
  
! 	    /* If both the ' ' and '+' flags appear, the ' ' flag should be
! 	     * ignored. */
  	    int	    space_for_positive = 1;
  
! 	    /* allowed values: \0, h, l, L */
  	    char    length_modifier = '\0';
  
! 	    /* temporary buffer for simple numeric->string conversion */
  # if defined(FEAT_FLOAT)
! #  define TMP_LEN 350	/* On my system 1e308 is the biggest number possible.
! 			 * That sounds reasonable to use as the maximum
! 			 * printable. */
  # elif defined(FEAT_NUM64)
  #  define TMP_LEN 66
  # else
--- 4215,4232 ----
  	    int	    zero_padding = 0, precision_specified = 0, justify_left = 0;
  	    int	    alternate_form = 0, force_sign = 0;
  
! 	    // If both the ' ' and '+' flags appear, the ' ' flag should be
! 	    // ignored.
  	    int	    space_for_positive = 1;
  
! 	    // allowed values: \0, h, l, L
  	    char    length_modifier = '\0';
  
! 	    // temporary buffer for simple numeric->string conversion
  # if defined(FEAT_FLOAT)
! #  define TMP_LEN 350	// On my system 1e308 is the biggest number possible.
! 			// That sounds reasonable to use as the maximum
! 			// printable.
  # elif defined(FEAT_NUM64)
  #  define TMP_LEN 66
  # else
***************
*** 4235,4268 ****
  # endif
  	    char    tmp[TMP_LEN];
  
! 	    /* string address in case of string argument */
  	    const char  *str_arg = NULL;
  
! 	    /* natural field width of arg without padding and sign */
  	    size_t  str_arg_l;
  
! 	    /* unsigned char argument value - only defined for c conversion.
! 	     * N.B. standard explicitly states the char argument for the c
! 	     * conversion is unsigned */
  	    unsigned char uchar_arg;
  
! 	    /* number of zeros to be inserted for numeric conversions as
! 	     * required by the precision or minimal field width */
  	    size_t  number_of_zeros_to_pad = 0;
  
! 	    /* index into tmp where zero padding is to be inserted */
  	    size_t  zero_padding_insertion_ind = 0;
  
! 	    /* current conversion specifier character */
  	    char    fmt_spec = '\0';
  
! 	    /* buffer for 's' and 'S' specs */
  	    char_u  *tofree = NULL;
  
  
! 	    p++;  /* skip '%' */
  
! 	    /* parse flags */
  	    while (*p == '0' || *p == '-' || *p == '+' || *p == ' '
  						   || *p == '#' || *p == '\'')
  	    {
--- 4234,4267 ----
  # endif
  	    char    tmp[TMP_LEN];
  
! 	    // string address in case of string argument
  	    const char  *str_arg = NULL;
  
! 	    // natural field width of arg without padding and sign
  	    size_t  str_arg_l;
  
! 	    // unsigned char argument value - only defined for c conversion.
! 	    // N.B. standard explicitly states the char argument for the c
! 	    // conversion is unsigned
  	    unsigned char uchar_arg;
  
! 	    // number of zeros to be inserted for numeric conversions as
! 	    // required by the precision or minimal field width
  	    size_t  number_of_zeros_to_pad = 0;
  
! 	    // index into tmp where zero padding is to be inserted
  	    size_t  zero_padding_insertion_ind = 0;
  
! 	    // current conversion specifier character
  	    char    fmt_spec = '\0';
  
! 	    // buffer for 's' and 'S' specs
  	    char_u  *tofree = NULL;
  
  
! 	    p++;  // skip '%'
  
! 	    // parse flags
  	    while (*p == '0' || *p == '-' || *p == '+' || *p == ' '
  						   || *p == '#' || *p == '\'')
  	    {
***************
*** 4272,4289 ****
  		    case '-': justify_left = 1; break;
  		    case '+': force_sign = 1; space_for_positive = 0; break;
  		    case ' ': force_sign = 1;
! 			      /* If both the ' ' and '+' flags appear, the ' '
! 			       * flag should be ignored */
  			      break;
  		    case '#': alternate_form = 1; break;
  		    case '\'': break;
  		}
  		p++;
  	    }
! 	    /* If the '0' and '-' flags both appear, the '0' flag should be
! 	     * ignored. */
  
! 	    /* parse field width */
  	    if (*p == '*')
  	    {
  		int j;
--- 4271,4288 ----
  		    case '-': justify_left = 1; break;
  		    case '+': force_sign = 1; space_for_positive = 0; break;
  		    case ' ': force_sign = 1;
! 			      // If both the ' ' and '+' flags appear, the ' '
! 			      // flag should be ignored
  			      break;
  		    case '#': alternate_form = 1; break;
  		    case '\'': break;
  		}
  		p++;
  	    }
! 	    // If the '0' and '-' flags both appear, the '0' flag should be
! 	    // ignored.
  
! 	    // parse field width
  	    if (*p == '*')
  	    {
  		int j;
***************
*** 4304,4311 ****
  	    }
  	    else if (VIM_ISDIGIT((int)(*p)))
  	    {
! 		/* size_t could be wider than unsigned int; make sure we treat
! 		 * argument like common implementations do */
  		unsigned int uj = *p++ - '0';
  
  		while (VIM_ISDIGIT((int)(*p)))
--- 4303,4310 ----
  	    }
  	    else if (VIM_ISDIGIT((int)(*p)))
  	    {
! 		// size_t could be wider than unsigned int; make sure we treat
! 		// argument like common implementations do
  		unsigned int uj = *p++ - '0';
  
  		while (VIM_ISDIGIT((int)(*p)))
***************
*** 4313,4319 ****
  		min_field_width = uj;
  	    }
  
! 	    /* parse precision */
  	    if (*p == '.')
  	    {
  		p++;
--- 4312,4318 ----
  		min_field_width = uj;
  	    }
  
! 	    // parse precision
  	    if (*p == '.')
  	    {
  		p++;
***************
*** 4338,4345 ****
  		}
  		else if (VIM_ISDIGIT((int)(*p)))
  		{
! 		    /* size_t could be wider than unsigned int; make sure we
! 		     * treat argument like common implementations do */
  		    unsigned int uj = *p++ - '0';
  
  		    while (VIM_ISDIGIT((int)(*p)))
--- 4337,4344 ----
  		}
  		else if (VIM_ISDIGIT((int)(*p)))
  		{
! 		    // size_t could be wider than unsigned int; make sure we
! 		    // treat argument like common implementations do
  		    unsigned int uj = *p++ - '0';
  
  		    while (VIM_ISDIGIT((int)(*p)))
***************
*** 4348,4372 ****
  		}
  	    }
  
! 	    /* parse 'h', 'l' and 'll' length modifiers */
  	    if (*p == 'h' || *p == 'l')
  	    {
  		length_modifier = *p;
  		p++;
  		if (length_modifier == 'l' && *p == 'l')
  		{
! 		    /* double l = long long */
  # ifdef FEAT_NUM64
  		    length_modifier = 'L';
  # else
! 		    length_modifier = 'l';	/* treat it as a single 'l' */
  # endif
  		    p++;
  		}
  	    }
  	    fmt_spec = *p;
  
! 	    /* common synonyms: */
  	    switch (fmt_spec)
  	    {
  		case 'i': fmt_spec = 'd'; break;
--- 4347,4371 ----
  		}
  	    }
  
! 	    // parse 'h', 'l' and 'll' length modifiers
  	    if (*p == 'h' || *p == 'l')
  	    {
  		length_modifier = *p;
  		p++;
  		if (length_modifier == 'l' && *p == 'l')
  		{
! 		    // double l = long long
  # ifdef FEAT_NUM64
  		    length_modifier = 'L';
  # else
! 		    length_modifier = 'l';	// treat it as a single 'l'
  # endif
  		    p++;
  		}
  	    }
  	    fmt_spec = *p;
  
! 	    // common synonyms:
  	    switch (fmt_spec)
  	    {
  		case 'i': fmt_spec = 'd'; break;
***************
*** 4385,4395 ****
  	    }
  # endif
  
! 	    /* get parameter value, do initial processing */
  	    switch (fmt_spec)
  	    {
! 		/* '%' and 'c' behave similar to 's' regarding flags and field
! 		 * widths */
  	    case '%':
  	    case 'c':
  	    case 's':
--- 4384,4394 ----
  	    }
  # endif
  
! 	    // get parameter value, do initial processing
  	    switch (fmt_spec)
  	    {
! 		// '%' and 'c' behave similar to 's' regarding flags and field
! 		// widths
  	    case '%':
  	    case 'c':
  	    case 's':
***************
*** 4410,4416 ****
  			    tvs != NULL ? tv_nr(tvs, &arg_idx) :
  # endif
  				va_arg(ap, int);
! 			/* standard demands unsigned char */
  			uchar_arg = (unsigned char)j;
  			str_arg = (char *)&uchar_arg;
  			break;
--- 4409,4415 ----
  			    tvs != NULL ? tv_nr(tvs, &arg_idx) :
  # endif
  				va_arg(ap, int);
! 			// standard demands unsigned char
  			uchar_arg = (unsigned char)j;
  			str_arg = (char *)&uchar_arg;
  			break;
***************
*** 4428,4445 ****
  			str_arg = "[NULL]";
  			str_arg_l = 6;
  		    }
! 		    /* make sure not to address string beyond the specified
! 		     * precision !!! */
  		    else if (!precision_specified)
  			str_arg_l = strlen(str_arg);
! 		    /* truncate string if necessary as requested by precision */
  		    else if (precision == 0)
  			str_arg_l = 0;
  		    else
  		    {
! 			/* Don't put the #if inside memchr(), it can be a
! 			 * macro. */
! 			/* memchr on HP does not like n > 2^31  !!! */
  			char *q = memchr(str_arg, '\0',
  				  precision <= (size_t)0x7fffffffL ? precision
  						       : (size_t)0x7fffffffL);
--- 4427,4444 ----
  			str_arg = "[NULL]";
  			str_arg_l = 6;
  		    }
! 		    // make sure not to address string beyond the specified
! 		    // precision !!!
  		    else if (!precision_specified)
  			str_arg_l = strlen(str_arg);
! 		    // truncate string if necessary as requested by precision
  		    else if (precision == 0)
  			str_arg_l = 0;
  		    else
  		    {
! 			// Don't put the #if inside memchr(), it can be a
! 			// macro.
! 			// memchr on HP does not like n > 2^31  !!!
  			char *q = memchr(str_arg, '\0',
  				  precision <= (size_t)0x7fffffffL ? precision
  						       : (size_t)0x7fffffffL);
***************
*** 4479,4514 ****
  	    case 'x': case 'X':
  	    case 'p':
  		{
! 		    /* NOTE: the u, b, o, x, X and p conversion specifiers
! 		     * imply the value is unsigned;  d implies a signed
! 		     * value */
! 
! 		    /* 0 if numeric argument is zero (or if pointer is
! 		     * NULL for 'p'), +1 if greater than zero (or nonzero
! 		     * for unsigned arguments), -1 if negative (unsigned
! 		     * argument is never negative) */
  		    int arg_sign = 0;
  
! 		    /* only defined for length modifier h, or for no
! 		     * length modifiers */
  		    int int_arg = 0;
  		    unsigned int uint_arg = 0;
  
! 		    /* only defined for length modifier l */
  		    long int long_arg = 0;
  		    unsigned long int ulong_arg = 0;
  
  # ifdef FEAT_NUM64
! 		    /* only defined for length modifier ll */
  		    varnumber_T llong_arg = 0;
  		    uvarnumber_T ullong_arg = 0;
  # endif
  
! 		    /* only defined for b conversion */
  		    uvarnumber_T bin_arg = 0;
  
! 		    /* pointer argument value -only defined for p
! 		     * conversion */
  		    void *ptr_arg = NULL;
  
  		    if (fmt_spec == 'p')
--- 4478,4513 ----
  	    case 'x': case 'X':
  	    case 'p':
  		{
! 		    // NOTE: the u, b, o, x, X and p conversion specifiers
! 		    // imply the value is unsigned;  d implies a signed
! 		    // value
! 
! 		    // 0 if numeric argument is zero (or if pointer is
! 		    // NULL for 'p'), +1 if greater than zero (or nonzero
! 		    // for unsigned arguments), -1 if negative (unsigned
! 		    // argument is never negative)
  		    int arg_sign = 0;
  
! 		    // only defined for length modifier h, or for no
! 		    // length modifiers
  		    int int_arg = 0;
  		    unsigned int uint_arg = 0;
  
! 		    // only defined for length modifier l
  		    long int long_arg = 0;
  		    unsigned long int ulong_arg = 0;
  
  # ifdef FEAT_NUM64
! 		    // only defined for length modifier ll
  		    varnumber_T llong_arg = 0;
  		    uvarnumber_T ullong_arg = 0;
  # endif
  
! 		    // only defined for b conversion
  		    uvarnumber_T bin_arg = 0;
  
! 		    // pointer argument value -only defined for p
! 		    // conversion
  		    void *ptr_arg = NULL;
  
  		    if (fmt_spec == 'p')
***************
*** 4536,4547 ****
  		    }
  		    else if (fmt_spec == 'd')
  		    {
! 			/* signed */
  			switch (length_modifier)
  			{
  			case '\0':
  			case 'h':
! 			    /* char and short arguments are passed as int. */
  			    int_arg =
  # if defined(FEAT_EVAL)
  					tvs != NULL ? tv_nr(tvs, &arg_idx) :
--- 4535,4546 ----
  		    }
  		    else if (fmt_spec == 'd')
  		    {
! 			// signed
  			switch (length_modifier)
  			{
  			case '\0':
  			case 'h':
! 			    // char and short arguments are passed as int.
  			    int_arg =
  # if defined(FEAT_EVAL)
  					tvs != NULL ? tv_nr(tvs, &arg_idx) :
***************
*** 4580,4586 ****
  		    }
  		    else
  		    {
! 			/* unsigned */
  			switch (length_modifier)
  			{
  			    case '\0':
--- 4579,4585 ----
  		    }
  		    else
  		    {
! 			// unsigned
  			switch (length_modifier)
  			{
  			    case '\0':
***************
*** 4622,4641 ****
  		    str_arg = tmp;
  		    str_arg_l = 0;
  
! 		    /* NOTE:
! 		     *   For d, i, u, o, x, and X conversions, if precision is
! 		     *   specified, the '0' flag should be ignored. This is so
! 		     *   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,
! 		     *   FreeBSD, NetBSD; but not with Perl.
! 		     */
  		    if (precision_specified)
  			zero_padding = 0;
  		    if (fmt_spec == 'd')
  		    {
  			if (force_sign && arg_sign >= 0)
  			    tmp[str_arg_l++] = space_for_positive ? ' ' : '+';
! 			/* leave negative numbers for sprintf to handle, to
! 			 * avoid handling tricky cases like (short int)-32768 */
  		    }
  		    else if (alternate_form)
  		    {
--- 4621,4639 ----
  		    str_arg = tmp;
  		    str_arg_l = 0;
  
! 		    // NOTE:
! 		    //   For d, i, u, o, x, and X conversions, if precision is
! 		    //   specified, the '0' flag should be ignored. This is so
! 		    //   with Solaris 2.6, Digital UNIX 4.0, HPUX 10, Linux,
! 		    //   FreeBSD, NetBSD; but not with Perl.
  		    if (precision_specified)
  			zero_padding = 0;
  		    if (fmt_spec == 'd')
  		    {
  			if (force_sign && arg_sign >= 0)
  			    tmp[str_arg_l++] = space_for_positive ? ' ' : '+';
! 			// leave negative numbers for sprintf to handle, to
! 			// avoid handling tricky cases like (short int)-32768
  		    }
  		    else if (alternate_form)
  		    {
***************
*** 4646,4670 ****
  			    tmp[str_arg_l++] = '0';
  			    tmp[str_arg_l++] = fmt_spec;
  			}
! 			/* alternate form should have no effect for p
! 			 * conversion, but ... */
  		    }
  
  		    zero_padding_insertion_ind = str_arg_l;
  		    if (!precision_specified)
! 			precision = 1;   /* default precision is 1 */
  		    if (precision == 0 && arg_sign == 0)
  		    {
! 			/* When zero value is formatted with an explicit
! 			 * precision 0, the resulting formatted string is
! 			 * empty (d, i, u, b, B, o, x, X, p).   */
  		    }
  		    else
  		    {
  			char	f[6];
  			int	f_l = 0;
  
! 			/* construct a simple format string for sprintf */
  			f[f_l++] = '%';
  			if (!length_modifier)
  			    ;
--- 4644,4668 ----
  			    tmp[str_arg_l++] = '0';
  			    tmp[str_arg_l++] = fmt_spec;
  			}
! 			// alternate form should have no effect for p
! 			// conversion, but ...
  		    }
  
  		    zero_padding_insertion_ind = str_arg_l;
  		    if (!precision_specified)
! 			precision = 1;   // default precision is 1
  		    if (precision == 0 && arg_sign == 0)
  		    {
! 			// When zero value is formatted with an explicit
! 			// precision 0, the resulting formatted string is
! 			// empty (d, i, u, b, B, o, x, X, p).
  		    }
  		    else
  		    {
  			char	f[6];
  			int	f_l = 0;
  
! 			// construct a simple format string for sprintf
  			f[f_l++] = '%';
  			if (!length_modifier)
  			    ;
***************
*** 4708,4714 ****
  			}
  			else if (fmt_spec == 'd')
  			{
! 			    /* signed */
  			    switch (length_modifier)
  			    {
  			    case '\0':
--- 4706,4712 ----
  			}
  			else if (fmt_spec == 'd')
  			{
! 			    // signed
  			    switch (length_modifier)
  			    {
  			    case '\0':
***************
*** 4727,4733 ****
  			}
  			else
  			{
! 			    /* unsigned */
  			    switch (length_modifier)
  			    {
  			    case '\0':
--- 4725,4731 ----
  			}
  			else
  			{
! 			    // unsigned
  			    switch (length_modifier)
  			    {
  			    case '\0':
***************
*** 4745,4753 ****
  			    }
  			}
  
! 			/* include the optional minus sign and possible
! 			 * "0x" in the region before the zero padding
! 			 * insertion point */
  			if (zero_padding_insertion_ind < str_arg_l
  				&& tmp[zero_padding_insertion_ind] == '-')
  			    zero_padding_insertion_ind++;
--- 4743,4751 ----
  			    }
  			}
  
! 			// include the optional minus sign and possible
! 			// "0x" in the region before the zero padding
! 			// insertion point
  			if (zero_padding_insertion_ind < str_arg_l
  				&& tmp[zero_padding_insertion_ind] == '-')
  			    zero_padding_insertion_ind++;
***************
*** 4763,4790 ****
  						 - zero_padding_insertion_ind;
  
  			if (alternate_form && fmt_spec == 'o'
! 				/* unless zero is already the first
! 				 * character */
  				&& !(zero_padding_insertion_ind < str_arg_l
  				    && tmp[zero_padding_insertion_ind] == '0'))
  			{
! 			    /* assure leading zero for alternate-form
! 			     * octal numbers */
  			    if (!precision_specified
  					     || precision < num_of_digits + 1)
  			    {
! 				/* precision is increased to force the
! 				 * first character to be zero, except if a
! 				 * zero value is formatted with an
! 				 * explicit precision of zero */
  				precision = num_of_digits + 1;
  			    }
  			}
! 			/* zero padding to specified precision? */
  			if (num_of_digits < precision)
  			    number_of_zeros_to_pad = precision - num_of_digits;
  		    }
! 		    /* zero padding to specified minimal field width? */
  		    if (!justify_left && zero_padding)
  		    {
  			int n = (int)(min_field_width - (str_arg_l
--- 4761,4788 ----
  						 - zero_padding_insertion_ind;
  
  			if (alternate_form && fmt_spec == 'o'
! 				// unless zero is already the first
! 				// character
  				&& !(zero_padding_insertion_ind < str_arg_l
  				    && tmp[zero_padding_insertion_ind] == '0'))
  			{
! 			    // assure leading zero for alternate-form
! 			    // octal numbers
  			    if (!precision_specified
  					     || precision < num_of_digits + 1)
  			    {
! 				// precision is increased to force the
! 				// first character to be zero, except if a
! 				// zero value is formatted with an
! 				// explicit precision of zero
  				precision = num_of_digits + 1;
  			    }
  			}
! 			// zero padding to specified precision?
  			if (num_of_digits < precision)
  			    number_of_zeros_to_pad = precision - num_of_digits;
  		    }
! 		    // zero padding to specified minimal field width?
  		    if (!justify_left && zero_padding)
  		    {
  			int n = (int)(min_field_width - (str_arg_l
***************
*** 4803,4809 ****
  	    case 'g':
  	    case 'G':
  		{
! 		    /* Floating point. */
  		    double	f;
  		    double	abs_f;
  		    char	format[40];
--- 4801,4807 ----
  	    case 'g':
  	    case 'G':
  		{
! 		    // Floating point.
  		    double	f;
  		    double	abs_f;
  		    char	format[40];
***************
*** 4819,4826 ****
  
  		    if (fmt_spec == 'g' || fmt_spec == 'G')
  		    {
! 			/* Would be nice to use %g directly, but it prints
! 			 * "1.0" as "1", we don't want that. */
  			if ((abs_f >= 0.001 && abs_f < 10000000.0)
  							      || abs_f == 0.0)
  			    fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';
--- 4817,4824 ----
  
  		    if (fmt_spec == 'g' || fmt_spec == 'G')
  		    {
! 			// Would be nice to use %g directly, but it prints
! 			// "1.0" as "1", we don't want that.
  			if ((abs_f >= 0.001 && abs_f < 10000000.0)
  							      || abs_f == 0.0)
  			    fmt_spec = ASCII_ISUPPER(fmt_spec) ? 'F' : 'f';
***************
*** 4837,4843 ****
  #  endif
  			    )
  		    {
! 			/* Avoid a buffer overflow */
  			STRCPY(tmp, infinity_str(f > 0.0, fmt_spec,
  					      force_sign, space_for_positive));
  			str_arg_l = STRLEN(tmp);
--- 4835,4841 ----
  #  endif
  			    )
  		    {
! 			// Avoid a buffer overflow
  			STRCPY(tmp, infinity_str(f > 0.0, fmt_spec,
  					      force_sign, space_for_positive));
  			str_arg_l = STRLEN(tmp);
***************
*** 4847,4853 ****
  		    {
  			if (isnan(f))
  			{
! 			    /* Not a number: nan or NAN */
  			    STRCPY(tmp, ASCII_ISUPPER(fmt_spec) ? "NAN"
  								      : "nan");
  			    str_arg_l = 3;
--- 4845,4851 ----
  		    {
  			if (isnan(f))
  			{
! 			    // Not a number: nan or NAN
  			    STRCPY(tmp, ASCII_ISUPPER(fmt_spec) ? "NAN"
  								      : "nan");
  			    str_arg_l = 3;
***************
*** 4862,4868 ****
  			}
  			else
  			{
! 			    /* Regular float number */
  			    format[0] = '%';
  			    l = 1;
  			    if (force_sign)
--- 4860,4866 ----
  			}
  			else
  			{
! 			    // Regular float number
  			    format[0] = '%';
  			    l = 1;
  			    if (force_sign)
***************
*** 4871,4878 ****
  			    {
  				size_t max_prec = TMP_LEN - 10;
  
! 				/* Make sure we don't get more digits than we
! 				 * have room for. */
  				if ((fmt_spec == 'f' || fmt_spec == 'F')
  								&& abs_f > 1.0)
  				    max_prec -= (size_t)log10(abs_f);
--- 4869,4876 ----
  			    {
  				size_t max_prec = TMP_LEN - 10;
  
! 				// Make sure we don't get more digits than we
! 				// have room for.
  				if ((fmt_spec == 'f' || fmt_spec == 'F')
  								&& abs_f > 1.0)
  				    max_prec -= (size_t)log10(abs_f);
***************
*** 4891,4897 ****
  			    int i;
  			    char *tp;
  
! 			    /* Using %g or %G: remove superfluous zeroes. */
  			    if (fmt_spec == 'f' || fmt_spec == 'F')
  				tp = tmp + str_arg_l - 1;
  			    else
--- 4889,4895 ----
  			    int i;
  			    char *tp;
  
! 			    // Using %g or %G: remove superfluous zeroes.
  			    if (fmt_spec == 'f' || fmt_spec == 'F')
  				tp = tmp + str_arg_l - 1;
  			    else
***************
*** 4900,4917 ****
  						 fmt_spec == 'e' ? 'e' : 'E');
  				if (tp != NULL)
  				{
! 				    /* Remove superfluous '+' and leading
! 				     * zeroes from the exponent. */
  				    if (tp[1] == '+')
  				    {
! 					/* Change "1.0e+07" to "1.0e07" */
  					STRMOVE(tp + 1, tp + 2);
  					--str_arg_l;
  				    }
  				    i = (tp[1] == '-') ? 2 : 1;
  				    while (tp[i] == '0')
  				    {
! 					/* Change "1.0e07" to "1.0e7" */
  					STRMOVE(tp + i, tp + i + 1);
  					--str_arg_l;
  				    }
--- 4898,4915 ----
  						 fmt_spec == 'e' ? 'e' : 'E');
  				if (tp != NULL)
  				{
! 				    // Remove superfluous '+' and leading
! 				    // zeroes from the exponent.
  				    if (tp[1] == '+')
  				    {
! 					// Change "1.0e+07" to "1.0e07"
  					STRMOVE(tp + 1, tp + 2);
  					--str_arg_l;
  				    }
  				    i = (tp[1] == '-') ? 2 : 1;
  				    while (tp[i] == '0')
  				    {
! 					// Change "1.0e07" to "1.0e7"
  					STRMOVE(tp + i, tp + i + 1);
  					--str_arg_l;
  				    }
***************
*** 4920,4927 ****
  			    }
  
  			    if (tp != NULL && !precision_specified)
! 				/* Remove trailing zeroes, but keep the one
! 				 * just after a dot. */
  				while (tp > tmp + 2 && *tp == '0'
  							     && tp[-1] != '.')
  				{
--- 4918,4925 ----
  			    }
  
  			    if (tp != NULL && !precision_specified)
! 				// Remove trailing zeroes, but keep the one
! 				// just after a dot.
  				while (tp > tmp + 2 && *tp == '0'
  							     && tp[-1] != '.')
  				{
***************
*** 4934,4942 ****
  			{
  			    char *tp;
  
! 			    /* Be consistent: some printf("%e") use 1.0e+12
! 			     * and some 1.0e+012.  Remove one zero in the last
! 			     * case. */
  			    tp = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
  			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
--- 4932,4940 ----
  			{
  			    char *tp;
  
! 			    // Be consistent: some printf("%e") use 1.0e+12
! 			    // and some 1.0e+012.  Remove one zero in the last
! 			    // case.
  			    tp = (char *)vim_strchr((char_u *)tmp,
  						 fmt_spec == 'e' ? 'e' : 'E');
  			    if (tp != NULL && (tp[1] == '+' || tp[1] == '-')
***************
*** 4952,4958 ****
  		    if (zero_padding && min_field_width > str_arg_l
  					      && (tmp[0] == '-' || force_sign))
  		    {
! 			/* padding 0's should be inserted after the sign */
  			number_of_zeros_to_pad = min_field_width - str_arg_l;
  			zero_padding_insertion_ind = 1;
  		    }
--- 4950,4956 ----
  		    if (zero_padding && min_field_width > str_arg_l
  					      && (tmp[0] == '-' || force_sign))
  		    {
! 			// padding 0's should be inserted after the sign
  			number_of_zeros_to_pad = min_field_width - str_arg_l;
  			zero_padding_insertion_ind = 1;
  		    }
***************
*** 4962,4993 ****
  # endif
  
  	    default:
! 		/* unrecognized conversion specifier, keep format string
! 		 * as-is */
! 		zero_padding = 0;  /* turn zero padding off for non-numeric
! 				      conversion */
  		justify_left = 1;
! 		min_field_width = 0;		    /* reset flags */
  
! 		/* discard the unrecognized conversion, just keep *
! 		 * the unrecognized conversion character	  */
  		str_arg = p;
  		str_arg_l = 0;
  		if (*p != NUL)
! 		    str_arg_l++;  /* include invalid conversion specifier
! 				     unchanged if not at end-of-string */
  		break;
  	    }
  
  	    if (*p != NUL)
! 		p++;     /* step over the just processed conversion specifier */
  
! 	    /* insert padding to the left as requested by min_field_width;
! 	     * this does not include the zero padding in case of numerical
! 	     * conversions*/
  	    if (!justify_left)
  	    {
! 		/* left padding with blank or zero */
  		int pn = (int)(min_field_width - (str_arg_l + number_of_zeros_to_pad));
  
  		if (pn > 0)
--- 4960,4991 ----
  # endif
  
  	    default:
! 		// unrecognized conversion specifier, keep format string
! 		// as-is
! 		zero_padding = 0;  // turn zero padding off for non-numeric
! 				   // conversion
  		justify_left = 1;
! 		min_field_width = 0;		    // reset flags
  
! 		// discard the unrecognized conversion, just keep *
! 		// the unrecognized conversion character
  		str_arg = p;
  		str_arg_l = 0;
  		if (*p != NUL)
! 		    str_arg_l++;  // include invalid conversion specifier
! 				  // unchanged if not at end-of-string
  		break;
  	    }
  
  	    if (*p != NUL)
! 		p++;     // step over the just processed conversion specifier
  
! 	    // insert padding to the left as requested by min_field_width;
! 	    // this does not include the zero padding in case of numerical
! 	    // conversions
  	    if (!justify_left)
  	    {
! 		// left padding with blank or zero
  		int pn = (int)(min_field_width - (str_arg_l + number_of_zeros_to_pad));
  
  		if (pn > 0)
***************
*** 5004,5021 ****
  		}
  	    }
  
! 	    /* zero padding as requested by the precision or by the minimal
! 	     * field width for numeric conversions required? */
  	    if (number_of_zeros_to_pad == 0)
  	    {
! 		/* will not copy first part of numeric right now, *
! 		 * force it to be copied later in its entirety    */
  		zero_padding_insertion_ind = 0;
  	    }
  	    else
  	    {
! 		/* insert first part of numerics (sign or '0x') before zero
! 		 * padding */
  		int zn = (int)zero_padding_insertion_ind;
  
  		if (zn > 0)
--- 5002,5019 ----
  		}
  	    }
  
! 	    // zero padding as requested by the precision or by the minimal
! 	    // field width for numeric conversions required?
  	    if (number_of_zeros_to_pad == 0)
  	    {
! 		// will not copy first part of numeric right now, *
! 		// force it to be copied later in its entirety
  		zero_padding_insertion_ind = 0;
  	    }
  	    else
  	    {
! 		// insert first part of numerics (sign or '0x') before zero
! 		// padding
  		int zn = (int)zero_padding_insertion_ind;
  
  		if (zn > 0)
***************
*** 5031,5038 ****
  		    str_l += zn;
  		}
  
! 		/* insert zero padding as requested by the precision or min
! 		 * field width */
  		zn = (int)number_of_zeros_to_pad;
  		if (zn > 0)
  		{
--- 5029,5036 ----
  		    str_l += zn;
  		}
  
! 		// insert zero padding as requested by the precision or min
! 		// field width
  		zn = (int)number_of_zeros_to_pad;
  		if (zn > 0)
  		{
***************
*** 5048,5055 ****
  		}
  	    }
  
! 	    /* insert formatted string
! 	     * (or as-is conversion specifier for unknown conversions) */
  	    {
  		int sn = (int)(str_arg_l - zero_padding_insertion_ind);
  
--- 5046,5053 ----
  		}
  	    }
  
! 	    // insert formatted string
! 	    // (or as-is conversion specifier for unknown conversions)
  	    {
  		int sn = (int)(str_arg_l - zero_padding_insertion_ind);
  
***************
*** 5067,5076 ****
  		}
  	    }
  
! 	    /* insert right padding */
  	    if (justify_left)
  	    {
! 		/* right blank padding to the field width */
  		int pn = (int)(min_field_width
  				      - (str_arg_l + number_of_zeros_to_pad));
  
--- 5065,5074 ----
  		}
  	    }
  
! 	    // insert right padding
  	    if (justify_left)
  	    {
! 		// right blank padding to the field width
  		int pn = (int)(min_field_width
  				      - (str_arg_l + number_of_zeros_to_pad));
  
***************
*** 5093,5111 ****
  
      if (str_m > 0)
      {
! 	/* make sure the string is nul-terminated even at the expense of
! 	 * overwriting the last character (shouldn't happen, but just in case)
! 	 * */
  	str[str_l <= str_m - 1 ? str_l : str_m - 1] = '\0';
      }
  
      if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)
  	emsg(_("E767: Too many arguments to printf()"));
  
!     /* Return the number of characters formatted (excluding trailing nul
!      * character), that is, the number of characters that would have been
!      * written to the buffer if it were large enough. */
      return (int)str_l;
  }
  
! #endif /* PROTO */
--- 5091,5109 ----
  
      if (str_m > 0)
      {
! 	// make sure the string is nul-terminated even at the expense of
! 	// overwriting the last character (shouldn't happen, but just in case)
! 	//
  	str[str_l <= str_m - 1 ? str_l : str_m - 1] = '\0';
      }
  
      if (tvs != NULL && tvs[arg_idx - 1].v_type != VAR_UNKNOWN)
  	emsg(_("E767: Too many arguments to printf()"));
  
!     // Return the number of characters formatted (excluding trailing nul
!     // character), that is, the number of characters that would have been
!     // written to the buffer if it were large enough.
      return (int)str_l;
  }
  
! #endif // PROTO
*** ../vim-8.2.0025/src/message_test.c	2017-04-02 18:08:20.000000000 +0200
--- src/message_test.c	2019-12-21 18:18:10.923197763 +0100
***************
*** 14,25 ****
  #undef NDEBUG
  #include <assert.h>
  
! /* Must include main.c because it contains much more than just main() */
  #define NO_VIM_MAIN
  #include "main.c"
  
! /* This file has to be included because some of the tested functions are
!  * static. */
  #include "message.c"
  
  /*
--- 14,25 ----
  #undef NDEBUG
  #include <assert.h>
  
! // Must include main.c because it contains much more than just main()
  #define NO_VIM_MAIN
  #include "main.c"
  
! // This file has to be included because some of the tested functions are
! // static.
  #include "message.c"
  
  /*
***************
*** 31,37 ****
      char_u  *buf; /*allocated every time to find uninit errors */
      char_u  *s;
  
!     /* in place */
      buf = alloc(40);
      STRCPY(buf, "text");
      trunc_string(buf, buf, 20, 40);
--- 31,37 ----
      char_u  *buf; /*allocated every time to find uninit errors */
      char_u  *s;
  
!     // in place
      buf = alloc(40);
      STRCPY(buf, "text");
      trunc_string(buf, buf, 20, 40);
***************
*** 56,62 ****
      assert(STRCMP(buf, "a text t...nott fits") == 0);
      vim_free(buf);
  
!     /* copy from string to buf */
      buf = alloc(40);
      s = vim_strsave((char_u *)"text");
      trunc_string(s, buf, 20, 40);
--- 56,62 ----
      assert(STRCMP(buf, "a text t...nott fits") == 0);
      vim_free(buf);
  
!     // copy from string to buf
      buf = alloc(40);
      s = vim_strsave((char_u *)"text");
      trunc_string(s, buf, 20, 40);
*** ../vim-8.2.0025/src/misc1.c	2019-11-05 21:42:59.000000000 +0100
--- src/misc1.c	2019-12-21 18:10:15.636873781 +0100
***************
*** 18,25 ****
  # include <lm.h>
  #endif
  
! #define URL_SLASH	1		/* path_is_url() has found "://" */
! #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
  
  // All user names (for ~user completion as done by shell).
  static garray_T	ga_users;
--- 18,25 ----
  # include <lm.h>
  #endif
  
! #define URL_SLASH	1		// path_is_url() has found "://"
! #define URL_BACKSLASH	2		// path_is_url() has found ":\\"
  
  // All user names (for ~user completion as done by shell).
  static garray_T	ga_users;
***************
*** 45,59 ****
      int		result;
      int		got_com = FALSE;
      int		found_one;
!     char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
!     char_u	*string;		/* pointer to comment string */
      char_u	*list;
      int		middle_match_len = 0;
      char_u	*prev_list;
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (VIM_ISWHITE(line[i]))    /* leading white space is ignored */
  	++i;
  
      /*
--- 45,59 ----
      int		result;
      int		got_com = FALSE;
      int		found_one;
!     char_u	part_buf[COM_MAX_LEN];	// buffer for one option part
!     char_u	*string;		// pointer to comment string
      char_u	*list;
      int		middle_match_len = 0;
      char_u	*prev_list;
      char_u	*saved_flags = NULL;
  
      result = i = 0;
!     while (VIM_ISWHITE(line[i]))    // leading white space is ignored
  	++i;
  
      /*
***************
*** 67,126 ****
  	found_one = FALSE;
  	for (list = curbuf->b_p_com; *list; )
  	{
! 	    /* Get one option part into part_buf[].  Advance "list" to next
! 	     * one.  Put "string" at start of string.  */
  	    if (!got_com && flags != NULL)
! 		*flags = list;	    /* remember where flags started */
  	    prev_list = list;
  	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
  	    string = vim_strchr(part_buf, ':');
! 	    if (string == NULL)	    /* missing ':', ignore this part */
  		continue;
! 	    *string++ = NUL;	    /* isolate flags from string */
  
! 	    /* If we found a middle match previously, use that match when this
! 	     * is not a middle or end. */
  	    if (middle_match_len != 0
  		    && vim_strchr(part_buf, COM_MIDDLE) == NULL
  		    && vim_strchr(part_buf, COM_END) == NULL)
  		break;
  
! 	    /* When we already found a nested comment, only accept further
! 	     * nested comments. */
  	    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)
  		continue;
  
! 	    /* When 'O' flag present and using "O" command skip this one. */
  	    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)
  		continue;
  
! 	    /* Line contents and string must match.
! 	     * When string starts with white space, must have some white space
! 	     * (but the amount does not need to match, there might be a mix of
! 	     * TABs and spaces). */
  	    if (VIM_ISWHITE(string[0]))
  	    {
  		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
! 		    continue;  /* missing white space */
  		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
  		;
  	    if (string[j] != NUL)
! 		continue;  /* string doesn't match */
  
! 	    /* When 'b' flag used, there must be white space or an
! 	     * end-of-line after the string in the line. */
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
  			   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  		continue;
  
! 	    /* We have found a match, stop searching unless this is a middle
! 	     * comment. The middle comment can be a substring of the end
! 	     * comment in which case it's better to return the length of the
! 	     * end comment and its flags.  Thus we keep searching with middle
! 	     * and end matches and use an end match if it matches better. */
  	    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)
  	    {
  		if (middle_match_len == 0)
--- 67,126 ----
  	found_one = FALSE;
  	for (list = curbuf->b_p_com; *list; )
  	{
! 	    // Get one option part into part_buf[].  Advance "list" to next
! 	    // one.  Put "string" at start of string.
  	    if (!got_com && flags != NULL)
! 		*flags = list;	    // remember where flags started
  	    prev_list = list;
  	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
  	    string = vim_strchr(part_buf, ':');
! 	    if (string == NULL)	    // missing ':', ignore this part
  		continue;
! 	    *string++ = NUL;	    // isolate flags from string
  
! 	    // If we found a middle match previously, use that match when this
! 	    // is not a middle or end.
  	    if (middle_match_len != 0
  		    && vim_strchr(part_buf, COM_MIDDLE) == NULL
  		    && vim_strchr(part_buf, COM_END) == NULL)
  		break;
  
! 	    // When we already found a nested comment, only accept further
! 	    // nested comments.
  	    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)
  		continue;
  
! 	    // When 'O' flag present and using "O" command skip this one.
  	    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)
  		continue;
  
! 	    // Line contents and string must match.
! 	    // When string starts with white space, must have some white space
! 	    // (but the amount does not need to match, there might be a mix of
! 	    // TABs and spaces).
  	    if (VIM_ISWHITE(string[0]))
  	    {
  		if (i == 0 || !VIM_ISWHITE(line[i - 1]))
! 		    continue;  // missing white space
  		while (VIM_ISWHITE(string[0]))
  		    ++string;
  	    }
  	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
  		;
  	    if (string[j] != NUL)
! 		continue;  // string doesn't match
  
! 	    // When 'b' flag used, there must be white space or an
! 	    // end-of-line after the string in the line.
  	    if (vim_strchr(part_buf, COM_BLANK) != NULL
  			   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)
  		continue;
  
! 	    // We have found a match, stop searching unless this is a middle
! 	    // comment. The middle comment can be a substring of the end
! 	    // comment in which case it's better to return the length of the
! 	    // end comment and its flags.  Thus we keep searching with middle
! 	    // and end matches and use an end match if it matches better.
  	    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)
  	    {
  		if (middle_match_len == 0)
***************
*** 131,138 ****
  		continue;
  	    }
  	    if (middle_match_len != 0 && j > middle_match_len)
! 		/* Use this match instead of the middle match, since it's a
! 		 * longer thus better match. */
  		middle_match_len = 0;
  
  	    if (middle_match_len == 0)
--- 131,138 ----
  		continue;
  	    }
  	    if (middle_match_len != 0 && j > middle_match_len)
! 		// Use this match instead of the middle match, since it's a
! 		// longer thus better match.
  		middle_match_len = 0;
  
  	    if (middle_match_len == 0)
***************
*** 143,170 ****
  
  	if (middle_match_len != 0)
  	{
! 	    /* Use the previously found middle match after failing to find a
! 	     * match with an end. */
  	    if (!got_com && flags != NULL)
  		*flags = saved_flags;
  	    i += middle_match_len;
  	    found_one = TRUE;
  	}
  
! 	/* No match found, stop scanning. */
  	if (!found_one)
  	    break;
  
  	result = i;
  
! 	/* Include any trailing white space. */
  	while (VIM_ISWHITE(line[i]))
  	    ++i;
  
  	if (include_space)
  	    result = i;
  
! 	/* If this comment doesn't nest, stop here. */
  	got_com = TRUE;
  	if (vim_strchr(part_buf, COM_NEST) == NULL)
  	    break;
--- 143,170 ----
  
  	if (middle_match_len != 0)
  	{
! 	    // Use the previously found middle match after failing to find a
! 	    // match with an end.
  	    if (!got_com && flags != NULL)
  		*flags = saved_flags;
  	    i += middle_match_len;
  	    found_one = TRUE;
  	}
  
! 	// No match found, stop scanning.
  	if (!found_one)
  	    break;
  
  	result = i;
  
! 	// Include any trailing white space.
  	while (VIM_ISWHITE(line[i]))
  	    ++i;
  
  	if (include_space)
  	    result = i;
  
! 	// If this comment doesn't nest, stop here.
  	got_com = TRUE;
  	if (vim_strchr(part_buf, COM_NEST) == NULL)
  	    break;
***************
*** 190,196 ****
      char_u	*com_flags;
      char_u	*list;
      int		found_one;
!     char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
  
      /*
       * Repeat to match several nested comment strings.
--- 190,196 ----
      char_u	*com_flags;
      char_u	*list;
      int		found_one;
!     char_u	part_buf[COM_MAX_LEN];	// buffer for one option part
  
      /*
       * Repeat to match several nested comment strings.
***************
*** 212,221 ****
  	     */
  	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
  	    string = vim_strchr(part_buf, ':');
! 	    if (string == NULL)	/* If everything is fine, this cannot actually
! 				 * happen. */
  		continue;
! 	    *string++ = NUL;	/* Isolate flags from string. */
  	    com_leader = string;
  
  	    /*
--- 212,221 ----
  	     */
  	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
  	    string = vim_strchr(part_buf, ':');
! 	    if (string == NULL)	// If everything is fine, this cannot actually
! 				// happen.
  		continue;
! 	    *string++ = NUL;	// Isolate flags from string.
  	    com_leader = string;
  
  	    /*
***************
*** 271,277 ****
  
  	if (found_one)
  	{
! 	    char_u  part_buf2[COM_MAX_LEN];	/* buffer for one option part */
  	    int     len1, len2, off;
  
  	    result = i;
--- 271,277 ----
  
  	if (found_one)
  	{
! 	    char_u  part_buf2[COM_MAX_LEN];	// buffer for one option part
  	    int     len1, len2, off;
  
  	    result = i;
***************
*** 283,293 ****
  
  	    lower_check_bound = i;
  
! 	    /* Let's verify whether the comment leader found is a substring
! 	     * of other comment leaders. If it is, let's adjust the
! 	     * lower_check_bound so that we make sure that we have determined
! 	     * the comment leader correctly.
! 	     */
  
  	    while (VIM_ISWHITE(*com_leader))
  		++com_leader;
--- 283,292 ----
  
  	    lower_check_bound = i;
  
! 	    // Let's verify whether the comment leader found is a substring
! 	    // of other comment leaders. If it is, let's adjust the
! 	    // lower_check_bound so that we make sure that we have determined
! 	    // the comment leader correctly.
  
  	    while (VIM_ISWHITE(*com_leader))
  		++com_leader;
***************
*** 308,315 ****
  		if (len2 == 0)
  		    continue;
  
! 		/* Now we have to verify whether string ends with a substring
! 		 * beginning the com_leader. */
  		for (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2;)
  		{
  		    --off;
--- 307,314 ----
  		if (len2 == 0)
  		    continue;
  
! 		// Now we have to verify whether string ends with a substring
! 		// beginning the com_leader.
  		for (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2;)
  		{
  		    --off;
***************
*** 338,348 ****
  plines_win(
      win_T	*wp,
      linenr_T	lnum,
!     int		winheight)	/* when TRUE limit to window height */
  {
  #if defined(FEAT_DIFF) || defined(PROTO)
!     /* Check for filler lines above this buffer line.  When folded the result
!      * is one line anyway. */
      return plines_win_nofill(wp, lnum, winheight) + diff_check_fill(wp, lnum);
  }
  
--- 337,347 ----
  plines_win(
      win_T	*wp,
      linenr_T	lnum,
!     int		winheight)	// when TRUE limit to window height
  {
  #if defined(FEAT_DIFF) || defined(PROTO)
!     // Check for filler lines above this buffer line.  When folded the result
!     // is one line anyway.
      return plines_win_nofill(wp, lnum, winheight) + diff_check_fill(wp, lnum);
  }
  
***************
*** 356,362 ****
  plines_win_nofill(
      win_T	*wp,
      linenr_T	lnum,
!     int		winheight)	/* when TRUE limit to window height */
  {
  #endif
      int		lines;
--- 355,361 ----
  plines_win_nofill(
      win_T	*wp,
      linenr_T	lnum,
!     int		winheight)	// when TRUE limit to window height
  {
  #endif
      int		lines;
***************
*** 368,375 ****
  	return 1;
  
  #ifdef FEAT_FOLDING
!     /* A folded lines is handled just like an empty line. */
!     /* NOTE: Caller must handle lines that are MAYBE folded. */
      if (lineFolded(wp, lnum) == TRUE)
  	return 1;
  #endif
--- 367,374 ----
  	return 1;
  
  #ifdef FEAT_FOLDING
!     // A folded lines is handled just like an empty line.
!     // NOTE: Caller must handle lines that are MAYBE folded.
      if (lineFolded(wp, lnum) == TRUE)
  	return 1;
  #endif
***************
*** 392,398 ****
      int		width;
  
      s = ml_get_buf(wp->w_buffer, lnum, FALSE);
!     if (*s == NUL)		/* empty line */
  	return 1;
      col = win_linetabsize(wp, s, (colnr_T)MAXCOL);
  
--- 391,397 ----
      int		width;
  
      s = ml_get_buf(wp->w_buffer, lnum, FALSE);
!     if (*s == NUL)		// empty line
  	return 1;
      col = win_linetabsize(wp, s, (colnr_T)MAXCOL);
  
***************
*** 430,437 ****
      char_u	*line;
  
  #ifdef FEAT_DIFF
!     /* Check for filler lines above this buffer line.  When folded the result
!      * is one line anyway. */
      lines = diff_check_fill(wp, lnum);
  #endif
  
--- 429,436 ----
      char_u	*line;
  
  #ifdef FEAT_DIFF
!     // Check for filler lines above this buffer line.  When folded the result
!     // is one line anyway.
      lines = diff_check_fill(wp, lnum);
  #endif
  
***************
*** 483,494 ****
  #ifdef FEAT_FOLDING
  	int	x;
  
! 	/* Check if there are any really folded lines, but also included lines
! 	 * that are maybe folded. */
  	x = foldedCount(wp, first, NULL);
  	if (x > 0)
  	{
! 	    ++count;	    /* count 1 for "+-- folded" line */
  	    first += x;
  	}
  	else
--- 482,493 ----
  #ifdef FEAT_FOLDING
  	int	x;
  
! 	// Check if there are any really folded lines, but also included lines
! 	// that are maybe folded.
  	x = foldedCount(wp, first, NULL);
  	if (x > 0)
  	{
! 	    ++count;	    // count 1 for "+-- folded" line
  	    first += x;
  	}
  	else
***************
*** 511,517 ****
  {
      char_u	*ptr;
  
!     /* When searching columns is sometimes put at the end of a line. */
      if (pos->col == MAXCOL)
  	return NUL;
      ptr = ml_get_pos(pos);
--- 510,516 ----
  {
      char_u	*ptr;
  
!     // When searching columns is sometimes put at the end of a line.
      if (pos->col == MAXCOL)
  	return NUL;
      ptr = ml_get_pos(pos);
***************
*** 585,591 ****
      int	    r = ' ';
      int	    save_State = State;
  
!     if (exiting)		/* put terminal in raw mode for this question */
  	settmode(TMODE_RAW);
      ++no_wait_return;
  #ifdef USE_ON_FLY_SCROLL
--- 584,590 ----
      int	    r = ' ';
      int	    save_State = State;
  
!     if (exiting)		// put terminal in raw mode for this question
  	settmode(TMODE_RAW);
      ++no_wait_return;
  #ifdef USE_ON_FLY_SCROLL
***************
*** 598,604 ****
  
      while (r != 'y' && r != 'n')
      {
! 	/* same highlighting as for wait_return */
  	smsg_attr(HL_ATTR(HLF_R), "%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
--- 597,603 ----
  
      while (r != 'y' && r != 'n')
      {
! 	// same highlighting as for wait_return
  	smsg_attr(HL_ATTR(HLF_R), "%s (y/n)?", str);
  	if (direct)
  	    r = get_keystroke();
***************
*** 606,612 ****
  	    r = plain_vgetc();
  	if (r == Ctrl_C || r == ESC)
  	    r = 'n';
! 	msg_putchar(r);	    /* show what you typed */
  	out_flush();
      }
      --no_wait_return;
--- 605,611 ----
  	    r = plain_vgetc();
  	if (r == Ctrl_C || r == ESC)
  	    r = 'n';
! 	msg_putchar(r);	    // show what you typed
  	out_flush();
      }
      --no_wait_return;
***************
*** 632,638 ****
  
      if (time_for_testing == 93784)
      {
! 	/* Testing the two-character code. */
  	buf[0] = 'x';
  	buf[1] = '!';
      }
--- 631,637 ----
  
      if (time_for_testing == 93784)
      {
! 	// Testing the two-character code.
  	buf[0] = 'x';
  	buf[1] = '!';
      }
***************
*** 702,709 ****
  	}
      }
  
!     /* Clear out the minor mode when the argument is not a non-zero number or
!      * non-empty string.  */
      if (!non_zero_arg(&argvars[0]))
  	buf[1] = NUL;
  
--- 701,708 ----
  	}
      }
  
!     // Clear out the minor mode when the argument is not a non-zero number or
!     // non-empty string.
      if (!non_zero_arg(&argvars[0]))
  	buf[1] = NUL;
  
***************
*** 777,791 ****
      int		save_mapped_ctrl_c = mapped_ctrl_c;
      int		waited = 0;
  
!     mapped_ctrl_c = FALSE;	/* mappings are not used here */
      for (;;)
      {
  	cursor_on();
  	out_flush();
  
! 	/* Leave some room for check_termcode() to insert a key code into (max
! 	 * 5 chars plus NUL).  And fix_input_buffer() can triple the number of
! 	 * bytes. */
  	maxlen = (buflen - 6 - len) / 3;
  	if (buf == NULL)
  	    buf = alloc(buflen);
--- 776,790 ----
      int		save_mapped_ctrl_c = mapped_ctrl_c;
      int		waited = 0;
  
!     mapped_ctrl_c = FALSE;	// mappings are not used here
      for (;;)
      {
  	cursor_on();
  	out_flush();
  
! 	// Leave some room for check_termcode() to insert a key code into (max
! 	// 5 chars plus NUL).  And fix_input_buffer() can triple the number of
! 	// bytes.
  	maxlen = (buflen - 6 - len) / 3;
  	if (buf == NULL)
  	    buf = alloc(buflen);
***************
*** 793,800 ****
  	{
  	    char_u  *t_buf = buf;
  
! 	    /* Need some more space. This might happen when receiving a long
! 	     * escape sequence. */
  	    buflen += 100;
  	    buf = vim_realloc(buf, buflen);
  	    if (buf == NULL)
--- 792,799 ----
  	{
  	    char_u  *t_buf = buf;
  
! 	    // Need some more space. This might happen when receiving a long
! 	    // escape sequence.
  	    buflen += 100;
  	    buf = vim_realloc(buf, buflen);
  	    if (buf == NULL)
***************
*** 804,846 ****
  	if (buf == NULL)
  	{
  	    do_outofmem_msg((long_u)buflen);
! 	    return ESC;  /* panic! */
  	}
  
! 	/* First time: blocking wait.  Second time: wait up to 100ms for a
! 	 * terminal code to complete. */
  	n = ui_inchar(buf + len, maxlen, len == 0 ? -1L : 100L, 0);
  	if (n > 0)
  	{
! 	    /* Replace zero and CSI by a special key code. */
  	    n = fix_input_buffer(buf + len, n);
  	    len += n;
  	    waited = 0;
  	}
  	else if (len > 0)
! 	    ++waited;	    /* keep track of the waiting time */
  
! 	/* Incomplete termcode and not timed out yet: get more characters */
  	if ((n = check_termcode(1, buf, buflen, &len)) < 0
  	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
  	    continue;
  
! 	if (n == KEYLEN_REMOVED)  /* key code removed */
  	{
  	    if (must_redraw != 0 && !need_wait_return && (State & CMDLINE) == 0)
  	    {
! 		/* Redrawing was postponed, do it now. */
  		update_screen(0);
! 		setcursor(); /* put cursor back where it belongs */
  	    }
  	    continue;
  	}
! 	if (n > 0)		/* found a termcode: adjust length */
  	    len = n;
! 	if (len == 0)		/* nothing typed yet */
  	    continue;
  
! 	/* Handle modifier and/or special key code. */
  	n = buf[0];
  	if (n == K_SPECIAL)
  	{
--- 803,845 ----
  	if (buf == NULL)
  	{
  	    do_outofmem_msg((long_u)buflen);
! 	    return ESC;  // panic!
  	}
  
! 	// First time: blocking wait.  Second time: wait up to 100ms for a
! 	// terminal code to complete.
  	n = ui_inchar(buf + len, maxlen, len == 0 ? -1L : 100L, 0);
  	if (n > 0)
  	{
! 	    // Replace zero and CSI by a special key code.
  	    n = fix_input_buffer(buf + len, n);
  	    len += n;
  	    waited = 0;
  	}
  	else if (len > 0)
! 	    ++waited;	    // keep track of the waiting time
  
! 	// Incomplete termcode and not timed out yet: get more characters
  	if ((n = check_termcode(1, buf, buflen, &len)) < 0
  	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
  	    continue;
  
! 	if (n == KEYLEN_REMOVED)  // key code removed
  	{
  	    if (must_redraw != 0 && !need_wait_return && (State & CMDLINE) == 0)
  	    {
! 		// Redrawing was postponed, do it now.
  		update_screen(0);
! 		setcursor(); // put cursor back where it belongs
  	    }
  	    continue;
  	}
! 	if (n > 0)		// found a termcode: adjust length
  	    len = n;
! 	if (len == 0)		// nothing typed yet
  	    continue;
  
! 	// Handle modifier and/or special key code.
  	n = buf[0];
  	if (n == K_SPECIAL)
  	{
***************
*** 866,872 ****
  	if (has_mbyte)
  	{
  	    if (MB_BYTE2LEN(n) > len)
! 		continue;	/* more bytes to get */
  	    buf[len >= buflen ? buflen - 1 : len] = NUL;
  	    n = (*mb_ptr2char)(buf);
  	}
--- 865,871 ----
  	if (has_mbyte)
  	{
  	    if (MB_BYTE2LEN(n) > len)
! 		continue;	// more bytes to get
  	    buf[len >= buflen ? buflen - 1 : len] = NUL;
  	    n = (*mb_ptr2char)(buf);
  	}
***************
*** 888,894 ****
   */
      int
  get_number(
!     int	    colon,			/* allow colon to abort */
      int	    *mouse_used)
  {
      int	n = 0;
--- 887,893 ----
   */
      int
  get_number(
!     int	    colon,			// allow colon to abort
      int	    *mouse_used)
  {
      int	n = 0;
***************
*** 898,913 ****
      if (mouse_used != NULL)
  	*mouse_used = FALSE;
  
!     /* When not printing messages, the user won't know what to type, return a
!      * zero (as if CR was hit). */
      if (msg_silent != 0)
  	return 0;
  
  #ifdef USE_ON_FLY_SCROLL
!     dont_scroll = TRUE;		/* disallow scrolling here */
  #endif
      ++no_mapping;
!     ++allow_keys;		/* no mapping here, but recognize keys */
      for (;;)
      {
  	windgoto(msg_row, msg_col);
--- 897,912 ----
      if (mouse_used != NULL)
  	*mouse_used = FALSE;
  
!     // When not printing messages, the user won't know what to type, return a
!     // zero (as if CR was hit).
      if (msg_silent != 0)
  	return 0;
  
  #ifdef USE_ON_FLY_SCROLL
!     dont_scroll = TRUE;		// disallow scrolling here
  #endif
      ++no_mapping;
!     ++allow_keys;		// no mapping here, but recognize keys
      for (;;)
      {
  	windgoto(msg_row, msg_col);
***************
*** 938,944 ****
  	    stuffcharReadbuff(':');
  	    if (!exmode_active)
  		cmdline_row = msg_row;
! 	    skip_redraw = TRUE;	    /* skip redraw once */
  	    do_redraw = FALSE;
  	    break;
  	}
--- 937,943 ----
  	    stuffcharReadbuff(':');
  	    if (!exmode_active)
  		cmdline_row = msg_row;
! 	    skip_redraw = TRUE;	    // skip redraw once
  	    do_redraw = FALSE;
  	    break;
  	}
***************
*** 962,968 ****
      int		save_cmdline_row;
      int		save_State;
  
!     /* When using ":silent" assume that <CR> was entered. */
      if (mouse_used != NULL)
  	msg_puts(_("Type number and <Enter> or click with mouse (empty cancels): "));
      else
--- 961,967 ----
      int		save_cmdline_row;
      int		save_State;
  
!     // When using ":silent" assume that <CR> was entered.
      if (mouse_used != NULL)
  	msg_puts(_("Type number and <Enter> or click with mouse (empty cancels): "));
      else
***************
*** 1002,1014 ****
  {
      long pn;
  
!     if (global_busy	    /* no messages now, wait until global is finished */
! 	    || !messaging())  /* 'lazyredraw' set, don't do messages now */
  	return;
  
!     /* We don't want to overwrite another important message, but do overwrite
!      * a previous "more lines" or "fewer lines" message, so that "5dd" and
!      * then "put" reports the last action. */
      if (keep_msg != NULL && !keep_msg_more)
  	return;
  
--- 1001,1013 ----
  {
      long pn;
  
!     if (global_busy	    // no messages now, wait until global is finished
! 	    || !messaging())  // 'lazyredraw' set, don't do messages now
  	return;
  
!     // We don't want to overwrite another important message, but do overwrite
!     // a previous "more lines" or "fewer lines" message, so that "5dd" and
!     // then "put" reports the last action.
      if (keep_msg != NULL && !keep_msg_more)
  	return;
  
***************
*** 1054,1060 ****
   */
      void
  vim_beep(
!     unsigned val) /* one of the BO_ values, e.g., BO_OPER */
  {
  #ifdef FEAT_EVAL
      called_vim_beep = TRUE;
--- 1053,1059 ----
   */
      void
  vim_beep(
!     unsigned val) // one of the BO_ values, e.g., BO_OPER
  {
  #ifdef FEAT_EVAL
      called_vim_beep = TRUE;
***************
*** 1068,1075 ****
  	    static int		did_init = FALSE;
  	    static elapsed_T	start_tv;
  
! 	    /* Only beep once per half a second, otherwise a sequence of beeps
! 	     * would freeze Vim. */
  	    if (!did_init || ELAPSED_FUNC(start_tv) > 500)
  	    {
  		did_init = TRUE;
--- 1067,1074 ----
  	    static int		did_init = FALSE;
  	    static elapsed_T	start_tv;
  
! 	    // Only beep once per half a second, otherwise a sequence of beeps
! 	    // would freeze Vim.
  	    if (!did_init || ELAPSED_FUNC(start_tv) > 500)
  	    {
  		did_init = TRUE;
***************
*** 1077,1091 ****
  #endif
  		if (p_vb
  #ifdef FEAT_GUI
! 			/* While the GUI is starting up the termcap is set for
! 			 * the GUI but the output still goes to a terminal. */
  			&& !(gui.in_use && gui.starting)
  #endif
  			)
  		{
  		    out_str_cf(T_VB);
  #ifdef FEAT_VTP
! 		    /* No restore color information, refresh the screen. */
  		    if (has_vtp_working() != 0
  # ifdef FEAT_TERMGUICOLORS
  			    && (p_tgc || (!p_tgc && t_colors >= 256))
--- 1076,1090 ----
  #endif
  		if (p_vb
  #ifdef FEAT_GUI
! 			// While the GUI is starting up the termcap is set for
! 			// the GUI but the output still goes to a terminal.
  			&& !(gui.in_use && gui.starting)
  #endif
  			)
  		{
  		    out_str_cf(T_VB);
  #ifdef FEAT_VTP
! 		    // No restore color information, refresh the screen.
  		    if (has_vtp_working() != 0
  # ifdef FEAT_TERMGUICOLORS
  			    && (p_tgc || (!p_tgc && t_colors >= 256))
***************
*** 1105,1113 ****
  #endif
  	}
  
! 	/* When 'debug' contains "beep" produce a message.  If we are sourcing
! 	 * a script or executing a function give the user a hint where the beep
! 	 * comes from. */
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
  	    msg_source(HL_ATTR(HLF_W));
--- 1104,1112 ----
  #endif
  	}
  
! 	// When 'debug' contains "beep" produce a message.  If we are sourcing
! 	// a script or executing a function give the user a hint where the beep
! 	// comes from.
  	if (vim_strchr(p_debug, 'e') != NULL)
  	{
  	    msg_source(HL_ATTR(HLF_W));
***************
*** 1132,1138 ****
  {
      char_u  *var;
  
!     /* In case we are called a second time (when 'encoding' changes). */
      VIM_CLEAR(homedir);
  
  #ifdef VMS
--- 1131,1137 ----
  {
      char_u  *var;
  
!     // In case we are called a second time (when 'encoding' changes).
      VIM_CLEAR(homedir);
  
  #ifdef VMS
***************
*** 1192,1198 ****
  	}
      }
  
!     if (var != NULL && *var == NUL)	/* empty is same as not set */
  	var = NULL;
  
      if (enc_utf8 && var != NULL)
--- 1191,1197 ----
  	}
      }
  
!     if (var != NULL && *var == NUL)	// empty is same as not set
  	var = NULL;
  
      if (enc_utf8 && var != NULL)
***************
*** 1200,1207 ****
  	int	len;
  	char_u  *pp = NULL;
  
! 	/* Convert from active codepage to UTF-8.  Other conversions are
! 	 * not done, because they would fail for non-ASCII characters. */
  	acp_to_enc(var, (int)STRLEN(var), &pp, &len);
  	if (pp != NULL)
  	{
--- 1199,1206 ----
  	int	len;
  	char_u  *pp = NULL;
  
! 	// Convert from active codepage to UTF-8.  Other conversions are
! 	// not done, because they would fail for non-ASCII characters.
  	acp_to_enc(var, (int)STRLEN(var), &pp, &len);
  	if (pp != NULL)
  	{
***************
*** 1286,1325 ****
   */
      void
  expand_env(
!     char_u	*src,		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst,		/* where to put the result */
!     int		dstlen)		/* maximum length of the result */
  {
      expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
  }
  
      void
  expand_env_esc(
!     char_u	*srcp,		/* input string e.g. "$HOME/vim.hlp" */
!     char_u	*dst,		/* where to put the result */
!     int		dstlen,		/* maximum length of the result */
!     int		esc,		/* escape spaces in expanded variables */
!     int		one,		/* "srcp" is one file name */
!     char_u	*startstr)	/* start again after this (can be NULL) */
  {
      char_u	*src;
      char_u	*tail;
      int		c;
      char_u	*var;
      int		copy_char;
!     int		mustfree;	/* var was allocated, need to free it later */
!     int		at_start = TRUE; /* at start of a name */
      int		startstr_len = 0;
  
      if (startstr != NULL)
  	startstr_len = (int)STRLEN(startstr);
  
      src = skipwhite(srcp);
!     --dstlen;		    /* leave one char space for "\," */
      while (*src && dstlen > 0)
      {
  #ifdef FEAT_EVAL
! 	/* Skip over `=expr`. */
  	if (src[0] == '`' && src[1] == '=')
  	{
  	    size_t len;
--- 1285,1324 ----
   */
      void
  expand_env(
!     char_u	*src,		// input string e.g. "$HOME/vim.hlp"
!     char_u	*dst,		// where to put the result
!     int		dstlen)		// maximum length of the result
  {
      expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);
  }
  
      void
  expand_env_esc(
!     char_u	*srcp,		// input string e.g. "$HOME/vim.hlp"
!     char_u	*dst,		// where to put the result
!     int		dstlen,		// maximum length of the result
!     int		esc,		// escape spaces in expanded variables
!     int		one,		// "srcp" is one file name
!     char_u	*startstr)	// start again after this (can be NULL)
  {
      char_u	*src;
      char_u	*tail;
      int		c;
      char_u	*var;
      int		copy_char;
!     int		mustfree;	// var was allocated, need to free it later
!     int		at_start = TRUE; // at start of a name
      int		startstr_len = 0;
  
      if (startstr != NULL)
  	startstr_len = (int)STRLEN(startstr);
  
      src = skipwhite(srcp);
!     --dstlen;		    // leave one char space for "\,"
      while (*src && dstlen > 0)
      {
  #ifdef FEAT_EVAL
! 	// Skip over `=expr`.
  	if (src[0] == '`' && src[1] == '=')
  	{
  	    size_t len;
***************
*** 1355,1371 ****
  	     * The variable name is copied into dst temporarily, because it may
  	     * be a string in read-only memory and a NUL needs to be appended.
  	     */
! 	    if (*src != '~')				/* environment var */
  	    {
  		tail = src + 1;
  		var = dst;
  		c = dstlen - 1;
  
  #ifdef UNIX
! 		/* Unix has ${var-name} type environment vars */
  		if (*tail == '{' && !vim_isIDc('{'))
  		{
! 		    tail++;	/* ignore '{' */
  		    while (c-- > 0 && *tail && *tail != '}')
  			*var++ = *tail++;
  		}
--- 1354,1370 ----
  	     * The variable name is copied into dst temporarily, because it may
  	     * be a string in read-only memory and a NUL needs to be appended.
  	     */
! 	    if (*src != '~')				// environment var
  	    {
  		tail = src + 1;
  		var = dst;
  		c = dstlen - 1;
  
  #ifdef UNIX
! 		// Unix has ${var-name} type environment vars
  		if (*tail == '{' && !vim_isIDc('{'))
  		{
! 		    tail++;	// ignore '{'
  		    while (c-- > 0 && *tail && *tail != '}')
  			*var++ = *tail++;
  		}
***************
*** 1402,1408 ****
  		}
  #endif
  	    }
! 							/* home directory */
  	    else if (  src[1] == NUL
  		    || vim_ispathsep(src[1])
  		    || vim_strchr((char_u *)" ,\t\n", src[1]) != NULL)
--- 1401,1407 ----
  		}
  #endif
  	    }
! 							// home directory
  	    else if (  src[1] == NUL
  		    || vim_ispathsep(src[1])
  		    || vim_strchr((char_u *)" ,\t\n", src[1]) != NULL)
***************
*** 1410,1416 ****
  		var = homedir;
  		tail = src + 1;
  	    }
! 	    else					/* user directory */
  	    {
  #if defined(UNIX) || (defined(VMS) && defined(USER_HOME))
  		/*
--- 1409,1415 ----
  		var = homedir;
  		tail = src + 1;
  	    }
! 	    else					// user directory
  	    {
  #if defined(UNIX) || (defined(VMS) && defined(USER_HOME))
  		/*
***************
*** 1434,1441 ****
  		 */
  #  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
  		{
! 		    /* Note: memory allocated by getpwnam() is never freed.
! 		     * Calling endpwent() apparently doesn't help. */
  		    struct passwd *pw = (*dst == NUL)
  					? NULL : getpwnam((char *)dst + 1);
  
--- 1433,1440 ----
  		 */
  #  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)
  		{
! 		    // Note: memory allocated by getpwnam() is never freed.
! 		    // Calling endpwent() apparently doesn't help.
  		    struct passwd *pw = (*dst == NUL)
  					? NULL : getpwnam((char *)dst + 1);
  
***************
*** 1453,1459 ****
  		    mustfree = TRUE;
  		}
  
! # else	/* !UNIX, thus VMS */
  		/*
  		 * USER_HOME is a comma-separated list of
  		 * directories to search for the user account in.
--- 1452,1458 ----
  		    mustfree = TRUE;
  		}
  
! # else	// !UNIX, thus VMS
  		/*
  		 * USER_HOME is a comma-separated list of
  		 * directories to search for the user account in.
***************
*** 1483,1499 ****
  			}
  		    }
  		}
! # endif /* UNIX */
  #else
! 		/* cannot expand user's home directory, so don't try */
  		var = NULL;
! 		tail = (char_u *)"";	/* for gcc */
! #endif /* UNIX || VMS */
  	    }
  
  #ifdef BACKSLASH_IN_FILENAME
! 	    /* If 'shellslash' is set change backslashes to forward slashes.
! 	     * Can't use slash_adjust(), p_ssl may be set temporarily. */
  	    if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL)
  	    {
  		char_u	*p = vim_strsave(var);
--- 1482,1498 ----
  			}
  		    }
  		}
! # endif // UNIX
  #else
! 		// cannot expand user's home directory, so don't try
  		var = NULL;
! 		tail = (char_u *)"";	// for gcc
! #endif // UNIX || VMS
  	    }
  
  #ifdef BACKSLASH_IN_FILENAME
! 	    // If 'shellslash' is set change backslashes to forward slashes.
! 	    // Can't use slash_adjust(), p_ssl may be set temporarily.
  	    if (p_ssl && var != NULL && vim_strchr(var, '\\') != NULL)
  	    {
  		char_u	*p = vim_strsave(var);
***************
*** 1509,1516 ****
  	    }
  #endif
  
! 	    /* If "var" contains white space, escape it with a backslash.
! 	     * Required for ":e ~/tt" when $HOME includes a space. */
  	    if (esc && var != NULL && vim_strpbrk(var, (char_u *)" \t") != NULL)
  	    {
  		char_u	*p = vim_strsave_escaped(var, (char_u *)" \t");
--- 1508,1515 ----
  	    }
  #endif
  
! 	    // If "var" contains white space, escape it with a backslash.
! 	    // Required for ":e ~/tt" when $HOME includes a space.
  	    if (esc && var != NULL && vim_strpbrk(var, (char_u *)" \t") != NULL)
  	    {
  		char_u	*p = vim_strsave_escaped(var, (char_u *)" \t");
***************
*** 1530,1537 ****
  		STRCPY(dst, var);
  		dstlen -= (int)STRLEN(var);
  		c = (int)STRLEN(var);
! 		/* if var[] ends in a path separator and tail[] starts
! 		 * with it, skip a character */
  		if (*var != NUL && after_pathsep(dst, dst + c)
  #if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)
  			&& dst[-1] != ':'
--- 1529,1536 ----
  		STRCPY(dst, var);
  		dstlen -= (int)STRLEN(var);
  		c = (int)STRLEN(var);
! 		// if var[] ends in a path separator and tail[] starts
! 		// with it, skip a character
  		if (*var != NUL && after_pathsep(dst, dst + c)
  #if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)
  			&& dst[-1] != ':'
***************
*** 1546,1552 ****
  		vim_free(var);
  	}
  
! 	if (copy_char)	    /* copy at least one char */
  	{
  	    /*
  	     * Recognize the start of a new name, for '~'.
--- 1545,1551 ----
  		vim_free(var);
  	}
  
! 	if (copy_char)	    // copy at least one char
  	{
  	    /*
  	     * Recognize the start of a new name, for '~'.
***************
*** 1729,1744 ****
  #endif
  	if (p != NULL)
  	{
! 	    /* remove the file name */
  	    pend = gettail(p);
  
! 	    /* remove "doc/" from 'helpfile', if present */
  	    if (p == p_hf)
  		pend = remove_tail(p, pend, (char_u *)"doc");
  
  #ifdef USE_EXE_NAME
  # ifdef MACOS_X
! 	    /* remove "MacOS" from exe_name and add "Resources/vim" */
  	    if (p == exe_name)
  	    {
  		char_u	*pend1;
--- 1728,1743 ----
  #endif
  	if (p != NULL)
  	{
! 	    // remove the file name
  	    pend = gettail(p);
  
! 	    // remove "doc/" from 'helpfile', if present
  	    if (p == p_hf)
  		pend = remove_tail(p, pend, (char_u *)"doc");
  
  #ifdef USE_EXE_NAME
  # ifdef MACOS_X
! 	    // remove "MacOS" from exe_name and add "Resources/vim"
  	    if (p == exe_name)
  	    {
  		char_u	*pend1;
***************
*** 1758,1783 ****
  		}
  	    }
  # endif
! 	    /* remove "src/" from exe_name, if present */
  	    if (p == exe_name)
  		pend = remove_tail(p, pend, (char_u *)"src");
  #endif
  
! 	    /* for $VIM, remove "runtime/" or "vim54/", if present */
  	    if (!vimruntime)
  	    {
  		pend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);
  		pend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);
  	    }
  
! 	    /* remove trailing path separator */
  	    if (pend > p && after_pathsep(p, pend))
  		--pend;
  
  #ifdef MACOS_X
  	    if (p == exe_name || p == p_hf)
  #endif
! 		/* check that the result is a directory name */
  		p = vim_strnsave(p, (int)(pend - p));
  
  	    if (p != NULL && !mch_isdir(p))
--- 1757,1782 ----
  		}
  	    }
  # endif
! 	    // remove "src/" from exe_name, if present
  	    if (p == exe_name)
  		pend = remove_tail(p, pend, (char_u *)"src");
  #endif
  
! 	    // for $VIM, remove "runtime/" or "vim54/", if present
  	    if (!vimruntime)
  	    {
  		pend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);
  		pend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);
  	    }
  
! 	    // remove trailing path separator
  	    if (pend > p && after_pathsep(p, pend))
  		--pend;
  
  #ifdef MACOS_X
  	    if (p == exe_name || p == p_hf)
  #endif
! 		// check that the result is a directory name
  		p = vim_strnsave(p, (int)(pend - p));
  
  	    if (p != NULL && !mch_isdir(p))
***************
*** 1785,1791 ****
  	    else
  	    {
  #ifdef USE_EXE_NAME
! 		/* may add "/vim54" or "/runtime" if it exists */
  		if (vimruntime && (pend = vim_version_dir(p)) != NULL)
  		{
  		    vim_free(p);
--- 1784,1790 ----
  	    else
  	    {
  #ifdef USE_EXE_NAME
! 		// may add "/vim54" or "/runtime" if it exists
  		if (vimruntime && (pend = vim_version_dir(p)) != NULL)
  		{
  		    vim_free(p);
***************
*** 1798,1808 ****
      }
  
  #ifdef HAVE_PATHDEF
!     /* When there is a pathdef.c file we can use default_vim_dir and
!      * default_vimruntime_dir */
      if (p == NULL)
      {
! 	/* Only use default_vimruntime_dir when it is not empty */
  	if (vimruntime && *default_vimruntime_dir != NUL)
  	{
  	    p = default_vimruntime_dir;
--- 1797,1807 ----
      }
  
  #ifdef HAVE_PATHDEF
!     // When there is a pathdef.c file we can use default_vim_dir and
!     // default_vimruntime_dir
      if (p == NULL)
      {
! 	// Only use default_vimruntime_dir when it is not empty
  	if (vimruntime && *default_vimruntime_dir != NUL)
  	{
  	    p = default_vimruntime_dir;
***************
*** 1909,1915 ****
      return NULL;
  # else
  # ifndef __WIN32__
!     /* Borland C++ 5.2 has this in a header file. */
      extern char		**environ;
  # endif
  # define ENVNAMELEN 100
--- 1908,1914 ----
      return NULL;
  # else
  # ifndef __WIN32__
!     // Borland C++ 5.2 has this in a header file.
      extern char		**environ;
  # endif
  # define ENVNAMELEN 100
***************
*** 2053,2061 ****
      for (i = 0; i < ga_users.ga_len; i++)
      {
  	if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)
! 	    return 2; /* full match */
  	if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)
! 	    result = 1; /* partial match */
      }
      return result;
  }
--- 2052,2060 ----
      for (i = 0; i < ga_users.ga_len; i++)
      {
  	if (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)
! 	    return 2; // full match
  	if (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)
! 	    result = 1; // partial match
      }
      return result;
  }
***************
*** 2083,2091 ****
  prepare_to_exit(void)
  {
  #if defined(SIGHUP) && defined(SIG_IGN)
!     /* Ignore SIGHUP, because a dropped connection causes a read error, which
!      * makes Vim exit and then handling SIGHUP causes various reentrance
!      * problems. */
      signal(SIGHUP, SIG_IGN);
  #endif
  
--- 2082,2090 ----
  prepare_to_exit(void)
  {
  #if defined(SIGHUP) && defined(SIG_IGN)
!     // Ignore SIGHUP, because a dropped connection causes a read error, which
!     // makes Vim exit and then handling SIGHUP causes various reentrance
!     // problems.
      signal(SIGHUP, SIG_IGN);
  #endif
  
***************
*** 2093,2099 ****
      if (gui.in_use)
      {
  	gui.dying = TRUE;
! 	out_trash();	/* trash any pending output */
      }
      else
  #endif
--- 2092,2098 ----
      if (gui.in_use)
      {
  	gui.dying = TRUE;
! 	out_trash();	// trash any pending output
      }
      else
  #endif
***************
*** 2123,2151 ****
  
      prepare_to_exit();
  
!     /* Setting this will prevent free() calls.  That avoids calling free()
!      * recursively when free() was invoked with a bad pointer. */
      really_exiting = TRUE;
  
      out_str(IObuff);
!     screen_start();		    /* don't know where cursor is now */
      out_flush();
  
!     ml_close_notmod();		    /* close all not-modified buffers */
  
      FOR_ALL_BUFFERS(buf)
      {
  	if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)
  	{
  	    OUT_STR("Vim: preserving files...\n");
! 	    screen_start();	    /* don't know where cursor is now */
  	    out_flush();
! 	    ml_sync_all(FALSE, FALSE);	/* preserve all swap files */
  	    break;
  	}
      }
  
!     ml_close_all(FALSE);	    /* close all memfiles, without deleting */
  
      OUT_STR("Vim: Finished.\n");
  
--- 2122,2150 ----
  
      prepare_to_exit();
  
!     // Setting this will prevent free() calls.  That avoids calling free()
!     // recursively when free() was invoked with a bad pointer.
      really_exiting = TRUE;
  
      out_str(IObuff);
!     screen_start();		    // don't know where cursor is now
      out_flush();
  
!     ml_close_notmod();		    // close all not-modified buffers
  
      FOR_ALL_BUFFERS(buf)
      {
  	if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)
  	{
  	    OUT_STR("Vim: preserving files...\n");
! 	    screen_start();	    // don't know where cursor is now
  	    out_flush();
! 	    ml_sync_all(FALSE, FALSE);	// preserve all swap files
  	    break;
  	}
      }
  
!     ml_close_all(FALSE);	    // close all memfiles, without deleting
  
      OUT_STR("Vim: Finished.\n");
  
***************
*** 2208,2215 ****
      char_u *
  get_cmd_output(
      char_u	*cmd,
!     char_u	*infile,	/* optional input file name */
!     int		flags,		/* can be SHELL_SILENT */
      int		*ret_len)
  {
      char_u	*tempname;
--- 2207,2214 ----
      char_u *
  get_cmd_output(
      char_u	*cmd,
!     char_u	*infile,	// optional input file name
!     int		flags,		// can be SHELL_SILENT
      int		*ret_len)
  {
      char_u	*tempname;
***************
*** 2222,2235 ****
      if (check_restricted() || check_secure())
  	return NULL;
  
!     /* get a name for the temp file */
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
  	emsg(_(e_notmp));
  	return NULL;
      }
  
!     /* Add the redirection stuff */
      command = make_filter_cmd(cmd, infile, tempname);
      if (command == NULL)
  	goto done;
--- 2221,2234 ----
      if (check_restricted() || check_secure())
  	return NULL;
  
!     // get a name for the temp file
      if ((tempname = vim_tempname('o', FALSE)) == NULL)
      {
  	emsg(_(e_notmp));
  	return NULL;
      }
  
!     // Add the redirection stuff
      command = make_filter_cmd(cmd, infile, tempname);
      if (command == NULL)
  	goto done;
***************
*** 2248,2254 ****
       * read the names from the file into memory
       */
  # ifdef VMS
!     /* created temporary file is not always readable as binary */
      fd = mch_fopen((char *)tempname, "r");
  # else
      fd = mch_fopen((char *)tempname, READBIN);
--- 2247,2253 ----
       * read the names from the file into memory
       */
  # ifdef VMS
!     // created temporary file is not always readable as binary
      fd = mch_fopen((char *)tempname, "r");
  # else
      fd = mch_fopen((char *)tempname, READBIN);
***************
*** 2261,2267 ****
      }
  
      fseek(fd, 0L, SEEK_END);
!     len = ftell(fd);		    /* get size of temp file */
      fseek(fd, 0L, SEEK_SET);
  
      buffer = alloc(len + 1);
--- 2260,2266 ----
      }
  
      fseek(fd, 0L, SEEK_END);
!     len = ftell(fd);		    // get size of temp file
      fseek(fd, 0L, SEEK_SET);
  
      buffer = alloc(len + 1);
***************
*** 2272,2278 ****
      if (buffer == NULL)
  	goto done;
  #ifdef VMS
!     len = i;	/* VMS doesn't give us what we asked for... */
  #endif
      if (i != len)
      {
--- 2271,2277 ----
      if (buffer == NULL)
  	goto done;
  #ifdef VMS
!     len = i;	// VMS doesn't give us what we asked for...
  #endif
      if (i != len)
      {
***************
*** 2281,2292 ****
      }
      else if (ret_len == NULL)
      {
! 	/* Change NUL into SOH, otherwise the string is truncated. */
  	for (i = 0; i < len; ++i)
  	    if (buffer[i] == NUL)
  		buffer[i] = 1;
  
! 	buffer[len] = NUL;	/* make sure the buffer is terminated */
      }
      else
  	*ret_len = len;
--- 2280,2291 ----
      }
      else if (ret_len == NULL)
      {
! 	// Change NUL into SOH, otherwise the string is truncated.
  	for (i = 0; i < len; ++i)
  	    if (buffer[i] == NUL)
  		buffer[i] = 1;
  
! 	buffer[len] = NUL;	// make sure the buffer is terminated
      }
      else
  	*ret_len = len;
***************
*** 2377,2383 ****
  	    if (p == NULL)
  	    {
  		fclose(fd);
! 		goto errret;		/* type error; errmsg already given */
  	    }
  	    len = STRLEN(p);
  	    if (len > 0 && fwrite(p, len, 1, fd) != 1)
--- 2376,2382 ----
  	    if (p == NULL)
  	    {
  		fclose(fd);
! 		goto errret;		// type error; errmsg already given
  	    }
  	    len = STRLEN(p);
  	    if (len > 0 && fwrite(p, len, 1, fd) != 1)
***************
*** 2392,2399 ****
  	}
      }
  
!     /* Omit SHELL_COOKED when invoked with ":silent".  Avoids that the shell
!      * echoes typeahead, that messes up the display. */
      if (!msg_silent)
  	flags += SHELL_COOKED;
  
--- 2391,2398 ----
  	}
      }
  
!     // Omit SHELL_COOKED when invoked with ":silent".  Avoids that the shell
!     // echoes typeahead, that messes up the display.
      if (!msg_silent)
  	flags += SHELL_COOKED;
  
***************
*** 2448,2454 ****
      {
  	res = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, NULL);
  #ifdef USE_CRNL
! 	/* translate <CR><NL> into <NL> */
  	if (res != NULL)
  	{
  	    char_u	*s, *d;
--- 2447,2453 ----
      {
  	res = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, NULL);
  #ifdef USE_CRNL
! 	// translate <CR><NL> into <NL>
  	if (res != NULL)
  	{
  	    char_u	*s, *d;
***************
*** 2531,2544 ****
      p = skiptowhite(p_sh);
      if (*p == NUL)
      {
! 	/* No white space, use the tail. */
  	p = vim_strsave(gettail(p_sh));
      }
      else
      {
  	char_u  *p1, *p2;
  
! 	/* Find the last path separator before the space. */
  	p1 = p_sh;
  	for (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))
  	    if (vim_ispathsep(*p2))
--- 2530,2543 ----
      p = skiptowhite(p_sh);
      if (*p == NUL)
      {
! 	// No white space, use the tail.
  	p = vim_strsave(gettail(p_sh));
      }
      else
      {
  	char_u  *p1, *p2;
  
! 	// Find the last path separator before the space.
  	p1 = p_sh;
  	for (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))
  	    if (vim_ispathsep(*p2))
***************
*** 2593,2602 ****
      {
  	curtime = vim_localtime(&tt, &tmval);
  	if (vim_time() - tt < (60L * 60L * 12L))
! 	    /* within 12 hours */
  	    (void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
  	else
! 	    /* longer ago */
  	    (void)strftime((char *)buf, buflen, "%Y/%m/%d %H:%M:%S", curtime);
      }
      else
--- 2592,2601 ----
      {
  	curtime = vim_localtime(&tt, &tmval);
  	if (vim_time() - tt < (60L * 60L * 12L))
! 	    // within 12 hours
  	    (void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
  	else
! 	    // longer ago
  	    (void)strftime((char *)buf, buflen, "%Y/%m/%d %H:%M:%S", curtime);
      }
      else
*** ../vim-8.2.0025/src/misc2.c	2019-12-14 16:18:11.578458401 +0100
--- src/misc2.c	2019-12-21 18:13:39.260159083 +0100
***************
*** 12,18 ****
   */
  #include "vim.h"
  
! static char_u	*username = NULL; /* cached result of mch_get_user_name() */
  
  static int coladvance2(pos_T *pos, int addspaces, int finetune, colnr_T wcol);
  
--- 12,18 ----
   */
  #include "vim.h"
  
! static char_u	*username = NULL; // cached result of mch_get_user_name()
  
  static int coladvance2(pos_T *pos, int addspaces, int finetune, colnr_T wcol);
  
***************
*** 22,30 ****
      int
  virtual_active(void)
  {
!     /* While an operator is being executed we return "virtual_op", because
!      * VIsual_active has already been reset, thus we can't check for "block"
!      * being used. */
      if (virtual_op != MAYBE)
  	return virtual_op;
      return (ve_flags == VE_ALL
--- 22,30 ----
      int
  virtual_active(void)
  {
!     // While an operator is being executed we return "virtual_op", because
!     // VIsual_active has already been reset, thus we can't check for "block"
!     // being used.
      if (virtual_op != MAYBE)
  	return virtual_op;
      return (ve_flags == VE_ALL
***************
*** 58,64 ****
  	curwin->w_valid &= ~VALID_VIRTCOL;
      else
      {
! 	/* Virtcol is valid */
  	curwin->w_valid |= VALID_VIRTCOL;
  	curwin->w_virtcol = wcol;
      }
--- 58,64 ----
  	curwin->w_valid &= ~VALID_VIRTCOL;
      else
      {
! 	// Virtcol is valid
  	curwin->w_valid |= VALID_VIRTCOL;
  	curwin->w_virtcol = wcol;
      }
***************
*** 99,105 ****
  	curwin->w_valid &= ~VALID_VIRTCOL;
      else if (*ml_get_cursor() != TAB)
      {
! 	/* Virtcol is valid when not on a TAB */
  	curwin->w_valid |= VALID_VIRTCOL;
  	curwin->w_virtcol = wcol;
      }
--- 99,105 ----
  	curwin->w_valid &= ~VALID_VIRTCOL;
      else if (*ml_get_cursor() != TAB)
      {
! 	// Virtcol is valid when not on a TAB
  	curwin->w_valid |= VALID_VIRTCOL;
  	curwin->w_virtcol = wcol;
      }
***************
*** 168,177 ****
  	    if (wcol / width > (colnr_T)csize / width
  		    && ((State & INSERT) == 0 || (int)wcol > csize + 1))
  	    {
! 		/* In case of line wrapping don't move the cursor beyond the
! 		 * right screen edge.  In Insert mode allow going just beyond
! 		 * the last character (like what happens when typing and
! 		 * reaching the right window edge). */
  		wcol = (csize / width + 1) * width - 1;
  	    }
  	}
--- 168,177 ----
  	    if (wcol / width > (colnr_T)csize / width
  		    && ((State & INSERT) == 0 || (int)wcol > csize + 1))
  	    {
! 		// In case of line wrapping don't move the cursor beyond the
! 		// right screen edge.  In Insert mode allow going just beyond
! 		// the last character (like what happens when typing and
! 		// reaching the right window edge).
  		wcol = (csize / width + 1) * width - 1;
  	    }
  	}
***************
*** 179,185 ****
  	ptr = line;
  	while (col <= wcol && *ptr != NUL)
  	{
! 	    /* Count a tab for what it's worth (if list mode not on) */
  #ifdef FEAT_LINEBREAK
  	    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);
  	    MB_PTR_ADV(ptr);
--- 179,185 ----
  	ptr = line;
  	while (col <= wcol && *ptr != NUL)
  	{
! 	    // Count a tab for what it's worth (if list mode not on)
  #ifdef FEAT_LINEBREAK
  	    csize = win_lbr_chartabsize(curwin, line, ptr, col, &head);
  	    MB_PTR_ADV(ptr);
***************
*** 199,205 ****
  	{
  	    idx -= 1;
  # ifdef FEAT_LINEBREAK
! 	    /* Don't count the chars from 'showbreak'. */
  	    csize -= head;
  # endif
  	    col -= csize;
--- 199,205 ----
  	{
  	    idx -= 1;
  # ifdef FEAT_LINEBREAK
! 	    // Don't count the chars from 'showbreak'.
  	    csize -= head;
  # endif
  	    col -= csize;
***************
*** 210,221 ****
  		&& wcol >= 0
  		&& ((col != wcol && col != wcol + 1) || csize > 1))
  	{
! 	    /* 'virtualedit' is set: The difference between wcol and col is
! 	     * filled with spaces. */
  
  	    if (line[idx] == NUL)
  	    {
! 		/* Append spaces */
  		int	correct = wcol - col;
  		char_u	*newline = alloc(idx + correct + 1);
  		int	t;
--- 210,221 ----
  		&& wcol >= 0
  		&& ((col != wcol && col != wcol + 1) || csize > 1))
  	{
! 	    // 'virtualedit' is set: The difference between wcol and col is
! 	    // filled with spaces.
  
  	    if (line[idx] == NUL)
  	    {
! 		// Append spaces
  		int	correct = wcol - col;
  		char_u	*newline = alloc(idx + correct + 1);
  		int	t;
***************
*** 238,246 ****
  	    }
  	    else
  	    {
! 		/* Break a tab */
  		int	linelen = (int)STRLEN(line);
! 		int	correct = wcol - col - csize + 1; /* negative!! */
  		char_u	*newline;
  		int	t, s = 0;
  		int	v;
--- 238,246 ----
  	    }
  	    else
  	    {
! 		// Break a tab
  		int	linelen = (int)STRLEN(line);
! 		int	correct = wcol - col - csize + 1; // negative!!
  		char_u	*newline;
  		int	t, s = 0;
  		int	v;
***************
*** 282,288 ****
      {
  	if (wcol == MAXCOL)
  	{
! 	    /* The width of the last character is used to set coladd. */
  	    if (!one_more)
  	    {
  		colnr_T	    scol, ecol;
--- 282,288 ----
      {
  	if (wcol == MAXCOL)
  	{
! 	    // The width of the last character is used to set coladd.
  	    if (!one_more)
  	    {
  		colnr_T	    scol, ecol;
***************
*** 295,301 ****
  	{
  	    int b = (int)wcol - (int)col;
  
! 	    /* The difference between wcol and col is used to set coladd. */
  	    if (b > 0 && b < (MAXCOL - 2 * curwin->w_width))
  		pos->coladd = b;
  
--- 295,301 ----
  	{
  	    int b = (int)wcol - (int)col;
  
! 	    // The difference between wcol and col is used to set coladd.
  	    if (b > 0 && b < (MAXCOL - 2 * curwin->w_width))
  		pos->coladd = b;
  
***************
*** 303,309 ****
  	}
      }
  
!     /* prevent from moving onto a trail byte */
      if (has_mbyte)
  	mb_adjustpos(curbuf, pos);
  
--- 303,309 ----
  	}
      }
  
!     // prevent from moving onto a trail byte
      if (has_mbyte)
  	mb_adjustpos(curbuf, pos);
  
***************
*** 333,343 ****
  {
      char_u  *p;
  
!     /* when searching position may be set to end of a line */
      if (lp->col != MAXCOL)
      {
  	p = ml_get_pos(lp);
! 	if (*p != NUL)	/* still within line, move to next char (may be NUL) */
  	{
  	    if (has_mbyte)
  	    {
--- 333,343 ----
  {
      char_u  *p;
  
!     // when searching position may be set to end of a line
      if (lp->col != MAXCOL)
      {
  	p = ml_get_pos(lp);
! 	if (*p != NUL)	// still within line, move to next char (may be NUL)
  	{
  	    if (has_mbyte)
  	    {
***************
*** 351,357 ****
  	    return ((p[1] != NUL) ? 0 : 2);
  	}
      }
!     if (lp->lnum != curbuf->b_ml.ml_line_count)     /* there is a next line */
      {
  	lp->col = 0;
  	lp->lnum++;
--- 351,357 ----
  	    return ((p[1] != NUL) ? 0 : 2);
  	}
      }
!     if (lp->lnum != curbuf->b_ml.ml_line_count)     // there is a next line
      {
  	lp->col = 0;
  	lp->lnum++;
***************
*** 394,400 ****
      lp->coladd = 0;
      if (lp->col == MAXCOL)
      {
! 	/* past end of line */
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
  	if (has_mbyte)
--- 394,400 ----
      lp->coladd = 0;
      if (lp->col == MAXCOL)
      {
! 	// past end of line
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
  	if (has_mbyte)
***************
*** 404,410 ****
  
      if (lp->col > 0)
      {
! 	/* still within line */
  	lp->col--;
  	if (has_mbyte)
  	{
--- 404,410 ----
  
      if (lp->col > 0)
      {
! 	// still within line
  	lp->col--;
  	if (has_mbyte)
  	{
***************
*** 416,422 ****
  
      if (lp->lnum > 1)
      {
! 	/* there is a prior line */
  	lp->lnum--;
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
--- 416,422 ----
  
      if (lp->lnum > 1)
      {
! 	// there is a prior line
  	lp->lnum--;
  	p = ml_get(lp->lnum);
  	lp->col = (colnr_T)STRLEN(p);
***************
*** 425,431 ****
  	return 1;
      }
  
!     /* at start of file */
      return -1;
  }
  
--- 425,431 ----
  	return 1;
      }
  
!     // at start of file
      return -1;
  }
  
***************
*** 450,456 ****
      linenr_T
  get_cursor_rel_lnum(
      win_T	*wp,
!     linenr_T	lnum)		    /* line number to get the result for */
  {
      linenr_T	cursor = wp->w_cursor.lnum;
      linenr_T	retval = 0;
--- 450,456 ----
      linenr_T
  get_cursor_rel_lnum(
      win_T	*wp,
!     linenr_T	lnum)		    // line number to get the result for
  {
      linenr_T	cursor = wp->w_cursor.lnum;
      linenr_T	retval = 0;
***************
*** 463,470 ****
  	    while (lnum > cursor)
  	    {
  		(void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
! 		/* if lnum and cursor are in the same fold,
! 		 * now lnum <= cursor */
  		if (lnum > cursor)
  		    retval++;
  		lnum--;
--- 463,470 ----
  	    while (lnum > cursor)
  	    {
  		(void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
! 		// if lnum and cursor are in the same fold,
! 		// now lnum <= cursor
  		if (lnum > cursor)
  		    retval++;
  		lnum--;
***************
*** 475,490 ****
  	    while (lnum < cursor)
  	    {
  		(void)hasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);
! 		/* if lnum and cursor are in the same fold,
! 		 * now lnum >= cursor */
  		if (lnum < cursor)
  		    retval--;
  		lnum++;
  	    }
  	}
! 	/* else if (lnum == cursor)
! 	 *     retval = 0;
! 	 */
      }
      else
  #endif
--- 475,489 ----
  	    while (lnum < cursor)
  	    {
  		(void)hasFoldingWin(wp, lnum, NULL, &lnum, TRUE, NULL);
! 		// if lnum and cursor are in the same fold,
! 		// now lnum >= cursor
  		if (lnum < cursor)
  		    retval--;
  		lnum++;
  	    }
  	}
! 	// else if (lnum == cursor)
! 	//     retval = 0;
      }
      else
  #endif
***************
*** 524,531 ****
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
      {
  #ifdef FEAT_FOLDING
! 	/* If there is a closed fold at the end of the file, put the cursor in
! 	 * its first line.  Otherwise in the last line. */
  	if (!hasFolding(curbuf->b_ml.ml_line_count,
  						&curwin->w_cursor.lnum, NULL))
  #endif
--- 523,530 ----
      if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
      {
  #ifdef FEAT_FOLDING
! 	// If there is a closed fold at the end of the file, put the cursor in
! 	// its first line.  Otherwise in the last line.
  	if (!hasFolding(curbuf->b_ml.ml_line_count,
  						&curwin->w_cursor.lnum, NULL))
  #endif
***************
*** 559,568 ****
  	win->w_cursor.col = 0;
      else if (win->w_cursor.col >= len)
      {
! 	/* Allow cursor past end-of-line when:
! 	 * - in Insert mode or restarting Insert mode
! 	 * - in Visual mode and 'selection' isn't "old"
! 	 * - 'virtualedit' is set */
  	if ((State & INSERT) || restart_edit
  		|| (VIsual_active && *p_sel != 'o')
  		|| (ve_flags & VE_ONEMORE)
--- 558,567 ----
  	win->w_cursor.col = 0;
      else if (win->w_cursor.col >= len)
      {
! 	// Allow cursor past end-of-line when:
! 	// - in Insert mode or restarting Insert mode
! 	// - in Visual mode and 'selection' isn't "old"
! 	// - 'virtualedit' is set
  	if ((State & INSERT) || restart_edit
  		|| (VIsual_active && *p_sel != 'o')
  		|| (ve_flags & VE_ONEMORE)
***************
*** 571,577 ****
  	else
  	{
  	    win->w_cursor.col = len - 1;
! 	    /* Move the cursor to the head byte. */
  	    if (has_mbyte)
  		mb_adjustpos(win->w_buffer, &win->w_cursor);
  	}
--- 570,576 ----
  	else
  	{
  	    win->w_cursor.col = len - 1;
! 	    // Move the cursor to the head byte.
  	    if (has_mbyte)
  		mb_adjustpos(win->w_buffer, &win->w_cursor);
  	}
***************
*** 579,587 ****
      else if (win->w_cursor.col < 0)
  	win->w_cursor.col = 0;
  
!     /* If virtual editing is on, we can leave the cursor on the old position,
!      * only we must set it to virtual.  But don't do it when at the end of the
!      * line. */
      if (oldcol == MAXCOL)
  	win->w_cursor.coladd = 0;
      else if (ve_flags == VE_ALL)
--- 578,586 ----
      else if (win->w_cursor.col < 0)
  	win->w_cursor.col = 0;
  
!     // If virtual editing is on, we can leave the cursor on the old position,
!     // only we must set it to virtual.  But don't do it when at the end of the
!     // line.
      if (oldcol == MAXCOL)
  	win->w_cursor.coladd = 0;
      else if (ve_flags == VE_ALL)
***************
*** 590,598 ****
  	{
  	    win->w_cursor.coladd = oldcoladd - win->w_cursor.col;
  
! 	    /* Make sure that coladd is not more than the char width.
! 	     * Not for the last character, coladd is then used when the cursor
! 	     * is actually after the last character. */
  	    if (win->w_cursor.col + 1 < len && win->w_cursor.coladd > 0)
  	    {
  		int cs, ce;
--- 589,597 ----
  	{
  	    win->w_cursor.coladd = oldcoladd - win->w_cursor.col;
  
! 	    // Make sure that coladd is not more than the char width.
! 	    // Not for the last character, coladd is then used when the cursor
! 	    // is actually after the last character.
  	    if (win->w_cursor.col + 1 < len && win->w_cursor.coladd > 0)
  	    {
  		int cs, ce;
***************
*** 603,609 ****
  	    }
  	}
  	else
! 	    /* avoid weird number when there is a miscalculation or overflow */
  	    win->w_cursor.coladd = 0;
      }
  }
--- 602,608 ----
  	    }
  	}
  	else
! 	    // avoid weird number when there is a miscalculation or overflow
  	    win->w_cursor.coladd = 0;
      }
  }
***************
*** 678,686 ****
      else if (s < curwin->w_leftcol)
      {
  	retval = TRUE;
! 	if (coladvance(e + 1) == FAIL)	/* there isn't another character */
  	{
! 	    curwin->w_leftcol = s;	/* adjust w_leftcol instead */
  	    changed_cline_bef_curs();
  	}
      }
--- 677,685 ----
      else if (s < curwin->w_leftcol)
      {
  	retval = TRUE;
! 	if (coladvance(e + 1) == FAIL)	// there isn't another character
  	{
! 	    curwin->w_leftcol = s;	// adjust w_leftcol instead
  	    changed_cline_bef_curs();
  	}
      }
***************
*** 794,800 ****
  	    num_alloc, num_freed);
  }
  
! #endif /* MEM_PROFILE */
  
  #ifdef FEAT_EVAL
      int
--- 793,799 ----
  	    num_alloc, num_freed);
  }
  
! #endif // MEM_PROFILE
  
  #ifdef FEAT_EVAL
      int
***************
*** 890,900 ****
      void *
  lalloc(size_t size, int message)
  {
!     void	*p;		    /* pointer to new storage space */
!     static int	releasing = FALSE;  /* don't do mf_release_all() recursive */
      int		try_again;
  #if defined(HAVE_AVAIL_MEM)
!     static size_t allocated = 0;    /* allocated since last avail check */
  #endif
  
      // Safety check for allocating zero bytes
--- 889,899 ----
      void *
  lalloc(size_t size, int message)
  {
!     void	*p;		    // pointer to new storage space
!     static int	releasing = FALSE;  // don't do mf_release_all() recursive
      int		try_again;
  #if defined(HAVE_AVAIL_MEM)
!     static size_t allocated = 0;    // allocated since last avail check
  #endif
  
      // Safety check for allocating zero bytes
***************
*** 926,945 ****
  	if ((p = malloc(size)) != NULL)
  	{
  #ifndef HAVE_AVAIL_MEM
! 	    /* 1. No check for available memory: Just return. */
  	    goto theend;
  #else
! 	    /* 2. Slow check for available memory: call mch_avail_mem() after
! 	     *    allocating (KEEP_ROOM / 2) amount of memory. */
  	    allocated += size;
  	    if (allocated < KEEP_ROOM / 2)
  		goto theend;
  	    allocated = 0;
  
! 	    /* 3. check for available memory: call mch_avail_mem() */
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
! 		free(p);	/* System is low... no go! */
  		p = NULL;
  	    }
  	    else
--- 925,944 ----
  	if ((p = malloc(size)) != NULL)
  	{
  #ifndef HAVE_AVAIL_MEM
! 	    // 1. No check for available memory: Just return.
  	    goto theend;
  #else
! 	    // 2. Slow check for available memory: call mch_avail_mem() after
! 	    //    allocating (KEEP_ROOM / 2) amount of memory.
  	    allocated += size;
  	    if (allocated < KEEP_ROOM / 2)
  		goto theend;
  	    allocated = 0;
  
! 	    // 3. check for available memory: call mch_avail_mem()
  	    if (mch_avail_mem(TRUE) < KEEP_ROOM_KB && !releasing)
  	    {
! 		free(p);	// System is low... no go!
  		p = NULL;
  	    }
  	    else
***************
*** 954,961 ****
  	    break;
  	releasing = TRUE;
  
! 	clear_sb_text(TRUE);	      /* free any scrollback text */
! 	try_again = mf_release_all(); /* release as many blocks as possible */
  
  	releasing = FALSE;
  	if (!try_again)
--- 953,960 ----
  	    break;
  	releasing = TRUE;
  
! 	clear_sb_text(TRUE);	      // free any scrollback text
! 	try_again = mf_release_all(); // release as many blocks as possible
  
  	releasing = FALSE;
  	if (!try_again)
***************
*** 1046,1061 ****
  {
      buf_T	*buf, *nextbuf;
  
!     /* When we cause a crash here it is caught and Vim tries to exit cleanly.
!      * Don't try freeing everything again. */
      if (entered_free_all_mem)
  	return;
      entered_free_all_mem = TRUE;
  
!     /* Don't want to trigger autocommands from here on. */
      block_autocmds();
  
!     /* Close all tabs and windows.  Reset 'equalalways' to avoid redraws. */
      p_ea = FALSE;
      if (first_tabpage != NULL && first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
--- 1045,1060 ----
  {
      buf_T	*buf, *nextbuf;
  
!     // When we cause a crash here it is caught and Vim tries to exit cleanly.
!     // Don't try freeing everything again.
      if (entered_free_all_mem)
  	return;
      entered_free_all_mem = TRUE;
  
!     // Don't want to trigger autocommands from here on.
      block_autocmds();
  
!     // Close all tabs and windows.  Reset 'equalalways' to avoid redraws.
      p_ea = FALSE;
      if (first_tabpage != NULL && first_tabpage->tp_next != NULL)
  	do_cmdline_cmd((char_u *)"tabonly!");
***************
*** 1063,1069 ****
  	do_cmdline_cmd((char_u *)"only!");
  
  # if defined(FEAT_SPELL)
!     /* Free all spell info. */
      spell_free_all();
  # endif
  
--- 1062,1068 ----
  	do_cmdline_cmd((char_u *)"only!");
  
  # if defined(FEAT_SPELL)
!     // Free all spell info.
      spell_free_all();
  # endif
  
***************
*** 1109,1115 ****
      free_findfile();
  # endif
  
!     /* Obviously named calls. */
      free_all_autocmds();
      clear_termcodes();
      free_all_marks();
--- 1108,1114 ----
      free_findfile();
  # endif
  
!     // Obviously named calls.
      free_all_autocmds();
      clear_termcodes();
      free_all_marks();
***************
*** 1134,1142 ****
      if (curtab != NULL)
  	diff_clear(curtab);
  # endif
!     clear_sb_text(TRUE);	      /* free any scrollback text */
  
!     /* Free some global vars. */
      vim_free(username);
  # ifdef FEAT_CLIPBOARD
      vim_regfree(clip_exclude_prog);
--- 1133,1141 ----
      if (curtab != NULL)
  	diff_clear(curtab);
  # endif
!     clear_sb_text(TRUE);	      // free any scrollback text
  
!     // Free some global vars.
      vim_free(username);
  # ifdef FEAT_CLIPBOARD
      vim_regfree(clip_exclude_prog);
***************
*** 1145,1151 ****
      vim_free(new_last_cmdline);
      set_keep_msg(NULL, 0);
  
!     /* Clear cmdline history. */
      p_hi = 0;
      init_history();
  # ifdef FEAT_PROP_POPUP
--- 1144,1150 ----
      vim_free(new_last_cmdline);
      set_keep_msg(NULL, 0);
  
!     // Clear cmdline history.
      p_hi = 0;
      init_history();
  # ifdef FEAT_PROP_POPUP
***************
*** 1171,1181 ****
  	// Destroy all windows.  Must come before freeing buffers.
  	win_free_all();
  
!     /* Free all option values.  Must come after closing windows. */
      free_all_options();
  
!     /* Free all buffers.  Reset 'autochdir' to avoid accessing things that
!      * were freed already. */
  # ifdef FEAT_AUTOCHDIR
      p_acd = FALSE;
  # endif
--- 1170,1180 ----
  	// Destroy all windows.  Must come before freeing buffers.
  	win_free_all();
  
!     // Free all option values.  Must come after closing windows.
      free_all_options();
  
!     // Free all buffers.  Reset 'autochdir' to avoid accessing things that
!     // were freed already.
  # ifdef FEAT_AUTOCHDIR
      p_acd = FALSE;
  # endif
***************
*** 1187,1193 ****
  	nextbuf = buf->b_next;
  	close_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);
  	if (bufref_valid(&bufref))
! 	    buf = nextbuf;	/* didn't work, try next one */
  	else
  	    buf = firstbuf;
      }
--- 1186,1192 ----
  	nextbuf = buf->b_next;
  	close_buffer(NULL, buf, DOBUF_WIPE, FALSE, FALSE);
  	if (bufref_valid(&bufref))
! 	    buf = nextbuf;	// didn't work, try next one
  	else
  	    buf = firstbuf;
      }
***************
*** 1196,1202 ****
      free_arshape_buf();
  # endif
  
!     /* Clear registers. */
      clear_registers();
      ResetRedobuff();
      ResetRedobuff();
--- 1195,1201 ----
      free_arshape_buf();
  # endif
  
!     // Clear registers.
      clear_registers();
      ResetRedobuff();
      ResetRedobuff();
***************
*** 1205,1211 ****
      vim_free(serverDelayedStartName);
  # endif
  
!     /* highlight info */
      free_highlight();
  
      reset_last_sourcing();
--- 1204,1210 ----
      vim_free(serverDelayedStartName);
  # endif
  
!     // highlight info
      free_highlight();
  
      reset_last_sourcing();
***************
*** 1217,1227 ****
      }
  
  # ifdef UNIX
!     /* Machine-specific free. */
      mch_free_mem();
  # endif
  
!     /* message history */
      for (;;)
  	if (delete_first_msg() == FAIL)
  	    break;
--- 1216,1226 ----
      }
  
  # ifdef UNIX
!     // Machine-specific free.
      mch_free_mem();
  # endif
  
!     // message history
      for (;;)
  	if (delete_first_msg() == FAIL)
  	    break;
***************
*** 1233,1249 ****
      timer_free_all();
  # endif
  # ifdef FEAT_EVAL
!     /* must be after channel_free_all() with unrefs partials */
      eval_clear();
  # endif
  # ifdef FEAT_JOB_CHANNEL
!     /* must be after eval_clear() with unrefs jobs */
      job_free_all();
  # endif
  
      free_termoptions();
  
!     /* screenlines (can't display anything now!) */
      free_screenlines();
  
  # if defined(FEAT_SOUND)
--- 1232,1248 ----
      timer_free_all();
  # endif
  # ifdef FEAT_EVAL
!     // must be after channel_free_all() with unrefs partials
      eval_clear();
  # endif
  # ifdef FEAT_JOB_CHANNEL
!     // must be after eval_clear() with unrefs jobs
      job_free_all();
  # endif
  
      free_termoptions();
  
!     // screenlines (can't display anything now!)
      free_screenlines();
  
  # if defined(FEAT_SOUND)
***************
*** 1347,1364 ****
       * First count the number of backslashes required.
       * Then allocate the memory and insert them.
       */
!     length = 1;				/* count the trailing NUL */
      for (p = string; *p; p++)
      {
  	if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  	{
! 	    length += l;		/* count a multibyte char */
  	    p += l - 1;
  	    continue;
  	}
  	if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
! 	    ++length;			/* count a backslash */
! 	++length;			/* count an ordinary char */
      }
      escaped_string = alloc(length);
      if (escaped_string != NULL)
--- 1346,1363 ----
       * First count the number of backslashes required.
       * Then allocate the memory and insert them.
       */
!     length = 1;				// count the trailing NUL
      for (p = string; *p; p++)
      {
  	if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
  	{
! 	    length += l;		// count a multibyte char
  	    p += l - 1;
  	    continue;
  	}
  	if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
! 	    ++length;			// count a backslash
! 	++length;			// count an ordinary char
      }
      escaped_string = alloc(length);
      if (escaped_string != NULL)
***************
*** 1370,1376 ****
  	    {
  		mch_memmove(p2, p, (size_t)l);
  		p2 += l;
! 		p += l - 1;		/* skip multibyte char  */
  		continue;
  	    }
  	    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
--- 1369,1375 ----
  	    {
  		mch_memmove(p2, p, (size_t)l);
  		p2 += l;
! 		p += l - 1;		// skip multibyte char
  		continue;
  	    }
  	    if (vim_strchr(esc_chars, *p) != NULL || (bsl && rem_backslash(p)))
***************
*** 1411,1457 ****
      int		l;
      int		csh_like;
  
!     /* Only csh and similar shells expand '!' within single quotes.  For sh and
!      * the like we must not put a backslash before it, it will be taken
!      * literally.  If do_special is set the '!' will be escaped twice.
!      * Csh also needs to have "\n" escaped twice when do_special is set. */
      csh_like = csh_like_shell();
  
!     /* First count the number of extra bytes required. */
!     length = (unsigned)STRLEN(string) + 3;  /* two quotes and a trailing NUL */
      for (p = string; *p != NUL; MB_PTR_ADV(p))
      {
  # ifdef MSWIN
  	if (!p_ssl)
  	{
  	    if (*p == '"')
! 		++length;		/* " -> "" */
  	}
  	else
  # endif
  	if (*p == '\'')
! 	    length += 3;		/* ' => '\'' */
  	if ((*p == '\n' && (csh_like || do_newline))
  		|| (*p == '!' && (csh_like || do_special)))
  	{
! 	    ++length;			/* insert backslash */
  	    if (csh_like && do_special)
! 		++length;		/* insert backslash */
  	}
  	if (do_special && find_cmdline_var(p, &l) >= 0)
  	{
! 	    ++length;			/* insert backslash */
  	    p += l - 1;
  	}
      }
  
!     /* Allocate memory for the result and fill it. */
      escaped_string = alloc(length);
      if (escaped_string != NULL)
      {
  	d = escaped_string;
  
! 	/* add opening quote */
  # ifdef MSWIN
  	if (!p_ssl)
  	    *d++ = '"';
--- 1410,1456 ----
      int		l;
      int		csh_like;
  
!     // Only csh and similar shells expand '!' within single quotes.  For sh and
!     // the like we must not put a backslash before it, it will be taken
!     // literally.  If do_special is set the '!' will be escaped twice.
!     // Csh also needs to have "\n" escaped twice when do_special is set.
      csh_like = csh_like_shell();
  
!     // First count the number of extra bytes required.
!     length = (unsigned)STRLEN(string) + 3;  // two quotes and a trailing NUL
      for (p = string; *p != NUL; MB_PTR_ADV(p))
      {
  # ifdef MSWIN
  	if (!p_ssl)
  	{
  	    if (*p == '"')
! 		++length;		// " -> ""
  	}
  	else
  # endif
  	if (*p == '\'')
! 	    length += 3;		// ' => '\''
  	if ((*p == '\n' && (csh_like || do_newline))
  		|| (*p == '!' && (csh_like || do_special)))
  	{
! 	    ++length;			// insert backslash
  	    if (csh_like && do_special)
! 		++length;		// insert backslash
  	}
  	if (do_special && find_cmdline_var(p, &l) >= 0)
  	{
! 	    ++length;			// insert backslash
  	    p += l - 1;
  	}
      }
  
!     // Allocate memory for the result and fill it.
      escaped_string = alloc(length);
      if (escaped_string != NULL)
      {
  	d = escaped_string;
  
! 	// add opening quote
  # ifdef MSWIN
  	if (!p_ssl)
  	    *d++ = '"';
***************
*** 1494,1501 ****
  	    }
  	    if (do_special && find_cmdline_var(p, &l) >= 0)
  	    {
! 		*d++ = '\\';		/* insert backslash */
! 		while (--l >= 0)	/* copy the var */
  		    *d++ = *p++;
  		continue;
  	    }
--- 1493,1500 ----
  	    }
  	    if (do_special && find_cmdline_var(p, &l) >= 0)
  	    {
! 		*d++ = '\\';		// insert backslash
! 		while (--l >= 0)	// copy the var
  		    *d++ = *p++;
  		continue;
  	    }
***************
*** 1503,1509 ****
  	    MB_COPY_CHAR(p, d);
  	}
  
! 	/* add terminating quote and finish with a NUL */
  # ifdef MSWIN
  	if (!p_ssl)
  	    *d++ = '"';
--- 1502,1508 ----
  	    MB_COPY_CHAR(p, d);
  	}
  
! 	// add terminating quote and finish with a NUL
  # ifdef MSWIN
  	if (!p_ssl)
  	    *d++ = '"';
***************
*** 1595,1608 ****
  		l = utf_ptr2len(p);
  		if (c == 0)
  		{
! 		    /* overlong sequence, use only the first byte */
  		    c = *p;
  		    l = 1;
  		}
  		uc = utf_toupper(c);
  
! 		/* Reallocate string when byte count changes.  This is rare,
! 		 * thus it's OK to do another malloc()/free(). */
  		newl = utf_char2len(uc);
  		if (newl != l)
  		{
--- 1594,1607 ----
  		l = utf_ptr2len(p);
  		if (c == 0)
  		{
! 		    // overlong sequence, use only the first byte
  		    c = *p;
  		    l = 1;
  		}
  		uc = utf_toupper(c);
  
! 		// Reallocate string when byte count changes.  This is rare,
! 		// thus it's OK to do another malloc()/free().
  		newl = utf_char2len(uc);
  		if (newl != l)
  		{
***************
*** 1623,1632 ****
  		p += newl;
  	    }
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
! 		p += l;		/* skip multi-byte character */
  	    else
  	    {
! 		*p = TOUPPER_LOC(*p); /* note that toupper() can be a macro */
  		p++;
  	    }
  	}
--- 1622,1631 ----
  		p += newl;
  	    }
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
! 		p += l;		// skip multi-byte character
  	    else
  	    {
! 		*p = TOUPPER_LOC(*p); // note that toupper() can be a macro
  		p++;
  	    }
  	}
***************
*** 1662,1675 ****
  		l = utf_ptr2len(p);
  		if (c == 0)
  		{
! 		    /* overlong sequence, use only the first byte */
  		    c = *p;
  		    l = 1;
  		}
  		lc = utf_tolower(c);
  
! 		/* Reallocate string when byte count changes.  This is rare,
! 		 * thus it's OK to do another malloc()/free(). */
  		newl = utf_char2len(lc);
  		if (newl != l)
  		{
--- 1661,1674 ----
  		l = utf_ptr2len(p);
  		if (c == 0)
  		{
! 		    // overlong sequence, use only the first byte
  		    c = *p;
  		    l = 1;
  		}
  		lc = utf_tolower(c);
  
! 		// Reallocate string when byte count changes.  This is rare,
! 		// thus it's OK to do another malloc()/free().
  		newl = utf_char2len(lc);
  		if (newl != l)
  		{
***************
*** 1690,1699 ****
  		p += newl;
  	    }
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
! 		p += l;		/* skip multi-byte character */
  	    else
  	    {
! 		*p = TOLOWER_LOC(*p); /* note that tolower() can be a macro */
  		p++;
  	    }
  	}
--- 1689,1698 ----
  		p += newl;
  	    }
  	    else if (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)
! 		p += l;		// skip multi-byte character
  	    else
  	    {
! 		*p = TOLOWER_LOC(*p); // note that tolower() can be a macro
  		p++;
  	    }
  	}
***************
*** 1762,1768 ****
      int	    len = 0;
      char_u  *p = *option;
  
!     /* skip '.' at start of option part, for 'suffixes' */
      if (*p == '.')
  	buf[len++] = *p++;
      while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL)
--- 1761,1767 ----
      int	    len = 0;
      char_u  *p = *option;
  
!     // skip '.' at start of option part, for 'suffixes'
      if (*p == '.')
  	buf[len++] = *p++;
      while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL)
***************
*** 1778,1786 ****
      }
      buf[len] = NUL;
  
!     if (*p != NUL && *p != ',')	/* skip non-standard separator */
  	++p;
!     p = skip_to_option_part(p);	/* p points to next file name */
  
      *option = p;
      return len;
--- 1777,1785 ----
      }
      buf[len] = NUL;
  
!     if (*p != NUL && *p != ',')	// skip non-standard separator
  	++p;
!     p = skip_to_option_part(p);	// p points to next file name
  
      *option = p;
      return len;
***************
*** 1832,1844 ****
      {
  	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
  	if (i != 0)
! 	    return i;			    /* this character different */
  	if (*s1 == NUL)
! 	    break;			    /* strings match until NUL */
  	++s1;
  	++s2;
      }
!     return 0;				    /* strings match */
  }
  #endif
  
--- 1831,1843 ----
      {
  	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
  	if (i != 0)
! 	    return i;			    // this character different
  	if (*s1 == NUL)
! 	    break;			    // strings match until NUL
  	++s1;
  	++s2;
      }
!     return 0;				    // strings match
  }
  #endif
  
***************
*** 1857,1870 ****
      {
  	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
  	if (i != 0)
! 	    return i;			    /* this character different */
  	if (*s1 == NUL)
! 	    break;			    /* strings match until NUL */
  	++s1;
  	++s2;
  	--len;
      }
!     return 0;				    /* strings match */
  }
  #endif
  
--- 1856,1869 ----
      {
  	i = (int)TOLOWER_LOC(*s1) - (int)TOLOWER_LOC(*s2);
  	if (i != 0)
! 	    return i;			    // this character different
  	if (*s1 == NUL)
! 	    break;			    // strings match until NUL
  	++s1;
  	++s2;
  	--len;
      }
!     return 0;				    // strings match
  }
  #endif
  
***************
*** 1886,1892 ****
  	{
  	    int l = utfc_ptr2len(p);
  
! 	    /* Avoid matching an illegal byte here. */
  	    if (utf_ptr2char(p) == c && l > 1)
  		return p;
  	    p += l;
--- 1885,1891 ----
  	{
  	    int l = utfc_ptr2len(p);
  
! 	    // Avoid matching an illegal byte here.
  	    if (utf_ptr2char(p) == c && l > 1)
  		return p;
  	    p += l;
***************
*** 2177,2183 ****
      void
  append_ga_line(garray_T *gap)
  {
!     /* Remove trailing CR. */
      if (gap->ga_len > 0
  	    && !curbuf->b_p_bin
  	    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)
--- 2176,2182 ----
      void
  append_ga_line(garray_T *gap)
  {
!     // Remove trailing CR.
      if (gap->ga_len > 0
  	    && !curbuf->b_p_bin
  	    && ((char_u *)gap->ga_data)[gap->ga_len - 1] == CAR)
***************
*** 2199,2207 ****
  
  static struct modmasktable
  {
!     short	mod_mask;	/* Bit-mask for particular key modifier */
!     short	mod_flag;	/* Bit(s) for particular key modifier */
!     char_u	name;		/* Single letter name of modifier */
  } mod_mask_table[] =
  {
      {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'M'},
--- 2198,2206 ----
  
  static struct modmasktable
  {
!     short	mod_mask;	// Bit-mask for particular key modifier
!     short	mod_flag;	// Bit(s) for particular key modifier
!     char_u	name;		// Single letter name of modifier
  } mod_mask_table[] =
  {
      {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'M'},
***************
*** 2214,2223 ****
  #ifdef MACOS_X
      {MOD_MASK_CMD,		MOD_MASK_CMD,		(char_u)'D'},
  #endif
!     /* 'A' must be the last one */
      {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'A'},
      {0, 0, NUL}
!     /* NOTE: when adding an entry, update MAX_KEY_NAME_LEN! */
  };
  
  /*
--- 2213,2222 ----
  #ifdef MACOS_X
      {MOD_MASK_CMD,		MOD_MASK_CMD,		(char_u)'D'},
  #endif
!     // 'A' must be the last one
      {MOD_MASK_ALT,		MOD_MASK_ALT,		(char_u)'A'},
      {0, 0, NUL}
!     // NOTE: when adding an entry, update MAX_KEY_NAME_LEN!
  };
  
  /*
***************
*** 2228,2275 ****
  
  static char_u modifier_keys_table[] =
  {
! /*  mod mask	    with modifier		without modifier */
!     MOD_MASK_SHIFT, '&', '9',			'@', '1',	/* begin */
!     MOD_MASK_SHIFT, '&', '0',			'@', '2',	/* cancel */
!     MOD_MASK_SHIFT, '*', '1',			'@', '4',	/* command */
!     MOD_MASK_SHIFT, '*', '2',			'@', '5',	/* copy */
!     MOD_MASK_SHIFT, '*', '3',			'@', '6',	/* create */
!     MOD_MASK_SHIFT, '*', '4',			'k', 'D',	/* delete char */
!     MOD_MASK_SHIFT, '*', '5',			'k', 'L',	/* delete line */
!     MOD_MASK_SHIFT, '*', '7',			'@', '7',	/* end */
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,	'@', '7',	/* end */
!     MOD_MASK_SHIFT, '*', '9',			'@', '9',	/* exit */
!     MOD_MASK_SHIFT, '*', '0',			'@', '0',	/* find */
!     MOD_MASK_SHIFT, '#', '1',			'%', '1',	/* help */
!     MOD_MASK_SHIFT, '#', '2',			'k', 'h',	/* home */
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,	'k', 'h',	/* home */
!     MOD_MASK_SHIFT, '#', '3',			'k', 'I',	/* insert */
!     MOD_MASK_SHIFT, '#', '4',			'k', 'l',	/* left arrow */
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,	'k', 'l',	/* left arrow */
!     MOD_MASK_SHIFT, '%', 'a',			'%', '3',	/* message */
!     MOD_MASK_SHIFT, '%', 'b',			'%', '4',	/* move */
!     MOD_MASK_SHIFT, '%', 'c',			'%', '5',	/* next */
!     MOD_MASK_SHIFT, '%', 'd',			'%', '7',	/* options */
!     MOD_MASK_SHIFT, '%', 'e',			'%', '8',	/* previous */
!     MOD_MASK_SHIFT, '%', 'f',			'%', '9',	/* print */
!     MOD_MASK_SHIFT, '%', 'g',			'%', '0',	/* redo */
!     MOD_MASK_SHIFT, '%', 'h',			'&', '3',	/* replace */
!     MOD_MASK_SHIFT, '%', 'i',			'k', 'r',	/* right arr. */
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,	'k', 'r',	/* right arr. */
!     MOD_MASK_SHIFT, '%', 'j',			'&', '5',	/* resume */
!     MOD_MASK_SHIFT, '!', '1',			'&', '6',	/* save */
!     MOD_MASK_SHIFT, '!', '2',			'&', '7',	/* suspend */
!     MOD_MASK_SHIFT, '!', '3',			'&', '8',	/* undo */
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,	'k', 'u',	/* up arrow */
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,	'k', 'd',	/* down arrow */
  
! 								/* vt100 F1 */
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,	KS_EXTRA, (int)KE_XF1,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,	KS_EXTRA, (int)KE_XF2,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,	KS_EXTRA, (int)KE_XF3,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,	KS_EXTRA, (int)KE_XF4,
  
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,	'k', '1',	/* F1 */
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,	'k', '2',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,	'k', '3',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,	'k', '4',
--- 2227,2274 ----
  
  static char_u modifier_keys_table[] =
  {
! //  mod mask	    with modifier		without modifier
!     MOD_MASK_SHIFT, '&', '9',			'@', '1',	// begin
!     MOD_MASK_SHIFT, '&', '0',			'@', '2',	// cancel
!     MOD_MASK_SHIFT, '*', '1',			'@', '4',	// command
!     MOD_MASK_SHIFT, '*', '2',			'@', '5',	// copy
!     MOD_MASK_SHIFT, '*', '3',			'@', '6',	// create
!     MOD_MASK_SHIFT, '*', '4',			'k', 'D',	// delete char
!     MOD_MASK_SHIFT, '*', '5',			'k', 'L',	// delete line
!     MOD_MASK_SHIFT, '*', '7',			'@', '7',	// end
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_END,	'@', '7',	// end
!     MOD_MASK_SHIFT, '*', '9',			'@', '9',	// exit
!     MOD_MASK_SHIFT, '*', '0',			'@', '0',	// find
!     MOD_MASK_SHIFT, '#', '1',			'%', '1',	// help
!     MOD_MASK_SHIFT, '#', '2',			'k', 'h',	// home
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_HOME,	'k', 'h',	// home
!     MOD_MASK_SHIFT, '#', '3',			'k', 'I',	// insert
!     MOD_MASK_SHIFT, '#', '4',			'k', 'l',	// left arrow
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_LEFT,	'k', 'l',	// left arrow
!     MOD_MASK_SHIFT, '%', 'a',			'%', '3',	// message
!     MOD_MASK_SHIFT, '%', 'b',			'%', '4',	// move
!     MOD_MASK_SHIFT, '%', 'c',			'%', '5',	// next
!     MOD_MASK_SHIFT, '%', 'd',			'%', '7',	// options
!     MOD_MASK_SHIFT, '%', 'e',			'%', '8',	// previous
!     MOD_MASK_SHIFT, '%', 'f',			'%', '9',	// print
!     MOD_MASK_SHIFT, '%', 'g',			'%', '0',	// redo
!     MOD_MASK_SHIFT, '%', 'h',			'&', '3',	// replace
!     MOD_MASK_SHIFT, '%', 'i',			'k', 'r',	// right arr.
!     MOD_MASK_CTRL,  KS_EXTRA, (int)KE_C_RIGHT,	'k', 'r',	// right arr.
!     MOD_MASK_SHIFT, '%', 'j',			'&', '5',	// resume
!     MOD_MASK_SHIFT, '!', '1',			'&', '6',	// save
!     MOD_MASK_SHIFT, '!', '2',			'&', '7',	// suspend
!     MOD_MASK_SHIFT, '!', '3',			'&', '8',	// undo
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_UP,	'k', 'u',	// up arrow
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_DOWN,	'k', 'd',	// down arrow
  
! 								// vt100 F1
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF1,	KS_EXTRA, (int)KE_XF1,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF2,	KS_EXTRA, (int)KE_XF2,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF3,	KS_EXTRA, (int)KE_XF3,
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_XF4,	KS_EXTRA, (int)KE_XF4,
  
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F1,	'k', '1',	// F1
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F2,	'k', '2',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F3,	'k', '3',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F4,	'k', '4',
***************
*** 2278,2284 ****
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,	'k', '7',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,	'k', '8',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,	'k', '9',
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,	'k', ';',	/* F10 */
  
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,	'F', '1',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,	'F', '2',
--- 2277,2283 ----
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F7,	'k', '7',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F8,	'k', '8',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F9,	'k', '9',
!     MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F10,	'k', ';',	// F10
  
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F11,	'F', '1',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F12,	'F', '2',
***************
*** 2310,2316 ****
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,	'F', 'Q',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,	'F', 'R',
  
! 							    /* TAB pseudo code*/
      MOD_MASK_SHIFT, 'k', 'B',			KS_EXTRA, (int)KE_TAB,
  
      NUL
--- 2309,2315 ----
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F36,	'F', 'Q',
      MOD_MASK_SHIFT, KS_EXTRA, (int)KE_S_F37,	'F', 'R',
  
! 							    // TAB pseudo code
      MOD_MASK_SHIFT, 'k', 'B',			KS_EXTRA, (int)KE_TAB,
  
      NUL
***************
*** 2318,2346 ****
  
  static struct key_name_entry
  {
!     int	    key;	/* Special key code or ascii value */
!     char_u  *name;	/* Name of key */
  } key_names_table[] =
  {
      {' ',		(char_u *)"Space"},
      {TAB,		(char_u *)"Tab"},
      {K_TAB,		(char_u *)"Tab"},
      {NL,		(char_u *)"NL"},
!     {NL,		(char_u *)"NewLine"},	/* Alternative name */
!     {NL,		(char_u *)"LineFeed"},	/* Alternative name */
!     {NL,		(char_u *)"LF"},	/* Alternative name */
      {CAR,		(char_u *)"CR"},
!     {CAR,		(char_u *)"Return"},	/* Alternative name */
!     {CAR,		(char_u *)"Enter"},	/* Alternative name */
      {K_BS,		(char_u *)"BS"},
!     {K_BS,		(char_u *)"BackSpace"},	/* Alternative name */
      {ESC,		(char_u *)"Esc"},
      {CSI,		(char_u *)"CSI"},
      {K_CSI,		(char_u *)"xCSI"},
      {'|',		(char_u *)"Bar"},
      {'\\',		(char_u *)"Bslash"},
      {K_DEL,		(char_u *)"Del"},
!     {K_DEL,		(char_u *)"Delete"},	/* Alternative name */
      {K_KDEL,		(char_u *)"kDel"},
      {K_UP,		(char_u *)"Up"},
      {K_DOWN,		(char_u *)"Down"},
--- 2317,2345 ----
  
  static struct key_name_entry
  {
!     int	    key;	// Special key code or ascii value
!     char_u  *name;	// Name of key
  } key_names_table[] =
  {
      {' ',		(char_u *)"Space"},
      {TAB,		(char_u *)"Tab"},
      {K_TAB,		(char_u *)"Tab"},
      {NL,		(char_u *)"NL"},
!     {NL,		(char_u *)"NewLine"},	// Alternative name
!     {NL,		(char_u *)"LineFeed"},	// Alternative name
!     {NL,		(char_u *)"LF"},	// Alternative name
      {CAR,		(char_u *)"CR"},
!     {CAR,		(char_u *)"Return"},	// Alternative name
!     {CAR,		(char_u *)"Enter"},	// Alternative name
      {K_BS,		(char_u *)"BS"},
!     {K_BS,		(char_u *)"BackSpace"},	// Alternative name
      {ESC,		(char_u *)"Esc"},
      {CSI,		(char_u *)"CSI"},
      {K_CSI,		(char_u *)"xCSI"},
      {'|',		(char_u *)"Bar"},
      {'\\',		(char_u *)"Bslash"},
      {K_DEL,		(char_u *)"Del"},
!     {K_DEL,		(char_u *)"Delete"},	// Alternative name
      {K_KDEL,		(char_u *)"kDel"},
      {K_UP,		(char_u *)"Up"},
      {K_DOWN,		(char_u *)"Down"},
***************
*** 2402,2408 ****
      {K_HELP,		(char_u *)"Help"},
      {K_UNDO,		(char_u *)"Undo"},
      {K_INS,		(char_u *)"Insert"},
!     {K_INS,		(char_u *)"Ins"},	/* Alternative name */
      {K_KINS,		(char_u *)"kInsert"},
      {K_HOME,		(char_u *)"Home"},
      {K_KHOME,		(char_u *)"kHome"},
--- 2401,2407 ----
      {K_HELP,		(char_u *)"Help"},
      {K_UNDO,		(char_u *)"Undo"},
      {K_INS,		(char_u *)"Insert"},
!     {K_INS,		(char_u *)"Ins"},	// Alternative name
      {K_KINS,		(char_u *)"kInsert"},
      {K_HOME,		(char_u *)"Home"},
      {K_KHOME,		(char_u *)"kHome"},
***************
*** 2471,2478 ****
      {K_MOUSEUP,		(char_u *)"ScrollWheelDown"},
      {K_MOUSELEFT,	(char_u *)"ScrollWheelRight"},
      {K_MOUSERIGHT,	(char_u *)"ScrollWheelLeft"},
!     {K_MOUSEDOWN,	(char_u *)"MouseDown"}, /* OBSOLETE: Use	  */
!     {K_MOUSEUP,		(char_u *)"MouseUp"},	/* ScrollWheelXXX instead */
      {K_X1MOUSE,		(char_u *)"X1Mouse"},
      {K_X1DRAG,		(char_u *)"X1Drag"},
      {K_X1RELEASE,		(char_u *)"X1Release"},
--- 2470,2477 ----
      {K_MOUSEUP,		(char_u *)"ScrollWheelDown"},
      {K_MOUSELEFT,	(char_u *)"ScrollWheelRight"},
      {K_MOUSERIGHT,	(char_u *)"ScrollWheelLeft"},
!     {K_MOUSEDOWN,	(char_u *)"MouseDown"}, // OBSOLETE: Use
!     {K_MOUSEUP,		(char_u *)"MouseUp"},	// ScrollWheelXXX instead
      {K_X1MOUSE,		(char_u *)"X1Mouse"},
      {K_X1DRAG,		(char_u *)"X1Drag"},
      {K_X1RELEASE,		(char_u *)"X1Release"},
***************
*** 2488,2494 ****
      {K_CURSORHOLD,	(char_u *)"CursorHold"},
      {K_IGNORE,		(char_u *)"Ignore"},
      {0,			NULL}
!     /* NOTE: When adding a long name update MAX_KEY_NAME_LEN. */
  };
  
  #define KEY_NAMES_TABLE_LEN (sizeof(key_names_table) / sizeof(struct key_name_entry))
--- 2487,2493 ----
      {K_CURSORHOLD,	(char_u *)"CursorHold"},
      {K_IGNORE,		(char_u *)"Ignore"},
      {0,			NULL}
!     // NOTE: When adding a long name update MAX_KEY_NAME_LEN.
  };
  
  #define KEY_NAMES_TABLE_LEN (sizeof(key_names_table) / sizeof(struct key_name_entry))
***************
*** 2522,2528 ****
  
      if (*modifiers & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))
      {
! 	/* TAB is a special case */
  	if (key == TAB && (*modifiers & MOD_MASK_SHIFT))
  	{
  	    *modifiers &= ~MOD_MASK_SHIFT;
--- 2521,2527 ----
  
      if (*modifiers & (MOD_MASK_SHIFT | MOD_MASK_CTRL | MOD_MASK_ALT))
      {
! 	// TAB is a special case
  	if (key == TAB && (*modifiers & MOD_MASK_SHIFT))
  	{
  	    *modifiers &= ~MOD_MASK_SHIFT;
***************
*** 2587,2593 ****
      string[0] = '<';
      idx = 1;
  
!     /* Key that stands for a normal character. */
      if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)
  	c = KEY2TERMCAP1(c);
  
--- 2586,2592 ----
      string[0] = '<';
      idx = 1;
  
!     // Key that stands for a normal character.
      if (IS_SPECIAL(c) && KEY2TERMCAP0(c) == KS_KEY)
  	c = KEY2TERMCAP1(c);
  
***************
*** 2608,2614 ****
  	    }
      }
  
!     /* try to find the key in the special key table */
      table_idx = find_special_key_in_table(c);
  
      /*
--- 2607,2613 ----
  	    }
      }
  
!     // try to find the key in the special key table
      table_idx = find_special_key_in_table(c);
  
      /*
***************
*** 2623,2629 ****
  	{
  	    c &= 0x7f;
  	    modifiers |= MOD_MASK_ALT;
! 	    /* try again, to find the un-alted key in the special key table */
  	    table_idx = find_special_key_in_table(c);
  	}
  	if (table_idx < 0 && !vim_isprintc(c) && c < ' ')
--- 2622,2628 ----
  	{
  	    c &= 0x7f;
  	    modifiers |= MOD_MASK_ALT;
! 	    // try again, to find the un-alted key in the special key table
  	    table_idx = find_special_key_in_table(c);
  	}
  	if (table_idx < 0 && !vim_isprintc(c) && c < ' ')
***************
*** 2637,2643 ****
  	}
      }
  
!     /* translate the modifier into a string */
      for (i = 0; mod_mask_table[i].name != 'A'; i++)
  	if ((modifiers & mod_mask_table[i].mod_mask)
  						== mod_mask_table[i].mod_flag)
--- 2636,2642 ----
  	}
      }
  
!     // translate the modifier into a string
      for (i = 0; mod_mask_table[i].name != 'A'; i++)
  	if ((modifiers & mod_mask_table[i].mod_mask)
  						== mod_mask_table[i].mod_flag)
***************
*** 2646,2652 ****
  	    string[idx++] = (char_u)'-';
  	}
  
!     if (table_idx < 0)		/* unknown special key, may output t_xx */
      {
  	if (IS_SPECIAL(c))
  	{
--- 2645,2651 ----
  	    string[idx++] = (char_u)'-';
  	}
  
!     if (table_idx < 0)		// unknown special key, may output t_xx
      {
  	if (IS_SPECIAL(c))
  	{
***************
*** 2655,2661 ****
  	    string[idx++] = KEY2TERMCAP0(c);
  	    string[idx++] = KEY2TERMCAP1(c);
  	}
! 	/* Not a special key, only modifiers, output directly */
  	else
  	{
  	    if (has_mbyte && (*mb_char2len)(c) > 1)
--- 2654,2660 ----
  	    string[idx++] = KEY2TERMCAP0(c);
  	    string[idx++] = KEY2TERMCAP1(c);
  	}
! 	// Not a special key, only modifiers, output directly
  	else
  	{
  	    if (has_mbyte && (*mb_char2len)(c) > 1)
***************
*** 2670,2676 ****
  	    }
  	}
      }
!     else		/* use name of special key */
      {
  	size_t len = STRLEN(key_names_table[table_idx].name);
  
--- 2669,2675 ----
  	    }
  	}
      }
!     else		// use name of special key
      {
  	size_t len = STRLEN(key_names_table[table_idx].name);
  
***************
*** 2723,2729 ****
  {
      int		dlen = 0;
  
!     /* Put the appropriate modifier in a string */
      if (modifiers != 0)
      {
  	dst[dlen++] = K_SPECIAL;
--- 2722,2728 ----
  {
      int		dlen = 0;
  
!     // Put the appropriate modifier in a string
      if (modifiers != 0)
      {
  	dst[dlen++] = K_SPECIAL;
***************
*** 2776,2782 ****
      if (src[0] != '<')
  	return 0;
  
!     /* Find end of modifier list */
      last_dash = src;
      for (bp = src + 1; *bp == '-' || vim_isIDc(*bp); bp++)
      {
--- 2775,2781 ----
      if (src[0] != '<')
  	return 0;
  
!     // Find end of modifier list
      last_dash = src;
      for (bp = src + 1; *bp == '-' || vim_isIDc(*bp); bp++)
      {
***************
*** 2800,2806 ****
  	    }
  	}
  	if (bp[0] == 't' && bp[1] == '_' && bp[2] && bp[3])
! 	    bp += 3;	/* skip t_xx, xx may be '-' or '>' */
  	else if (STRNICMP(bp, "char-", 5) == 0)
  	{
  	    vim_str2nr(bp + 5, NULL, &l, STR2NR_ALL, NULL, NULL, 0, TRUE);
--- 2799,2805 ----
  	    }
  	}
  	if (bp[0] == 't' && bp[1] == '_' && bp[2] && bp[3])
! 	    bp += 3;	// skip t_xx, xx may be '-' or '>'
  	else if (STRNICMP(bp, "char-", 5) == 0)
  	{
  	    vim_str2nr(bp + 5, NULL, &l, STR2NR_ALL, NULL, NULL, 0, TRUE);
***************
*** 2814,2824 ****
  	}
      }
  
!     if (*bp == '>')	/* found matching '>' */
      {
  	end_of_name = bp + 1;
  
! 	/* Which modifiers are given? */
  	modifiers = 0x0;
  	for (bp = src + 1; bp < last_dash; bp++)
  	{
--- 2813,2823 ----
  	}
      }
  
!     if (*bp == '>')	// found matching '>'
      {
  	end_of_name = bp + 1;
  
! 	// Which modifiers are given?
  	modifiers = 0x0;
  	for (bp = src + 1; bp < last_dash; bp++)
  	{
***************
*** 2826,2832 ****
  	    {
  		bit = name_to_mod_mask(*bp);
  		if (bit == 0x0)
! 		    break;	/* Illegal modifier name */
  		modifiers |= bit;
  	    }
  	}
--- 2825,2831 ----
  	    {
  		bit = name_to_mod_mask(*bp);
  		if (bit == 0x0)
! 		    break;	// Illegal modifier name
  		modifiers |= bit;
  	    }
  	}
***************
*** 2839,2845 ****
  	    if (STRNICMP(last_dash + 1, "char-", 5) == 0
  						 && VIM_ISDIGIT(last_dash[6]))
  	    {
! 		/* <Char-123> or <Char-033> or <Char-0x33> */
  		vim_str2nr(last_dash + 6, NULL, &l, STR2NR_ALL, NULL,
  								  &n, 0, TRUE);
  		if (l == 0)
--- 2838,2844 ----
  	    if (STRNICMP(last_dash + 1, "char-", 5) == 0
  						 && VIM_ISDIGIT(last_dash[6]))
  	    {
! 		// <Char-123> or <Char-033> or <Char-0x33>
  		vim_str2nr(last_dash + 6, NULL, &l, STR2NR_ALL, NULL,
  								  &n, 0, TRUE);
  		if (l == 0)
***************
*** 2853,2859 ****
  	    {
  		int off = 1;
  
! 		/* Modifier with single letter, or special key name.  */
  		if (in_string && last_dash[1] == '\\' && last_dash[2] == '"')
  		    off = 2;
  		if (has_mbyte)
--- 2852,2858 ----
  	    {
  		int off = 1;
  
! 		// Modifier with single letter, or special key name.
  		if (in_string && last_dash[1] == '\\' && last_dash[2] == '"')
  		    off = 2;
  		if (has_mbyte)
***************
*** 2884,2890 ****
  
  		if (!keycode)
  		{
! 		    /* don't want keycode, use single byte code */
  		    if (key == K_BS)
  			key = BS;
  		    else if (key == K_DEL || key == K_KDEL)
--- 2883,2889 ----
  
  		if (!keycode)
  		{
! 		    // don't want keycode, use single byte code
  		    if (key == K_BS)
  			key = BS;
  		    else if (key == K_DEL || key == K_KDEL)
***************
*** 2948,2954 ****
      {
  	key = Ctrl_chr(key);
  	modifiers &= ~MOD_MASK_CTRL;
! 	/* <C-@> is <Nul> */
  	if (key == 0)
  	    key = K_ZERO;
  	if (did_simplify != NULL)
--- 2947,2953 ----
      {
  	key = Ctrl_chr(key);
  	modifiers &= ~MOD_MASK_CTRL;
! 	// <C-@> is <Nul>
  	if (key == 0)
  	    key = K_ZERO;
  	if (did_simplify != NULL)
***************
*** 2956,2969 ****
      }
  
  #ifdef MACOS_X
!     /* Command-key really special, no fancynest */
      if (!(modifiers & MOD_MASK_CMD))
  #endif
      if (simplify && (modifiers & MOD_MASK_ALT) && key < 0x80
  	    && !enc_dbcs)		// avoid creating a lead byte
      {
  	key |= 0x80;
! 	modifiers &= ~MOD_MASK_ALT;	/* remove the META modifier */
  	if (did_simplify != NULL)
  	    *did_simplify = TRUE;
      }
--- 2955,2968 ----
      }
  
  #ifdef MACOS_X
!     // Command-key really special, no fancynest
      if (!(modifiers & MOD_MASK_CMD))
  #endif
      if (simplify && (modifiers & MOD_MASK_ALT) && key < 0x80
  	    && !enc_dbcs)		// avoid creating a lead byte
      {
  	key |= 0x80;
! 	modifiers &= ~MOD_MASK_ALT;	// remove the META modifier
  	if (did_simplify != NULL)
  	    *did_simplify = TRUE;
      }
***************
*** 3057,3063 ****
      int
  get_fileformat_force(
      buf_T	*buf,
!     exarg_T	*eap)	    /* can be NULL! */
  {
      int		c;
  
--- 3056,3062 ----
      int
  get_fileformat_force(
      buf_T	*buf,
!     exarg_T	*eap)	    // can be NULL!
  {
      int		c;
  
***************
*** 3085,3091 ****
      void
  set_fileformat(
      int		t,
!     int		opt_flags)	/* OPT_LOCAL and/or OPT_GLOBAL */
  {
      char	*p = NULL;
  
--- 3084,3090 ----
      void
  set_fileformat(
      int		t,
!     int		opt_flags)	// OPT_LOCAL and/or OPT_GLOBAL
  {
      char	*p = NULL;
  
***************
*** 3108,3118 ****
  	set_string_option_direct((char_u *)"ff", -1, (char_u *)p,
  						     OPT_FREE | opt_flags, 0);
  
!     /* This may cause the buffer to become (un)modified. */
      check_status(curbuf);
      redraw_tabline = TRUE;
  #ifdef FEAT_TITLE
!     need_maketitle = TRUE;	    /* set window title later */
  #endif
  }
  
--- 3107,3117 ----
  	set_string_option_direct((char_u *)"ff", -1, (char_u *)p,
  						     OPT_FREE | opt_flags, 0);
  
!     // This may cause the buffer to become (un)modified.
      check_status(curbuf);
      redraw_tabline = TRUE;
  #ifdef FEAT_TITLE
!     need_maketitle = TRUE;	    // set window title later
  #endif
  }
  
***************
*** 3165,3177 ****
      else
      {
  #ifdef FEAT_GUI_MSWIN
! 	/* Don't hide the pointer while executing a shell command. */
  	gui_mch_mousehide(FALSE);
  #endif
  #ifdef FEAT_GUI
  	++hold_gui_events;
  #endif
! 	/* The external command may update a tags file, clear cached tags. */
  	tag_freematch();
  
  	if (cmd == NULL || *p_sxq == NUL)
--- 3164,3176 ----
      else
      {
  #ifdef FEAT_GUI_MSWIN
! 	// Don't hide the pointer while executing a shell command.
  	gui_mch_mousehide(FALSE);
  #endif
  #ifdef FEAT_GUI
  	++hold_gui_events;
  #endif
! 	// The external command may update a tags file, clear cached tags.
  	tag_freematch();
  
  	if (cmd == NULL || *p_sxq == NUL)
***************
*** 3269,3275 ****
      char_u	*t1;
      char_u	*t2;
  
!     /* safety check */
      if (f1 == NULL || f2 == NULL)
  	return FALSE;
  
--- 3268,3274 ----
      char_u	*t1;
      char_u	*t2;
  
!     // safety check
      if (f1 == NULL || f2 == NULL)
  	return FALSE;
  
***************
*** 3327,3337 ****
  illegal_slash(const char *name)
  {
      if (name[0] == NUL)
! 	return FALSE;	    /* no file name is not illegal */
      if (name[strlen(name) - 1] != '/')
! 	return FALSE;	    /* no trailing slash */
      if (mch_isdir((char_u *)name))
! 	return FALSE;	    /* trailing slash for a directory */
      return TRUE;
  }
  
--- 3326,3336 ----
  illegal_slash(const char *name)
  {
      if (name[0] == NUL)
! 	return FALSE;	    // no file name is not illegal
      if (name[strlen(name) - 1] != '/')
! 	return FALSE;	    // no trailing slash
      if (mch_isdir((char_u *)name))
! 	return FALSE;	    // trailing slash for a directory
      return TRUE;
  }
  
***************
*** 3341,3348 ****
      int
  vim_stat(const char *name, stat_T *stp)
  {
!     /* On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
!      * the name ends in "/" and it's not a directory. */
      return illegal_slash(name) ? -1 : stat(name, stp);
  }
  #endif
--- 3340,3347 ----
      int
  vim_stat(const char *name, stat_T *stp)
  {
!     // On Solaris stat() accepts "file/" as if it was "file".  Return -1 if
!     // the name ends in "/" and it's not a directory.
      return illegal_slash(name) ? -1 : stat(name, stp);
  }
  #endif
***************
*** 3355,3363 ****
  
  cursorentry_T shape_table[SHAPE_IDX_COUNT] =
  {
!     /* The values will be filled in from the 'guicursor' and 'mouseshape'
!      * defaults when Vim starts.
!      * Adjust the SHAPE_IDX_ defines when making changes! */
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "n", SHAPE_CURSOR+SHAPE_MOUSE},
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "v", SHAPE_CURSOR+SHAPE_MOUSE},
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "i", SHAPE_CURSOR+SHAPE_MOUSE},
--- 3354,3362 ----
  
  cursorentry_T shape_table[SHAPE_IDX_COUNT] =
  {
!     // The values will be filled in from the 'guicursor' and 'mouseshape'
!     // defaults when Vim starts.
!     // Adjust the SHAPE_IDX_ defines when making changes!
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "n", SHAPE_CURSOR+SHAPE_MOUSE},
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "v", SHAPE_CURSOR+SHAPE_MOUSE},
      {0,	0, 0, 700L, 400L, 250L, 0, 0, "i", SHAPE_CURSOR+SHAPE_MOUSE},
***************
*** 3384,3391 ****
   */
  static char * mshape_names[] =
  {
!     "arrow",	/* default, must be the first one */
!     "blank",	/* hidden */
      "beam",
      "updown",
      "udsizing",
--- 3383,3390 ----
   */
  static char * mshape_names[] =
  {
!     "arrow",	// default, must be the first one
!     "blank",	// hidden
      "beam",
      "updown",
      "udsizing",
***************
*** 3417,3428 ****
      char_u	*commap;
      char_u	*slashp;
      char_u	*p, *endp;
!     int		idx = 0;		/* init for GCC */
      int		all_idx;
      int		len;
      int		i;
      long	n;
!     int		found_ve = FALSE;	/* found "ve" flag */
      int		round;
  
      /*
--- 3416,3427 ----
      char_u	*commap;
      char_u	*slashp;
      char_u	*p, *endp;
!     int		idx = 0;		// init for GCC
      int		all_idx;
      int		len;
      int		i;
      long	n;
!     int		found_ve = FALSE;	// found "ve" flag
      int		round;
  
      /*
***************
*** 3458,3464 ****
  	    {
  		if (all_idx < 0)
  		{
! 		    /* Find the mode. */
  		    if (modep[1] == '-' || modep[1] == ':')
  			len = 1;
  		    else
--- 3457,3463 ----
  	    {
  		if (all_idx < 0)
  		{
! 		    // Find the mode.
  		    if (modep[1] == '-' || modep[1] == ':')
  			len = 1;
  		    else
***************
*** 3487,3499 ****
  #ifdef FEAT_MOUSESHAPE
  		    if (what == SHAPE_MOUSE)
  		    {
! 			/* Set the default, for the missing parts */
  			shape_table[idx].mshape = 0;
  		    }
  		    else
  #endif
  		    {
! 			/* Set the defaults, for the missing parts */
  			shape_table[idx].shape = SHAPE_BLOCK;
  			shape_table[idx].blinkwait = 700L;
  			shape_table[idx].blinkon = 400L;
--- 3486,3498 ----
  #ifdef FEAT_MOUSESHAPE
  		    if (what == SHAPE_MOUSE)
  		    {
! 			// Set the default, for the missing parts
  			shape_table[idx].mshape = 0;
  		    }
  		    else
  #endif
  		    {
! 			// Set the defaults, for the missing parts
  			shape_table[idx].shape = SHAPE_BLOCK;
  			shape_table[idx].blinkwait = 700L;
  			shape_table[idx].blinkon = 400L;
***************
*** 3501,3507 ****
  		    }
  		}
  
! 		/* Parse the part after the colon */
  		for (p = colonp + 1; *p && *p != ','; )
  		{
  #ifdef FEAT_MOUSESHAPE
--- 3500,3506 ----
  		    }
  		}
  
! 		// Parse the part after the colon
  		for (p = colonp + 1; *p && *p != ','; )
  		{
  #ifdef FEAT_MOUSESHAPE
***************
*** 3530,3536 ****
  			    }
  			}
  		    }
! 		    else /* if (what == SHAPE_MOUSE) */
  #endif
  		    {
  			/*
--- 3529,3535 ----
  			    }
  			}
  		    }
! 		    else // if (what == SHAPE_MOUSE)
  #endif
  		    {
  			/*
***************
*** 3554,3560 ****
  			    if (!VIM_ISDIGIT(*p))
  				return N_("E548: digit expected");
  			    n = getdigits(&p);
! 			    if (len == 3)   /* "ver" or "hor" */
  			    {
  				if (n == 0)
  				    return N_("E549: Illegal percentage");
--- 3553,3559 ----
  			    if (!VIM_ISDIGIT(*p))
  				return N_("E548: digit expected");
  			    n = getdigits(&p);
! 			    if (len == 3)   // "ver" or "hor"
  			    {
  				if (n == 0)
  				    return N_("E549: Illegal percentage");
***************
*** 3583,3602 ****
  				shape_table[idx].shape = SHAPE_BLOCK;
  			    p += 5;
  			}
! 			else	/* must be a highlight group name then */
  			{
  			    endp = vim_strchr(p, '-');
! 			    if (commap == NULL)		    /* last part */
  			    {
  				if (endp == NULL)
! 				    endp = p + STRLEN(p);   /* find end of part */
  			    }
  			    else if (endp > commap || endp == NULL)
  				endp = commap;
  			    slashp = vim_strchr(p, '/');
  			    if (slashp != NULL && slashp < endp)
  			    {
! 				/* "group/langmap_group" */
  				i = syn_check_group(p, (int)(slashp - p));
  				p = slashp + 1;
  			    }
--- 3582,3601 ----
  				shape_table[idx].shape = SHAPE_BLOCK;
  			    p += 5;
  			}
! 			else	// must be a highlight group name then
  			{
  			    endp = vim_strchr(p, '-');
! 			    if (commap == NULL)		    // last part
  			    {
  				if (endp == NULL)
! 				    endp = p + STRLEN(p);   // find end of part
  			    }
  			    else if (endp > commap || endp == NULL)
  				endp = commap;
  			    slashp = vim_strchr(p, '/');
  			    if (slashp != NULL && slashp < endp)
  			    {
! 				// "group/langmap_group"
  				i = syn_check_group(p, (int)(slashp - p));
  				p = slashp + 1;
  			    }
***************
*** 3610,3616 ****
  			    }
  			    p = endp;
  			}
! 		    } /* if (what != SHAPE_MOUSE) */
  
  		    if (*p == '-')
  			++p;
--- 3609,3615 ----
  			    }
  			    p = endp;
  			}
! 		    } // if (what != SHAPE_MOUSE)
  
  		    if (*p == '-')
  			++p;
***************
*** 3622,3628 ****
  	}
      }
  
!     /* If the 's' flag is not given, use the 'v' cursor for 's' */
      if (!found_ve)
      {
  #ifdef FEAT_MOUSESHAPE
--- 3621,3627 ----
  	}
      }
  
!     // If the 's' flag is not given, use the 'v' cursor for 's'
      if (!found_ve)
      {
  #ifdef FEAT_MOUSESHAPE
***************
*** 3719,3737 ****
  {
      int new_mouse_shape;
  
!     /* Only works in GUI mode. */
      if (!gui.in_use || gui.starting)
  	return;
  
!     /* Postpone the updating when more is to come.  Speeds up executing of
!      * mappings. */
      if (shape_idx == -1 && char_avail())
      {
  	postponed_mouseshape = TRUE;
  	return;
      }
  
!     /* When ignoring the mouse don't change shape on the statusline. */
      if (*p_mouse == NUL
  	    && (shape_idx == SHAPE_IDX_CLINE
  		|| shape_idx == SHAPE_IDX_STATUS
--- 3718,3736 ----
  {
      int new_mouse_shape;
  
!     // Only works in GUI mode.
      if (!gui.in_use || gui.starting)
  	return;
  
!     // Postpone the updating when more is to come.  Speeds up executing of
!     // mappings.
      if (shape_idx == -1 && char_avail())
      {
  	postponed_mouseshape = TRUE;
  	return;
      }
  
!     // When ignoring the mouse don't change shape on the statusline.
      if (*p_mouse == NUL
  	    && (shape_idx == SHAPE_IDX_CLINE
  		|| shape_idx == SHAPE_IDX_STATUS
***************
*** 3756,3762 ****
  }
  # endif
  
! #endif /* CURSOR_SHAPE */
  
  
  /*
--- 3755,3761 ----
  }
  # endif
  
! #endif // CURSOR_SHAPE
  
  
  /*
***************
*** 3829,3840 ****
  	for (i = gap; i < elm_count; ++i)
  	    for (j = i - gap; j >= 0; j -= gap)
  	    {
! 		/* Compare the elements. */
  		p1 = (char_u *)base + j * elm_size;
  		p2 = (char_u *)base + (j + gap) * elm_size;
  		if ((*cmp)((void *)p1, (void *)p2) <= 0)
  		    break;
! 		/* Exchange the elements. */
  		mch_memmove(buf, p1, elm_size);
  		mch_memmove(p1, p2, elm_size);
  		mch_memmove(p2, buf, elm_size);
--- 3828,3839 ----
  	for (i = gap; i < elm_count; ++i)
  	    for (j = i - gap; j >= 0; j -= gap)
  	    {
! 		// Compare the elements.
  		p1 = (char_u *)base + j * elm_size;
  		p2 = (char_u *)base + (j + gap) * elm_size;
  		if ((*cmp)((void *)p1, (void *)p2) <= 0)
  		    break;
! 		// Exchange the elements.
  		mch_memmove(buf, p1, elm_size);
  		mch_memmove(p1, p2, elm_size);
  		mch_memmove(p2, buf, elm_size);
***************
*** 3891,3904 ****
  
  #if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)
  
! #define EXTRASIZE 5		/* increment to add to env. size */
  
! static int  envsize = -1;	/* current size of environment */
! extern char **environ;		/* the global which is your env. */
  
! static int  findenv(char *name); /* look for a name in the env. */
! static int  newenv(void);	/* copy env. from stack to heap */
! static int  moreenv(void);	/* incr. size of env. */
  
      int
  putenv(const char *string)
--- 3890,3903 ----
  
  #if !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)
  
! #define EXTRASIZE 5		// increment to add to env. size
  
! static int  envsize = -1;	// current size of environment
! extern char **environ;		// the global which is your env.
  
! static int  findenv(char *name); // look for a name in the env.
! static int  newenv(void);	// copy env. from stack to heap
! static int  moreenv(void);	// incr. size of env.
  
      int
  putenv(const char *string)
***************
*** 3907,3939 ****
      char    *p;
  
      if (envsize < 0)
!     {				/* first time putenv called */
! 	if (newenv() < 0)	/* copy env. to heap */
  	    return -1;
      }
  
!     i = findenv((char *)string); /* look for name in environment */
  
      if (i < 0)
!     {				/* name must be added */
  	for (i = 0; environ[i]; i++);
  	if (i >= (envsize - 1))
! 	{			/* need new slot */
  	    if (moreenv() < 0)
  		return -1;
  	}
  	p = alloc(strlen(string) + 1);
! 	if (p == NULL)		/* not enough core */
  	    return -1;
! 	environ[i + 1] = 0;	/* new end of env. */
      }
      else
!     {				/* name already in env. */
  	p = vim_realloc(environ[i], strlen(string) + 1);
  	if (p == NULL)
  	    return -1;
      }
!     sprintf(p, "%s", string);	/* copy into env. */
      environ[i] = p;
  
      return 0;
--- 3906,3938 ----
      char    *p;
  
      if (envsize < 0)
!     {				// first time putenv called
! 	if (newenv() < 0)	// copy env. to heap
  	    return -1;
      }
  
!     i = findenv((char *)string); // look for name in environment
  
      if (i < 0)
!     {				// name must be added
  	for (i = 0; environ[i]; i++);
  	if (i >= (envsize - 1))
! 	{			// need new slot
  	    if (moreenv() < 0)
  		return -1;
  	}
  	p = alloc(strlen(string) + 1);
! 	if (p == NULL)		// not enough core
  	    return -1;
! 	environ[i + 1] = 0;	// new end of env.
      }
      else
!     {				// name already in env.
  	p = vim_realloc(environ[i], strlen(string) + 1);
  	if (p == NULL)
  	    return -1;
      }
!     sprintf(p, "%s", string);	// copy into env.
      environ[i] = p;
  
      return 0;
***************
*** 4027,4033 ****
  }
  # endif
  
! #endif /* !defined(HAVE_SETENV) && !defined(HAVE_PUTENV) */
  
  #if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)
  /*
--- 4026,4032 ----
  }
  # endif
  
! #endif // !defined(HAVE_SETENV) && !defined(HAVE_PUTENV)
  
  #if defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)
  /*
***************
*** 4108,4115 ****
  get4c(FILE *fd)
  {
      int		c;
!     /* Use unsigned rather than int otherwise result is undefined
!      * when left-shift sets the MSB. */
      unsigned	n;
  
      c = getc(fd);
--- 4107,4114 ----
  get4c(FILE *fd)
  {
      int		c;
!     // Use unsigned rather than int otherwise result is undefined
!     // when left-shift sets the MSB.
      unsigned	n;
  
      c = getc(fd);
***************
*** 4158,4168 ****
      int		i;
      int		c;
  
!     /* allocate memory */
      str = alloc(cnt + 1);
      if (str != NULL)
      {
! 	/* Read the string.  Quit when running into the EOF. */
  	for (i = 0; i < cnt; ++i)
  	{
  	    c = getc(fd);
--- 4157,4167 ----
      int		i;
      int		c;
  
!     // allocate memory
      str = alloc(cnt + 1);
      if (str != NULL)
      {
! 	// Read the string.  Quit when running into the EOF.
  	for (i = 0; i < cnt; ++i)
  	{
  	    c = getc(fd);
***************
*** 4194,4201 ****
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
! /* This line is required for VC6 without the service pack.  Also see the
!  * matching #pragma below. */
   #  pragma optimize("", off)
  # endif
  #endif
--- 4193,4200 ----
  
  #ifdef _MSC_VER
  # if (_MSC_VER <= 1200)
! // This line is required for VC6 without the service pack.  Also see the
! // matching #pragma below.
   #  pragma optimize("", off)
  # endif
  #endif
***************
*** 4224,4240 ****
      int		bi = 0;
      time_T	wtime = the_time;
  
!     /* time_T can be up to 8 bytes in size, more than long_u, thus we
!      * can't use put_bytes() here.
!      * Another problem is that ">>" may do an arithmetic shift that keeps the
!      * sign.  This happens for large values of wtime.  A cast to long_u may
!      * truncate if time_T is 8 bytes.  So only use a cast when it is 4 bytes,
!      * it's safe to assume that long_u is 4 bytes or more and when using 8
!      * bytes the top bit won't be set. */
      for (i = 7; i >= 0; --i)
      {
  	if (i + 1 > (int)sizeof(time_T))
! 	    /* ">>" doesn't work well when shifting more bits than avail */
  	    buf[bi++] = 0;
  	else
  	{
--- 4223,4239 ----
      int		bi = 0;
      time_T	wtime = the_time;
  
!     // time_T can be up to 8 bytes in size, more than long_u, thus we
!     // can't use put_bytes() here.
!     // Another problem is that ">>" may do an arithmetic shift that keeps the
!     // sign.  This happens for large values of wtime.  A cast to long_u may
!     // truncate if time_T is 8 bytes.  So only use a cast when it is 4 bytes,
!     // it's safe to assume that long_u is 4 bytes or more and when using 8
!     // bytes the top bit won't be set.
      for (i = 7; i >= 0; --i)
      {
  	if (i + 1 > (int)sizeof(time_T))
! 	    // ">>" doesn't work well when shifting more bits than avail
  	    buf[bi++] = 0;
  	else
  	{
***************
*** 4274,4280 ****
  }
  #endif
  
! #ifndef PROTO  /* proto is defined in vim.h */
  # ifdef ELAPSED_TIMEVAL
  /*
   * Return time in msec since "start_tv".
--- 4273,4279 ----
  }
  #endif
  
! #ifndef PROTO  // proto is defined in vim.h
  # ifdef ELAPSED_TIMEVAL
  /*
   * Return time in msec since "start_tv".
***************
*** 4368,4374 ****
  	{
  	    if (use_shcf)
  	    {
! 		/* Account for possible multiple args in p_shcf. */
  		p = p_shcf;
  		for (;;)
  		{
--- 4367,4373 ----
  	{
  	    if (use_shcf)
  	    {
! 		// Account for possible multiple args in p_shcf.
  		p = p_shcf;
  		for (;;)
  		{
***************
*** 4381,4387 ****
  	    }
  
  	    *argv = ALLOC_MULT(char *, *argc + 4);
! 	    if (*argv == NULL)	    /* out of memory */
  		return FAIL;
  	}
      }
--- 4380,4386 ----
  	    }
  
  	    *argv = ALLOC_MULT(char *, *argc + 4);
! 	    if (*argv == NULL)	    // out of memory
  		return FAIL;
  	}
      }
***************
*** 4400,4406 ****
      char_u	*cmd_copy;
      int		i;
  
!     /* Make a copy, parsing will modify "cmd". */
      cmd_copy = vim_strsave(cmd);
      if (cmd_copy == NULL
  	    || mch_parse_cmd(cmd_copy, FALSE, argv, argc) == FAIL)
--- 4399,4405 ----
      char_u	*cmd_copy;
      int		i;
  
!     // Make a copy, parsing will modify "cmd".
      cmd_copy = vim_strsave(cmd);
      if (cmd_copy == NULL
  	    || mch_parse_cmd(cmd_copy, FALSE, argv, argc) == FAIL)
***************
*** 4426,4432 ****
      listitem_T  *li;
      char_u	*s;
  
!     /* Pass argv[] to mch_call_shell(). */
      *argv = ALLOC_MULT(char *, l->lv_len + 1);
      if (*argv == NULL)
  	return FAIL;
--- 4425,4431 ----
      listitem_T  *li;
      char_u	*s;
  
!     // Pass argv[] to mch_call_shell().
      *argv = ALLOC_MULT(char *, l->lv_len + 1);
      if (*argv == NULL)
  	return FAIL;
*** ../vim-8.2.0025/src/move.c	2019-12-14 18:41:52.155639334 +0100
--- src/move.c	2019-12-21 18:20:03.458797784 +0100
***************
*** 25,35 ****
  
  typedef struct
  {
!     linenr_T	    lnum;	/* line number */
  #ifdef FEAT_DIFF
!     int		    fill;	/* filler lines */
  #endif
!     int		    height;	/* height of added line */
  } lineoff_T;
  
  static void topline_back(lineoff_T *lp);
--- 25,35 ----
  
  typedef struct
  {
!     linenr_T	    lnum;	// line number
  #ifdef FEAT_DIFF
!     int		    fill;	// filler lines
  #endif
!     int		    height;	// height of added line
  } lineoff_T;
  
  static void topline_back(lineoff_T *lp);
***************
*** 108,114 ****
  #endif
      }
  
!     /* wp->w_botline is the line that is just below the window */
      wp->w_botline = lnum;
      wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
  
--- 108,114 ----
  #endif
      }
  
!     // wp->w_botline is the line that is just below the window
      wp->w_botline = lnum;
      wp->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP;
  
***************
*** 192,199 ****
      long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;
      int		save_so = *so_ptr;
  
!     /* If there is no valid screen and when the window height is zero just use
!      * the cursor line. */
      if (!screen_valid(TRUE) || curwin->w_height == 0)
      {
  	curwin->w_topline = curwin->w_cursor.lnum;
--- 192,199 ----
      long        *so_ptr = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;
      int		save_so = *so_ptr;
  
!     // If there is no valid screen and when the window height is zero just use
!     // the cursor line.
      if (!screen_valid(TRUE) || curwin->w_height == 0)
      {
  	curwin->w_topline = curwin->w_cursor.lnum;
***************
*** 207,213 ****
      if (curwin->w_valid & VALID_TOPLINE)
  	return;
  
!     /* When dragging with the mouse, don't scroll that quickly */
      if (mouse_dragging > 0)
  	*so_ptr = mouse_dragging - 1;
  
--- 207,213 ----
      if (curwin->w_valid & VALID_TOPLINE)
  	return;
  
!     // When dragging with the mouse, don't scroll that quickly
      if (mouse_dragging > 0)
  	*so_ptr = mouse_dragging - 1;
  
***************
*** 219,225 ****
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (BUFEMPTY())		/* special case - file is empty */
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
--- 219,225 ----
      /*
       * If the buffer is empty, always set topline to 1.
       */
!     if (BUFEMPTY())		// special case - file is empty
      {
  	if (curwin->w_topline != 1)
  	    redraw_later(NOT_VALID);
***************
*** 237,252 ****
      {
  	if (curwin->w_topline > 1)
  	{
! 	    /* If the cursor is above topline, scrolling is always needed.
! 	     * If the cursor is far below topline and there is no folding,
! 	     * scrolling down is never needed. */
  	    if (curwin->w_cursor.lnum < curwin->w_topline)
  		check_topline = TRUE;
  	    else if (check_top_offset())
  		check_topline = TRUE;
  	}
  #ifdef FEAT_DIFF
! 	    /* Check if there are more filler lines than allowed. */
  	if (!check_topline && curwin->w_topfill > diff_check_fill(curwin,
  							   curwin->w_topline))
  	    check_topline = TRUE;
--- 237,252 ----
      {
  	if (curwin->w_topline > 1)
  	{
! 	    // If the cursor is above topline, scrolling is always needed.
! 	    // If the cursor is far below topline and there is no folding,
! 	    // scrolling down is never needed.
  	    if (curwin->w_cursor.lnum < curwin->w_topline)
  		check_topline = TRUE;
  	    else if (check_top_offset())
  		check_topline = TRUE;
  	}
  #ifdef FEAT_DIFF
! 	    // Check if there are more filler lines than allowed.
  	if (!check_topline && curwin->w_topfill > diff_check_fill(curwin,
  							   curwin->w_topline))
  	    check_topline = TRUE;
***************
*** 261,275 ****
  #ifdef FEAT_FOLDING
  	    if (hasAnyFolding(curwin))
  	    {
! 		/* Count the number of logical lines between the cursor and
! 		 * topline + scrolloff (approximation of how much will be
! 		 * scrolled). */
  		n = 0;
  		for (lnum = curwin->w_cursor.lnum;
! 				      lnum < curwin->w_topline + *so_ptr; ++lnum)
  		{
  		    ++n;
! 		    /* stop at end of file or when we know we are far off */
  		    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)
  			break;
  		    (void)hasFolding(lnum, NULL, &lnum);
--- 261,275 ----
  #ifdef FEAT_FOLDING
  	    if (hasAnyFolding(curwin))
  	    {
! 		// Count the number of logical lines between the cursor and
! 		// topline + scrolloff (approximation of how much will be
! 		// scrolled).
  		n = 0;
  		for (lnum = curwin->w_cursor.lnum;
! 				    lnum < curwin->w_topline + *so_ptr; ++lnum)
  		{
  		    ++n;
! 		    // stop at end of file or when we know we are far off
  		    if (lnum >= curbuf->b_ml.ml_line_count || n >= halfheight)
  			break;
  		    (void)hasFolding(lnum, NULL, &lnum);
***************
*** 279,287 ****
  #endif
  		n = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;
  
! 	    /* If we weren't very close to begin with, we scroll to put the
! 	     * cursor in the middle of the window.  Otherwise put the cursor
! 	     * near the top of the window. */
  	    if (n >= halfheight)
  		scroll_cursor_halfway(FALSE);
  	    else
--- 279,287 ----
  #endif
  		n = curwin->w_topline + *so_ptr - curwin->w_cursor.lnum;
  
! 	    // If we weren't very close to begin with, we scroll to put the
! 	    // cursor in the middle of the window.  Otherwise put the cursor
! 	    // near the top of the window.
  	    if (n >= halfheight)
  		scroll_cursor_halfway(FALSE);
  	    else
***************
*** 294,300 ****
  	else
  	{
  #ifdef FEAT_FOLDING
! 	    /* Make sure topline is the first line of a fold. */
  	    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
  	    check_botline = TRUE;
--- 294,300 ----
  	else
  	{
  #ifdef FEAT_FOLDING
! 	    // Make sure topline is the first line of a fold.
  	    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
  	    check_botline = TRUE;
***************
*** 327,339 ****
  	      {
  		lineoff_T	loff;
  
! 		/* Cursor is (a few lines) above botline, check if there are
! 		 * 'scrolloff' window lines below the cursor.  If not, need to
! 		 * scroll. */
  		n = curwin->w_empty_rows;
  		loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
! 		/* In a fold go to its last line. */
  		(void)hasFolding(loff.lnum, NULL, &loff.lnum);
  #endif
  #ifdef FEAT_DIFF
--- 327,339 ----
  	      {
  		lineoff_T	loff;
  
! 		// Cursor is (a few lines) above botline, check if there are
! 		// 'scrolloff' window lines below the cursor.  If not, need to
! 		// scroll.
  		n = curwin->w_empty_rows;
  		loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_FOLDING
! 		// In a fold go to its last line.
  		(void)hasFolding(loff.lnum, NULL, &loff.lnum);
  #endif
  #ifdef FEAT_DIFF
***************
*** 353,363 ****
  		    botline_forw(&loff);
  		}
  		if (n >= *so_ptr)
! 		    /* sufficient context, no need to scroll */
  		    check_botline = FALSE;
  	      }
  	      else
! 		  /* sufficient context, no need to scroll */
  		  check_botline = FALSE;
  	    }
  	    if (check_botline)
--- 353,363 ----
  		    botline_forw(&loff);
  		}
  		if (n >= *so_ptr)
! 		    // sufficient context, no need to scroll
  		    check_botline = FALSE;
  	      }
  	      else
! 		  // sufficient context, no need to scroll
  		  check_botline = FALSE;
  	    }
  	    if (check_botline)
***************
*** 365,379 ****
  #ifdef FEAT_FOLDING
  		if (hasAnyFolding(curwin))
  		{
! 		    /* Count the number of logical lines between the cursor and
! 		     * botline - scrolloff (approximation of how much will be
! 		     * scrolled). */
  		    line_count = 0;
  		    for (lnum = curwin->w_cursor.lnum;
! 				     lnum >= curwin->w_botline - *so_ptr; --lnum)
  		    {
  			++line_count;
! 			/* stop at end of file or when we know we are far off */
  			if (lnum <= 0 || line_count > curwin->w_height + 1)
  			    break;
  			(void)hasFolding(lnum, &lnum, NULL);
--- 365,379 ----
  #ifdef FEAT_FOLDING
  		if (hasAnyFolding(curwin))
  		{
! 		    // Count the number of logical lines between the cursor and
! 		    // botline - scrolloff (approximation of how much will be
! 		    // scrolled).
  		    line_count = 0;
  		    for (lnum = curwin->w_cursor.lnum;
! 				   lnum >= curwin->w_botline - *so_ptr; --lnum)
  		    {
  			++line_count;
! 			// stop at end of file or when we know we are far off
  			if (lnum <= 0 || line_count > curwin->w_height + 1)
  			    break;
  			(void)hasFolding(lnum, &lnum, NULL);
***************
*** 409,415 ****
  	}
  	else
  	    redraw_later(VALID);
! 	/* May need to set w_skipcol when cursor in w_topline. */
  	if (curwin->w_cursor.lnum == curwin->w_topline)
  	    validate_cursor();
      }
--- 409,415 ----
  	}
  	else
  	    redraw_later(VALID);
! 	// May need to set w_skipcol when cursor in w_topline.
  	if (curwin->w_cursor.lnum == curwin->w_topline)
  	    validate_cursor();
      }
***************
*** 450,464 ****
  	loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_DIFF
  	loff.fill = 0;
! 	n = curwin->w_topfill;	    /* always have this context */
  #else
  	n = 0;
  #endif
! 	/* Count the visible screen lines above the cursor line. */
  	while (n < so)
  	{
  	    topline_back(&loff);
! 	    /* Stop when included a line above the window. */
  	    if (loff.lnum < curwin->w_topline
  #ifdef FEAT_DIFF
  		    || (loff.lnum == curwin->w_topline && loff.fill > 0)
--- 450,464 ----
  	loff.lnum = curwin->w_cursor.lnum;
  #ifdef FEAT_DIFF
  	loff.fill = 0;
! 	n = curwin->w_topfill;	    // always have this context
  #else
  	n = 0;
  #endif
! 	// Count the visible screen lines above the cursor line.
  	while (n < so)
  	{
  	    topline_back(&loff);
! 	    // Stop when included a line above the window.
  	    if (loff.lnum < curwin->w_topline
  #ifdef FEAT_DIFF
  		    || (loff.lnum == curwin->w_topline && loff.fill > 0)
***************
*** 535,544 ****
  set_topline(win_T *wp, linenr_T lnum)
  {
  #ifdef FEAT_FOLDING
!     /* go to first of folded lines */
      (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
  #endif
!     /* Approximate the value of w_botline */
      wp->w_botline += lnum - wp->w_topline;
      wp->w_topline = lnum;
      wp->w_topline_was_set = TRUE;
--- 535,544 ----
  set_topline(win_T *wp, linenr_T lnum)
  {
  #ifdef FEAT_FOLDING
!     // go to first of folded lines
      (void)hasFoldingWin(wp, lnum, &lnum, NULL, TRUE, NULL);
  #endif
!     // Approximate the value of w_botline
      wp->w_botline += lnum - wp->w_topline;
      wp->w_topline = lnum;
      wp->w_topline_was_set = TRUE;
***************
*** 546,552 ****
      wp->w_topfill = 0;
  #endif
      wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);
!     /* Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked. */
      redraw_later(VALID);
  }
  
--- 546,552 ----
      wp->w_topfill = 0;
  #endif
      wp->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE|VALID_TOPLINE);
!     // Don't set VALID_TOPLINE here, 'scrolloff' needs to be checked.
      redraw_later(VALID);
  }
  
***************
*** 675,681 ****
      long	fold_count;
  #endif
  
!     /* Check if wp->w_lines[].wl_size is invalid */
      all_invalid = (!redrawing()
  			|| wp->w_lines_valid == 0
  			|| wp->w_lines[0].wl_lnum > wp->w_topline);
--- 675,681 ----
      long	fold_count;
  #endif
  
!     // Check if wp->w_lines[].wl_size is invalid
      all_invalid = (!redrawing()
  			|| wp->w_lines_valid == 0
  			|| wp->w_lines[0].wl_lnum > wp->w_topline);
***************
*** 687,698 ****
  	if (!all_invalid && i < wp->w_lines_valid)
  	{
  	    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)
! 		continue;		/* skip changed or deleted lines */
  	    if (wp->w_lines[i].wl_lnum == lnum)
  	    {
  #ifdef FEAT_FOLDING
! 		/* Check for newly inserted lines below this row, in which
! 		 * case we need to check for folded lines. */
  		if (!wp->w_buffer->b_mod_set
  			|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum
  			|| wp->w_buffer->b_mod_top
--- 687,698 ----
  	if (!all_invalid && i < wp->w_lines_valid)
  	{
  	    if (wp->w_lines[i].wl_lnum < lnum || !wp->w_lines[i].wl_valid)
! 		continue;		// skip changed or deleted lines
  	    if (wp->w_lines[i].wl_lnum == lnum)
  	    {
  #ifdef FEAT_FOLDING
! 		// Check for newly inserted lines below this row, in which
! 		// case we need to check for folded lines.
  		if (!wp->w_buffer->b_mod_set
  			|| wp->w_lines[i].wl_lastlnum < wp->w_cursor.lnum
  			|| wp->w_buffer->b_mod_top
***************
*** 701,707 ****
  		valid = TRUE;
  	    }
  	    else if (wp->w_lines[i].wl_lnum > lnum)
! 		--i;			/* hold at inserted lines */
  	}
  	if (valid
  #ifdef FEAT_DIFF
--- 701,707 ----
  		valid = TRUE;
  	    }
  	    else if (wp->w_lines[i].wl_lnum > lnum)
! 		--i;			// hold at inserted lines
  	}
  	if (valid
  #ifdef FEAT_DIFF
***************
*** 711,717 ****
  	{
  #ifdef FEAT_FOLDING
  	    lnum = wp->w_lines[i].wl_lastlnum + 1;
! 	    /* Cursor inside folded lines, don't count this row */
  	    if (lnum > wp->w_cursor.lnum)
  		break;
  #else
--- 711,717 ----
  	{
  #ifdef FEAT_FOLDING
  	    lnum = wp->w_lines[i].wl_lastlnum + 1;
! 	    // Cursor inside folded lines, don't count this row
  	    if (lnum > wp->w_cursor.lnum)
  		break;
  #else
***************
*** 765,771 ****
  	}
  	else if (i > wp->w_lines_valid)
  	{
! 	    /* a line that is too long to fit on the last screen line */
  	    wp->w_cline_height = 0;
  #ifdef FEAT_FOLDING
  	    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,
--- 765,771 ----
  	}
  	else if (i > wp->w_lines_valid)
  	{
! 	    // a line that is too long to fit on the last screen line
  	    wp->w_cline_height = 0;
  #ifdef FEAT_FOLDING
  	    wp->w_cline_folded = hasFoldingWin(wp, wp->w_cursor.lnum,
***************
*** 854,864 ****
  	col += off;
  	width = curwin->w_width - off + curwin_col_off2();
  
! 	/* long line wrapping, adjust curwin->w_wrow */
  	if (curwin->w_p_wrap
  		&& col >= (colnr_T)curwin->w_width
  		&& width > 0)
! 	    /* use same formula as what is used in curs_columns() */
  	    col -= ((col - curwin->w_width) / width + 1) * width;
  	if (col > (int)curwin->w_leftcol)
  	    col -= curwin->w_leftcol;
--- 854,864 ----
  	col += off;
  	width = curwin->w_width - off + curwin_col_off2();
  
! 	// long line wrapping, adjust curwin->w_wrow
  	if (curwin->w_p_wrap
  		&& col >= (colnr_T)curwin->w_width
  		&& width > 0)
! 	    // use same formula as what is used in curs_columns()
  	    col -= ((col - curwin->w_width) / width + 1) * width;
  	if (col > (int)curwin->w_leftcol)
  	    col -= curwin->w_leftcol;
***************
*** 922,931 ****
   */
      void
  curs_columns(
!     int		may_scroll)	/* when TRUE, may scroll horizontally */
  {
      int		diff;
!     int		extra;		/* offset for first screen line */
      int		off_left, off_right;
      int		n;
      int		p_lines;
--- 922,931 ----
   */
      void
  curs_columns(
!     int		may_scroll)	// when TRUE, may scroll horizontally
  {
      int		diff;
!     int		extra;		// offset for first screen line
      int		off_left, off_right;
      int		n;
      int		p_lines;
***************
*** 954,967 ****
       */
  #ifdef FEAT_FOLDING
      if (curwin->w_cline_folded)
! 	/* In a folded line the cursor is always in the first column */
  	startcol = curwin->w_virtcol = endcol = curwin->w_leftcol;
      else
  #endif
  	getvvcol(curwin, &curwin->w_cursor,
  				&startcol, &(curwin->w_virtcol), &endcol);
  
!     /* remove '$' from change command when cursor moves onto it */
      if (startcol > dollar_vcol)
  	dollar_vcol = -1;
  
--- 954,967 ----
       */
  #ifdef FEAT_FOLDING
      if (curwin->w_cline_folded)
! 	// In a folded line the cursor is always in the first column
  	startcol = curwin->w_virtcol = endcol = curwin->w_leftcol;
      else
  #endif
  	getvvcol(curwin, &curwin->w_cursor,
  				&startcol, &(curwin->w_virtcol), &endcol);
  
!     // remove '$' from change command when cursor moves onto it
      if (startcol > dollar_vcol)
  	dollar_vcol = -1;
  
***************
*** 977,983 ****
      textwidth = curwin->w_width - extra;
      if (textwidth <= 0)
      {
! 	/* No room for text, put cursor in last char of window. */
  	curwin->w_wcol = curwin->w_width - 1;
  	curwin->w_wrow = curwin->w_height - 1;
      }
--- 977,983 ----
      textwidth = curwin->w_width - extra;
      if (textwidth <= 0)
      {
! 	// No room for text, put cursor in last char of window.
  	curwin->w_wcol = curwin->w_width - 1;
  	curwin->w_wrow = curwin->w_height - 1;
      }
***************
*** 985,1006 ****
      {
  	width = textwidth + curwin_col_off2();
  
! 	/* long line wrapping, adjust curwin->w_wrow */
  	if (curwin->w_wcol >= curwin->w_width)
  	{
  #ifdef FEAT_LINEBREAK
  	    char_u *sbr;
  #endif
  
! 	    /* this same formula is used in validate_cursor_col() */
  	    n = (curwin->w_wcol - curwin->w_width) / width + 1;
  	    curwin->w_wcol -= n * width;
  	    curwin->w_wrow += n;
  
  #ifdef FEAT_LINEBREAK
! 	    /* When cursor wraps to first char of next line in Insert
! 	     * mode, the 'showbreak' string isn't shown, backup to first
! 	     * column */
  	    sbr = get_showbreak_value(curwin);
  	    if (*sbr && *ml_get_cursor() == NUL
  				    && curwin->w_wcol == (int)vim_strsize(sbr))
--- 985,1006 ----
      {
  	width = textwidth + curwin_col_off2();
  
! 	// long line wrapping, adjust curwin->w_wrow
  	if (curwin->w_wcol >= curwin->w_width)
  	{
  #ifdef FEAT_LINEBREAK
  	    char_u *sbr;
  #endif
  
! 	    // this same formula is used in validate_cursor_col()
  	    n = (curwin->w_wcol - curwin->w_width) / width + 1;
  	    curwin->w_wcol -= n * width;
  	    curwin->w_wrow += n;
  
  #ifdef FEAT_LINEBREAK
! 	    // When cursor wraps to first char of next line in Insert
! 	    // mode, the 'showbreak' string isn't shown, backup to first
! 	    // column
  	    sbr = get_showbreak_value(curwin);
  	    if (*sbr && *ml_get_cursor() == NUL
  				    && curwin->w_wcol == (int)vim_strsize(sbr))
***************
*** 1009,1017 ****
  	}
      }
  
!     /* No line wrapping: compute curwin->w_leftcol if scrolling is on and line
!      * is not folded.
!      * If scrolling is off, curwin->w_leftcol is assumed to be 0 */
      else if (may_scroll
  #ifdef FEAT_FOLDING
  	    && !curwin->w_cline_folded
--- 1009,1017 ----
  	}
      }
  
!     // No line wrapping: compute curwin->w_leftcol if scrolling is on and line
!     // is not folded.
!     // If scrolling is off, curwin->w_leftcol is assumed to be 0
      else if (may_scroll
  #ifdef FEAT_FOLDING
  	    && !curwin->w_cline_folded
***************
*** 1034,1041 ****
  	    else
  		diff = off_right;
  
! 	    /* When far off or not enough room on either side, put cursor in
! 	     * middle of window. */
  	    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)
  		new_leftcol = curwin->w_wcol - extra - textwidth / 2;
  	    else
--- 1034,1041 ----
  	    else
  		diff = off_right;
  
! 	    // When far off or not enough room on either side, put cursor in
! 	    // middle of window.
  	    if (p_ss == 0 || diff >= textwidth / 2 || off_right >= off_left)
  		new_leftcol = curwin->w_wcol - extra - textwidth / 2;
  	    else
***************
*** 1052,1058 ****
  	    if (new_leftcol != (int)curwin->w_leftcol)
  	    {
  		curwin->w_leftcol = new_leftcol;
! 		/* screen has to be redrawn with new curwin->w_leftcol */
  		redraw_later(NOT_VALID);
  	    }
  	}
--- 1052,1058 ----
  	    if (new_leftcol != (int)curwin->w_leftcol)
  	    {
  		curwin->w_leftcol = new_leftcol;
! 		// screen has to be redrawn with new curwin->w_leftcol
  		redraw_later(NOT_VALID);
  	    }
  	}
***************
*** 1064,1071 ****
  	curwin->w_wcol = 0;
  
  #ifdef FEAT_DIFF
!     /* Skip over filler lines.  At the top use w_topfill, there
!      * may be some filler lines above the window. */
      if (curwin->w_cursor.lnum == curwin->w_topline)
  	curwin->w_wrow += curwin->w_topfill;
      else
--- 1064,1071 ----
  	curwin->w_wcol = 0;
  
  #ifdef FEAT_DIFF
!     // Skip over filler lines.  At the top use w_topfill, there
!     // may be some filler lines above the window.
      if (curwin->w_cursor.lnum == curwin->w_topline)
  	curwin->w_wrow += curwin->w_topfill;
      else
***************
*** 1092,1108 ****
  	    && width > 0
  	    && curwin->w_width != 0)
      {
! 	/* Cursor past end of screen.  Happens with a single line that does
! 	 * not fit on screen.  Find a skipcol to show the text around the
! 	 * cursor.  Avoid scrolling all the time. compute value of "extra":
! 	 * 1: Less than 'scrolloff' lines above
! 	 * 2: Less than 'scrolloff' lines below
! 	 * 3: both of them */
  	extra = 0;
  	if (curwin->w_skipcol + so * width > curwin->w_virtcol)
  	    extra = 1;
! 	/* Compute last display line of the buffer line that we want at the
! 	 * bottom of the window. */
  	if (p_lines == 0)
  	    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);
  	--p_lines;
--- 1092,1108 ----
  	    && width > 0
  	    && curwin->w_width != 0)
      {
! 	// Cursor past end of screen.  Happens with a single line that does
! 	// not fit on screen.  Find a skipcol to show the text around the
! 	// cursor.  Avoid scrolling all the time. compute value of "extra":
! 	// 1: Less than 'scrolloff' lines above
! 	// 2: Less than 'scrolloff' lines below
! 	// 3: both of them
  	extra = 0;
  	if (curwin->w_skipcol + so * width > curwin->w_virtcol)
  	    extra = 1;
! 	// Compute last display line of the buffer line that we want at the
! 	// bottom of the window.
  	if (p_lines == 0)
  	    p_lines = plines_win(curwin, curwin->w_cursor.lnum, FALSE);
  	--p_lines;
***************
*** 1115,1134 ****
  
  	if (extra == 3 || p_lines < so * 2)
  	{
! 	    /* not enough room for 'scrolloff', put cursor in the middle */
  	    n = curwin->w_virtcol / width;
  	    if (n > curwin->w_height / 2)
  		n -= curwin->w_height / 2;
  	    else
  		n = 0;
! 	    /* don't skip more than necessary */
  	    if (n > p_lines - curwin->w_height + 1)
  		n = p_lines - curwin->w_height + 1;
  	    curwin->w_skipcol = n * width;
  	}
  	else if (extra == 1)
  	{
! 	    /* less then 'scrolloff' lines above, decrease skipcol */
  	    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol
  				     + width - 1) / width;
  	    if (extra > 0)
--- 1115,1134 ----
  
  	if (extra == 3 || p_lines < so * 2)
  	{
! 	    // not enough room for 'scrolloff', put cursor in the middle
  	    n = curwin->w_virtcol / width;
  	    if (n > curwin->w_height / 2)
  		n -= curwin->w_height / 2;
  	    else
  		n = 0;
! 	    // don't skip more than necessary
  	    if (n > p_lines - curwin->w_height + 1)
  		n = p_lines - curwin->w_height + 1;
  	    curwin->w_skipcol = n * width;
  	}
  	else if (extra == 1)
  	{
! 	    // less then 'scrolloff' lines above, decrease skipcol
  	    extra = (curwin->w_skipcol + so * width - curwin->w_virtcol
  				     + width - 1) / width;
  	    if (extra > 0)
***************
*** 1140,1146 ****
  	}
  	else if (extra == 2)
  	{
! 	    /* less then 'scrolloff' lines below, increase skipcol */
  	    endcol = (n - curwin->w_height + 1) * width;
  	    while (endcol > curwin->w_virtcol)
  		endcol -= width;
--- 1140,1146 ----
  	}
  	else if (extra == 2)
  	{
! 	    // less then 'scrolloff' lines below, increase skipcol
  	    endcol = (n - curwin->w_height + 1) * width;
  	    while (endcol > curwin->w_virtcol)
  		endcol -= width;
***************
*** 1151,1157 ****
  	curwin->w_wrow -= curwin->w_skipcol / width;
  	if (curwin->w_wrow >= curwin->w_height)
  	{
! 	    /* small window, make sure cursor is in it */
  	    extra = curwin->w_wrow - curwin->w_height + 1;
  	    curwin->w_skipcol += extra * width;
  	    curwin->w_wrow -= extra;
--- 1151,1157 ----
  	curwin->w_wrow -= curwin->w_skipcol / width;
  	if (curwin->w_wrow >= curwin->w_height)
  	{
! 	    // small window, make sure cursor is in it
  	    extra = curwin->w_wrow - curwin->w_height + 1;
  	    curwin->w_skipcol += extra * width;
  	    curwin->w_wrow -= extra;
***************
*** 1169,1175 ****
  	redraw_later(NOT_VALID);
  
  #ifdef FEAT_SYN_HL
!     /* Redraw when w_virtcol changes and 'cursorcolumn' is set */
      if (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0
  	    && !pum_visible())
  	redraw_later(SOME_VALID);
--- 1169,1175 ----
  	redraw_later(NOT_VALID);
  
  #ifdef FEAT_SYN_HL
!     // Redraw when w_virtcol changes and 'cursorcolumn' is set
      if (curwin->w_p_cuc && (curwin->w_valid & VALID_VIRTCOL) == 0
  	    && !pum_visible())
  	redraw_later(SOME_VALID);
***************
*** 1279,1297 ****
      void
  scrolldown(
      long	line_count,
!     int		byfold UNUSED)	/* TRUE: count a closed fold as one line */
  {
!     long	done = 0;	/* total # of physical lines done */
      int		wrow;
      int		moved = FALSE;
  
  #ifdef FEAT_FOLDING
      linenr_T	first;
  
!     /* Make sure w_topline is at the first of a sequence of folded lines. */
      (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
!     validate_cursor();		/* w_wrow needs to be valid */
      while (line_count-- > 0)
      {
  #ifdef FEAT_DIFF
--- 1279,1297 ----
      void
  scrolldown(
      long	line_count,
!     int		byfold UNUSED)	// TRUE: count a closed fold as one line
  {
!     long	done = 0;	// total # of physical lines done
      int		wrow;
      int		moved = FALSE;
  
  #ifdef FEAT_FOLDING
      linenr_T	first;
  
!     // Make sure w_topline is at the first of a sequence of folded lines.
      (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
!     validate_cursor();		// w_wrow needs to be valid
      while (line_count-- > 0)
      {
  #ifdef FEAT_DIFF
***************
*** 1311,1317 ****
  	    curwin->w_topfill = 0;
  #endif
  #ifdef FEAT_FOLDING
! 	    /* A sequence of folded lines only counts for one logical line */
  	    if (hasFolding(curwin->w_topline, &first, NULL))
  	    {
  		++done;
--- 1311,1317 ----
  	    curwin->w_topfill = 0;
  #endif
  #ifdef FEAT_FOLDING
! 	    // A sequence of folded lines only counts for one logical line
  	    if (hasFolding(curwin->w_topline, &first, NULL))
  	    {
  		++done;
***************
*** 1324,1334 ****
  #endif
  		done += PLINES_NOFILL(curwin->w_topline);
  	}
! 	--curwin->w_botline;		/* approximate w_botline */
  	invalidate_botline();
      }
!     curwin->w_wrow += done;		/* keep w_wrow updated */
!     curwin->w_cline_row += done;	/* keep w_cline_row updated */
  
  #ifdef FEAT_DIFF
      if (curwin->w_cursor.lnum == curwin->w_topline)
--- 1324,1334 ----
  #endif
  		done += PLINES_NOFILL(curwin->w_topline);
  	}
! 	--curwin->w_botline;		// approximate w_botline
  	invalidate_botline();
      }
!     curwin->w_wrow += done;		// keep w_wrow updated
!     curwin->w_cline_row += done;	// keep w_cline_row updated
  
  #ifdef FEAT_DIFF
      if (curwin->w_cursor.lnum == curwin->w_topline)
***************
*** 1369,1375 ****
      if (moved)
      {
  #ifdef FEAT_FOLDING
! 	/* Move cursor to first line of closed fold. */
  	foldAdjustCursor();
  #endif
  	coladvance(curwin->w_curswant);
--- 1369,1375 ----
      if (moved)
      {
  #ifdef FEAT_FOLDING
! 	// Move cursor to first line of closed fold.
  	foldAdjustCursor();
  #endif
  	coladvance(curwin->w_curswant);
***************
*** 1382,1388 ****
      void
  scrollup(
      long	line_count,
!     int		byfold UNUSED)	/* TRUE: count a closed fold as one line */
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
--- 1382,1388 ----
      void
  scrollup(
      long	line_count,
!     int		byfold UNUSED)	// TRUE: count a closed fold as one line
  {
  #if defined(FEAT_FOLDING) || defined(FEAT_DIFF)
      linenr_T	lnum;
***************
*** 1399,1405 ****
  # endif
  	    )
      {
! 	/* count each sequence of folded lines as one logical line */
  	lnum = curwin->w_topline;
  	while (line_count--)
  	{
--- 1399,1405 ----
  # endif
  	    )
      {
! 	// count each sequence of folded lines as one logical line
  	lnum = curwin->w_topline;
  	while (line_count--)
  	{
***************
*** 1421,1427 ****
  # endif
  	    }
  	}
! 	/* approximate w_botline */
  	curwin->w_botline += lnum - curwin->w_topline;
  	curwin->w_topline = lnum;
      }
--- 1421,1427 ----
  # endif
  	    }
  	}
! 	// approximate w_botline
  	curwin->w_botline += lnum - curwin->w_topline;
  	curwin->w_topline = lnum;
      }
***************
*** 1429,1435 ****
  #endif
      {
  	curwin->w_topline += line_count;
! 	curwin->w_botline += line_count;	/* approximate w_botline */
      }
  
      if (curwin->w_topline > curbuf->b_ml.ml_line_count)
--- 1429,1435 ----
  #endif
      {
  	curwin->w_topline += line_count;
! 	curwin->w_botline += line_count;	// approximate w_botline
      }
  
      if (curwin->w_topline > curbuf->b_ml.ml_line_count)
***************
*** 1443,1449 ****
  
  #ifdef FEAT_FOLDING
      if (hasAnyFolding(curwin))
! 	/* Make sure w_topline is at the first of a sequence of folded lines. */
  	(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
  
--- 1443,1449 ----
  
  #ifdef FEAT_FOLDING
      if (hasAnyFolding(curwin))
! 	// Make sure w_topline is at the first of a sequence of folded lines.
  	(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
  
***************
*** 1464,1470 ****
      void
  check_topfill(
      win_T	*wp,
!     int		down)	/* when TRUE scroll down when not enough space */
  {
      int		n;
  
--- 1464,1470 ----
      void
  check_topfill(
      win_T	*wp,
!     int		down)	// when TRUE scroll down when not enough space
  {
      int		n;
  
***************
*** 1529,1535 ****
  	    )
  	return;
  
!     validate_cursor();	    /* w_wrow needs to be valid */
  
      /*
       * Compute the row number of the last row of the cursor line
--- 1529,1535 ----
  	    )
  	return;
  
!     validate_cursor();	    // w_wrow needs to be valid
  
      /*
       * Compute the row number of the last row of the cursor line
***************
*** 1571,1577 ****
  #ifdef FEAT_FOLDING
  	(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
! 	--curwin->w_botline;	    /* approximate w_botline */
  	curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
      }
  }
--- 1571,1577 ----
  #ifdef FEAT_FOLDING
  	(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
  #endif
! 	--curwin->w_botline;	    // approximate w_botline
  	curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
      }
  }
***************
*** 1592,1598 ****
  	    )
  	return;
  
!     validate_cursor();	    /* w_wrow needs to be valid */
  
      /*
       * Compute the row number of the first row of the cursor line
--- 1592,1598 ----
  	    )
  	return;
  
!     validate_cursor();	    // w_wrow needs to be valid
  
      /*
       * Compute the row number of the first row of the cursor line
***************
*** 1623,1629 ****
  #endif
  	    ++curwin->w_topline;
  	}
! 	++curwin->w_botline;		/* approximate w_botline */
  	curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
      }
  }
--- 1623,1629 ----
  #endif
  	    ++curwin->w_topline;
  	}
! 	++curwin->w_botline;		// approximate w_botline
  	curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
      }
  }
***************
*** 1640,1646 ****
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum))
      {
! 	/* Add a filler line. */
  	++lp->fill;
  	lp->height = 1;
      }
--- 1640,1646 ----
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum))
      {
! 	// Add a filler line.
  	++lp->fill;
  	lp->height = 1;
      }
***************
*** 1656,1662 ****
  	else
  #ifdef FEAT_FOLDING
  	    if (hasFolding(lp->lnum, &lp->lnum, NULL))
! 	    /* Add a closed fold */
  	    lp->height = 1;
  	else
  #endif
--- 1656,1662 ----
  	else
  #ifdef FEAT_FOLDING
  	    if (hasFolding(lp->lnum, &lp->lnum, NULL))
! 	    // Add a closed fold
  	    lp->height = 1;
  	else
  #endif
***************
*** 1676,1682 ****
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))
      {
! 	/* Add a filler line. */
  	++lp->fill;
  	lp->height = 1;
      }
--- 1676,1682 ----
  #ifdef FEAT_DIFF
      if (lp->fill < diff_check_fill(curwin, lp->lnum + 1))
      {
! 	// Add a filler line.
  	++lp->fill;
  	lp->height = 1;
      }
***************
*** 1692,1698 ****
  	else
  #ifdef FEAT_FOLDING
  	    if (hasFolding(lp->lnum, NULL, &lp->lnum))
! 	    /* Add a closed fold */
  	    lp->height = 1;
  	else
  #endif
--- 1692,1698 ----
  	else
  #ifdef FEAT_FOLDING
  	    if (hasFolding(lp->lnum, NULL, &lp->lnum))
! 	    // Add a closed fold
  	    lp->height = 1;
  	else
  #endif
***************
*** 1744,1751 ****
      int		extra = 0;
      int		used;
      int		i;
!     linenr_T	top;		/* just above displayed lines */
!     linenr_T	bot;		/* just below displayed lines */
      linenr_T	old_topline = curwin->w_topline;
  #ifdef FEAT_DIFF
      linenr_T	old_topfill = curwin->w_topfill;
--- 1744,1751 ----
      int		extra = 0;
      int		used;
      int		i;
!     linenr_T	top;		// just above displayed lines
!     linenr_T	bot;		// just below displayed lines
      linenr_T	old_topline = curwin->w_topline;
  #ifdef FEAT_DIFF
      linenr_T	old_topfill = curwin->w_topfill;
***************
*** 1764,1770 ****
       * - at least 'scrolloff' lines above and below the cursor
       */
      validate_cheight();
!     used = curwin->w_cline_height; /* includes filler lines above */
      if (curwin->w_cursor.lnum < curwin->w_topline)
  	scrolled = used;
  
--- 1764,1770 ----
       * - at least 'scrolloff' lines above and below the cursor
       */
      validate_cheight();
!     used = curwin->w_cline_height; // includes filler lines above
      if (curwin->w_cursor.lnum < curwin->w_topline)
  	scrolled = used;
  
***************
*** 1783,1791 ****
      new_topline = top + 1;
  
  #ifdef FEAT_DIFF
!     /* "used" already contains the number of filler lines above, don't add it
!      * again.
!      * Hide filler lines above cursor line by adding them to "extra". */
      extra += diff_check_fill(curwin, curwin->w_cursor.lnum);
  #endif
  
--- 1783,1791 ----
      new_topline = top + 1;
  
  #ifdef FEAT_DIFF
!     // "used" already contains the number of filler lines above, don't add it
!     // again.
!     // Hide filler lines above cursor line by adding them to "extra".
      extra += diff_check_fill(curwin, curwin->w_cursor.lnum);
  #endif
  
***************
*** 1797,1803 ****
      {
  #ifdef FEAT_FOLDING
  	if (hasFolding(top, &top, NULL))
! 	    /* count one logical line for a sequence of folded lines */
  	    i = 1;
  	else
  #endif
--- 1797,1803 ----
      {
  #ifdef FEAT_FOLDING
  	if (hasFolding(top, &top, NULL))
! 	    // count one logical line for a sequence of folded lines
  	    i = 1;
  	else
  #endif
***************
*** 1807,1813 ****
  	{
  #ifdef FEAT_FOLDING
  	    if (hasFolding(bot, NULL, &bot))
! 		/* count one logical line for a sequence of folded lines */
  		++used;
  	    else
  #endif
--- 1807,1813 ----
  	{
  #ifdef FEAT_FOLDING
  	    if (hasFolding(bot, NULL, &bot))
! 		// count one logical line for a sequence of folded lines
  		++used;
  	    else
  #endif
***************
*** 1880,1886 ****
      wp->w_filler_rows = 0;
  #endif
      if (used == 0)
! 	wp->w_empty_rows = 0;	/* single line that doesn't fit */
      else
      {
  	wp->w_empty_rows = wp->w_height - used;
--- 1880,1886 ----
      wp->w_filler_rows = 0;
  #endif
      if (used == 0)
! 	wp->w_empty_rows = 0;	// single line that doesn't fit
      else
      {
  	wp->w_empty_rows = wp->w_height - used;
***************
*** 1924,1930 ****
      linenr_T	old_botline = curwin->w_botline;
      linenr_T	old_valid = curwin->w_valid;
      int		old_empty_rows = curwin->w_empty_rows;
!     linenr_T	cln;		    /* Cursor Line Number */
      long        so = get_scrolloff_value();
  
      cln = curwin->w_cursor.lnum;
--- 1924,1930 ----
      linenr_T	old_botline = curwin->w_botline;
      linenr_T	old_valid = curwin->w_valid;
      int		old_empty_rows = curwin->w_empty_rows;
!     linenr_T	cln;		    // Cursor Line Number
      long        so = get_scrolloff_value();
  
      cln = curwin->w_cursor.lnum;
***************
*** 1960,1966 ****
      else
  	validate_botline();
  
!     /* The lines of the cursor line itself are always used. */
  #ifdef FEAT_DIFF
      used = plines_nofill(cln);
  #else
--- 1960,1966 ----
      else
  	validate_botline();
  
!     // The lines of the cursor line itself are always used.
  #ifdef FEAT_DIFF
      used = plines_nofill(cln);
  #else
***************
*** 1968,1976 ****
      used = curwin->w_cline_height;
  #endif
  
!     /* If the cursor is below botline, we will at least scroll by the height
!      * of the cursor line.  Correct for empty lines, which are really part of
!      * botline. */
      if (cln >= curwin->w_botline)
      {
  	scrolled = used;
--- 1968,1976 ----
      used = curwin->w_cline_height;
  #endif
  
!     // If the cursor is below botline, we will at least scroll by the height
!     // of the cursor line.  Correct for empty lines, which are really part of
!     // botline.
      if (cln >= curwin->w_botline)
      {
  	scrolled = used;
***************
*** 2001,2008 ****
  
      while (loff.lnum > 1)
      {
! 	/* Stop when scrolled nothing or at least "min_scroll", found "extra"
! 	 * context for 'scrolloff' and counted all lines below the window. */
  	if ((((scrolled <= 0 || scrolled >= min_scroll)
  		    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))
  		    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)
--- 2001,2008 ----
  
      while (loff.lnum > 1)
      {
! 	// Stop when scrolled nothing or at least "min_scroll", found "extra"
! 	// context for 'scrolloff' and counted all lines below the window.
  	if ((((scrolled <= 0 || scrolled >= min_scroll)
  		    && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so))
  		    || boff.lnum + 1 > curbuf->b_ml.ml_line_count)
***************
*** 2014,2020 ****
  		)
  	    break;
  
! 	/* Add one line above */
  	topline_back(&loff);
  	if (loff.height == MAXCOL)
  	    used = MAXCOL;
--- 2014,2020 ----
  		)
  	    break;
  
! 	// Add one line above
  	topline_back(&loff);
  	if (loff.height == MAXCOL)
  	    used = MAXCOL;
***************
*** 2029,2035 ****
  #endif
  		)
  	{
! 	    /* Count screen lines that are below the window. */
  	    scrolled += loff.height;
  	    if (loff.lnum == curwin->w_botline
  #ifdef FEAT_DIFF
--- 2029,2035 ----
  #endif
  		)
  	{
! 	    // Count screen lines that are below the window.
  	    scrolled += loff.height;
  	    if (loff.lnum == curwin->w_botline
  #ifdef FEAT_DIFF
***************
*** 2041,2047 ****
  
  	if (boff.lnum < curbuf->b_ml.ml_line_count)
  	{
! 	    /* Add one line below */
  	    botline_forw(&boff);
  	    used += boff.height;
  	    if (used > curwin->w_height)
--- 2041,2047 ----
  
  	if (boff.lnum < curbuf->b_ml.ml_line_count)
  	{
! 	    // Add one line below
  	    botline_forw(&boff);
  	    used += boff.height;
  	    if (used > curwin->w_height)
***************
*** 2057,2063 ****
  #endif
  		   )
  		{
! 		    /* Count screen lines that are below the window. */
  		    scrolled += boff.height;
  		    if (boff.lnum == curwin->w_botline
  #ifdef FEAT_DIFF
--- 2057,2063 ----
  #endif
  		   )
  		{
! 		    // Count screen lines that are below the window.
  		    scrolled += boff.height;
  		    if (boff.lnum == curwin->w_botline
  #ifdef FEAT_DIFF
***************
*** 2070,2082 ****
  	}
      }
  
!     /* curwin->w_empty_rows is larger, no need to scroll */
      if (scrolled <= 0)
  	line_count = 0;
!     /* more than a screenfull, don't scroll but redraw */
      else if (used > curwin->w_height)
  	line_count = used;
!     /* scroll minimal number of lines */
      else
      {
  	line_count = 0;
--- 2070,2082 ----
  	}
      }
  
!     // curwin->w_empty_rows is larger, no need to scroll
      if (scrolled <= 0)
  	line_count = 0;
!     // more than a screenfull, don't scroll but redraw
      else if (used > curwin->w_height)
  	line_count = used;
!     // scroll minimal number of lines
      else
      {
  	line_count = 0;
***************
*** 2090,2096 ****
  	    i += boff.height;
  	    ++line_count;
  	}
! 	if (i < scrolled)	/* below curwin->w_botline, don't scroll */
  	    line_count = 9999;
      }
  
--- 2090,2096 ----
  	    i += boff.height;
  	    ++line_count;
  	}
! 	if (i < scrolled)	// below curwin->w_botline, don't scroll
  	    line_count = 9999;
      }
  
***************
*** 2151,2157 ****
      topline = loff.lnum;
      while (topline > 1)
      {
! 	if (below <= above)	    /* add a line below the cursor first */
  	{
  	    if (boff.lnum < curbuf->b_ml.ml_line_count)
  	    {
--- 2151,2157 ----
      topline = loff.lnum;
      while (topline > 1)
      {
! 	if (below <= above)	    // add a line below the cursor first
  	{
  	    if (boff.lnum < curbuf->b_ml.ml_line_count)
  	    {
***************
*** 2163,2175 ****
  	    }
  	    else
  	    {
! 		++below;	    /* count a "~" line */
  		if (atend)
  		    ++used;
  	    }
  	}
  
! 	if (below > above)	    /* add a line above the cursor */
  	{
  	    topline_back(&loff);
  	    if (loff.height == MAXCOL)
--- 2163,2175 ----
  	    }
  	    else
  	    {
! 		++below;	    // count a "~" line
  		if (atend)
  		    ++used;
  	    }
  	}
  
! 	if (below > above)	    // add a line above the cursor
  	{
  	    topline_back(&loff);
  	    if (loff.height == MAXCOL)
***************
*** 2208,2219 ****
      void
  cursor_correct(void)
  {
!     int		above = 0;	    /* screen lines above topline */
      linenr_T	topline;
!     int		below = 0;	    /* screen lines below botline */
      linenr_T	botline;
      int		above_wanted, below_wanted;
!     linenr_T	cln;		    /* Cursor Line Number */
      int		max_off;
      long        so = get_scrolloff_value();
  
--- 2208,2219 ----
      void
  cursor_correct(void)
  {
!     int		above = 0;	    // screen lines above topline
      linenr_T	topline;
!     int		below = 0;	    // screen lines below botline
      linenr_T	botline;
      int		above_wanted, below_wanted;
!     linenr_T	cln;		    // Cursor Line Number
      int		max_off;
      long        so = get_scrolloff_value();
  
***************
*** 2267,2273 ****
      topline = curwin->w_topline;
      botline = curwin->w_botline - 1;
  #ifdef FEAT_DIFF
!     /* count filler lines as context */
      above = curwin->w_topfill;
      below = curwin->w_filler_rows;
  #endif
--- 2267,2273 ----
      topline = curwin->w_topline;
      botline = curwin->w_botline - 1;
  #ifdef FEAT_DIFF
!     // count filler lines as context
      above = curwin->w_topfill;
      below = curwin->w_filler_rows;
  #endif
***************
*** 2292,2298 ****
  #endif
  		above += PLINES_NOFILL(topline);
  #ifdef FEAT_DIFF
! 	    /* Count filler lines below this line as context. */
  	    if (topline < botline)
  		above += diff_check_fill(curwin, topline + 1);
  #endif
--- 2292,2298 ----
  #endif
  		above += PLINES_NOFILL(topline);
  #ifdef FEAT_DIFF
! 	    // Count filler lines below this line as context.
  	    if (topline < botline)
  		above += diff_check_fill(curwin, topline + 1);
  #endif
***************
*** 2337,2343 ****
      linenr_T	old_topline = curwin->w_topline;
      long        so = get_scrolloff_value();
  
!     if (curbuf->b_ml.ml_line_count == 1)    /* nothing to do */
      {
  	beep_flush();
  	return FAIL;
--- 2337,2343 ----
      linenr_T	old_topline = curwin->w_topline;
      long        so = get_scrolloff_value();
  
!     if (curbuf->b_ml.ml_line_count == 1)    // nothing to do
      {
  	beep_flush();
  	return FAIL;
***************
*** 2374,2380 ****
  	{
  	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
! 		/* Vi compatible scrolling */
  		if (p_window <= 2)
  		    ++curwin->w_topline;
  		else
--- 2374,2380 ----
  	{
  	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
! 		// Vi compatible scrolling
  		if (p_window <= 2)
  		    ++curwin->w_topline;
  		else
***************
*** 2385,2391 ****
  	    }
  	    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)
  	    {
! 		/* at end of file */
  		curwin->w_topline = curbuf->b_ml.ml_line_count;
  #ifdef FEAT_DIFF
  		curwin->w_topfill = 0;
--- 2385,2391 ----
  	    }
  	    else if (curwin->w_botline > curbuf->b_ml.ml_line_count)
  	    {
! 		// at end of file
  		curwin->w_topline = curbuf->b_ml.ml_line_count;
  #ifdef FEAT_DIFF
  		curwin->w_topfill = 0;
***************
*** 2394,2401 ****
  	    }
  	    else
  	    {
! 		/* For the overlap, start with the line just below the window
! 		 * and go upwards. */
  		loff.lnum = curwin->w_botline;
  #ifdef FEAT_DIFF
  		loff.fill = diff_check_fill(curwin, loff.lnum)
--- 2394,2401 ----
  	    }
  	    else
  	    {
! 		// For the overlap, start with the line just below the window
! 		// and go upwards.
  		loff.lnum = curwin->w_botline;
  #ifdef FEAT_DIFF
  		loff.fill = diff_check_fill(curwin, loff.lnum)
***************
*** 2412,2430 ****
  				   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
  	    }
  	}
! 	else	/* dir == BACKWARDS */
  	{
  #ifdef FEAT_DIFF
  	    if (curwin->w_topline == 1)
  	    {
! 		/* Include max number of filler lines */
  		max_topfill();
  		continue;
  	    }
  #endif
  	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
! 		/* Vi compatible scrolling (sort of) */
  		if (p_window <= 2)
  		    --curwin->w_topline;
  		else
--- 2412,2430 ----
  				   VALID_CROW|VALID_BOTLINE|VALID_BOTLINE_AP);
  	    }
  	}
! 	else	// dir == BACKWARDS
  	{
  #ifdef FEAT_DIFF
  	    if (curwin->w_topline == 1)
  	    {
! 		// Include max number of filler lines
  		max_topfill();
  		continue;
  	    }
  #endif
  	    if (ONE_WINDOW && p_window > 0 && p_window < Rows - 1)
  	    {
! 		// Vi compatible scrolling (sort of)
  		if (p_window <= 2)
  		    --curwin->w_topline;
  		else
***************
*** 2437,2445 ****
  		continue;
  	    }
  
! 	    /* Find the line at the top of the window that is going to be the
! 	     * line at the bottom of the window.  Make sure this results in
! 	     * the same line as before doing CTRL-F. */
  	    loff.lnum = curwin->w_topline - 1;
  #ifdef FEAT_DIFF
  	    loff.fill = diff_check_fill(curwin, loff.lnum + 1)
--- 2437,2445 ----
  		continue;
  	    }
  
! 	    // Find the line at the top of the window that is going to be the
! 	    // line at the bottom of the window.  Make sure this results in
! 	    // the same line as before doing CTRL-F.
  	    loff.lnum = curwin->w_topline - 1;
  #ifdef FEAT_DIFF
  	    loff.fill = diff_check_fill(curwin, loff.lnum + 1)
***************
*** 2460,2467 ****
  	    }
  	    curwin->w_cursor.lnum = loff.lnum;
  
! 	    /* Find the line just above the new topline to get the right line
! 	     * at the bottom of the window. */
  	    n = 0;
  	    while (n <= curwin->w_height && loff.lnum >= 1)
  	    {
--- 2460,2467 ----
  	    }
  	    curwin->w_cursor.lnum = loff.lnum;
  
! 	    // Find the line just above the new topline to get the right line
! 	    // at the bottom of the window.
  	    n = 0;
  	    while (n <= curwin->w_height && loff.lnum >= 1)
  	    {
***************
*** 2471,2477 ****
  		else
  		    n += loff.height;
  	    }
! 	    if (loff.lnum < 1)			/* at begin of file */
  	    {
  		curwin->w_topline = 1;
  #ifdef FEAT_DIFF
--- 2471,2477 ----
  		else
  		    n += loff.height;
  	    }
! 	    if (loff.lnum < 1)			// at begin of file
  	    {
  		curwin->w_topline = 1;
  #ifdef FEAT_DIFF
***************
*** 2481,2487 ****
  	    }
  	    else
  	    {
! 		/* Go two lines forward again. */
  #ifdef FEAT_DIFF
  		topline_botline(&loff);
  #endif
--- 2481,2487 ----
  	    }
  	    else
  	    {
! 		// Go two lines forward again.
  #ifdef FEAT_DIFF
  		topline_botline(&loff);
  #endif
***************
*** 2491,2502 ****
  		botline_topline(&loff);
  #endif
  #ifdef FEAT_FOLDING
! 		/* We're at the wrong end of a fold now. */
  		(void)hasFolding(loff.lnum, &loff.lnum, NULL);
  #endif
  
! 		/* Always scroll at least one line.  Avoid getting stuck on
! 		 * very long lines. */
  		if (loff.lnum >= curwin->w_topline
  #ifdef FEAT_DIFF
  			&& (loff.lnum > curwin->w_topline
--- 2491,2502 ----
  		botline_topline(&loff);
  #endif
  #ifdef FEAT_FOLDING
! 		// We're at the wrong end of a fold now.
  		(void)hasFolding(loff.lnum, &loff.lnum, NULL);
  #endif
  
! 		// Always scroll at least one line.  Avoid getting stuck on
! 		// very long lines.
  		if (loff.lnum >= curwin->w_topline
  #ifdef FEAT_DIFF
  			&& (loff.lnum > curwin->w_topline
***************
*** 2505,2512 ****
  			)
  		{
  #ifdef FEAT_DIFF
! 		    /* First try using the maximum number of filler lines.  If
! 		     * that's not enough, backup one line. */
  		    loff.fill = curwin->w_topfill;
  		    if (curwin->w_topfill < diff_check_fill(curwin,
  							   curwin->w_topline))
--- 2505,2512 ----
  			)
  		{
  #ifdef FEAT_DIFF
! 		    // First try using the maximum number of filler lines.  If
! 		    // that's not enough, backup one line.
  		    loff.fill = curwin->w_topfill;
  		    if (curwin->w_topfill < diff_check_fill(curwin,
  							   curwin->w_topline))
***************
*** 2601,2607 ****
  #endif
      h1 = lp->height;
      if (h1 > min_height)
! 	return;		/* no overlap */
  
      loff0 = *lp;
      if (dir > 0)
--- 2601,2607 ----
  #endif
      h1 = lp->height;
      if (h1 > min_height)
! 	return;		// no overlap
  
      loff0 = *lp;
      if (dir > 0)
***************
*** 2611,2617 ****
      h2 = lp->height;
      if (h2 == MAXCOL || h2 + h1 > min_height)
      {
! 	*lp = loff0;	/* no overlap */
  	return;
      }
  
--- 2611,2617 ----
      h2 = lp->height;
      if (h2 == MAXCOL || h2 + h1 > min_height)
      {
! 	*lp = loff0;	// no overlap
  	return;
      }
  
***************
*** 2623,2629 ****
      h3 = lp->height;
      if (h3 == MAXCOL || h3 + h2 > min_height)
      {
! 	*lp = loff0;	/* no overlap */
  	return;
      }
  
--- 2623,2629 ----
      h3 = lp->height;
      if (h3 == MAXCOL || h3 + h2 > min_height)
      {
! 	*lp = loff0;	// no overlap
  	return;
      }
  
***************
*** 2634,2642 ****
  	topline_back(lp);
      h4 = lp->height;
      if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)
! 	*lp = loff1;	/* 1 line overlap */
      else
! 	*lp = loff2;	/* 2 lines overlap */
      return;
  }
  
--- 2634,2642 ----
  	topline_back(lp);
      h4 = lp->height;
      if (h4 == MAXCOL || h4 + h3 + h2 > min_height || h3 + h2 + h1 > min_height)
! 	*lp = loff1;	// 1 line overlap
      else
! 	*lp = loff2;	// 2 lines overlap
      return;
  }
  
***************
*** 2814,2820 ****
  	}
      }
  # ifdef FEAT_FOLDING
!     /* Move cursor to first line of closed fold. */
      foldAdjustCursor();
  # endif
  #ifdef FEAT_DIFF
--- 2814,2820 ----
  	}
      }
  # ifdef FEAT_FOLDING
!     // Move cursor to first line of closed fold.
      foldAdjustCursor();
  # endif
  #ifdef FEAT_DIFF
***************
*** 2846,2852 ****
      FOR_ALL_WINDOWS(curwin)
      {
  	curbuf = curwin->w_buffer;
! 	/* skip original window  and windows with 'noscrollbind' */
  	if (curwin != old_curwin && curwin->w_p_crb)
  	{
  # ifdef FEAT_DIFF
--- 2846,2852 ----
      FOR_ALL_WINDOWS(curwin)
      {
  	curbuf = curwin->w_buffer;
! 	// skip original window  and windows with 'noscrollbind'
  	if (curwin != old_curwin && curwin->w_p_crb)
  	{
  # ifdef FEAT_DIFF
***************
*** 2861,2868 ****
  	    curwin->w_curswant = curswant;
  	    curwin->w_set_curswant = set_curswant;
  
! 	    /* Make sure the cursor is in a valid position.  Temporarily set
! 	     * "restart_edit" to allow the cursor to be beyond the EOL. */
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
--- 2861,2868 ----
  	    curwin->w_curswant = curswant;
  	    curwin->w_set_curswant = set_curswant;
  
! 	    // Make sure the cursor is in a valid position.  Temporarily set
! 	    // "restart_edit" to allow the cursor to be beyond the EOL.
  	    restart_edit_save = restart_edit;
  	    restart_edit = TRUE;
  	    check_cursor();
***************
*** 2871,2882 ****
  		validate_cursor();
  # endif
  	    restart_edit = restart_edit_save;
! 	    /* Correct cursor for multi-byte character. */
  	    if (has_mbyte)
  		mb_adjust_cursor();
  	    redraw_later(VALID);
  
! 	    /* Only scroll when 'scrollbind' hasn't done this. */
  	    if (!curwin->w_p_scb)
  		update_topline();
  	    curwin->w_redr_status = TRUE;
--- 2871,2882 ----
  		validate_cursor();
  # endif
  	    restart_edit = restart_edit_save;
! 	    // Correct cursor for multi-byte character.
  	    if (has_mbyte)
  		mb_adjust_cursor();
  	    redraw_later(VALID);
  
! 	    // Only scroll when 'scrollbind' hasn't done this.
  	    if (!curwin->w_p_scb)
  		update_topline();
  	    curwin->w_redr_status = TRUE;
*** ../vim-8.2.0025/src/version.c	2019-12-20 19:06:54.288991943 +0100
--- src/version.c	2019-12-21 18:25:21.165665075 +0100
***************
*** 744,745 ****
--- 744,747 ----
  {   /* Add new patch number below this line */
+ /**/
+     26,
  /**/

-- 
Not too long ago, a program was something you watched on TV...

 /// Bram Moolenaar -- Bram@Moolenaar.net -- http://www.Moolenaar.net   \\\
///        sponsor Vim, vote for features -- http://www.Vim.org/sponsor/ \\\
\\\  an exciting new programming language -- http://www.Zimbu.org        ///
 \\\            help me help AIDS victims -- http://ICCF-Holland.org    ///
